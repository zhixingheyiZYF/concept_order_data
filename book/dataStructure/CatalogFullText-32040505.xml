<?xml version="1.0" encoding="utf-8" standalone="no"?>
<METS xmlns:METS="http://www.loc.gov/METS/" xmlns:gdm="http://sunsite.berkeley.edu/GDM/" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" TITLE="Zhejiang University.jdl.China-America digital library project" TYPE="Section" xsi:schemalocation="http://www.loc.gov/METS/http://www.loc.gov/standards/METS/METS.xsd">
  
    <div ORDERLABEL="00000010" TITLE="第1章  绪论" TYPE="Chapter">
    <fptr LogicalPageNum="10" PhysicalPageNum="10"/>
      <div ORDERLABEL="00000010" TITLE="1.1  数据、数据表示和数据处理" TYPE="Chapter">
      <fptr LogicalPageNum="10" PhysicalPageNum="10"/>
        <div ORDERLABEL="00000010" TITLE="1.1.1  数据" TYPE="Chapter">
        <fptr LogicalPageNum="10" PhysicalPageNum="10"/>
        <Paragraph CONTEXT="z数据结构息在表中占一行，这就作为一个数据元素或记录。而每个数据元素由编号、姓名、性别、工作日期、职称、婚否、基本工资、奖金、实发金额等9个数据项组成。服能一，草｝一洲界｛由此可见，数据、数据元素和数据项实际上反映了数据组织的三个层次，即数据可由若干数据元素构成.而数据元素又可由若干个数据项构成。" ID="1">
          <fptr EndPN="00000011" StartPN="00000011"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000011" TITLE="1.1.2  数据表示" TYPE="Chapter">
        <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
        <Paragraph CONTEXT="数据在什算机存储器之外的存在形式.即在现实生活和实际问题中的呈现形式，则称为数据的机外表示。将数据输人到计算机存储器中的存在形式.则称为数据的机内表示。因此，为了让计算机对数据进行加工处理，必须首先将数据从机外表示转化为机内表示，这项工作称为" ID="1">
          <fptr EndPN="00000011" StartPN="00000011"/>
        </Paragraph>
        <Paragraph CONTEXT="数据表示。" ID="2">
          <fptr EndPN="00000011" StartPN="00000011"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000011" TITLE="1.1.3  数据处理" TYPE="Chapter">
        <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
        <Paragraph CONTEXT="仅仅将数据转化为机内表示并不能解决问题，还必须根据实际问题的处理要求和数据的组织形式定义一组操作或运算，并编制程序，让计算机执行所编的程序去完成这组操作从而实现处理要求，并得到所需的处理结果。这项工作称为数据处理。指出.数据表示与数据处理是密切相关的，数据处理方式总是与数据的表示形式相联系，反之亦然。" ID="1">
          <fptr EndPN="00000011" StartPN="00000011"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000011" TITLE="1.2  什么是数据结构" TYPE="Chapter">
      <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
        <div ORDERLABEL="00000011" TITLE="1.2.1  数据的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
        <Paragraph CONTEXT="所谓数据的逻辑结构是指具有逻辑关系的数据元素的集合。所谓逻辑关系是指数据元素第1章绪论3的集合。且Kki,kz，一knn为K中数据元素的个数.当K是一个空集时，则DS也就无结构而言。而R二｛r；，rs，一，r,},zn为R中二元关系的个数，若R为空集，表明K中的数据元素之间不存在任何关系，彼此是独立的。K上的一个关系R是序偶的集合。假设K中的两个数据元素k。和k;存在逻辑关系，则用序偶＜kk;）表示，我们把k;叫做序偶的第一元素，把k,叫做序偶的第二元素，又称k;是玩的直接前驱（简称前驱），称转为k,的直接后继（简称后继）。在数据结构中，数据元素又称为元素或结点。若某个结点没有前驱，则称该结点为开始结" ID="1">
          <fptr EndPN="00000012" StartPN="00000011"/>
        </Paragraph>
        <Paragraph CONTEXT="点；若某个结点没有后继，则称该结点为终端结点。" ID="2">
          <fptr EndPN="00000012" StartPN="00000012"/>
        </Paragraph>
        <Paragraph CONTEXT="对于对称序CkkER,CkkER，则用圆括号代替尖括号，即（k‘，kER,由此可知，R是K中所有具有逻辑关系的数据元素所构成的序偶集合。" ID="3">
          <fptr EndPN="00000012" StartPN="00000012"/>
        </Paragraph>
        <Paragraph CONTEXT="对应的数据结构表示为DS二（K,R)，其中R={CkkzCkz,k3Ck，kCk，ks可用图1.1表示。" ID="4">
          <fptr EndPN="00000012" StartPN="00000012"/>
        </Paragraph>
        <Paragraph CONTEXT="⑥一硕于一C卜（蛋一④图1.1表1.1数据结构的示意图例1.2给出以下逻辑结构图，如图1.2所示.$Picture[00000012\00000012_new\0021.jpg]Picture$4数据结构集合中任何两个结点之间都没有逻辑关系，彼此是独立的，其组织形式是散列的。如图1.3OJT示。在数据结构】3S二（K,R）中，R为空集，即空关系。" ID="5">
          <fptr EndPN="00000013" StartPN="00000012"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)线性结构线性结构中的结点按逻辑关系依次相邻而排列成一条“锁链”，结点间存在一个对一个的图1.4线性结构" ID="6">
          <fptr EndPN="00000013" StartPN="00000013"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）树形结构树形结构中结点的组织形式具有分支、层次特点，结点之间存在一个对多个的关系，其形" ID="7">
          <fptr EndPN="00000013" StartPN="00000013"/>
        </Paragraph>
        <Paragraph CONTEXT="态如同自然界中的树。结点.如图1.所示.图1.5树形结构" ID="8">
          <fptr EndPN="00000013" StartPN="00000013"/>
        </Paragraph>
        <Paragraph CONTEXT="图状结构是最复杂的，在这种结构中，结点间既存在纵向联系，又存在横向联系，即结点间存在多个对多个的关系。每个结点的前驱和后继的个数都是任意的。如图1.6所示。第i章绪论5图状结构的特例。" ID="9">
          <fptr EndPN="00000014" StartPN="00000013"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000014" TITLE="1.2.2  数据的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
        <Paragraph CONTEXT="数据的存储结构是数据的逻辑结构在机内的表示。或者说，数据的存储结构是数据的逻构在计算机存储器中的存储实现。一般地说，一个存储结构必须包括以下两个主要部分：" ID="1">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="Z.存储结点，每个存储结点存放一个数据元素；" ID="2">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="2.数据元素之间关联方式的表示，也就是逻辑关系的机内表示。通常.存储结点之间的关联方式有四种，故分为以下四种基本的存储方式：数据的存储结构是数据的逻辑结构在机内的表示。" ID="3">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="辑结构在计算机存储器中的存储实现。一般地说，一个；（”顺序存储方式用存储结点间的位置关系表示数据元素之间的逻辑关系。按这种方式表示逻辑关系的存储结" ID="4">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="构称为顺序存储结构." ID="5">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)链式存储方式每个存储结点不仅含有一个数据元素，还包含一个（或一组）指针。每个指针指向一个与未全全占1旨另四翻多理；茗配睦参占日n田月廿币们的全乡空于月撼于冬乌妞翻昌二竺互大七名寺云五月阮.二卜妇刁剑16台望室才幽盛士封，玉分」卜按这种方式组织的存储结构称为链式存储结构。" ID="6">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)索引存储方式每个存储结点只含一个数据元素，所有存储结点连续存放.另外增设一个索引表，用结点的索引号来确定结点的存储位置。按这种方式组织的存储结构称为索引存储结构。" ID="7">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)散列存储方式每个结点含有一个数据元素，根据结点的值用散列函数来确定各结点的存储位置。按这" ID="8">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="种方式组织的存储结构称为散列存储结构。" ID="9">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000014" TITLE="1.2.3  数据的运算" TYPE="Chapter">
        <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
        <Paragraph CONTEXT="数据的运算是指在数据的逻辑结构上定义一组操作（又称运算），以实现数据处理要求。设S为某种逻辑结构，在S上到底定义哪些操作，可以根据需要而定义.因此，操作的种B数据结构" ID="1">
          <fptr EndPN="00000015" StartPN="00000014"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="数据结构是指数据的组织形式，即数据元素之间的相互关系。数据结构的内容包括三个舌面而_Ir娜OEr;叨#Sr4fir3#oh左肩鑫4tii泊11r#it,弓Y'" ID="1">
        <fptr EndPN="00000011" StartPN="00000011"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000015" TITLE="1.3  算法及其描述" TYPE="Chapter">
      <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <div ORDERLABEL="00000015" TITLE="1.3.1  什么是算法" TYPE="Chapter">
        <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <Paragraph CONTEXT="在解决实际问题时，当确定了数据的逻辑结构和实现了数据的存储结构之后，必须进一步研究与之相关的一组操作（或运算）的实现。为了实现某种操作通常需要一种算确切地说，算法是对特定问题求解步骤的一种描述，它是指令的有限序列。实质上，算法是在存储结构上的操作实现方法。一个算法应具有以下五个重要特性：" ID="1">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)有穷性。一个算法必须在执行有穷步之后结束，且每一步都可在有穷时间内完成。" ID="2">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)可行性。一个算法是可行的，即算法中描述的操作都可通过已经实现的基本运算执行有限次来实现。" ID="3">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）输人。一个算法有零个或多个输人，这些输人取自于某个选定的对象的集合。" ID="4">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="（斤、蛤中＿个首冲右＿个前之本检点＿4守禅么编束具目拾人右览止匕土象空兰玄的考昏" ID="5">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="C5）输出。例1.3设计一个算法：求一元二次方程axz十bx+c=4的实根。该算法由下列步骤构成（用C语言表达）：" ID="6">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="第1步：计算d=bib-4*a，c;第2步：如果d&gt;0，则转第5步；第3步：如果d=0，则转第9步；" ID="7">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="第4步：如果dCo，则转第12步；" ID="8">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="第5步：计算x1=（一b十sgrtCdG7*a)第i章绪论7" ID="9">
          <fptr EndPN="00000016" StartPN="00000015"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000016" TITLE="1.3.2  算法的描述" TYPE="Chapter">
        <fptr LogicalPageNum="16" PhysicalPageNum="16"/>
        <Paragraph CONTEXT="算法的描述是指用某种方式将算法的实现具体的描写出来。算法的描述可以有多种方式，如语言方式、图形方式和表格方式等。在本书中将采用C语言描述，C语言是一种高效、灵活和精炼的高级程序设训语言，其优点是数据类型丰富、语句简洁。编写的程序结构化程度高、可读性强。例如，例1.3的算法用C-语言描述如下：oidsaiution(floata,fl。atb,floatc)" ID="1">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="{floatd,x,x1.x2:" ID="2">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="d=b*b-4*a+e;ifiJ＞〕）{祖_（一卜＋冈rt（d〕）／（2，a）；x2=（一b一组“（d））／（2势a）；" ID="3">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="printfxlf,x2=％fnxl.x" ID="4">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="5">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="{x=（一b）／（2.a）；" ID="6">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="printfxf\nx李elseprint”不存在实根＼n）用于描述算法的常用C语言语句：" ID="7">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)输人语句Scanf＜格式控制串＞，人项表＞〕；{2}输出语句" ID="8">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(＜格式控制申＞，＜输出项表＞）。" ID="9">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)赋值语句" ID="10">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="变量名弃表达式；条件语句" ID="11">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)if＜条件＞）＜语句＞，或者il(＜条件＞）＜语句1＞el二＜语句2i;" ID="12">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）循环语句While(＜表达式＞）＜循环体t句＞；do" ID="13">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="＜循环体语句＞。While(＜表达式＞〕，forllfk初值表达式1＜条件表达式'L&gt;s＜步长表达式38数据结构" ID="14">
          <fptr EndPN="00000017" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="｛＜说明部分＞；" ID="15">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="＜执行语句部分＞；" ID="16">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="(8)调用函数语句" ID="18">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="＜函数名＞（＜实参1＜实参2…" ID="19">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="数据结构的各种操作都是以算法形式描述的，而算法的实现都是以程序形式表现的。故数据结构、算法和程序是密不可分的，它们之间的关系可表示为：本节先介绍算法的定义和特性，然后介绍算法的描述方法。" ID="1">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000017" TITLE="1.4  算法分析" TYPE="Chapter">
      <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <div ORDERLABEL="00000017" TITLE="1.4.1  算法的性能标准" TYPE="Chapter">
        <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <Paragraph CONTEXT="算法与数据结构的好坏直接相关。判断一个算法的优劣主要有以下几个标准：（”正确性。算法应当满足实际问题的需求，能够正确地实现预先规定的功能。（”正确性。算法应当满足实际问题的需求，能够正确地实现预先规定的功能。这是最它全节国浮行J自‘丢熟」目二Ar65屏卜Ilt1C2}可读性。算法应当可读性好，这样才有助于对算法的阅读和理解。为达此要求，算法的思路应当是清晰的.层次逻辑应当是结构化的。" ID="1">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)健壮性。要求算法具有很好的容错性，即提供例外处理，能够对非法数据进行检查并作出相应反应，而不会产生莫明其妙的输出结果。处理出错的方法应是返回一个错误信息，且中止程序的执行。" ID="2">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)效率。算法的效率主要是指算法执行时所消耗的计算机资源，包括存储空间和运行" ID="3">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="时间的开销。前者叫做算法的空间代价，后者叫做算法的时间代价。" ID="4">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000017" TITLE="1.4.2  算法的效率分析" TYPE="Chapter">
        <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <Paragraph CONTEXT="口斗戊引唯才丈灿‘吞启台习乡挂工催扩谁土石杯自聋宜互配.健室启挺目周.＿曰」邑月户恢七七石井.1‘迢卜t,a牛怕‘袭势" ID="1">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="I，空间复杂度我们首先应当了解什么是问题的规模.问题的规模或一个算法的输人规模是指该算法物1.8tsfri尽.石异刁卜'fti4x'月子去f#s岌x曰＿石脸烤soy'曰，右笼二is{i#墉3#14+aHim_gt刁二妻1S{杏协'id-第1章绪论9本操作重复执行的次数是依据算法中最大语句频度来估计，它是问题规模n的某个函数fT(nO(f(n它表示随间题规模n的增大算法执行时间的增长率与f(n)的增长率相同.称为线性算法，其运行时间与n成正比。例如，对表l.i进行顺序查找时，其时间复杂ft1)1中第" ID="2">
          <fptr EndPN="00000018" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="均为0（1）。具有数量级0（n）的算法" ID="3">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="进行顺序查找时，其时间复杂度为0" ID="4">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="（n）。各种不同时间复杂度存在如下关系：0（1）＜0（109：n）＜（）（n）＜0（n，10段nj＜（）（nZ）＜0（n3）指出下列程序段的时问复杂度。例1.4for（1＝1：1＜＝n；1＋＋）for（j牛1；」（“n汁1一＋）" ID="5">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="x，x十1；" ID="6">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="在该程序段中所含基本操作是赋值语句x二x十1；其执行的次数（频度）为n”，故这个程序" ID="7">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="例1.5两个n阶方阵相乘即C二A，B，其算法：" ID="8">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="Voidmatri二ult（in1A〔过［n］，认t氏n〕［司，intC［司［n-1）生in［1，1，k；" ID="9">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="肠r（1二011＜n；1＋＋）for（j＝0；j＜1＋斗）IC［1〕［j］“0：①fnr（k＝0；k＜n；k十一〕" ID="10">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="C〔1〕口］件C［1］二j〕＋越1］［k］，逐坷〔j］；0" ID="11">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="》" ID="13">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="在该算法中基本操作是赋值语句.其中语句①执行nZ次，语句②执行记次，故该算法的时间复杂度为：T（n）！n，＋n‘！0（n二）.10数据结构" ID="14">
          <fptr EndPN="00000019" StartPN="00000018"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="一个算法话川一完后.需要对其进行分析，以确定该算法的优劣。评价一个算法的优劣主要考查这个算法的性能和效率。" ID="1">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000019" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="19" PhysicalPageNum="19"/>
      <Paragraph CONTEXT="1.什么是数据、数据表示和数据处理？" ID="1">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="2.数据结构如何采用二元组确切地描述？试举例说明。叙述数据结构包含的三个方面内容，并举例说明。说明数据的逻辑结构与存储结构之间的相互关系。" ID="2">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="数据的逻辑结构有哪些基本类型？数据的存储结构有哪些基本类型？" ID="3">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="什么是算法和算法描述？" ID="4">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="算法分析的目的是什么？如何评价一个算法的优劣？" ID="5">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="有下列几种用二元组表示的数据结构，画出它们的逻辑结构图，并指出它们分别属于" ID="6">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="3。" ID="7">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="4.5.6.7.8." ID="8">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="何种数据结构。" ID="9">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)DSAK,R)，其中：K=1a,b,c,d,e,f,g,hR二b&lt;b,cCc,dCd,e&lt;e,f&lt;f,gCg.h" ID="10">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)QSS=CK,R)，其中：K={a,b,c,d,e,f,g,hR=d,b&lt;d,gCd,a&lt;b,cCg,e&lt;g+h&lt;e,fR1,22,32,43,4}，{3,53.64,5){4,6，，设有如图l.i所示的逻辑结构图，试给出它的数据结构定义。图1.7逻辑结构图第1章绪论11{inti,j;for{i=0：i&lt;n;i十＋）for(j=U;j&lt;n;j十‘）任1］口〕＝a［1］马〕＋bLi］〔j］；" ID="11">
        <fptr EndPN="00000020" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="12">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)voidfun(intn)!inti二o,S=O;认飞1眨（5（n）咬1＋J－；5＝5＋1.｝卜" ID="13">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)i-1;K-0;n二100;do（K=K十10*i;i一本；}While(i，二n" ID="14">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)气二laj二OsWhile(i-j＜一n}" ID="15">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="iif(ij)j--f-selsei十十；{5)Vaidsor：fun{intb[I.intn){inti,j,lx;forCi=O;iCn-l;i十＋）(k=i;for(j=i十1;j&lt;n;j-1-fif（b［司＞b［j〕）k“j；x二bCi7;" ID="16">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="b［口＝b【k］；b[k]=x;｝｝" ID="17">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="(6)for{i二1；K＝n；1＋＋）for(j=1;jC=i;j十十）far(K=1;Kj;K12数据结构" ID="18">
        <fptr EndPN="00000021" StartPN="00000020"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000021" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="21" PhysicalPageNum="21"/>
      <Paragraph CONTEXT="1.内容：指针和结构体概念的应用。9曰配尸曹堪到当创J玉打括约仕娜鸿卜鹅甘窦家太坦橄＿衡太弓里扭的披挤受习谈空栩虑其款＿2.3.题目：有10个学生考试三门课程，每个学生的数据包括学号、姓名、三门课成绩及其总成绩。试利用指针和结构体概念实现下列功能：(1}从键盘输入每个学生的学号、姓名、三门课成绩，继而求出其总成绩，翰出全部数据；" ID="1">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）计算并愉出三门课的总平均成绩；(3}查找总分最高者，并输出他的有关数据（利用指针）。" ID="2">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="4,要求" ID="3">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)搞清解题思路和算法。" ID="4">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)设计程序.给出源程序清单和运行结果。" ID="5">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="charnarne[2013第z章线性表13" ID="6">
        <fptr EndPN="00000022" StartPN="00000021"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="广气气气气气气匆气气、气气气气气～气、气气气勺气分气气分、气知急趁.本罕甄，（”数据、数据表示和数据处理数据结构的含义数据的著爹逻辑结构、存储结构与运算，cap算法的描述与分析。落著本章要求理解数据结构的有关概念搞清数据的逻辑结构、存储结釜" ID="1">
      <fptr EndPN="00000010" StartPN="00000010"/>
    </Paragraph>
    <Paragraph CONTEXT="菠的墓本方法。著举仓牢色‘它‘蛛仁，仑牢今字色罕帐仁军仁牢蜂气七罕蛛份峥仁军气气怜气蜂坛纷纷仁牢蛛杠宁专字蛛蜂娜七刘夕" ID="2">
      <fptr EndPN="00000010" StartPN="00000010"/>
    </Paragraph>
    <Paragraph CONTEXT="当今的世界是一个充满信息的世界，社会中的诸多领域都形成了各自的信息海洋。在解" ID="3">
      <fptr EndPN="00000010" StartPN="00000010"/>
    </Paragraph>
    <Paragraph CONTEXT="决实际问题时.人们只关心对自己有用的信息，并利用计算机对这些信息进行高效处理，从而实现处理要求，最终获得所需的结果。因为信息是通过数据表达的，因此对信息的处理实质上就是对数据的处理。那么利用计算机怎样才能实现对数据的高效处理呢？这就必须研究和解" ID="4">
      <fptr EndPN="00000010" StartPN="00000010"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000022" TITLE="第2章  线性表" TYPE="Chapter">
    <fptr LogicalPageNum="22" PhysicalPageNum="22"/>
      <div ORDERLABEL="00000022" TITLE="2.1  线性表的定义及其基本算法" TYPE="Chapter">
      <fptr LogicalPageNum="22" PhysicalPageNum="22"/>
        <div ORDERLABEL="00000022" TITLE="2.1.1  线性表的定义" TYPE="Chapter">
        <fptr LogicalPageNum="22" PhysicalPageNum="22"/>
        <Paragraph CONTEXT="典邪千贵的刁、扮欲衡蜂书士丰的琴庵田。习怠F1fin4.二nttlhlll4.6Nc注3卫.＿h.r:当n＝0时，则线性表是一个空表。" ID="1">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000022" TITLE="2.1.2  线性表的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="22" PhysicalPageNum="22"/>
        <Paragraph CONTEXT="14数据结构其中，A二（a;｝1&lt;iCn,n&gt;0,a;EEletnType,/«E]二Type为C语言通用类型符二／对应的逻辑关系图如图2.1所示。" ID="1">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000023" TITLE="2.1.3  线性表的基本算法" TYPE="Chapter">
        <fptr LogicalPageNum="23" PhysicalPageNum="23"/>
        <Paragraph CONTEXT="线性表的基本算法主要有下列几种：" ID="1">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)置空表。Setnull(L)，将线性表L置为空表，又称初始化。" ID="2">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)求表长。length(L)，返回线性表L的长度，即L中元素的个数。" ID="3">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)读取表元。get(L,i返回L中第i(lCiCn)个结点ao" ID="4">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)按值查找。locat{L.x)，若L中存在一个或多个值为x的结点，则返回首次找到的其值为二的结点。" ID="5">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(5)插入结点.insert(L,x,i)，在线性表L的第i(1CiCn+1)个位置上插人一个值为x的新结点。" ID="6">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)除结点.delete(L,i),删除线性表L中的第i(1Gi&lt;n)个结点。" ID="7">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(7)输出线性表。display(L)，当线性表L非空时，则顺序显示L中各结点值." ID="8">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在介绍线性表的存储结构之前，先给出线性表的定义及其逻辑结构，并以逻辑形式给出线" ID="1">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="性表的基本算法。" ID="2">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000023" TITLE="2.2  线性表的顺序存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="23" PhysicalPageNum="23"/>
        <div ORDERLABEL="00000023" TITLE="2.2.1  线性表的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="23" PhysicalPageNum="23"/>
        <Paragraph CONTEXT="如上所述，线性表的逻辑结构是线性结构，将线性表的逻辑结构直接映射到存储结构最常用的存储方式是顺序存储。线性表的顺序存储又称为顺序表，这种存储方式既直观。又容易实" ID="1">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="现。本节将介绍顺序存储结构以及一些基本操作的实现。2.2.1线性表的顺序存储结构线性表的顺序存储结构的特点是：把线性表中所有元素按其逻辑顺序依次存放到指定存存储位置，记作LQC(ar}o假定线性表的元紊类型为ElemType.设每个元素所占存储空间大小为K=sizeof(ElemType）个字节，则第i个元素a;(2CiCn)的存储位置为LOC（ai）＝1刀〔（a：）＋K爷（1-1)而整个线性表所占用的存储空间大小为n*K个字节，其中n为线性表的长度，即元家个数。在C语言中，定义了一个数组就定义了一块连续的存储空间，其起始位置就是由数组名第2章线性表15元素占K个字节，则L所对应的顺序存储结构如图2.2所示。$Picture[00000024\00000024_new\0003.jpg]Picture$LOC(al}Kn-1)图2.2顺序存储示意图" ID="2">
          <fptr EndPN="00000024" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="在定义一个线性表的顺序存储类型时，需要定义一个数组来存储表中的所有元素。并定义" ID="3">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="一个整型的符号常量MaxSize，用来表示数组的最大允许长度，且定义一个整型变量size，表" ID="4">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="示数组的实际长度。元素类型用通用类型标识符ElemType表示，则线性表的顺序存储的结" ID="5">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="StructsList" ID="6">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="七ElemType1ist[MaxSize];" ID="7">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="intsize:" ID="8">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；" ID="9">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000024" TITLE="2.2.2  顺序表基本算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="24" PhysicalPageNum="24"/>
        <Paragraph CONTEXT="当线性表采用顺序存储结构时，我们就可用C语言实现各种基本操作算法，这里将介绍这些基本操作算法的实现过程。" ID="1">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="在线性表的顺序存储类型的描述中，其元素类型采用通用类型标识符ElemType，当涉及" ID="2">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="到C语言中某种具体类型时，如char类型或int类型时，可使用如下类11a定义语句：" ID="3">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="或typedefintElemType;另外.应当注意：在后面的操作算法中，list数组的下标是从。开始的，而顺序表的结点的" ID="4">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="序号是从1开始的。因此，要小心它们之间的转换关系。" ID="5">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="门、ni1白L＿屯醉:月性_QorTl1ri1数据结构目····.-3）读取表元：get&lt;L,i)答1值不正确，则显示错误信息。乙lemTypeget(structsList肠p,inti).f(i&lt;1｝！i&gt;g-size)i是结点的序号，／printfpositionerror!\nelsereturn(p-list仁i-11｝" ID="6">
          <fptr EndPN="00000025" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）按值查找：locate(L,x)该算法是在顺序表L中首次找到值为x的结点，并返回该结点的序号；若未找到，则返回一个特定值一1,int1acate(structsList+p,IJiemTypex){inti二Ori为数组的下标‘／" ID="7">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="while(i&lt;p-sizeg-list[i°x)i-F" ID="8">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="if(ipysize)" ID="9">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="return（一1" ID="10">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn(i+1);" ID="11">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）插入结点：insert(L,x.i)该算法是在顺序表L的第i个位置插人一新结点xo这时顺序表长度，ize增1，且将顺序表原来第i个结点及其以后结点后移一个位置，以腾出一个空位置插人xe若i值不正确,给出错误信息。voidinsert(structsList*p,ElemTypex,inti){mtx;" ID="12">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="if(i&lt;1｝王＞p～size-l-1)/，i为结点序号，／" ID="13">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="printfpositionerrorl\n" ID="14">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="else｛少中毓ze＋＋；" ID="15">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j°psize-1:J＞=itJ一一）p-卜lESt[〕一p-卜list-11,/‘结点依次后移，腾一空位‘／I｛第2章线性表17｛intj;if（i＜1只1＞p～幻动／，三为结点序号，／printfpositionerror!fin;else〔for(j°i-1;j&lt;psize-l,j-plist[j〕二p～1汉〔j＋习；／，结点依次前移，搜盖除结点，／p牵sue一一‘" ID="16">
          <fptr EndPN="00000026" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="(7）输出线性表：display(L)该算法是依次输出顺序表I.的各结点的值。在输出时，前一结点用指向后一个结点，最后一个结点不显示当只有一个结点时。只显示该结点的值。当顺序表L为空表时，应显示提示信息。若结点的值的数据类spa为。har类型，这时应使用类型定义语句：" ID="19">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefcharElemType;strtuctsList{ElemType1ist[MaxSize" ID="20">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="intsize｝。voiddisplay(srructsLisd+p)" ID="21">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="{intj;if(p一知sizeU)printfLisempty?\n一）1" ID="22">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="else{printfL" ID="23">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p今size二二1)/，只有一个结点。／printf%cp～list[p-size-11)telse/。有一个以上结点，／" ID="24">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="{for(j=0;j&lt;p-size-lajfprintf％一井，p～list臼］）." ID="25">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="printfcplist[j]" ID="26">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="27">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="printffin;｝）(8〕修改表元：modify(L,i)该算法是修改顺序表L中第i个结点的值，可通过键盘输人语句修改其值。如果i值不花.裔虑昆某‘坦全右以检自佃；昏姑占箔的粉垠坐刑当屯们亡开睡voidtnodify(structsList¢p,inti)｛18数据结构" ID="28">
          <fptr EndPN="00000027" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="29">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000027" TITLE="2.2.3  顺序表基本算法的时间复杂度分析" TYPE="Chapter">
        <fptr LogicalPageNum="27" PhysicalPageNum="27"/>
        <Paragraph CONTEXT="对于置空表二tnull(L)、求表长length(L)、读取表元get(L,i)、修改表元modify(L,i}来说，根据基本操作时执行次数，很显然，它们的时间复杂度量级均为O(1找各结点的概率p;(i&lt;i&lt;n》相同，即p。一1n，则按值查找的平均时间复杂度为资、，＿1，，.o.oJ.、＿1n（n＋1）＿n＋1LPt'一―‘上，尸石T3'rTn.一一－下产－一一1犷－故按值查找算法的平均时间复杂度为OCn" ID="1">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="时间复杂度也为O(n)o对于插入结点insert(L,i)算法，是在顺序表的第i个位置插入一个新结点，为了腾出第i有可能位置为n+1个，因为第n个结点后面也是一个可能插人位置。该算法的时间消耗主要在结点的移动上，而结点的移动次数取决于插入位置。假设P：是在第1个位置插人一个新结" ID="2">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="点的概率.则在长度为n的顺序表中插人一个结点所需移动结点的平均次数为州一t" ID="3">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000027" TITLE="2.3  线性表的链式存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="27" PhysicalPageNum="27"/>
        <div ORDERLABEL="00000027" TITLE="2.3.1  单链表" TYPE="Chapter">
        <fptr LogicalPageNum="27" PhysicalPageNum="27"/>
        <Paragraph CONTEXT="第2章线性表19个或多个指针域。假若每个存储结点除含有数据域外，只设置一个指针域，用以指向其后继结占＿神拦的桩宪软七苗召岌妻田，冲的雄丰的＿一木左吞会姑占栩今袄石木勿以戈创.左全舌书蛋二卜imvBt" ID="1">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="点，这样的链表称为单链表。图2.3单链表的结点形式其中data为数据域，用于存储线性表的一个数据元素。next为指针域或链域，用于存放本结一州、｝川图2.4线性表的单链表存储示意图$Picture[00000028\00000028_new\0013.jpg]Picture$其中，head称为头指针变量，用于存放单链表的第一个存储结点的指针（地址），称为头指针。终端结点或称表尾结点没有后继结点，故该结点的指针域为NULL,NULL称为空指针，通常" ID="2">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="用八表示。单链表的每个结点都被一个指针所指，并且任何结点也只能通过指向它的指针才" ID="3">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="能引用。因此，对单链表中任一结点的访问必须根据头指针找到第一个结点，再按各结点指针" ID="4">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="链表。例如，图2.4中的单链表称为“head表”或“表卜ead单链表结点的存储结构类型定义为：structLngde" ID="5">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="畜" ID="6">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;，；这里，数据域的数据类型采用通用类型标识符EletnType来表示。设有下列说明语句：strurtLttode*p;若使P指向一个新分配的结点，则用下面语句：" ID="7">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000028" TITLE="2.3.2  单链表基本算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="28" PhysicalPageNum="28"/>
        <Paragraph CONTEXT="2a数据结构如图2.5所示。气澄那卷峭返耳分.，.瑙伪）带头结点的空表（无表结点）图2.5带头结点的单链表下面介绍单链表基本算法的实现过程.如前所述，用头指针head标识一个单链表。" ID="1">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）初始化―置空表：setnull(head)该算法的结果将单链表head置为空表.只需将头结点的指针域置为NULL即可。" ID="2">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="算法" ID="3">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="实现如下：" ID="4">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="voidsetnull(structLnode+head)硬headnext二NULL;｝" ID="5">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）求表长：]ength(head)" ID="6">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="该算法返回单链表的长度，即表结点的个数。算法实现如下：" ID="7">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="intiength{stnjctLnode拼head)" ID="8">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="才" ID="9">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="intk=fl;" ID="10">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="structLttode*p;" ID="11">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="p=head;" ID="12">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="while(p-next!=NULL)" ID="13">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="王" ID="14">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="k+-t-;p=p-next;retum(k｝第2章线性表21intj-D:suuctLnobe粉p;p=head;whilep-nextl=IrLJLLj&lt;i〔" ID="15">
          <fptr EndPN="00000030" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="p=p-next;" ID="16">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="jam-+a" ID="17">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="卜if{p-nextNULL)mturn(pdata);elseprintfpositionerror}＼n｝" ID="18">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）按值查找：tocate(head,x)按值查找又称为定位。该算法按从前往后的顺序，依次将单链表中表结点的数据域值与" ID="19">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="给定值x相比较，则返回首次找到与x相等的表结点的序号；若未找到，则返回一个特定值一" ID="20">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="1,该算法的实现如下：ins1ocate(structLnode*head,ElemTyex){iritktructLnade关p;p-head;" ID="21">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="while{(pnext！二NU”一）氏乙（尸dstal！x））" ID="22">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="23">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="P-pr-next;k＋十；｝" ID="24">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="ifip-datax)return(kelseretum（一I）吞）" ID="25">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）插人结点：insert(head,E1cmTypex,inti)该算法是在单链表head的第i个位置插入数据域值为x的结点。如果i值不正确，则显示相应错误信息；否则插入该结点，插入后使得原单链表的第i个结点变为第i十1个结点。假设我们在单链表的a结点和h结点之间插人一个x结点，已知P已指向a结点，而指针s指向x结点，如图a,sta)所示，插人后如图2.stb所示.22数据结构思考：这两个语句的顺序不能颠倒，为什么？.！.一“’$Picture[00000031\00000031_new\0004.jpg]Picture$s-1xl图2.6在单链表中插人结点栩抖f，摘白敞杜丰的蟹石一7木姑占日n竺；木全古占i{ig#占!91.rx＿片、fr'bvfitr拐S" ID="26">
          <fptr EndPN="00000031" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）生成一个值为x的新结点，并使指针5指向它。（3）将新结点插入。插人算法的实现：" ID="27">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="voidinsert（structLnode，head，EI田TyPex，inti〕" ID="28">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="术intk二0；structL欲闭e.P、价5；p＝1份d；，，（溢叱tLI优己e祷）璐11叱（51卿1（峨rL鱿沈Ln司e）｝1s4dsta二翔.～next，NUIL；" ID="29">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="while（p净nextl！NU［‘L）乙＆（k！二1-1））" ID="30">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="哎p二p净nex！岁k十十。" ID="31">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="｝／，此循环使指针p指向第卜1个结点二／" ID="32">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="if（k二＝1-1）" ID="33">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="《s－－－next＝p净nex［；" ID="34">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="p～DeXt～5布" ID="35">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="奋" ID="36">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="dseprintf（‘.po日It访error！＼n，）1｝图2.7（a）是插人前状态，而图2.7（b）是插人后状态。（6）删除结点：delet。（head，1）该算法是删除单链表head的第1个表结点。若1值不正确，则显示相应错误信息；否则删除该结点。假若要删除结点b，而指针p已指向结点b的前趋结点a，只需使p的指针域指向结点b的后继结点即可，如图2.8所示。因此，为了删除结点b。只需修改结点a的指针域即可，使结点a的指针域指向结点b的后继结点，并通过下列语句实现：p～next-p-ne洲沈～next奋第2章线性表23" ID="37">
          <fptr EndPN="00000032" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="2)从单链表中删除第i个结点。气一…二拍峥亚今’.’～(Q插入前示意图.：＿”’伪）删除后示意图图2.8单链表中删除结点" ID="38">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="删除结点算法的实现：" ID="39">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="voiddelete(structI.node*head.inti){intk=0;structLinde二P,'9:" ID="40">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="p=head," ID="41">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="white(Cp～next!=NULik！二i-X" ID="42">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="谧p=anext:玫一十；" ID="43">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="｝ifp）next！二NULL)&amp;k！二i-1｛" ID="44">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="q=p-next;p-next=qnext;free(q);于24一致据结利图2.9(a)是删除前的状态，图2.9{h3是则除后的状态!a)删除结点气前的状老图2.s在单链表上r'1除结点" ID="45">
          <fptr EndPN="00000033" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="(7）单链表的输出：display(head)该算法是顺序输出单链表的所有结点的值；若单链表为空表，则显示相应的提示信息。" ID="46">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="算法的实现如下（设数据元素类型为int型）：" ID="47">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="voiddisplsy(structLinde*head)" ID="48">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="tstructLnde器pp=held;" ID="49">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p一知next二二NULL)" ID="50">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="printfDistisemptyn" ID="51">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="e！父" ID="52">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="while(pl=NULL)" ID="53">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="?printf9o5dp-，dara" ID="54">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="p=p～next;" ID="55">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="全每｝‘·J。J早节生衣的廷工将一个线性表的所有数据元素依次顺序输人并建立该线性表的单链表，这一算法称为建友。建立单链表的基本步骤：一“，c次读入各个数据元Fri的值并插人到表“ead的表尾，并用一个指针”始终指向表" ID="56">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="毛.由它提示链人位置，由指针r生成新结点。" ID="57">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="假设数据元素的类型为char'1，用‘＄‘作为输人结束标志。第2章线性表25head二（structLnode+)mslloc(sizeof(structLnode/，head为全局变量并指向头结点。／" ID="58">
          <fptr EndPN="00000034" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="headnext=r几」LL" ID="59">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="p=head;～f（”％c＆ch）；／。读人第一个元素，／while（ch！＝‘＄‘）{r=(structLnodemal1oc(sizeof(structLnode;rdata二ch;/。生成一个新结点，／p～，next=r;p二r;/，链人新结点并修改尾指针且指向新的表尾，／scan%c&amp;ch)" ID="60">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="卜P一，next二!NULL;/。设置尾结点标志，／｝" ID="61">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="该算法的链人操作如图2.10所示。P" ID="62">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000033" TITLE="2.3.3  单链表的建立" TYPE="Chapter">
        <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
        </div>
      </div>
      <div ORDERLABEL="00000034" TITLE="2.4  双链表和循环链表" TYPE="Chapter">
      <fptr LogicalPageNum="34" PhysicalPageNum="34"/>
        <div ORDERLABEL="00000034" TITLE="2.4.1  双链表" TYPE="Chapter">
        <fptr LogicalPageNum="34" PhysicalPageNum="34"/>
        <Paragraph CONTEXT="双链表又称双向链表。双链表中每个结点有三个域：一个数据域和两个指针域，如图2.11zs数据结构带有附加头结点的双链表（头指针为dhead）如图2.12所示。图2.12双链表dhrad其中，头结点的向前指针为NULL，而尾结点的向后指针也为NULL," ID="1">
          <fptr EndPN="00000035" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="在双链表中，有些操作如求表长、读取表元和查找元素等算法与单链表中的相应算法相" ID="2">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="同，这里不多讨论。在单链表中，进行结点插人和删除操作时只涉及到前后结点的一个指针域的变化。而在双链表中，结点的插人和删除操作要涉及到前后结点的两个指针的变化。这里的变化。而在双链表中，结点的插." ID="3">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="I.双链表中结点的精入" ID="4">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="假设在双链表中指针P所指结点之后插人一个指针s所指的结点x，其插人过程如$Picture[00000035\00000035_new\0015.jpg]Picture$$Picture[00000035\00000035_new\0016.jpg]Picture$$Picture[00000035\00000035_new\0018.jpg]Picture$(c)pynext-prior长趁甜笋户." ID="5">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="下匡明卫一稗.”" ID="6">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="()A-next，{插入后第2章线性表27structDnode书prior,*next;｝；" ID="7">
          <fptr EndPN="00000036" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）插人结点：insert(dhead,x,i}该算法是在带有头结点的双链表的第i个位置上插人一个新结点x。如果i值不正确，则〔习w-rr止4ar自acrtrr七县i勃-r,士.七Y刁霖rdwJ金卜smra4r-rrivoidinsert(stntctDnode*dltead,ElemTypex,inti)" ID="8">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="{intk=0structDmde苦P.苍s;sstructI]node«)malloc(sizeuf(structDnode)／，建立欲插人的新结点，／s-data=x;sprior=s-next=NULL;p=dhead;if{i1pnextMJLL)在空表中插入新结点作为表结点，／" ID="9">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="{sprior=p;" ID="10">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="夕今next=s;" ID="11">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝else{while(k&lt;i-1pnextt=1IUI.L)(p=pnextlkF}if(k=“卜17找到第i-1结点，／{if(p-nextIvIJLL)" ID="12">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="{叫卜next二pnext；/，将s结点擂人到第i个位置。／" ID="13">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="p-nect-prior=s" ID="14">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="s-pnor=p;" ID="15">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="1卜今next=s;" ID="16">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="d哭" ID="18">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="{s-Prior°Pp）next=s;/，将s结点作为新表尾结点。／" ID="19">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="20">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="）elseprintfpositionermr！＼n" ID="21">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="22">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="23">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="2.双桩表中结点的侧除(i)在双链表中结点的删除过程" ID="24">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="假设在双链表中删除s针P所指结点之后t所指结点x，其删除过程如图2.1所示。ZS一――一一―一一一止些竺$Picture[00000037\00000037_new\0003.jpg]Picture$(2}}点：deleteCdhead,i$Picture[00000037\00000037_new\0006.jpg]Picture$$Picture[00000037\00000037_new\0007.jpg]Picture$图2.14在双链表中删除结点的过程竺子传剧峰带头结点的碟表dhead中第‘个表结点·如果‘值不正确，则显示相应的错f信息，否则删除该结点。当i二1时，当e除此结点后，则剩下只有头结点的空表；当i&gt;i时，则应找到第i-I个结点，并使P指向它，而t指向待删结点（第i个表结点）。下面给出栩味绪点算法的买现：" ID="25">
          <fptr EndPN="00000037" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="voiddelete(structDnode井dhead.inti)" ID="26">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="布intk=0;structLhiode+pt;p=dhead:" ID="27">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="if(i1)j,当双链表只有一个表结点时，／" ID="28">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="{t=p-next;" ID="29">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="pnext=NULL:" ID="30">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="free(t于】Sewhile(k&lt;i-1pnext！二NULLI。查找第i-1个结点，由p指向它。／p=p-nexr{k＋十E{pnext！二NULLk二～i-1)t二p咔next；／‘t指向待删结点，／［（卜nexr！＝NULL）Pnext-tneatiIxJ除t指向的结点第2章线性表29" ID="31">
          <fptr EndPN="00000038" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="争" ID="32">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000038" TITLE="2.4.2  循环链表" TYPE="Chapter">
        <fptr LogicalPageNum="38" PhysicalPageNum="38"/>
        <Paragraph CONTEXT="循环链表分为单循环链表和双循环链表。单循环链表与单链表的主要区别在于：表中尾结点的指针域不再是空，而是指向头结点，" ID="1">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="链表形成一个环。因此，从表中任一结点出发均可找到链表中其他结点，如图2.15所示。chead-企ai皿）C巨卜一二·“一内百）图2.15单循环链表双循环链表与双链表的主要区别是：表中尾结点的向后指针next不为空，而是指向头结以从两方向搜索其他结点。无论利用向前链或向后链，都可遍历整个链表，如果有一条链失效，则可利用另一条链修复整个链表。如图a.is所示。head奋aaiE…＃区茸了图2.16双循环链表" ID="2">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在单链表中，从任一结点出发通过指针域能找到它的后继结点，但无法找到它的前趋结" ID="1">
        <fptr EndPN="00000034" StartPN="00000034"/>
      </Paragraph>
      <Paragraph CONTEXT="点。也就是说.从某一结点出发只能顺指针往后访问其它结点，若要访问结点的直接前趋.则只能从头指针出发，这是单链表的一个缺点。而双链表中，每个结点除了数据域之外，还包含两个指针域，一个指针指向该结点的直接前趋，另一个指针指向该结点的直接后继，这样可从" ID="2">
        <fptr EndPN="00000034" StartPN="00000034"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000038" TITLE="2.5  线性表的顺序存储结构与链式存储结构的性能比较" TYPE="Chapter">
      <fptr LogicalPageNum="38" PhysicalPageNum="38"/>
        <div ORDERLABEL="00000038" TITLE="2.5.1  空间性能的比较" TYPE="Chapter">
        <fptr LogicalPageNum="38" PhysicalPageNum="38"/>
        <Paragraph CONTEXT="30数据结构所占用的存储空间之比称为存储密度。显然，在顺序存储结构中，数据域占据了整个存储结点的存储空间，故它的存储密度等于1；而链式存储结构中，存储结点中除了数据域之外，还有链域，故它的存储密度小于1.因此，顺序存储结构的空间利用率高于链式存储结构.赶乡卜，顺序存储结构要求事先估计存储容量，有时比较困难.估计过大会造成存储空间的浪费，估计过小难以临时扩充空间而导致滥出。" ID="1">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="得到充分利用，并不像顺序存储结构那样需要一块连续的存储空间。" ID="2">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000039" TITLE="2.5.2  时间性能的比较" TYPE="Chapter">
        <fptr LogicalPageNum="39" PhysicalPageNum="39"/>
        <Paragraph CONTEXT="时间性能是指在一种存储结构上算法实现的时间复杂性。因为一个实际间题总要涉及多" ID="1">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="个算法，故需分别考虑这些算法的时间复杂性。对于线性表来说，按值查找（定位算法）在顺序" ID="2">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="个算法，故需分别考虑这些算法的时间复杂性。对于线性表来说，按值查找（定位算法）在顺序表和单链表上的算法实现其时间复杂性是同量级的，均为O(n)。读取表元算法在顺序表上的" ID="3">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="时间复杂性为常量级O(1)，因此顺序表是一种随机存取结构；而在链表上读取表元的实现必须对表结点进行扫描，其时间复杂性为O(n)，因此链式存储结构是一种顺序存取结构。故当" ID="4">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="随机存取时，不宜采用链式存储结构。另外，插入、删除操作在链表上可在O(1)时间内实现，而在顺序表上通常必须移动多个结点，其时间复杂性为O(n)。故当需要经常进行插人、删除" ID="5">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="操作时，不宜采用顺序存储结构。" ID="6">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="总之，线性表的顺序存储结构和链式存储结构的实现各有其优缺点，解决实际问题时，根" ID="7">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="据处理要求，应对各方的优缺点加以综合权衡，才能最终选定比较合适的实现方法." ID="8">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000039" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="39" PhysicalPageNum="39"/>
      <Paragraph CONTEXT="1.什么是线性表？线性表的逻辑结构是什么？" ID="1">
        <fptr EndPN="00000039" StartPN="00000039"/>
      </Paragraph>
      <Paragraph CONTEXT="2.线性表有哪两种存储结构？各自优缺点是什么？‘第2章线性表31序单链表headCoi2.设计一个算法，显示一个单循环链表中的所有元素，当存在两个或两个以上元素时，前一个元素要用符号指向下一个元素。" ID="2">
        <fptr EndPN="00000040" StartPN="00000039"/>
      </Paragraph>
      <Paragraph CONTEXT="13.在双链表上实现下列基本运算：(1)按值查找；(2)删除第i个结点；(3)在尾结点后" ID="3">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="14.设有一个双循环链表L-(a,b,c,d),如图2.17所示。设写一个算法，将该链表转换图2.17一个双循环链表" ID="4">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="15.设有一个单循环链表，其中指针P指向一个结点.试写一个算法，将P所指结点与其" ID="5">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000040" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="40" PhysicalPageNum="40"/>
      <Paragraph CONTEXT="1.内容：线性表" ID="1">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="2.目的：掌握单链表的基本操作与算法，包括单链表的建立与插人。" ID="2">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="试实现下列操作或算法：" ID="3">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）对这两个线性表分别建立一个带附加头结点的单链表ha和hb。" ID="4">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）将两单链表恤和hb合并成一个单链表址.并保持其有序性且输出该链表：" ID="5">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）在单链表hc中，插人一个值为x的结点，使插人后该链表仍然有序并输出此链表。" ID="6">
        <fptr EndPN="00000040" StartPN="00000040"/>
      </Paragraph>
      <Paragraph CONTEXT="4.要求32数据结构" ID="7">
        <fptr EndPN="00000041" StartPN="00000040"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="价气气知气、为气匆气台刁＄、气气气今，翔.，勺气，神。娜气勺气气今气气‘气气气‘气飞矛本章要点：(1)线性表的逻辑结构及其基.本算法（2)线性表的顺序存本章目的：(1)搞清线性表的逻辑结构及墓本算法（2)掌握线性表的序存储结构、链式存储结构及其墓本算法的实现方法" ID="1">
      <fptr EndPN="00000022" StartPN="00000022"/>
    </Paragraph>
    <Paragraph CONTEXT="才气铎奴？吸p仁军峥仁牢去‘坛勺坛纷怜气坛坛坛纷气？概字怜坛坛勺气坛气坛去常仑布气勺纷‘二欢母表（A,32)都是线性表，表中每个数字或字母是一个数据元素。又如表1.1也是一个线性表，表中每一行是一个数据元素，它由编号、姓名、…、实发金额等数据项组成.本章将介绍" ID="2">
      <fptr EndPN="00000022" StartPN="00000022"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000041" TITLE="第3章  栈和队列" TYPE="Chapter">
    <fptr LogicalPageNum="41" PhysicalPageNum="41"/>
      <div ORDERLABEL="00000041" TITLE="3.1  栈" TYPE="Chapter">
      <fptr LogicalPageNum="41" PhysicalPageNum="41"/>
        <div ORDERLABEL="00000041" TITLE="3.1.1  栈的定义及其基本操作算法" TYPE="Chapter">
        <fptr LogicalPageNum="41" PhysicalPageNum="41"/>
        <Paragraph CONTEXT="第3章栈和队列33" ID="1">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="一一～一一～一一－～一～－一－日白翔白自" ID="2">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="f一州卜一刊tOP一卜答刊「一月卜一」匕一一』P～LA匕‘A一！IA1tQP-1一兰‘｝wY~(a)空栈(b)A入栈(c)B.C.D入栈（d)D出栈（(e)C.B出栈图3.1栈的操作示意图" ID="3">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="2.栈的基本操作算法栈的基本操作算法有以下几种：" ID="4">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）初始化栈：Initstack(S)该操作是建立一个新的空栈。" ID="5">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）人栈：push(S,X)该操作是将数据元素X插人到栈5中作为栈顶元素。" ID="6">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）出栈：pop(s)该操作是当栈不空时，删除找顶元素，使栈顶指针指向下一个元素位置。" ID="7">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）判栈空：Empty&lt;S)" ID="8">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是若栈S为空栈，则返回1；否则返回。。" ID="9">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）读取栈顶元素：gettop(S)" ID="10">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是返回当前的栈顶元素。" ID="11">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(6}输出栈中元素：display(s)" ID="12">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是从栈顶开始依次顺序显示栈中所有元素。" ID="13">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="例3.1栈的基本操作" ID="14">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="initstack(S/，建立一个空栈，／" ID="15">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="Push（5，’）’）；" ID="16">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="Push（5，才）；" ID="17">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="push(S,’一‘），push(Sc)34数据结构pop(S/，元素〔出栈‘／PoF(S/，元素&quot;a口出栈，／pap(S/，元素十.栈，／pop(s/。元素h出栈‘／popCS/，元素）出栈二／ch，gettoP（5）；／，栈顶元素‘二读出并赋给chretum(empty(S;/。栈非空，故返回。二／" ID="18">
          <fptr EndPN="00000043" StartPN="00000042"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000043" TITLE="3.1.2  栈的顺序存储结构及其基本操作算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="43" PhysicalPageNum="43"/>
        <Paragraph CONTEXT="栈的顺序存储结构称为顺序栈。顺序栈通常由一个一维数组和一个指示栈顶位置的变量；。习惯上将栈底放在数组下标小的那端。假设用一维数组：t[7〕表示一个栈，并用一个变组成。习惯上将栈底放在数组下标小的那端。(a)栈空(b)&quot;入栈（(c)B.C.D入栈（(d)D出栈（(e)E.R,G入栈图3.2顺序栈的几种状态(a）表示顺序栈为栈空，由初始化操作得到。此时栈顶指示变量或称栈顶指针的下标值＿日n二nqfern里f[摄炸沛『吞声庄“门盯世”为0，即top二0。（b）表示元素A人栈，此时toP＝1。（c）表示在（b）基础上，B、C、D三个元素相继人栈，此时top！4。" ID="1">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="（d）表示在（c）基础上，元素D出栈，此时top＝3。" ID="2">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="（e）表示在（d）基础上，三个元素E、F、G相继人栈，toP-6，这种状态称为栈满。此时如" ID="3">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Picture URL="00000043\00000043_new\0014.jpg">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Picture>
        <Picture URL="00000043\00000043_new\0015.jpg">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Picture>
        <Picture URL="00000043\00000043_new\0016.jpg">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Picture>
        <Picture URL="00000043\00000043_new\0017.jpg">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Picture>
        <Picture URL="00000043\00000043_new\0018.jpg">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Picture>
        <Paragraph CONTEXT="果再作人栈操作，则会产生“上溢’。" ID="4">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="顺序栈的存储结构类型定义为：" ID="5">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="特defineMAXS】ZE100" ID="6">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="，truct明stack" ID="7">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="｛曰助T犯神：t［加沙0污】2日；InttOP；｝书下面介绍顺序栈基本操作算法的实现。" ID="8">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）初始化栈：1川tstack（5）第3章栈和队列35sstop=0;" ID="9">
          <fptr EndPN="00000044" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="争" ID="10">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="{2）人栈：gush(S,X)该操作算法是将元素X插人或压人到栈S中，先使栈顶指针加1，然后将X置于栈顶位置；若在插人前已经栈满，则显示相应信息.voidpush(structsgstack*S,EletnTypeX)｛if(StopMAXSIZE-1)" ID="11">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(&quot;上滋！,ntelse谧" ID="12">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="Stop＋十；" ID="13">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="5～：t〔5，to司＝X，｝｝或者voidpush(structsgstack*S,ElemTypeX)" ID="14">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="｛if(Stop&lt;MAXSfZE-1)｛" ID="15">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="5今mP十＋；Sst[S-top］二3｝" ID="16">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="elseprintf上,！1n）" ID="17">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）出栈：pop(S}该操作算法是从栈中删除栈顶元素。若栈空则显示相应信息，否则栈顶指针减1.使其指" ID="18">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="向下一个元素.voidpop(structsgsrack*S,ElemType*X)（if（5～topl＝0）X二Sst[S-topS-top一一；｝else｝" ID="19">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）取栈顶元素：gettop(S}" ID="20">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作算法是返回栈顶元素，且保持栈顶指针不动。若栈为空则显示相应信息。36数据结构elsereturn(S-st[S+top｝C5）判栈空：empty(S)该操作算法是判断栈是否为空。若栈为空则返回1；否则返回。。interttpty(structagstack*S)笼if(S-top°=0)return(1" ID="21">
          <fptr EndPN="00000045" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="22">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="return(0" ID="23">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="｝{6）输出栈中元素:display(S)该操作算法是从栈顶开始依次顺序显示栈中所有元素，但栈顶指针的位置原地不动。voiddisplay(structsgstack*S)" ID="24">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="｛inti;for(i二S-estop;i0;i一一）printf%c&quot;.Sr-st[i;" ID="25">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="printn&quot;争例3.Z试阅读分析下面程序，并指出运行结果。" ID="26">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="十dto才n卜。，p盛，门户main()｛structsgstack*sq;printf”建一个空栈\initstack(sq);printf”栈空：%d\nernpty(sq" ID="27">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(”依次插人字符＋一八％元素＼n" ID="28">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="Push{sqt" ID="29">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="push(sq,’一’）；" ID="30">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="例sh（sq，’肠‘）；push(sq,;push（sq，‘％‘）；printf栈中元索：”）；display(sq" ID="31">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(”退两次栈\nrppCSq)PaP(sq第3章栈和队列37｝" ID="32">
          <fptr EndPN="00000046" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="本程序运行结果：" ID="33">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="建一个空栈" ID="34">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="栈空：1依次插入字符＋，一八％元素栈中元素：写／，一＋" ID="35">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="退两次栈" ID="36">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="读取栈顶元素：，栈中元索：。一十" ID="37">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000046" TITLE="3.1.3  栈的链式存储结构及其基本操作算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="46" PhysicalPageNum="46"/>
        <Paragraph CONTEXT="采用链式存储结构的栈称为链栈。链栈的组织形式与单链表类似，如图3.3所示。图3.3链栈的存储结构在图3.3中（a)表示含有三个元素A,B,C的链栈的存储状态；(b)表示在（a)的基础上元$Picture[00000046\00000046_new\0005.jpg]Picture$$Picture[00000046\00000046_new\0006.jpg]Picture$$Picture[00000046\00000046_new\0007.jpg]Picture$素C出栈后的状态；(c)表示在（b)的基础上又进栈一个元素T后的状态。链栈的存储结构类型定义为：" ID="1">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="structLinknode" ID="2">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="3">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;" ID="4">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="structLinknode+next;下；应当指出，一个链栈由栈顶指针Ltop唯一确定。当Ltop为NULL时。是一个空栈。下砚轩吞烟胜烤的茸太场作瞥幸仁的喻士训" ID="5">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）初始化栈：initstack(Ltop)" ID="6">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是建一个新的空链栈，实际上是将栈顶指针Lt叩置空。" ID="7">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="voidinitstack(structLinknode+Ltop}" ID="8">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="｛Ltop=NULL;｝" ID="9">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）人栈：push(Ltop,X)" ID="10">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是将元素X插人到栈Lt叩中，并使栈顶指针Ltop指向新结点X,38数据结构p=(structLinkmdemalloc(sizeof(structLnkrtode;p-data-X;/，将X填人新结点的dal。域x/pynezt=Clap;/，原栈顶指针链人新结点的next城。／Ltop=p;/。新结点X成为新的栈顶，／｝" ID="11">
          <fptr EndPN="00000047" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）出栈：pap(Ltop)该操作是从链栈中删除栈顶元素。若栈为空则显示相应信息；否则栈顶指针指向下一个下井书卜31r典毖[r3a二Ap[f七&amp;r/tXvoidpop(structLinknode+Ltop,ElemType*t)" ID="12">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="t" ID="13">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="structLinknode+p;if(CropNULL)printf(”产生下滋！`n，，" ID="14">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="else｛P二Ltop;/，使P指向栈顶结点，／器t-p-deta;Ltop二p中next;使Ltop指向下一个结点，／" ID="15">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="Fraarn、。／。招络希份。‘俘J倪夕主占.／" ID="16">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="free（p）。杏" ID="17">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）读取栈顶元素：gettoP〔LtoP）该操作是读取栈顶元素.若栈为｛若栈为空则显示相应信息；否则返回栈顶元素，且栈顶指针保持" ID="18">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="不动。ElemT即e即ttop（structLinkl丫记e件Ltop）（if（LtoP“二NULL）pdntf（”Stackis曰刀ptyl＼n，，）；elseretum（LtoP呻data）；）" ID="19">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）判栈空：empty（Ltop）" ID="20">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是若栈为空则返回1；否则返回0。" ID="21">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="in［emP［y（structLinknode书1‘toP）" ID="22">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="23">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="if（LtoP，＝NULL）return（1）书第3章栈和队列39typedefcharFJertIType;voiddisplay(st二tinknode+Ltop)｛structLinknode*t;t-Ltopwhile(tl=M.JI_L)｛printfctdata" ID="24">
          <fptr EndPN="00000048" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="t，t扮next;" ID="25">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="26">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="printffin" ID="27">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例3.3试写一算法，借助栈将一个带头结点的单链表倒置，如图3.4所示。竺瞬口｛亚子.”州困困竺酬丑诬工于.”气困囚分析：利用栈的后进先出的特性，先沿单链表head从头到尾扫描一遍，将单链表的每个表结点data域的值依次进人链栈，然后再沿链栈从栈顶到栈尾扫描一遍，同时栈中元素依次出栈，并填人到链表的每个结点的data中，这样便形成了单链表的倒置二算法描述如下：voidrevetse_list(struct1,inknode*head)丈structLirkrpde二ls,*p;ElemTypex;initstack(ls7;/，链栈初始化.／P二head-中二xt;;，使P指f单链表的首结点二／wl7ile(p!=MJLL)毛pu9h{L9;pdata7;PvP奋加xt.卜／，此循环使单链表的表结点依次人栈，／p=head-next;" ID="28">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="whileempty{1s))" ID="29">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="30">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="pop(lsx)t犷司a加＝x；p=pnext40数据结构" ID="31">
          <fptr EndPN="00000049" StartPN="00000048"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000049" TITLE="3.1.4  栈的应用举例" TYPE="Chapter">
        <fptr LogicalPageNum="49" PhysicalPageNum="49"/>
        <Paragraph CONTEXT="栈是一种十分重要的数据结构，栈在实际中，特别是在计算机软件系统中得到非常广泛的应用，它可以很好地处理和解决具有“后进先出”特性的各种问题。这里着重介绍栈与函数的" ID="1">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="嵌套调用以及栈与函数的递归调用之间的关系，通过调用过程了解其实现的内部机理，以便为我们后续章节的学习莫定必要的基础。" ID="2">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="1，找与函数的嵌套调用" ID="3">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="为了说明栈与函数的嵌套调用之间的关系，下面我们给出一个示例。示例：用弦截法求方程x3-5xz+l6x-ao二。的根。求解过程如下：" ID="4">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）取两个不同点xl和x2，求出f(xl）和f(xz)，如果f(xl）和f(）异号，则在（xl,xz）区但应保持（xi,xz）区间内只有一个实根。" ID="5">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="图3.b函数f(z)图3.6弦截法N-S流程图x点可由下式求出：$Picture[00000049\00000049_new\0015.jpg]Picture$$Picture[00000049\00000049_new\0016.jpg]Picture$x一址芸景瑞戈抖且由x求出f(x" ID="6">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)若f(x)与f(xl）同号，则根必在（x,xz）区间内，此时将x作为新xl。如果f(x)与f&lt;xz)" ID="7">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="同号，则根必在〔XZ,X)区间内，此时将X作为新的x20" ID="8">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）重复步骤（2）和（3），直到If（x）1＜。第3章栈和队列41一―一～～－－一一－－－－一～－－－－一＿函数xpoint，而执行xpoint过程中要调用f函数。请读者先分析下面的程序：" ID="9">
          <fptr EndPN="00000050" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="include&quot;mathh&quot;" ID="10">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="floatfloatx)" ID="11">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="咬floaty;yx-5,0x+16.6x-80.4;" ID="12">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="rettuniy);）floatxpoint（floatxl,floatx2)" ID="13">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="｛floaty;y=Cx1*f(x2）一xxf(xli(x2〕一f(xl" ID="14">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="retttrn(y);｝floatrnot(floatxl,floatx2)" ID="15">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="16">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="inti书" ID="17">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="floatx,y,yl;" ID="18">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="y1=f(xl" ID="19">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="do｛x＝x师nt（滋，xZ）；" ID="20">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="y=f(x" ID="21">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="if(vl二Y一＞C?{yl=y;xl二x;)" ID="22">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="elsex2=x;}while(fabs(y)＞二o.ooool" ID="23">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="return(x);" ID="24">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="25">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="main()可floatxl,x2,fl,f2,x;" ID="26">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="do｛以，nf（”％几％f＆且，＆‘＆且，＆沼hE1二f(xlf2-f(x2Iwhile(flxf2＞二0);：弃r刚（xl，xZ）；printrealrootofequationif%f&quot;，二〕；42数据结核数xpoint，而函数xpoint又调用函数f。这些函数的嵌套调用关系如图3.7所示：在函数嵌套调用的过程中，编译软件则设置一个找，称为“工作栈”，专门用于存放被调函$Picture[00000051\00000051_new\0004.jpg]Picture$所示，主函数main执行到sl时则调用root函数，这时main函数暂时在t1处中断，tl称为断$Picture[00000051\00000051_new\0008.jpg]Picture$$Picture[00000051\00000051_new\0009.jpg]Picture$$Picture[00000051\00000051_new\0010.jpg]Picture$$Picture[00000051\00000051_new\0011.jpg]Picture$$Picture[00000051\00000051_new\0013.jpg]Picture$$Picture[00000051\00000051_new\0014.jpg]Picture$类似地，当xpoint函数执行到s3时则调用f函数，这时xpoint函数的i'r.点t3，即调用函数f结束后的返回地址，此时t3人栈。利用栈的后进先出的特性，当调用函数f结束后，则它的返回地址t3出栈，从t3处继续执行xpoint函数；当调用函数xpoint结束后，则它的返回地址t2出" ID="27">
          <fptr EndPN="00000051" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="栈，从t2处继续执行root函数；当调用函数root结束后，则它的返回地址tl出栈，从tl处继" ID="28">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="{d）调用f后sersaa.ucn.二43书3早?a(1'WNJ＿一" ID="29">
          <fptr EndPN="00000052" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="Irmgfac(intn)" ID="30">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="longd:" ID="31">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="ifn二二0)！1(n1" ID="32">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="d" ID="33">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="34">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="调用公一寻石／低溉／尸｛" ID="35">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="°i\i＼＼;1\l" ID="36">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="愉出结果fac(3bfac(2j=2fac(l1" ID="37">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="d二n*fac(n-1" ID="38">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="return(d" ID="39">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="｝下面给出主函数：瓜ain()｛ltmgp；图3,9调用fac(3）的递归调用一返回过程p=fac(3);printf3{=°°/uld\ri,p该函数的递归调用一返回过程如图3.9所示。$Picture[00000052\00000052_new\0025.jpg]Picture$$Picture[00000052\00000052_new\0026.jpg]Picture$$Picture[00000052\00000052_new\0027.jpg]Picture$$Picture[00000052\00000052_new\0028.jpg]Picture$$Picture[00000052\00000052_new\0029.jpg]Picture$$Picture[00000052\00000052_new\0030.jpg]Picture$性，将其返回地址和调用的参数值一一出栈，与图3.9相应的递归调用一返回其工作栈状态变化如图3.10所示。" ID="40">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="{d）调用fac(1）后" ID="41">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000052" TITLE="3.2  队列" TYPE="Chapter">
      <fptr LogicalPageNum="52" PhysicalPageNum="52"/>
        <div ORDERLABEL="00000053" TITLE="3.2.1  队列的定义" TYPE="Chapter">
        <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
        <Paragraph CONTEXT="队列也是一种操作受限的线性表，但它与栈不同。其所有的插人均限定在表的一端进行，而所有的删除则限定在表的另一端进行。允许插人的一端称为队尾〔rear允许删除的一端称为队头（front)。向队列中插人新元素称为人队或进队，新元素人队后就成为新的队尾元素；从队列中删除元素称为出队或离队，元素出队后，其后继元素就成为队头元素。队列的工作特点是先人队的元素先出队。假定队列Q二（a;，aZa一：，ai，…，an），则队列e中的元素" ID="1">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="a,a,‘二ate,&amp;“二a.出队十al吸，－－称1头一气十入队个个" ID="2">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="图3.11队列的示意图" ID="3">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="由于队列的插人和删除操作分别是在各自的一端进行的，每个元素必然按照人队的次序" ID="4">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="而出队.所以通常又把队列称为先进先出表。" ID="5">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="在日常生活中，队列可随处出现，如人们到火车站售票窗口购票，总是按照先来先买票而" ID="6">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="后来后买票的次序排成队列。" ID="7">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="与栈类似，队列的基本操作算法有以下几种：" ID="8">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）初始化：initqueue（Q）" ID="9">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="该操作是建立一个空队列Q。" ID="10">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）人队列：enteque（Q，x）该操作是在队列的尾部插入一个新的元素xa" ID="11">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）出队列：deleteqoe（Q）该操作是删除队列的队头元素。" ID="12">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）取队头元素：gethead（Q）该操作是读取队头元素，且取得队头元素后，而指向队头元素的指针并不修改。" ID="13">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）判队空：empty（Q）该操作是判断队列是否为空。若队列Q为空，则返回1；否则返回0。" ID="14">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="（6）输出队列中元素：display（Q）该操作是从队头到队尾顺序显示队列中所有元素。" ID="15">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000053" TITLE="3.2.2  队列的顺序存储结构及其基本操作算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
        <Paragraph CONTEXT="第3章找和队列4a仁defineMaxsize140" ID="1">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="则队列的顺序结构可描述为：" ID="2">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="atructsequeue" ID="3">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="4">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="El二Typeelem[Maxsize" ID="5">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="intfront,rear;" ID="6">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；$Picture[00000054\00000054_new\0009.jpg]Picture$由此我们可以说明一个顺序队列Q:structsequeue*Q;图3.13是可容纳6个元素的顺序队列在操作过程中首尾指针变化的示意图.其中（a)为该队列的初始状态为空，Q～二Q-front＝一1b}表示有三个元素ai.az,相继人队，故有Q-rear=2，而Qfront保持不动；(c)表示az.as先后出队，队列又成为空队，此时心卜争图3.13队列中元素出人队与首尾指针的关系下面给出在顺序队列上基本操作算法的实现：" ID="7">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）队列初始化：initqueue(Q)$Picture[00000054\00000054_new\0021.jpg]Picture$$Picture[00000054\00000054_new\0022.jpg]Picture$$Picture[00000054\00000054_new\0023.jpg]Picture$$Picture[00000054\00000054_new\0024.jpg]Picture$功能：建立一个新的空队列Q。将首尾指针fron：和rear均置成初始状态，即取值为一10voidinitqueue(structsequeue*Q)" ID="8">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="9">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="Qfront=Qrr＝一1;" ID="10">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="11">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）人队列：enter(Q,x)46数据结构＿＿····－一一一一一一－－～roidenter(structaequeue*Q.ElemTypex)｛if(Qrear一，Maxsize-1)printf上锐?fint" ID="12">
          <fptr EndPN="00000055" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="13">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="｛Q卜Iear十十；¢ele[gLQ`ICSr〕=Et" ID="14">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="15">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="卜&lt;3）出队列：delete(Q)功能：将队列Q的当前队头元素删除，即出队。若Q为空队，应给出相应信息，否则队首指针加1，即队首指针上移一个位置，而使被删头元素的后继元素成为新的队头元素。vooddelete(structsequeue‘Q)｛if(Qfront二二Q中rear)" ID="16">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="printf”队列为空！ni" ID="17">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="else守申front十十；｝" ID="18">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）取队头元素:gethead(Q)功能：返回当前的队头元素.即front+l位置上的元素。ElernTypegetltead(structsequeue劳Q)｛if(Q，front一二Q-rear)printf’空队列！nelsereturn(Q，eietn[Qfmnt-11);）" ID="19">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）判队空二empty(Q)" ID="20">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="功能：若队列Q为空，则返回1，否则返回0," ID="21">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="antempty(structsequeue*Q)" ID="22">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="｛if{QfrontQ-rear)retum(1);else第3章栈和队列4?" ID="23">
          <fptr EndPN="00000056" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="tnts;" ID="24">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=Q-front+l;iLr-rearii--)" ID="25">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="printfns" ID="26">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="｝采用顺序队列这种存储结构存在假溢出问题。当新的元素人队时，若此时队列中已经有size个元素，就会产生溢出。但是，假若有Maxsize次人队操作，m(0&lt;mCMaxsize）次出Maxs坛e个元素，就会产生溢出。但是，假若有Maoize次人队操作，m（0＜m《Maxsize）次出队操作，则在队列的队首部分会空出许多位置，而队尾指针指向队列中最后一个元素位置，无法使新的元素人队，这样就造成假溢出，导致队列空间的浪费。使用循环顺序队列可以解决假溢出间题。循环顺序队列是把顺序队列构造成一个首尾相连的循环表。当队列的第Maxs映一1个$Picture[00000056\00000056_new\0016.jpg]Picture$$Picture[00000056\00000056_new\0017.jpg]Picture$置上。监，而它与图3.14（c）所示队列为空的情况一样，均有Q今front＝Q今rear。那么，循环顺序队劲，占之1以盗法召1盆1竺盆配1坐d映‘卫乙孟上J习.矛J‘／.吐尼0’＠Q一五协。tQ一邝ar〕）（a）〕）（c）（d）图3.14循环队列动态变化示意图从图3.14（c）可看出，循环队列的队空条件是：Q今rear“今Q～f和t" ID="27">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="如何判断队满呢？在人队时则少用一个元素空间，以队尾指针加1等于队首指针判断队" ID="28">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="满，即判断队满的条件为：" ID="29">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="（Q，rear＋1）％Maxsize二二Q一，front" ID="30">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="其中％为求模运算符。图3。14（d）表示队满状态.48数据结构" ID="31">
          <fptr EndPN="00000057" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）人队：enter(Q,x)功能：将元素x插人到队列Q中，若队列已满，则给出相应信息；否则使尾指针加2，对MAXSIZE取模后，x人队.放在尾指针所指的位置.voidenter(9tructsequeue+Q,ElemTypex)长ifQ～rear+lMaxaize二＝Q-frant)printfQueueisfull!\n一）." ID="32">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="else硬Q-resr二（Qrear十Z)°/nMAXSIZE;" ID="33">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="Q-，elern[Qyrear]二x;" ID="34">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝" ID="35">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）出队：delete(Q)功能：删除队头元素，将队首指针加1即可.voiddeletes吐ructsequeue*Q)亏if(QfrantQ-今rear)printfQueueisempty;\n&quot;elseQ-卜f二nt二（Q-front二1}%MAXSiZE;｝" ID="36">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）取队头元素：gethead(Q)功能：返回队头元素，而队首指针保持原位。ElemTypegethead(structsequeue*Q)｛if{Qf了ontQ-rear)" ID="37">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="printfQiueueisempty！\nreturn(Qel二二（Q-ftnnt+IMAXSIZE卜" ID="38">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）判队空：empty(Q)功能：判断队列Q空否。" ID="39">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="若Q为空，则返回1；否则返回。。" ID="40">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="intempty{structseyueue*Q)" ID="41">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="（if(QfrontQrear)retum(1);第3章栈和队列49voiddisplay(atructaequeue+Q)" ID="42">
          <fptr EndPN="00000058" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="43">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="intl:" ID="44">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="if(empty(Q))" ID="45">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(&quot;队列为空，不能显示1、n" ID="46">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="47">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="《" ID="48">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="i=Qfront-1t" ID="49">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="whilei%MAXSIZE7！二Q-rear)" ID="50">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="printfrQ，elem[i°aMAXSIZE;printfcQelem[i%M.AXSIZEprintfCn:" ID="51">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="52">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例3.4假设Q[10］是一个顺序队列，初始状态为frant=rear二一1.画出做完下列操作后队列的头尾指针的状态变化情况，若不能人队，请指出其元素.并说明理由。" ID="53">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="d,e,b,g,h人队；d,e出队;i,j,k,l,m人队;b出队；n,o,p,q,r人队。fa）初始状态(b)d,e.g,b,h入队（c)d,e出队（(d}i,j,k,1、二入队（e)b出队$Picture[00000058\00000058_new\0021.jpg]Picture$$Picture[00000058\00000058_new\0022.jpg]Picture$$Picture[00000058\00000058_new\0023.jpg]Picture$$Picture[00000058\00000058_new\0024.jpg]Picture$$Picture[00000058\00000058_new\0025.jpg]Picture$图3.15顺序队列人队和出队的变化如图3.15所示，图3.15Ca)表示队列的初始状态，图3.15(b）表示元素d,e,b,g,h人队后的状态，此时front＝一l,reac=4。图3,15(c)表示元素d,e出队后的状态，此时front=1,rear_；图3.1S(d）表示元'i,j,k,l,m人队后的状态，此时front=l,rear=9；图3.1a(e)表示元素b出队后的状态，此时front=2,rear=9。此时若再使n,o,p,q,r人队，显然将产生上槛a50数据结构示n,o,p人队后的状态，此时front=4,rear=3;{g)表示g出队后的状态，此时front=5；如果这时让q,r入队，则q可入队，但r人队时，由于此时rear二4,front=5，则有（(rear+l11-" ID="54">
          <fptr EndPN="00000059" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="rear" ID="55">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="、哪巍砰扒加彦知$Picture[00000059\00000059_new\0008.jpg]Picture$$Picture[00000059\00000059_new\0009.jpg]Picture$$Picture[00000059\00000059_new\0010.jpg]Picture$盆吧习r(b)d.e.b.g.t入队后（c)d.。出队（(d)i,j.k.1,m入队后毋" ID="56">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)初始状态" ID="57">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="(fln.o.p入队后(g)g出队" ID="58">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="图3.16'（环队列人队和出队变化情况" ID="59">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000059" TITLE="3.2.3  队列的链式存储结构及其基本操作算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="59" PhysicalPageNum="59"/>
        <Paragraph CONTEXT="队列的链式存储结构是由结点构成的单链表，但只允许在单链表的表头进行删除和在单" ID="1">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="链表的表尾进行插人，故需使用两个指针：队头指针front和队尾指针rear.用front指向队头结点的存储位置，用～指向队尾结点的存储位置。用于存储队列的单链表简称为链队列。" ID="2">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="链队列的结点结构类型可描述为，" ID="3">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="atructLq宜lode〔ElemTypedata;atructI.gnode*next;第3栈和队列S1图3.1了给出了链队列的示意图二$Picture[00000060\00000060_new\0003.jpg]Picture$$Picture[00000060\00000060_new\0004.jpg]Picture$9一吵口二牙喂复丑压正手已囚t一代盯七－一二到卜－一一一一(d)outQucuc(Q,x)图3,t7队列示意图图3.18链队列操作指针变化示意图关于链队的初始化、人队、出队操作其动态变化过程如图3.1$所示。下面给出链队列基本操作算法的实现。" ID="4">
          <fptr EndPN="00000060" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）初始化voidinitQueue(LQueueTl'，Q)咬毗州切仪xfe*p;P一（strut[Lgnode二）malloc(sizeoftstrut[Lgnode)1;" ID="5">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="‘护今next-NULL;" ID="6">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="Q=(LQueueTPmallac(sizeof(LQueueTP:" ID="7">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="Cr-frpnt～p;Q申脱ar一仇｝" ID="8">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)判队空intemptyQueue(LQueueTP‘Q)" ID="9">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="《" ID="10">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="if(Gfront=Qrear)" ID="11">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="return(1)" ID="12">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="elseretum(0)i夕" ID="13">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）人队列voidenQueue(LQueueTP*Q,ElemTypex)＜" ID="14">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="structLgniode+si" ID="15">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="sst二tLgnodes)mall二（sizeaf(st二tLgtwde3)52数据结构Q-rear-s;" ID="16">
          <fptr EndPN="00000061" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="17">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="C4）出队列roidoutQueue(LQueueTP«Q,ElemType*x)亏structLgnade*p;if(FmptyQueue(QprintfQueueisempty,\nelse" ID="18">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="（p-Q-frontnext;*x=pydata;Q-front”next=p-next;ifip-next二二NULL);。链队列中只有一个表结点，／Q-tear=Qyfrelnitfree(p)" ID="19">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="20">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="(S）取队首元素filemTypegethead(LQueueTP二Q)悦" ID="22">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypex;strictLgnpde*p;if(EmptyQueue(QprintfC&quot;Queueisemptyl＼n:else" ID="23">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="毛p=Qfront～next;x=p-Mdata;" ID="24">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="return(x)i" ID="25">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="26">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="｝cs)输出队列全部元素二oiddVaplay(LQweueTPoQ)《structLgnode}p:p=QyfrOrn-t3exttwhile(p!=NULL)谁printfcpdatap=pnext;" ID="27">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="28">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例3.6阅读下面程序，指出运行结果。本程序中主要利用上述定义的基本操作函数。第3章栈和队列53typedefcharElempType" ID="29">
          <fptr EndPN="00000062" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="main()" ID="30">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="褚" ID="31">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="LQueueTP+LQ;print”初始化队列LQninitQueue(LQ）书printf”依次入队A,B,C,D元素＼nenQ此。e（LQ，，A‘）；" ID="32">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="enQueue(LQB)" ID="33">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="enQueue（LQ，亡）；" ID="34">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="即Queue（LQ，D），print”显示队列元素display(LQ)" ID="35">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(”出队一次、n”" ID="36">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="outQueue(I,Q);printf(”队首元索c\ngethead(LQiprintf(”队列元索：display(L4:" ID="37">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="卜" ID="38">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="运行结果：" ID="39">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="初始化队列1依次人队A,B,C,D元素显示队列元素:ABCD" ID="40">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="出队一次CD" ID="41">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="44数据结构" ID="1">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000062" TITLE="3.3  栈和队列的综合应用举例" TYPE="Chapter">
      <fptr LogicalPageNum="62" PhysicalPageNum="62"/>
      <Paragraph CONTEXT="栈和队列在实际中具有广泛的应用。在这里，结合栈和队列，通过一个完整的示例来说明栈与队列的综合应用。这个综合应用示例就是停车场管理。54数据结构在便道上等候是按队列的工作方式进行的.因此，将停车场设计成一个栈，汽车让路也需要另.卜广,入口一卡便道－－卜出口圈" ID="1">
        <fptr EndPN="00000063" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="图3.19停车场示意图" ID="2">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="停车场管理的算法描述如下：{1)输人命令和车号；" ID="3">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)若命令j'A'，则有汽车要进停车场，先判断停车场找是否满，若不满，则汽车入栈，否" ID="4">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="则汽车人便道队列等候。" ID="5">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)若命令为公，则是汽车要离开停车场，为给该汽车让路，将停车场栈中若干辆汽车人临时栈，等这辆汽车出停车场后，临时栈中汽车出栈.再进人停车场找，然后看便道队列是否为空，若不空则说明有汽车等候，从队头取出汽车号，使该车进人停车场栈。" ID="6">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)重复（123)直到接收命令（车号为。或负数）为止。停车场管理程序如下：井include&quot;stdio,h&quot;" ID="7">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="#itulude&quot;9tdlib.h&quot;" ID="8">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="#definestack_ize10lypedefgtruct;gstack/，顺序拽结构类型定义‘／iintdata[stackgizeanttop;／、以下是链队结构类型定义，／" ID="9">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="rypedefRtruct1inkedqueue" ID="10">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="{intdata;第3章栈和队列55push(sgstackTP*sq,ElemTypex)/，人栈函数、／｛if(sq今tOpst二ksize-1)printf栈上溢!\nelse" ID="11">
        <fptr EndPN="00000064" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="12">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="scrtop;9q今data[sq十top]-x;｝" ID="13">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="｝pop(sgarackTP*sq.ElemType璐x)出栈函数‘／吮if(stdtoPU)、丫）；" ID="14">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="else｛*x=sqdata[sqestop" ID="15">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="sqestop一一；" ID="16">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝intEmptystack(sgsrackTP*q)，判栈空函数，／咬if（sq今top““0）" ID="17">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="return(1);" ID="18">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="19">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="retwn(0｝intGetTop(sgstaokTY二sq,ElernType*x)，取栈顶元素，／｛if(sq-topU)(grintf空！\n；returnCOid配" ID="20">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="i，x=sq二data[eqtop" ID="21">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="return(I;" ID="22">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝／，以下是链队基本操作函数.／InitQueue(QueptrTP+1q)%*队初始化＊／" ID="23">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="｛LqurueTP+p;" ID="24">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="p，{LqueueTP，}malloc*(sizeof(LqueueTP;" ID="25">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="lqfront°p;lq～rear片p;56数据结构｝voidEnQueue(QueptrTP*1q,ElemTypex)/，人队函数，／（" ID="26">
        <fptr EndPN="00000065" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="LqueueTP*p;p-(LqueueZY笼)malloc(s二f(LQueueTP;P一扣data-x；p卜.next今NUI卜Iqrea份next=p;1q-rear=p;｝voidoutQueue(QueptrTP*1q,ElemType+x}/。出队函数‘／谧" ID="27">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="LqueueTP*s;if(lq-front＝二lq-gear)printf，队空！＼n,，):else" ID="28">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｛s=1q～ftvnt～next;«x=s～tlata;lq-frontnext-snext;if(s-next，一NULL)lq～二lq-卜fmnt;free(s)" ID="29">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="30">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝intEmptyQueue(QueptrTP。1y)/-sJ队空，／｛if(lq～一！lqfmnt)return(1);" ID="31">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="32">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="return(Q);" ID="33">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝tetHead(QueptrTP1q,ElemTypex)/，取队首元素‘/｛" ID="34">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="LqueueTP*p;if(lqnearlqfront}printf(”队空、nel二（p=1q-front-next;" ID="35">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="‘x=p-今data;" ID="36">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="37">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="38">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="main(}" ID="39">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｛sgstackTPpa,ta;/，is为临时栈QueptrTP1q;intout,ntnnber.temp;第3章栈和队列5?charch;" ID="40">
        <fptr EndPN="00000066" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="Tnitstackps);" ID="41">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="Initstackts);" ID="42">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="1nitQueue1q）;" ID="43">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="out=0;二习刀f（”％c＆ch）；／，输入命令，／scantd&amp;number/，输入车号，车号为。程序结束，／while(number＞0)" ID="44">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="45">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="switch(ch);" ID="46">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="{caseA:if{ps,topstacksize-1)《" ID="47">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="1:nQueue(＆lq,number);" ID="48">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="printf{”停车场已满！第％d一&quot;车人便道！finnumber｝" ID="49">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="50">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="谧" ID="51">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="pushps,number" ID="52">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(”第％d号车人停车场！finnumber);｝" ID="53">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="break;" ID="54">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="caseDwhile(！Emptysgstach(1Z.ps))｛popps.g.tempif&lt;temp！=number)" ID="55">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="pushts.tempelse{printf{”第％dam,车离开停车场！\nnumber);out=1;break;／二跳出本层循环，／1" ID="56">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="｝if(out0)printf%d号车不在停车场！\nnumber);／引商时栈中的汽车进入停车场二／" ID="57">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="push{fps,temp);｝if(out!EmptyQueue(8q{outQueuelq,tetnp);58数据结构" ID="58">
        <fptr EndPN="00000067" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="59">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="out4n;" ID="60">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="break;" ID="61">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="62">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="二ahf（”％c＆ch〕；／，继续输人命令，／" ID="63">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="二aufC°°ud-nun[ter);/，继续输入车号，／｝" ID="64">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="65">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000067" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="67" PhysicalPageNum="67"/>
      <Paragraph CONTEXT="1.叙述栈和队列之间的区别和联系。" ID="1">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="2.设有3个元素a,b,c进栈，给出它们所有可能的出栈次序。" ID="2">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="3.已知堆栈采用链式存储结构，初始时为空，试画出a,b,c,d这4个元素依次进栈以后堆栈的状态，然后再画出此时的栈顶元素出栈后的状态。" ID="3">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="4.有字符串次序为3，一Y-a/y个2，试利用进栈和出栈操作将次序改变为3y一二ay2中取出一字符加到新字符串尾的出栈的操作）。例如.AB（二变为BCA，则操作步骤为XXSX－SS。5：已知整数n（n）0），试写出计算下列递归函数f（n）的递归算法：" ID="4">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="r，、＿｛n＋1，当n＝。时I’n少一｝＿二，‘＿火一、n时当n＞0时" ID="5">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="6.在介绍队列时规定：无论是循环队列还是链表队列，队头指针总是指向实际队头元素的前一位置，队尾指针指向队尾元素。试画出有两个元素A、B的不同存储结构的图示及将这" ID="6">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="7.与一般队列相比，循环队列有什么优点？给出循环队列队满和队空的判断条件。" ID="7">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="只寸冲习阵＿.月凡目匀当.，目才沁苗；井配】子居军刁二代几谕.1三＿J刁℃甸犷是七J小堆当‘翻岛佗匀记泊；居下丈比人角11」1牛井钊毕石6" ID="8">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="8." ID="9">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="个数。" ID="10">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000067" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="67" PhysicalPageNum="67"/>
      <Paragraph CONTEXT="第3章栈和队列591卜1.＿1、盛，，1.＿1、，2一＼，当n试编程计算当n=5,7,9时的函数值。实习二：用单链表实现队列试建立一个带附加头结点的链表队列。编写实现队列的下列五种基本算法：" ID="1">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="(13将队列置成空队列；" ID="2">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）输人一批元素形成链队列；" ID="3">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）将元素x插入到队列中；60数据结构" ID="4">
        <fptr EndPN="00000069" StartPN="00000068"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="广气份分～知～一今～～气飞釜本章要点，（‘）栈的定义、栈的存储结构及其基本算法的实现；{z）队列的定乡《义、队列的存储结构及其墓本算法的实现。公" ID="1">
      <fptr EndPN="00000041" StartPN="00000041"/>
    </Paragraph>
    <Paragraph CONTEXT="飞.＿.＿＿‘＿‘.、＿公生上‘本算法的买现，（“）掌握在顺序队列和链队列上基本算法的实现，(4）栈和队登" ID="2">
      <fptr EndPN="00000041" StartPN="00000041"/>
    </Paragraph>
    <Paragraph CONTEXT="芬列的应用。吸" ID="3">
      <fptr EndPN="00000041" StartPN="00000041"/>
    </Paragraph>
    <Paragraph CONTEXT="及咨卒仁？仁？娜懊窄仁罕怜仁？今罕蜂么？仁？怜么p＊？仁孕蜂今，＊牢仁？仁罕仁？气今拿仁牵仁索今户今牢怜仁索套杂今索帐纷气沙从数据结构的角度看，栈和队列也是线性表，但它们是两种特殊的线性结构。我们知道，制。因此，栈和队列也称为操作受限的线性表。栈和队列在实际中具有广泛的应用，例如在铁" ID="4">
      <fptr EndPN="00000041" StartPN="00000041"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000069" TITLE="第4章  串" TYPE="Chapter">
    <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
      <div ORDERLABEL="00000069" TITLE="4.1  串的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
        <div ORDERLABEL="00000069" TITLE="4.1.1  串的定义" TYPE="Chapter">
        <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
        <Paragraph CONTEXT="串是由零个或多个字符组成的有限序列。一般记作：s二”alaZ‘”(n&gt;0)其中5是串名，用双引号括起来的字符序列为申的值，而双引号为限界符。a;(1&lt;i&lt;n)可以" ID="1">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="字符个数n称为串的长度。'n=0时，称为空串，其长度为0.第4章串sl" ID="2">
          <fptr EndPN="00000070" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="B二”str&quot;则它们的长度分别为26,3;8是A的子串，A为主串,B在A中出现两次，其中首次出现在主当两个串不相等时，假设S和T是两个给定的串，在S中寻找与T相同的子串的过程，称为模式匹配二通」" ID="3">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="5称为正文，T称为模式。如果在y中找到等于T的子串，则称匹配成功，否则称匹配失败。" ID="4">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="通常" ID="5">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000070" TITLE="4.1.2  串的基本操作算法" TYPE="Chapter">
        <fptr LogicalPageNum="70" PhysicalPageNum="70"/>
        <Paragraph CONTEXT="串的主要基本操作算法有：" ID="1">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）串赋值strassigh(s,t)将一个串值t赋给串so" ID="2">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）求串长strlength(s)" ID="3">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="返回串。的长度。" ID="4">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="{3）串比较strcmp(sl,s2)已知串sl和s2.若sl二！s2，则返回值为。；若sl&gt;s2，则返回值为i；若sl&lt;s2，则返回值为一1," ID="5">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）串复制strcapy(s,t)将一个串t复制到申。中。" ID="6">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）串连接strcancat(sl,s2)已知串sl,s2，在sl的后面连接Si的串值。并返回连接后的结果。" ID="7">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(6）求子串substr(s,i,k)已知串，，返回从串s的第i个位置开始的长度为k的子串。" ID="8">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(7）子串定位strIndex(s,t}已知串s和t，找子串t在主串，中首次出现的位置.若tEs，则返回t在s中首次出现的位置，否则返回值为一3," ID="9">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(8）子串插人strinsert(s,i,t}已知串s和t，将串t插人到串。的第i个位置上。" ID="10">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(9）子串姗除，trdelete(s,i,k)(1Q）子串替换strreplace(s,t,r)" ID="11">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="本节介绍串的定义以及串的基本操作。" ID="1">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000070" TITLE="4.2  串的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="70" PhysicalPageNum="70"/>
        <div ORDERLABEL="00000071" TITLE="4.2.1  串的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="71" PhysicalPageNum="71"/>
        <Paragraph CONTEXT="串的顺序存储结构简称为顺序串。顺序串是把串中所包含的字符序列依次存放在一组连续的存储单元中。在C语言中，申：符'作为结尾符。图4.1所示是顺序串”string&quot;在微机中的存储形式，一个字符占一个" ID="1">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="以字符聆作为结尾符。｝小卜Lnlg。卜｝！图4.1顺序申的存储形式" ID="2">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="与线性表的顺序存储相类似，顺序申的存储可用C语言的字符数组来实现，串值空间的" ID="3">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="可在编译时通过预定义来确定。'设串空间允许的最大值为MAXSIZE，则最多只能存" ID="4">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="大小可在编译时通过预定义来确定。" ID="5">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="放有MAXSIZE-1个字符。" ID="6">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="故顺序串的存储结构，其类型定义为：" ID="7">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineMAX5iZE200" ID="8">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="9">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="‘charstNIViAXSIZE]intJeri;" ID="10">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="）questr;其中，str域用来存储字符串，len域用来存储字符串的当前长度，MAXSIZE为符号常量，用于表示允许存储字符串的最大长度。" ID="11">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000071" TITLE="4.2.2  串的链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="71" PhysicalPageNum="71"/>
        <Paragraph CONTEXT="串的顺序存储结构，对于随机存取串中第k个字符是比较方便的；若要对串进行擂入、删有明显的优越性。下一个结点的指针（首地址，。结点的大小是指data域中可存放字符的个数，next域的大小取" ID="1">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="下一个结点的指针（首地址，。结点的大小是指data域中可" ID="2">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="决于寻址的范围。串的链式存储结构简称为链串。第4章串63chardata;structWade*acxt;}1inkstr;" ID="3">
          <fptr EndPN="00000072" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="littkstr，head;对于结点大小不为1的链串，例如结点大小为3，则结点类型可修改为：typedefstructnode" ID="4">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="仁" ID="5">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="chardata二3二;structnode*next;}Lstr;" ID="6">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="I.str*head;这时链串的最后一个结点的数据域不一定总能全被字符填满，此时未被占用的数据域部分可补填上特殊的符号（例如井），以示区别。图9,3点大小为3的链式存储结构这样。虽然使结点的存储密度增大，但在插入、删除操作时，需要考虑结点数据域内容的分点的存储密度低，但对于插人、删除等操作却相当方便。" ID="7">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="62数据结构" ID="1">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000072" TITLE="4.3  串的基本操作算法的实现" TYPE="Chapter">
      <fptr LogicalPageNum="72" PhysicalPageNum="72"/>
      <Paragraph CONTEXT="选择不同的存储结构，则有不同的算法实现。在4,1节曾介绍了串的基本操作算法，这里对于一部分基本操作算法将采用串的顺序存储结构来实现，而另一部分基本操作算法将采用串的链式存储结构来实现。／，以下六种基本操作算法采用顺序存储结构实现，／" ID="1">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)申赋值：strassign(s,t)，将一个串值t给串，。voidstrassigh(questr*s,cbart口）于inti=b;wbile(t[i=入仃）" ID="2">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="是" ID="3">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="s，str[i]°t[i];" ID="4">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="i十＋。" ID="5">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="冬fi4数据结构" ID="6">
        <fptr EndPN="00000073" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)求申长：strlength(s)，返回串s的长度。intstrlength{questr*s)" ID="7">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="丈" ID="8">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="returnCs-len);" ID="9">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="10">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）串比较：strcrnp(sl,s2)，已知串sl和s2，若有s1s2，则返回a；若，1&gt;s2，则返回1；若s1&lt;s2，则返回一1.intstrcmp(questr*sl,questr*s2)｛" ID="11">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="tntt;for{i二0;iCsl，leni&lt;s2ylen;i--)(if(sl-stx[is2-str[i" ID="12">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="retum(1elseif(sl～str[is2-str[i" ID="13">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="return（一lli" ID="14">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="｝if(i二＝sl～lenis2～len)return(0);elseif(sl-leti&gt;s2～砚en)" ID="15">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="retum(1);" ID="16">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturn（一1" ID="17">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="18">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)串复制：strcopy(s,t)，将串t复制到申s中。voidstrcapy(questr怜s,questr*t)厦" ID="19">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;for(i=0;iC=tlen;isystr[i]=t-str[i" ID="20">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="21">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(5)串连接：strconcat(sl,s2)，已知串，1和s2，将s2连接在sl的后面，并返回连接后的结果。假设sl.和s2的长度之和不会超过允许的最大长度MAXSIZE.questrstrooncat{questr器sl,questr荟s2)硬questrr;" ID="22">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="tntt,J;" ID="23">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i=0;i&lt;sl-en;i十十）" ID="24">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="r,str[i]二。1-str[i];for(j=0;j&lt;s2-glen;jt-3" ID="25">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="r.su[sl-glen十i〕二s2-str[j1;" ID="26">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="r,1en=i十j3" ID="27">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="retum(r);第a章串65fcs)求子串：substr{s,i,k)，已知串s，返回串s的从第i个存储位置开始的连续k个字符组成的申。quetitrsubstr(questr*s,inti,intk)可" ID="28">
        <fptr EndPN="00000074" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="quest[t;" ID="29">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="intj;for(j=i;j&lt;i+k;j＋一）tstr[j-I］二。Str]］i" ID="30">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="t,1en=k;" ID="31">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="t.、tr［1.1词今入仃；" ID="32">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="return(t);｝／，下面六种基本操作算法的实现采用链式存储结构，／" ID="33">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="(7)子串定位：strindex(s,t)，返回子串t在主串s中首次出现的位置；若t任s.则返回一laintstrindex(linkstr*s,1inkstr*t)不littkstr二p,*pl，井q.*qli" ID="34">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="inti二0;P=s;whileCpl=NULL)" ID="35">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="《q=t;if(pdata==q-心date}" ID="36">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="37">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="pl=p一卜next;q1=t-next;" ID="38">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pl！二NLiLL&amp;ql！二NULLtplydata-二qly" ID="39">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="40">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="pl=pl-next;" ID="41">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="ql=ql-next;" ID="42">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="卜if(q1NULL)return(i｝p-p-书next;i+-a" ID="43">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="44">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="return（一1｝（子串插人；strinsert(s,i,t)，将子串t插人到串s的第i个字符位置。voidstrinsert(iinkstr+s,inti,1inicstr*t)｛66数据结构intj;p=s;if(p＝二NULL){printferror!;return;lforCj=O;jCi3j＋一）p=p;next;/，使p指向，中的第i-1个结点，／q=p-next;/，使q指向。中的第i个结点，／fY卜TPYf二1.／#徐子由rFth一本k占作址亦，的镇石个1I卜肠／" ID="45">
        <fptr EndPN="00000075" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="p～理xt～L.r令t；w托1七（一叱xtl‘NIJU一）／，扫描到子申t的最后结点，／r片r～lleXt布户nex：二q，／、5中第1个结点开始其余结点连接在子串t之后“／）例如串5二”shhal”，子串t一”an衅，若将七插在5的第2个存储位置上（注：存储位置从0开始），如图4.4所示。·州习过月国旦多习三州习习叫习囚F从！－诬二一巨任州困囚·一匡一十地业寸笼红习，粗上州玉上州互正随亚三叫。｛川份飞子由t场入‘居的壮木图4.4子申插入示意图" ID="46">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="（9）子串删除：strdelete（5，1，k），在串5中删除从第1个位置开始的连续k个字符。voidstrdelete（linkstr，名，inti.intk）‘int］带linkstr二q，，P，‘t；q导5即for（j，0；j＜1；1十＋）硬" ID="47">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="if（q弃＝NIJLL）" ID="48">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="IPrintf（”。r印r！”）。retum；｝p导q奉q弃q‘今讹xt书｝for（j，1；j＜，k；j＋＋）｛" ID="49">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="汀（q～＝N兀JLL）第4章串67free(r" ID="50">
        <fptr EndPN="00000076" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="51">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="p-next=q;" ID="52">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="53">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="(10)子串替换：strreplace(s,t,r)，将串S中所有子串t均替换成rolinkstr二，trreplace(linkstr*s,1inkstr*t.1inkgtr#r)谧" ID="54">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="inti.k=0;while(tl=NiJLL}/。求子串t的长度，／{k＋十；t=t～next}}i=strindea(s.t);whileCi＞二o)" ID="55">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="咬strdelete(s.i,k);Stilnsert(b.i,r1二，trindex(s,t);｝" ID="56">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="return(s" ID="57">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="｝(11:)串显示：strdisplay(s)，显示输出串s的所有字符。voidstrdisplay(linkstr签s)硫" ID="58">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="linkstr*p=s}prtntf(”字符串s:white(p!=NULL)《prinif(”%c”,pyclatap=p-next}" ID="59">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="60">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="pnntf1n}" ID="61">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="卜" ID="62">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="(12）串创建：strcreate(h,n)。采用链式存储结构建一个有n个结点的串halinkstr+9trorrate(linkstr、h.intn){1inkstr*s,畏t;inti;S二（linkstrmalloc(sizeof(linkstrscarf(’'％C.9-dEtBv-next=NULL;h=s;" ID="63">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="i=1;while(in)汇68数据结构" ID="64">
        <fptr EndPN="00000077" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="····－－－－－－－一一～一－－" ID="65">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="t二（linkstr*)rnalloc(sizeof(linkstr;" ID="66">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="scant0°c&amp;t-data);" ID="67">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="t-next=NCTLL;" ID="68">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="synext=t;" ID="69">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="5片卜" ID="70">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="i--;" ID="71">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="72">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="retum(h);｝本章的基本内容包括：串的基本概念、串的顺序存储结构和链式存储结构以及串的基本操作算法的实现。通过本章学习，应掌握以下几点：" ID="73">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)串的定义与特点，串与线性表的关系。{2)申的各种存储结构，比较它们的优缺点，在实际应用中，根据具体情况能灵活选用合适的存储结构." ID="74">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="能力。" ID="75">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000077" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="77" PhysicalPageNum="77"/>
      <Paragraph CONTEXT="1.简述下列每对术语：串和串元素，空申和空白申，串常量和串变量，主串和子串。" ID="1">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="2。串有哪两种存储结构，各自特点是什么？" ID="2">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="3.假设一字符串s采用链式存储结构，试写一算法求字符串的长度。" ID="3">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="4.若字符串5采用顺序存储结构，试写一算法实现子串插人操作。" ID="4">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="5，若字符串，采用顺序存储结构，试写一算法实现子串删除操作。" ID="5">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="6，若字符串s采用链式存储结构，试写一算法实现串复制操作." ID="6">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="7.设两串s1和s2均采用链式存储结构，试写一算法实现两串的连接。" ID="7">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="8，若串s采用链式存储结构，试写一个函数将，中的所有字符c替换成字符，。" ID="8">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="9.若串S和串T均采用链式存储结构，试设计一个算法找出S中第一个不在T中出现的字符。" ID="9">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="10.假设两串，1和s2均采用顺序存储结构，试写一函数将，1中的第i个字符到第1个字第4章串69" ID="10">
        <fptr EndPN="00000078" StartPN="00000077"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000078" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="78" PhysicalPageNum="78"/>
      <Paragraph CONTEXT="1.内容：串的操作。" ID="1">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="2.目的：掌握串的概念、串的存储结构以及串的基本操作算法。" ID="2">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="3.题目：设有三个字符串s,si和s2，均采用顺序存储结构，参数ch,chl和ch2均为字符型，试分别编写下列算法：" ID="3">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)将s中所有值为chl的字符换成ch2;(2？从串，中删除其值等于ch的字符；&lt;3）在串s中第i个字符位置插人sli二（4)从5中删除所有与讼相同的子串。" ID="4">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="4。要求：（D设计主函数，愉人三个串，实现上述功能，70数据结构" ID="5">
        <fptr EndPN="00000079" StartPN="00000078"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="犷蕊戮蕊夏蒸馨其鑫言霍荔霖霭霜忿矶各”柔喜粼ha1基本概念线』，表之，、关系，&lt;z。顺.x字符串简称串，串是一种受限的线性表，它限定数据元素仅由字符组成。计算机处理的对" ID="1">
      <fptr EndPN="00000069" StartPN="00000069"/>
    </Paragraph>
    <Paragraph CONTEXT="象有数值数据和非数值数据.而串是最基本的非数值数据，串在计算机非数值数据处理中占有" ID="2">
      <fptr EndPN="00000069" StartPN="00000069"/>
    </Paragraph>
    <Paragraph CONTEXT="重要地位。本章将介绍串的基本概念、串的各种存储结构以及串的基本操作算法的实现。" ID="3">
      <fptr EndPN="00000069" StartPN="00000069"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000079" TITLE="第5章  数组" TYPE="Chapter">
    <fptr LogicalPageNum="79" PhysicalPageNum="79"/>
      <div ORDERLABEL="00000079" TITLE="5.1  数组的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="79" PhysicalPageNum="79"/>
      <Paragraph CONTEXT="数组是n(n&gt;1)个相同类型数据元素ao.ai,a2r、一i构成的有序组合。数组中的每个数据通常称为数组元素，数组元素是用下标识别的，下标的个数取决于数组的维数。例如，图" ID="1">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="5.1所示的二维数组，它由m行和n列组成，其中每一行都是一个线性表，而每一列也可看作" ID="2">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="是一个线性表。ao.二一」$Picture[00000079\00000079_new\0010.jpg]Picture$…日栩一i.a-i-第5章数组?1标用于确定该数组元素在数组中的相对位置。数组的维数便决定了元素的下标个数。例如，一维数组，其元素氏是由一个下标i描述；二维数组，其元素a。是由两个下标i,j描述；其中i" ID="3">
        <fptr EndPN="00000080" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="表示该元素所在的行号，j表示该元素所在的列号。由此可推广到多维数组，对于n维数组，其元素在数组中的相对位置要由n个下标才能决定。在高级语言中，我们知道，数组一旦被定义，其每一维的大小及其上下界便确定了，是不能对于数组的基本操作有两种：{1}给定一组有定义的下标，读取相应的数据元素的值；" ID="4">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）给定一组有定义的下标，修改相应的数据元素." ID="5">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000080" TITLE="5.2  数组的存储和数组元素的地址" TYPE="Chapter">
      <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
      <Paragraph CONTEXT="数组一旦定义，则它的维数及各维的长度就确定了，且各个数组元素的存放位置也随之确FArW理Fr4日涌查垂田师良左艘七才定。一＿一：：La价t.r丙，二1ai.ar，二1_ajla,A一｝一“一‘一＿＿＿一“尸1（5.‘）.‘二口.‘二72数据结构一个m行n列的数组，以行为主序存放时，先存放第。行，接着存放第1行，二，最后存放第m-1行，如图5.2所示。｛、ao卜一、一1aialali卜｝、一｝a1an卜as一卜｝、，一小“｝eL.一｝图5.2数组A以行为主序存放示意图" ID="1">
        <fptr EndPN="00000081" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）以列为主序存放，即一列分配完了，接着分配下一列。仍以二维数组A[m][n]为例，" ID="2">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="I’益’｝ao’（o、ial｛.二件.T引’aP，二”1a3.P卜；’.T一｝al.n-1｛二厂｛碑】，二1图5.3数组A以列为主序存放示意图下面以行为主序，介绍数组元素存储地址的计算方法。注龙(1}对于一维数组，用LOC(a;〕表示数组元素a的存储地址。则有(5.2)LOC(ay)=LOC(aoo)+(i*n+j)‘size(5.3)" ID="3">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000081" TITLE="5.3  特殊矩阵的压缩存储" TYPE="Chapter">
      <fptr LogicalPageNum="81" PhysicalPageNum="81"/>
        <div ORDERLABEL="00000082" TITLE="5.3.1  对称矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="82" PhysicalPageNum="82"/>
        <Paragraph CONTEXT="若一个n阶方阵A中的元素满足下列关系：" ID="1">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="则A称为对称矩阵。显然，对称矩阵中有近半数元素是重复的，我们为每一对对称元素只分配一个存储空间，这样可将nz个元素压缩存储到n(n+12个元素的存储空间中。我们可以存储矩阵中主对角线（含主对角线）以上的元素，称为上三角；也可以存储矩阵中主对角线（含主对角线）以下的元素，称为下三角。不失一般性，现以行为主序存储其下三角中的元素，如图5.4所示.目卜」，la十t.2图5.4对称矩阵的下三角部分当1）j（下三角中元素）当1镇j（上三角中元素）｝｝＊。｝al。｛：1｝匆。｝…｝、一｝…｛、一，一！…旦玉卫豪12…旦玉卫笋工2-1图5.5对称矩阵压缩存储示意图74数据结构" ID="2">
          <fptr EndPN="00000083" StartPN="00000082"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000083" TITLE="5.3.2  三角矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="83" PhysicalPageNum="83"/>
        <Paragraph CONTEXT="以主对角线划分，三角矩阵分为上三角矩阵和下三角矩阵。对于一个n阶方阵A，若当i&lt;j时，有ed。或、二c(c为常数），则称该矩阵为下三角矩阵；若当i＞j时，有内-。或ac(c为常数），则称该矩阵为上三角矩阵，如图5.6所示。三角矩阵中重复元素c可共享尸一个存储空间，其余元素和对称矩阵的压缩存储一样恰好占用n(n-12个存储空间，因此，三角矩阵可压缩存储到一维数组M〔n，（n＋1）／2十11中，若c为非。，则存放在数组M的最后一个元素中，若c为。，则不存储，这时三角矩阵可压缩存御，r‘〕厂知。" ID="1">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="卜”‘.一｝｛“‘’“）‘一：.二：」民1，。a（a）上三角炬阵（b）下三角矩阵三三三’·。刁十1，08卜1.la.esl。2二‘自介－1。，1-alJOA二橱处］御，i三" ID="2">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="压卜1.la.esl。2二" ID="3">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="图5.71＜j时内“。的下三角矩阵A" ID="4">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="对于下三角矩阵，只需存储下三角的元素。对于零元素则不存储。若以行为主序进行存" ID="5">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="储，则依次为：aoo，alo，all，a加，821，a22，二’，日护1.0，arl.1，.’.，场卜1，二1下三角矩阵的元素个数为n（n十1〕／2；因为有以下规律：第5章数组75假设每个数据元素占size个存储单元，则下三角矩阵中任意元素为在一维数组M中的存储位置可由下式求得LOC(a=LQC(aoo(i*(i+12*size(i&gt;j)以下关系：。＿i(i+1)丈、―一一－二－－～，尸J乙例如，一个5X5的下三角矩阵A，则可用一维数组M[15］对其进行压缩存储，如图5.9所" ID="6">
          <fptr EndPN="00000084" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="r5000月｝“了oao{其中，M[K〕与元素a之间存储位置K和i,j的关系为：" ID="7">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000084" TITLE="5.3.3  稀疏矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="84" PhysicalPageNum="84"/>
        <Paragraph CONTEXT="7s数据结构分布也无一定规律，显然是稀疏矩阵。一、稀疏矩阵的三元组衰存储" ID="1">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="根据压缩存储的基本思想，只需存储稀疏矩阵中的非零元素。为了能准确地找到相应的元素，除了存储非零元素的值外，还必须同时记下它所在的行和列。这样一个三元组（(i小aq}便能唯一地确定矩阵中的一个非零元素，其中i,j分别表示非零元素的行号和列号，au表示非$Picture[00000085\00000085_new\0008.jpg]Picture$$Picture[00000085\00000085_new\0009.jpg]Picture$(1,2,31,6,13,1,53,2，一1)" ID="2">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="(4,5,45,1，一36,3,76,6,8" ID="3">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="图5.11稀疏矩阵的三元组表typedefstruct第5章数组77斟$Picture[00000086\00000086_new\0005.jpg]Picture$二、稀硫矩阵的转置运算矩阵的转置运算是变换元素的位置，把位于（(i,j）位置上的元素变换到（(j，i)位置上，即将" ID="4">
          <fptr EndPN="00000086" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="元素的行和列对换。所以一个mXn的矩阵M，它的转置矩阵是nXm的矩阵N，且N[ij]" ID="5">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="=MG]Ci]，其中，OCiCn-1,OCCm-1。例如，图5.10中的矩阵B就是矩阵A的转置矩阵，而矩阵B也是一个稀疏矩阵，其三元组表如图5.11所示.求矩阵A的转换矩阵B，实际上就是由表5.1(a}求表5.1(b)a基于三元组的稀疏矩阵转置方法有两种：" ID="6">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="1。依b.data中三元组的次序进行转里" ID="7">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="这种转置方法，实际上是按照矩阵A的列序进行转置。显然，为了找到A中的每一列的" ID="8">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="所有的非零元素，需要对a.data从第。行开始整个扫描一遍。由于a,data是以A的行序来" ID="9">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="存放每一个非零元素的，所以在a.data中列号相同的非零元素则变换到b.data中必定是行号" ID="10">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="相同。这样所得到的顺序恰好是b,data的顺序。该转置算法如下：" ID="11">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="voidt?7±*rrnatCstn]ctspmatrixa,streetspmatrixb)" ID="12">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="{intp,y,co(" ID="13">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="b.m二an}b.n=am;" ID="14">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="{4=fl:" ID="15">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="[c兀（cot=1gool＜二a.n;cvl十十）for(p=0;pGatyp7s数据结构到的。当非零元素个数t与m*n同数量级时，该矩阵不是稀疏矩阵，故上面算法适用于t«m*n的情况，才有实际意义." ID="16">
          <fptr EndPN="00000087" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="2.依a,data中三元组的次序进行转里按这种方法转置后的元素不连续存放，而是直接放到b,data中应有的位置上，这样只需对a.data扫描一次。为了确定矩阵A中的每一列（即B中每一行）的第一个非零元素在b.data中应有的位置，应先求出矩阵A中的每一列中非零元素的个数。为此，需设置两个数组num[n十1］和pot[n十11（注意：下标为。的数组元素不考虑），分别存放矩阵A中每一列非零元素的个数和每一列第1个非零元素在b.data中的位置，即：" ID="17">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="num[col］表示矩阵A中第coI列非零元素的个数；" ID="18">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="pot[col］的初值表示A中第COI列的第1个非零元素在b.data中的位置，且有下列关系：" ID="19">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="pat[1〕二0" ID="20">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="pot[col］二pot[col-11+num[wE-11(2CmiCn?" ID="21">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="于是对于图5.10中的矩阵A.其num和pot的值如表5.2所示。" ID="22">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="澡惑二澎华廿到" ID="23">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="这种转置算法是一种快速的转置方法。该转置算法的实现，描述如下：" ID="24">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="voidfastran(structspmatrixa,structsprnatrixb){intp,q,k,col,num[an+11rpot[an+11;" ID="25">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="b.m二‘n;b.n二a,m;b.t二a.t;$Picture[00000087\00000087_new\0020.jpg]Picture$第5章数组?9三、稀疏矩阵的十字链表存储$Picture[00000088\00000088_new\0003.jpg]Picture$对于稀疏矩阵的十字链表存储，这里只做简要介绍。非零元素的位置都会发生变化，此时这种存储结构就很不方便，而采用链式存储结构更为恰" ID="26">
          <fptr EndPN="00000088" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="当。为此我们介绍十字链表的存储方法." ID="27">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="用十字链表表示稀疏矩阵时葱个非零元素存放在一个存储结点，而一个存储结点由5个" ID="28">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="域组成，其结构如图5.12所示。" ID="29">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="其中，(1)row：非零元素的行号域；" ID="30">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)col：非零元素的列号域；" ID="31">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)right：链接同一行下一非零元素的链域；80数据结构typedefqtr二tNode(introw,coE。非零元家的所在行和列，／" ID="32">
          <fptr EndPN="00000089" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="datatypevalues/、非零元素的值／，" ID="33">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="。trrtNvla+xriarhr（书rlnwn,，替才k4r'll'A`rY1G.fr韦'k1i妻fStfviy0at/structN浏e‘right，，由撇；" ID="34">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="｝OL仪记〔；ty，妇efstruct" ID="35">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="（OLn叼e二ro礼headt－－head；／，行、列链表的头指针，／intmu，nu.tu。／。稀疏矩阵的行数、列数和非零元素个数‘／" ID="36">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="第5章数组73表示是很恰当的。但在有些情况下.例如在某些高阶矩阵中，数据量很大，而非零元素很少。若仍采用二维数组存放，就会出现很多存储单元都存放的是a，这不仅造成存储空间的浪费，而且给运算也带来很大不便，这时，就希望只存储非零元素。此外，还有一些矩阵的数据元素的分布具有一定规律，如对称矩阵、三角矩阵等，就可利用这些规律，只存储部分元素，从而提高存储空间利用率。这些问题都需要对矩阵进行压缩存储，压缩存储的基本思想是：对有规律的矩阵只存储部分元素，而对值相同的元素只分配一个存储空间，对零元素不分配存储空间。下面我们分别介绍这些特殊矩阵。" ID="1">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000089" TITLE="5.4  数组基本操作的实现" TYPE="Chapter">
      <fptr LogicalPageNum="89" PhysicalPageNum="89"/>
      <Paragraph CONTEXT="下面以二维数组（即矩阵）为例介绍数组的基本运算，不失一般性，假设数组元素的数据类" ID="1">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="型均为整型（int）。" ID="2">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="1.转里矩阵" ID="3">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="转置是一种最简单的矩阵运算，对于一个MXN的矩阵A，其转置矩阵是一个NxM的" ID="4">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="矩阵B，且B［1〕口〕二a口〕［1〕，0簇1＜M，0目＜N。该算法实现如下：" ID="5">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="｛inti.j，" ID="6">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="for（1导0，1＜M弓1＋＋）化r（j“0，j＜N；j＋十）阳〕［1］二Ali〕D〕；｝" ID="7">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="2.拒阵相加" ID="8">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="两个大小均为MXN的矩阵A和B，相加后得到一个MxN的矩阵C，其运算是把A与" ID="9">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="B的相同位置的元素相加而得到矩阵C，即C［1］［j〕！A［1」D〕＋砚司口〕，0《1＜M，0目＜N" ID="10">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="该算法实现如下：voidaddmat（intA［阅「N〕，int砚叨［N］，int任明［N〕）｛inti，j；" ID="11">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="for（1＝0八＜Mo1＋＋）for（j，0，j＜N，j＋＋）任司口〕二A［1」口〕＋珑1］口习；第5章数组81" ID="12">
        <fptr EndPN="00000090" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="far{i°Oii&lt;M;i" ID="13">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="far{i二Q。i&lt;k;i＋十）" ID="14">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="15">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="16">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="4.拒阵显示逐行显示矩阵的所有元素。Vaiddisplay(intA[IiN{inti,j;" ID="17">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="for（1，0户＜M；1＋＋）" ID="18">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="19">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="printffin" ID="20">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="21">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="｝本章应重点掌握以下几点：{Z)数组的基本概念，数组的存储结构以及数组元素地址的计算方法；" ID="22">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）特殊矩阵的压缩存储，特别是稀疏矩阵的各种存储结构的特点及转置算法的实现。" ID="23">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000090" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="90" PhysicalPageNum="90"/>
      <Paragraph CONTEXT="1。已知二维数组A[41[61，其中每个元素占3个存储单元，且A仁的存储地址为lzoo，试求：" ID="1">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）当以行为主序存储时，元素A[21[4〕的存储地址；cz&gt;当以列为主序存储时，元素A[21[4〕的存储地址；" ID="2">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="82·数据结构、下三角形矩阵，每个三角形矩阵都有n行。试写一算法，将A和A=S00090000试写出A的三元组表和十字链表。表。" ID="3">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="8.当两个稀疏矩阵A和B均以三元组表作为存储结构时，试写出矩阵相加的算法，其结" ID="4">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="构放在三元组表C中。" ID="5">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="9.设有二维数组A[201[201，试写一算法，分别求出两条对角线上的元素之和。" ID="6">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000091" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="91" PhysicalPageNum="91"/>
      <Paragraph CONTEXT="1.内容：数组第s章树83" ID="1">
        <fptr EndPN="00000092" StartPN="00000091"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="价气气气气已坤。勺。勺气感命6勺今6勺6勺.与今巴冲。娜勺占沛已冲已协勺气巴冲息冲盛洲与之坤力勺方冲.勺白娜已冲。勺负扩、。二＊，1、‘相必，二＊＿绷二妻从二L，4本替七老扩平平宫品’、人了欺越口；义竹布悄”忙’摘串尹队甩了“那拍毯开lU才法；(3）特殊矩阵，特别是稀疏矩阵的存储结构；(4)矩阵的墓本操作算法的实老犷‘若才孔。奢镇本章要求掌握数组的逻辑结构和存储结构，（“，熟悉数组元素地址的长》计算方法，(3)掌握特殊矩阵的存储结构以及矩阵的基本操作算法。谷咯坛十，今宁今牢色常红字坛峪气峥蜂怜么？查罕仁？今罕仁？仁，呜，蛛纷么宁仁宁仁，怜梅仁？么？仁？仁？怜峰传户刻必" ID="1">
      <fptr EndPN="00000079" StartPN="00000079"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000092" TITLE="第6章  树" TYPE="Chapter">
    <fptr LogicalPageNum="92" PhysicalPageNum="92"/>
      <div ORDERLABEL="00000092" TITLE="6.1  树的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="92" PhysicalPageNum="92"/>
        <div ORDERLABEL="00000092" TITLE="6.1.1  树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="92" PhysicalPageNum="92"/>
        <Paragraph CONTEXT="$4数据结构显然，结点A没有前趋结点，是树根。其余结点划分成三个互不相交的子集；T：二｛BTa={C,E,F,HT,二＜D,G}" ID="1">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="图s.1树的示意图" ID="2">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000093" TITLE="6.1.2  树的表示" TYPE="Chapter">
        <fptr LogicalPageNum="93" PhysicalPageNum="93"/>
        <Paragraph CONTEXT="树有多种表示法，常见的有四种方法：" ID="1">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)倒悬树法。如图6.Z所示。这是树的最基本表示方法，用一裸倒置的树表示树结构既直观又形象." ID="2">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)文氏图法。采用集合以及集合的包含关系描述树结构。图6.2(a）是图6.1中所示树$Picture[00000093\00000093_new\0005.jpg]Picture$的文氏图表示法。" ID="3">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)凹人法：采用线段的伸缩描述树结构。图6.2(b)是图s.i中所示树的凹人表示法。DG" ID="4">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="文氏图表示法ro)凹入表示法（}括号表示法" ID="5">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.z树的不同表示法示意图" ID="6">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000093" TITLE="6.1.3  树的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="93" PhysicalPageNum="93"/>
        <Paragraph CONTEXT="(1)结点的度和树的度$Picture[00000093\00000093_new\0002.jpg]Picture$第6章树85树的度是指树中结点度的最大值。例如，图6.1所示树的度为3。因为树中结点A的度最大.值为3，故该树的度为3," ID="1">
          <fptr EndPN="00000094" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）分支结点和叶子结点度不为。的结点称为分支结点。也称非终端结点。例如，图6所示树中，A,C,D,E均为分支结点.度为。的结点称为叶子结点或终端结点。例如，图s.i所示树中，B,F,G,H均为叶子结" ID="2">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="点。" ID="3">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）孩子、双亲、兄弟、子孙、祖先结点的子树的根称为该结点的孩子结点，而该结点称为孩子结点的双亲结点，例如图6.1所示树中，结点A的孩子结点为B,C,D，相应地，结点A是结点B,C,D的双亲结点。结点，而结点E,F也是兄弟结点.以某结点为根的子树中的任一结点则称为该结点的子孙结点.例如，图6.1所示的树中，除A结点以外的任何结点均是A结点的子孙结点，而C结点的子孙结点为E,F,H." ID="4">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="对于树中某结点.从根结点开始到达该结点的双亲所通过的路径上的所有结点称为该结点的祖先结点。例如，图6.1所示的树中，A,C,E是结点H的祖先结点，而A,D结点是G结点的祖先。(4》结点的层数和树的高度" ID="5">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="结点的层次从根结点开始定义，根结点为第一层，根结点的孩子结点为第二层，依此类推，可得到每个结点的层数。例如，图s.i所示的树中，A结点的层数为1,B,C,D结点的层数均如果树中结点的各子树看成从左到右是有次序的（即不能互换），则称该树为有序树，否则无序树。在有序树中，最左边的子树的根称为第一个孩子，最右边的子树的根称为最后一" ID="6">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000094" TITLE="6.2  二叉树及其性质" TYPE="Chapter">
      <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
        <div ORDERLABEL="00000095" TITLE="6.2.1  二叉树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="95" PhysicalPageNum="95"/>
        <Paragraph CONTEXT="二叉树（BinaryTree）是n(n）0)个结点的有限集合.它或为空树（(n=0)，或为非空树，对于非空树：" ID="1">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="{1)有一个特定的称之为根的结点；" ID="2">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）根结点以外的其余结点分别由两棵互不相交的称之为左子树和右子树的二叉树组成。这个递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的互不相交的二叉树组成。由于左、右子树也是二叉树，由二叉树的定义，则它们也可以为空。" ID="3">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="厂＼中0$Picture[00000095\00000095_new\0012.jpg]Picture$图6.4二叉树的五种基本形态由二又树的定义可知，二叉树与一般树比较，有以下特点：" ID="4">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)二叉树上每个结点的度C2" ID="5">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)二叉树是有序树，其两棵子树严格区分为左子树和右子树，且不能随意颠倒的。如图" ID="6">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="例6.2由三个结点A,B,C构成的所有二叉树如图6.5所示。(a)(b)()(d)()图6.5由三个结点构成的所有二叉树" ID="7">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000095" TITLE="6.2.2  二叉树的重要性质" TYPE="Chapter">
        <fptr LogicalPageNum="95" PhysicalPageNum="95"/>
        <Paragraph CONTEXT="性质1二叉树第i(i）l)层上至多有2，个结点。根据二叉树和结点层次的定义可知，根结点在第一层，这层结点数至多为1个，即2‘一’二第6章树87由性质1可知，深度为k的二叉树最多结点数为" ID="1">
          <fptr EndPN="00000096" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="＝妙＋21＋2，＋·叶2k－－1＝冬二尝＝2“一1。1-1故深度为k的二叉树至多有2“一1个结点。" ID="2">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="性质3在任意二叉树中，若叶子结点个数为伐，度为1的结点个数为n；，度为2的结点" ID="3">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="假设二叉树结点总数为n，那么" ID="4">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="n-1导0‘no＋1‘nl＋2，兔将（6.1）式代人（6.2）式，得到山‘n，＋1在介绍二叉树下面两个性质之前，先介绍两种特殊形态的二叉树：满二叉树和完全二叉树。" ID="5">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="探度为k且含有Zk-1个结点的二叉树称为满二叉树。这种树的特点是每层上的结点数根结点开始，按照层次从上到下、同一层从左到右的顺序编号。在一棵二叉树中，除最后一层外，若其余各层结点数都是满的，而在最后一层的结点数或是满的，或是在右边缺少连续若干个结点，则称此树为完全二叉树，如图6.6（b）所示。而图“了。、J习J七巴白2卜一可七廿" ID="6">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="（a）满二叉树向完全二叉树间非完全二叉树$Picture[00000096\00000096_new\0026.jpg]Picture$$Picture[00000096\00000096_new\0027.jpg]Picture$$Picture[00000096\00000096_new\0028.jpg]Picture$88数据结构若2iCn，则有编号为2i的左孩子，否则没有左孩子.对照图6.2(b)，上述性质即" ID="7">
          <fptr EndPN="00000097" StartPN="00000096"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="86数据结构" ID="1">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000097" TITLE="6.3  二叉树的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="97" PhysicalPageNum="97"/>
        <div ORDERLABEL="00000097" TITLE="6.3.1  顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="97" PhysicalPageNum="97"/>
        <Picture URL="00000097\00000097_new\0005.jpg">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Picture>
        <Paragraph CONTEXT="I234567S9101112｝AIBICrDrE｝l:】GlHIfIJfKL(a)一裸完全二叉树bt{b)bt所对应的顺序存储结构示意图图6.7完全二叉树的顺序存储示例" ID="1">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="根据二又树的性质5，在数组a中由某结点a[i]的下标i可以很容易地找到它的双亲结点" ID="2">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="a[i%21.也很方便地找到它的左孩子结点。[2i]和右孩子结点a[2i+11。例如，由图s.7可知。" ID="3">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000097" TITLE="6.3.2  链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="97" PhysicalPageNum="97"/>
        <Paragraph CONTEXT="第6章树B9三叉链表的结点比二叉链表多了一个指向双亲的指针域，其结点结构描述为：structnode3" ID="1">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="摇" ID="2">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="datatypedata:" ID="3">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="structnode3*1chparentrch;" ID="4">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；图fi给出了二叉树链式存储结构中结点结构的示意图。{a）二叉链表结点结构（b)三叉链表结点结构图6.8二叉树链式存储结构中的结点结构对于图6.9(a）所示的二又树，它的二叉链表如图6.9(b)所示.三叉链表如图fi.9(c)所示。(s)二叉树T(b)T的二叉链表（c)T的三叉链表®6.9二叉树的链式存储结构" ID="5">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000098" TITLE="6.3.3  二叉树二叉链表的建立" TYPE="Chapter">
        <fptr LogicalPageNum="98" PhysicalPageNum="98"/>
        <Paragraph CONTEXT="这里介绍一个二叉树二叉链表的生成算法。算法的基本思路主要利用二叉树的性质5e去，因此编号并不是连续的，如图6.10(a)所示的二叉树，结点的编号及其值冽在图6.10(b)所90数据结构指针，即该结点的地址。将图6.14(h)的原始数据序列一一输人即可生成二叉链表。当结点的编号i二1时，所产生的结点为根结点.同时将指向该结点的指针存放在S[1」中." ID="1">
          <fptr EndPN="00000099" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="当结点编号1&gt;1时.产生一个新结点之后，也要将指向该结点的指针存放在S[i]中。由" ID="2">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="性质5可知，j=i/2为它的双亲结点编号。若i为偶数.则它是双亲结点的左孩子，即让SG7" ID="3">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="lch=S匹i]：如果i为奇数，则它是双亲结点的右孩子，即让S[j]～rch二S[i]。这样就将新输人" ID="4">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="的结点逐一与其双亲结点链接，生成二叉树。" ID="5">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="结点的结构可描述为：" ID="6">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="atruct们。del" ID="7">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="{intdata;" ID="8">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="siructnode2*1ch.，rch" ID="9">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="）；" ID="10">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="二叉树二叉链表的生成算法如下：" ID="11">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="Y$defineN50" ID="12">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Picture URL="00000099\00000099_new\0015.jpg">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Picture>
        <Paragraph CONTEXT="structrnde2*q,*t,*S[1V];" ID="13">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="printfi,x二？scarfod%d&amp;i.&amp;x}t" ID="14">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="whilei！二DCx4" ID="15">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="{q=(structttode2else{j=i/2;elses[jmarch-q;）printfC&quot;i,xscarfd°od一，ix" ID="16">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="同线性表一样，二叉树常用的存储结构也有两种：顺序存储结构（向量）和链式存储结构。" ID="1">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000099" TITLE="6.4  二叉树的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="99" PhysicalPageNum="99"/>
        <div ORDERLABEL="00000099" TITLE="6.4.1  遍历二叉树的规则" TYPE="Chapter">
        <fptr LogicalPageNum="99" PhysicalPageNum="99"/>
        <Paragraph CONTEXT="第6章树91设L、T、R分别代表遍历左子树、访问根结点和遍历右子树，则对一棵二又树的遍历可以有六种不同次序：LTR,LRT,TLR,TRL,RLT,RTL。然而通常采用的总是先左（L)后右（R)，这种不同次序：LTR，LRT，TLR，TRL。RLT，RTL。然而通常采用的总是先左（L）后右（R），这样一来，则只有三种不同的遍历次序：LTR，TLR，LRT。它们分别称为中根遍历、先根遍历和" ID="1">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="在这里我们首先介绍遍历二叉树的具体过程。例如有一棵二叉树，如图6.11〔a）所示。$Picture[00000100\00000100_new\0008.jpg]Picture$哪狱瓤蹂澎弩②②②②《a）一裸二又树（b）搜索路线示意图图6.11二叉树及其遍历搜索路线为便于理解遍历的基本思想，暂且为每个没有子树的结点均补上相应的空子树，用中表假设有一条搜索路线（用虚线表示），它从根结点的左侧开始，自上而下、自左而右进行搜尧过每个结点，最后由根结点右侧向上出去。很明显，在考虑到空子树的话，搜索路线途经" ID="2">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="每个实际结点恰好都是三次，如图6.11（b）所示。图中每个结点旁边有①、②、③，分别表" ID="3">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="经该结点的第1次、第2次和第3次。第1次经过访问的结点序列是A、B、D、E、G、H、C、" ID="4">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="示。" ID="5">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="索，经过每个结点，最后由根结点右侧向上出去。" ID="6">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="树中每个实际结点恰好都是三次，如图6.11（b）所示。" ID="7">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="示途经该结点的第1次、第2次和第3次。" ID="8">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="F.这就是先根遍历的结果。而第2次经过访问的结点序列是D、B、G、E、H、A、C、F，这就是中根遍历的结果。第3次经过访问的结点序列是D、C、H、E、B、F、C、A，这就是后根遍历的结" ID="9">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="果。" ID="10">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000100" TITLE="6.4.2  先根遍历" TYPE="Chapter">
        <fptr LogicalPageNum="100" PhysicalPageNum="100"/>
        </div>
        <div ORDERLABEL="00000101" TITLE="6.4.3  中根遍历" TYPE="Chapter">
        <fptr LogicalPageNum="100" PhysicalPageNum="100"/>
        <Paragraph CONTEXT="92数据结构否则，执行空操作返回。" ID="1">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="先根遍历的递归算法如下：S7oidpreorder{structnode*p){if(p！=NULL?{print%2cpdata):/，访问根结点，／preorder(p-lch).先根遍历左子树二／" ID="2">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="pTeo记er（p申Ich）I" ID="3">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="preorder（p申rch）；" ID="4">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝12所示的二叉树，采用先根退历的递归算法，其详细执行过程如图6.13所示。分司熏而J遍历左子树不二习匕二二二－－－$Picture[00000101\00000101_new\0018.jpg]Picture$第6树93" ID="5">
          <fptr EndPN="00000102" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)中根遍历右子树；" ID="6">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="否则，执行空操作返回。中根遍历的递归算法如下：Voidinorder(structnode*p){'rf(p!=NULL)毛inorder(p-filch／二中根遍历左子树，／。“.‘r，”02，‘u～J.，.、.1‘妥七信1翻日左舌六胜1p对ntf（”％Zc，，.p今data）；inorder白r今rch）；／‘中根遍历右子树，／" ID="7">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="；｝中根遍历递归调用具体执行过程，请读者自己分析并画出示意图。" ID="8">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000102" TITLE="6.4.4  后根遍历" TYPE="Chapter">
        <fptr LogicalPageNum="102" PhysicalPageNum="102"/>
        <Paragraph CONTEXT="后根退历可递归描述如下：" ID="1">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="如果根不空，则依次执行下列操作：" ID="2">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）后根遍历左子树；" ID="3">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）后根遍历右子树；" ID="4">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）访问根结点；否则，执行空操作返回。后根遍历的递归算法如下：Void伪：torder（5［ructllode井p）咬亏f（P！＝NULL）" ID="5">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="｛postorder（p伟Ich）；／，后根遍历左子树，／poslorder臼，中rch）。／，后根遍历右子树，／94数据结构试写出按先根遍历、中根遍历、后根遍历所得到的结点序列。先根遍历的结点序列为：" ID="6">
          <fptr EndPN="00000103" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="ACBRSEDFMHK中根遍历的结点序列为：RBSCEAFDHKM后根遍历的结点序列为：RSBECFKHMDA" ID="7">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000103" TITLE="6.4.5  二叉树遍历算法的一个简单应用" TYPE="Chapter">
        <fptr LogicalPageNum="103" PhysicalPageNum="103"/>
        <Paragraph CONTEXT="利用二叉树遍历算法的基本思想，我们不仅可以访问各个结点，还可以统计二叉树中结点，数和叶结点的个数。为此，在遍历二叉树时就设置两个计数器m和n，其中m用于统计" ID="1">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="的个数和叶结点的个数。结点个数，n用于统计叶结点个数。因为在以某种次序追历二叉树时，每个结点访间一次且仅" ID="2">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="访问一次，这就为我们的统计提供了方便的条件。" ID="3">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="假设采用先根遍历方法统计结点个数和叶结点个数，其算法实现如下：" ID="4">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="{if(tl=NULLl)" ID="5">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="{printf%4ctdata);/假设数据峨为char型*/" ID="6">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT=".斗.i.saga-F-Y占粉答1" ID="7">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="to十＋书ift～lch二二NULL).(torch二二NULL))n＋十.／，统计叶结点，／ejishu(t-lch/xj历左子树，／P阅1北u（t，Ich）；" ID="8">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="p闷ishu（卜比h）。｝）注意：上述函数中m、n应是全局变量，在主函数中先置零，在调用preji旅u函数后，m值切旧in（）" ID="9">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000103" TITLE="6.5  线索二叉树" TYPE="Chapter">
      <fptr LogicalPageNum="103" PhysicalPageNum="103"/>
        <div ORDERLABEL="00000104" TITLE="6.5.1  线索二叉树的基本概念" TYPE="Chapter">
        <fptr LogicalPageNum="104" PhysicalPageNum="104"/>
        <Paragraph CONTEXT="月J廿＿六一可出时的一下右发丰左油论古幼山＿夕。木沐食舀莽」些心于储出口田了。一下木七君召不豆纷nay木工七n-1个域，还有n＋1个孩" ID="1">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="子指针域被空闲。我们正是充分利用这些空闲的指针域来存放结点的线性前趋和线性后继信" ID="2">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="息.具体做法如下：当某结点无左孩子时，令其左指针指向它的前趋结点；当该结点无右孩子" ID="3">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="时，令右指针指向它的后继结点。为了严格区分结点的孩子指针域究竟指向孩子结点还是指" ID="4">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="向前趋或后继结点，需在原结点结构中增加两个标志域ltag和川以9。新的结点结构为：" ID="5">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="｝，·h｝，、｝“t·｝rtas｛！·h｛" ID="6">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="其中：ltag＝0表示Ich指向结点的左孩子" ID="7">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="ltag＝1表示Ich指向结点的直接前趋" ID="8">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="叶。叮二n妻录护广卜华白姑占的六蕊不rtag今0rtag二1表示rch指向结点的直接后继日兹廷占的廷幼米荆姗决令。狱ructn怕dex〔datatyp吧血切；访tltag，r妞9；｝；通常把指向结点的前趋和后继的指针称做线索。对二叉树以某种次序进行遍历并且加上线索的过程称做线索化。经过线索化之后生成的二叉链表表示称为线索二叉树。对一个已建好的二叉树的二叉链表进行线索化时规定〔对p结点）：" ID="9">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000104" TITLE="6.5.2  线索二叉树的逻辑表示图" TYPE="Chapter">
        <fptr LogicalPageNum="104" PhysicalPageNum="104"/>
        <Paragraph CONTEXT="96数据结构就一目了然知道任一结点（若无左孩子）的前趋结点和任一结点（若无右孩子）的后继结点。例加.f干国R＿16（，、居撼瑞尝～V树。拾后栩偏不访一b.呵fii33o11Sr占Ixrl.DBFEHIGCA由此可知，D的前趋结点为NULL和后继结点为S;F的前趋结点为B和后继结点为E;I的前" ID="1">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="趋结点为H和后继结点为G,$Picture[00000105\00000105_new\0007.jpg]Picture$$Picture[00000105\00000105_new\0008.jpg]Picture$图6.1中根次序线索二叉树(a)二叉树)先根线索二叉树（{c）中根线索二叉树《d)后根线索二叉树图6.16线索二叉树的逻辑表示图" ID="2">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000105" TITLE="6.5.3  中根次序线索化算法" TYPE="Chapter">
        <fptr LogicalPageNum="105" PhysicalPageNum="105"/>
        <Paragraph CONTEXT="二又树线索化可采用先根线索化算法、中根线索化算法或后根线索化算法。这里重点介根次序线索化的算法。中根次序线索化是在已建立好的二叉链表（每个结点有5个域）之绍中根次序线索化的算法。上，按中根遍历方法在访间根结点时建立线索。" ID="1">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="中根次序线索化递归算法如下：" ID="2">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="Voidinthxead(structnode二二P){ifCp!=NULL)《int卜read（p今Ich），" ID="3">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="if(P，lch1=NULL)pyltag二0:第fi章树97if(prT-NULL){if(pt-rchf=NULL)prrtag=0;else{prrtag=l;" ID="4">
          <fptr EndPN="00000106" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="｝／，前趋结点pr建右线索，指向结点P｝Pr°p;／，Pr跟上P.以便P向后移动，／inthread(p～rch" ID="5">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="卜" ID="6">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在该算法中P：是全局变量，在主程序中置初值为空。在inthread函数中pr始终做为当前结点P的前趋结点的指针。在线索化过程中，边判断二叉树的结点有无左、右孩子，边给相" ID="7">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="应标志域置0或1，边建立线索。在阅读此算法时，将inthread(plch）和inthread(pmarch）之" ID="8">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="间的一组语句看成一个整体，把这组语句理解为“访问”，很明显这甩应用了典型的中根遍历算" ID="9">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="法思路。在递归调用结束时P为空，这表明pr已是最后一个结点，应该没有后继结点。所以" ID="10">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="在返回主程序后还要使pr-arch=NULL，至此整个线索化结束.主函数示意如下：" ID="11">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="rnain()" ID="12">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="了structruodexxpr，二t;pr=NULL;t=Great;inthread(tpr-rch=NULL;争" ID="13">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000106" TITLE="6.5.4  在中根线索树上检索某结点的前趋和后继" TYPE="Chapter">
        <fptr LogicalPageNum="106" PhysicalPageNum="106"/>
        <Paragraph CONTEXT="(1)己知q结点，找出它的前趋结点数据结构yo。一truchnodex*impreCstructnadex'q)if(q-，ltsg＝二L)4=4-1011}" ID="1">
          <fptr EndPN="00000107" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT=";lse{r=qlch;" ID="2">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="Nhi1ertagl1)r=r+rch" ID="3">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="0=r书" ID="4">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="ceturnCp);" ID="5">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）已知4结点，找出它的后继结点当q-rtag=l时，q-rch即指向q的后继结点。当qrtag二。时，表明q有右孩子，那么q的后继应是中根遍历q的右子树时访向的第一个结点，即右子树的最左尾结点。如图6.16(c）所示，A的后继为F,C的后继为I。若用P记录q的后继结点.则算法如下：structnodex，irisucc(atructnedex‘q)" ID="7">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="wkuleCr-ltag1)r=r-lchs" ID="8">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="p=rs" ID="9">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="｝return(p);｝" ID="10">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000107" TITLE="6.5.5  在中根线索树上遍历二叉树" TYPE="Chapter">
        <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
        <Paragraph CONTEXT="在中根线索树上遏历二叉树，首先从根结点开始查找二叉树的最左结点，对最左结点进行｝。然后，利用在中根线索树上求某结点后继的算法，逐一找出每个结点加以访问，直到某的右孩子指针域为空时为止。其遍历算法如下：访词。" ID="1">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="后、的右孩子指针域为空时为止。李行局typeclefchardatatypesvoidintharderCstructnodex+t){stnsctnodexxpsp=tif{pt=NULL)while(p-lctl3ULIp=plens/‘查找二叉树的最左结点‘／" ID="2">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="printfCo4c&quot;.pdata)swhile(p今rch，=NULL){p二ins二（p调用求某结点P后继的算法。／" ID="3">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="printf%4cpdata)s第s章树99" ID="4">
          <fptr EndPN="00000108" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）其中根线索二叉树；" ID="5">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="(5)其后根线索二叉树。" ID="6">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Picture URL="00000108\00000108_new\0006.jpg">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Picture>
        <Paragraph CONTEXT="题解：(1）该树中根.'历序列为：dgbaechif" ID="7">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="第s章树95不方便的，能否在基本不增加存储空间的前提下保留结点的线性前趋和线性后继的信息呢？为此，我们引人了线索二叉树." ID="1">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000108" TITLE="6.6  二叉树、一般树和森林" TYPE="Chapter">
      <fptr LogicalPageNum="108" PhysicalPageNum="108"/>
        <div ORDERLABEL="00000108" TITLE="6.6.1  一般树的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="108" PhysicalPageNum="108"/>
        <Paragraph CONTEXT="树的存储结构有顺序结构和链表结构。顺序存储结构即向量，一般将树中的结点按自上$Picture[00000108\00000108_new\0002.jpg]Picture$100数据结构个指针域，指针域用于指向该结点的各个孩子。该树的三重链表如图6.2d(a）所示。如果用的长子，另一个指针指向它的一个兄弟.孩子―兄弟链表如图6.20&lt;b)所示。图6.2。树的存储结构$Picture[00000109\00000109_new\0009.jpg]Picture$假设把图fi.20(b)中指向兄弟的水平方向指针依顺时针下斜45°.不难发现它与一棵二叉" ID="1">
          <fptr EndPN="00000109" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="·分相似。由此可知二叉树的结构规范、简单并具有一些重要性质，因此常将一般树结构转" ID="2">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="树十分相似。换为二叉树结构进行处理。" ID="3">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000109" TITLE="6.6.2  一般树与二叉树之间的转换" TYPE="Chapter">
        <fptr LogicalPageNum="109" PhysicalPageNum="109"/>
        <Paragraph CONTEXT="由于一般树的子树个数不确定，如果采用类似二叉树的存储结构，其结点的指针域个数必" ID="1">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="须采用最多子树的个数，这样会浪费很多空间。为此，可将一般树转换成二叉树。采用二叉树的存储结构和操作，在处理之后再将该二叉树转换成一般树。下面讨论一般树与二叉树之间的转换方法。" ID="2">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="1.一般树转换成二叉树第s章树101一一" ID="3">
          <fptr EndPN="00000110" StartPN="00000109"/>
        </Paragraph>
        <Picture URL="00000110\00000110_new\0004.jpg">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Picture>
        <Picture URL="00000110\00000110_new\0005.jpg">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Picture>
        <Paragraph CONTEXT="(a)一般树向相邻兄弟连线图6.21一般树转换为二叉树过程" ID="4">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
        <Picture URL="00000110\00000110_new\0009.jpg">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Picture>
        <Picture URL="00000110\00000110_new\0010.jpg">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Picture>
        <Paragraph CONTEXT="2.二叉树还原为一般树应当指出，并不是随便一棵二叉树都能还原成一般树，二叉树若能还原为一般树，则该二必须是由某一树转换而来的且根结点没有右子树的二叉树。其还原过程也分三步：叉树必须是由某一树转换而来的且根结点没有右子树的二叉树。" ID="5">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)若某结点i是其双亲结点的左孩子，则将结点i的右孩子以及当且仅当连续地沿着右孩子的右链一直搜索到所有的右孩子，都分别与结点i的双亲结点用虚线连接起来。" ID="6">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）把原二叉树中所有双亲结点与其右孩子的连线删除。这里所删除的实质上是兄弟间的连线。并将图中虚线改为实线。" ID="7">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)进行整理，将结点按层次排列。" ID="8">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000110" TITLE="6.6.3  森林与二叉树间的转换" TYPE="Chapter">
        <fptr LogicalPageNum="110" PhysicalPageNum="110"/>
        <Paragraph CONTEXT="102数据结构" ID="1">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="1.森林转换为二又树" ID="2">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="将森林转换为二叉树的步骤如下：" ID="3">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)将森林中每棵子树转换成相应的二叉树，形成若干二叉树的森林." ID="4">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)按森林中树的先后次序，依次将后一棵二叉树作为前一棵二叉树根结点的右子树，于是整个森林就生成了一棵二叉树，显然第一棵树的根结点就是生成后的二又树的根结点。$Picture[00000111\00000111_new\0007.jpg]Picture$$Picture[00000111\00000111_new\0008.jpg]Picture$$Picture[00000111\00000111_new\0009.jpg]Picture$$Picture[00000111\00000111_new\0010.jpg]Picture$图6.22二叉树还原为一般树例6.，将图6.23(a)所示的森林转换为二叉树，其转换过程如图6.23(bcd)所" ID="5">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="示。" ID="6">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="了(a)森林第s章树103" ID="7">
          <fptr EndPN="00000112" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="2.二叉树还原为森林将一裸由森林转换成的二叉树还原为森林的步骤如下：（D将二叉树的根结点与其右孩子的连线以及当且仅当连续地沿着右链一直搜索到所有$Picture[00000112\00000112_new\0006.jpg]Picture$$Picture[00000112\00000112_new\0007.jpg]Picture$$Picture[00000112\00000112_new\0008.jpg]Picture$暑" ID="8">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Picture URL="00000112\00000112_new\0014.jpg">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Picture>
        <Paragraph CONTEXT="(c)还原森林结果$Picture[00000112\00000112_new\0016.jpg]Picture$图6.24二叉树还原为森林" ID="9">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000112" TITLE="6.6.4  一般树和森林的遍历" TYPE="Chapter">
        <fptr LogicalPageNum="112" PhysicalPageNum="112"/>
        <Paragraph CONTEXT="104数据结构②访问根结点。" ID="1">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）层次遍历若树非空，则①访问根结点；②若第1,…,iCi）l）层结点已被访问，且第i+1层结点尚未访问，则从左到右依次访$Picture[00000113\00000113_new\0008.jpg]Picture$显然，按层次遍历所得到的结点访问序列中，各结点的序号与按层编号所得到的编号相一致。例6.，用上述三种方法遍历如图6.25所示的树To图6.25树T对于树T;后根遍历结点序列为：DHIJEBFGCA;层次遍历结点序列为：ABCDEFGHIJ," ID="2">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="2.森林的遮历" ID="3">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="首先将森林转换成二叉树，然后按层次遍历该森林。" ID="4">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="这里将介绍一般树的存储结构、一般树与二叉树之间的转换以及森林与二叉树之间的转换方法，还要介绍一般树的遍历方法。" ID="1">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000113" TITLE="6.7  二叉排序树" TYPE="Chapter">
      <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <div ORDERLABEL="00000113" TITLE="6.7.1  二叉排序树的定义与特点" TYPE="Chapter">
        <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <Paragraph CONTEXT="第s章树105例如，图6.26所示的二又树是一棵二叉排序树.$Picture[00000114\00000114_new\0003.jpg]Picture$二叉排序树的特点：对二叉排序树进行中根遍历时，可得到一个由小到大的递增序列。例如，对图fi.2？所示的二叉排序树进行中根遍历，则得到以下递增序列：" ID="1">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Picture URL="00000114\00000114_new\0009.jpg">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Picture>
      </div>
        <div ORDERLABEL="00000114" TITLE="6.7.2  二叉排序树的建立" TYPE="Chapter">
        <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <Paragraph CONTEXT="建立二又排序树的过程，实质上是不断进行插入结点操作的过程。我们采用二又链表" ID="1">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="做为存储结构。其结点结构描述如下：" ID="2">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="structnodb" ID="3">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="{intdata;" ID="4">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="structmd6*tchrcha" ID="5">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；" ID="6">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="算法思路：" ID="7">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)让K，做为根；" ID="8">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)对于KQ.若K2&lt;K,，令K：做K，的左孩子；否则令K：做K.的右孩子；" ID="9">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)对于K3，从根K：开始比较.若KsCKt，到左子树中找；否则到右子树中找。找到适当位置进行插人；(}对于KKS····,K，重复第（3)步.直到K插人完为止。在建立二又排序树的过程中.每输人一个数据元素，就插人一次。故把插人一个结点的递归算法独立编写，而在建立二叉排序树的函数中对其进行调用。插入一个结点S的递归算法如下：Voidittsert(structnodb*t,structnodb二9)IOs数据结构elseif(s~data&lt;t.data}insert{t～lch,s}s" ID="10">
          <fptr EndPN="00000115" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="elseinsertCtrch,s｝建立二叉排序树的主体函数如下：structrrdb+GreatO" ID="11">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="{intn,i,k;" ID="12">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="structnodb朴t,»s;" ID="13">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="t=NULL;printfnscanfdn/。翰人结点个数，／for(i=1;in;i" ID="14">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="{printk%di)t" ID="15">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="scant%d&quot;.&amp;k);s=Cstructnodbmallac{simeof{structnodb}s一知date二k;s-工ehULLts-rch二NULLSinsert(trs)t" ID="16">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="return(t);" ID="18">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="｝假设给定一组数据（2a,13,as,ls,a,12}，依上述算法生成二叉排序树的过程如图s.as所示：" ID="19">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="⑩" ID="20">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="犷由此可见，在二叉排序树上插人结点不需遍历树，仅豁从根结点出发，走一条从根到某个$Picture[00000115\00000115_new\0027.jpg]Picture$$Picture[00000115\00000115_new\0028.jpg]Picture$$Picture[00000115\00000115_new\0029.jpg]Picture$有空子树的结点的路径，使该结点的空指针变为指向被插人结点的指针，使被插人结点成为新的叶结点。请读者思考：若上述这组数据，其输入的先后顺序改为〔12,13,16,20,28,30)，那么生成的二叉排序树如何呢？" ID="21">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000115" TITLE="6.7.3  在二叉排序树中删除结点" TYPE="Chapter">
        <fptr LogicalPageNum="115" PhysicalPageNum="115"/>
        <Paragraph CONTEXT="第6章树107点。现假定用它的后继结点来替代，这个结点：应是P的右子树中最左边结点（其数据域值在P的右子树中是最小的结点〕，而且它一定没有左孩子。这时先让P结点取8结点的值，然后$Picture[00000116\00000116_new\0004.jpg]Picture$$Picture[00000116\00000116_new\0007.jpg]Picture$$Picture[00000116\00000116_new\0008.jpg]Picture$冷娜了穿’飞翼补麒了～名日－声甲、小～$Picture[00000116\00000116_new\0015.jpg]Picture$$Picture[00000116\00000116_new\0016.jpg]Picture$$Picture[00000116\00000116_new\0017.jpg]Picture$$Picture[00000116\00000116_new\0018.jpg]Picture$冲＠‘互甄、冲（习{b)[c}" ID="1">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="(d)(e)" ID="2">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.29二叉排序树翻除结点示意图" ID="3">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000116" TITLE="6.7.4  在二叉排序树上查找结点" TYPE="Chapter">
        <fptr LogicalPageNum="116" PhysicalPageNum="116"/>
        <Paragraph CONTEXT="在二叉排序树中查找值域为x的结点，并返回指向该结点的指针。" ID="1">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="由于二叉排序树的特性，查找结点采用不回溯的方法：若x等于当前结点的值域，则退出；否则若x小于当前结点的值域，则在左子树中查找；否则若x大于当前结点的值域.则在右子" ID="2">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="树中查找。其算法实现如下：" ID="3">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="structnodh*find(structsod6*tintx)while(p！二NULLpdetal=x}" ID="4">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="二叉排序树是一种特殊的二叉树，在一般二叉树中，区分左子树和右子树，但结点的数据域的值是无序的.而在二叉排序树中。不仅区分左子树和右子树，且树上各结点的数据域的值是有序的。" ID="1">
        <fptr EndPN="00000113" StartPN="00000113"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000116" TITLE="6.8  哈夫曼树及其应用" TYPE="Chapter">
      <fptr LogicalPageNum="116" PhysicalPageNum="116"/>
        <div ORDERLABEL="00000117" TITLE="6.8.1  哈夫曼树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="117" PhysicalPageNum="117"/>
        <Paragraph CONTEXT="设二叉树具有n个带权值的叶结点，那么从根结点到各个叶结点的路径长度与相应叶结点权值的乘积之和.称为二叉树的带权路径长度，并记作：WPL二;WXLk为第k个叶结点的权值，Lk为第k个叶结点的路径长度‘即从根结点到该叶结点.其中.Wt图6.30带权二叉树如果给定一组具有确定权值的叶结点，那么可以构造出不同的带权二又树，它们的带权路度并不相同。我们把其中具有最小带权路径长度的二叉树称为哈夫曼树。$Picture[00000117\00000117_new\0011.jpg]Picture$&lt;)(c)" ID="1">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="图s.3i具有相同叶结点的不同带权路径长度的二叉树" ID="2">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="它们的带权路径长度分别为$Picture[00000117\00000117_new\0018.jpg]Picture$$Picture[00000117\00000117_new\0019.jpg]Picture$第6章树109(c)WPL=70X3十50X3+30X2十10X1=430" ID="3">
          <fptr EndPN="00000118" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="(a&gt;wPL=loX3+sox3+5ox2+7ox1-2sa" ID="4">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="可以证明，图6.31（由所示的二叉树就是一棵哈夫曼树。" ID="5">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000118" TITLE="6.8.2  哈夫曼树的构造及其算法的实现" TYPE="Chapter">
        <fptr LogicalPageNum="118" PhysicalPageNum="118"/>
        <Paragraph CONTEXT="根据哈夫曼树的定义，一棵带权叶结点的二叉树要使其WPL值最小，必须使权值越大的点越靠近根结点，而使权值越小的叶结点越远离根结点.那么如何构造一裸哈夫曼树呢？叶结点越靠近根结点，而使权值越小的叶结点越远离根结点.其方法如下：" ID="1">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)由给定的n个权值＜W，,Wz，W｝构造n棵只有一个叶结点的二叉树.从而得到一个二叉树的集合F二（Ti,TzTn" ID="2">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)在F中选取结点权值最小和次小两棵树为左、右子树而合并成一棵新的二叉树.其根结点的权值是左、右子树根结点权值之和；" ID="3">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)在集合F中删除作为左、右子树的两棵二叉树，并将新生成的二叉树加人到F中；例6.11给定一组叶结点。其权值集合为W°谧4,2,1,3,7}。试构造一棵哈夫曼树。$Picture[00000118\00000118_new\0012.jpg]Picture$110数据结构下面介绍哈夫曼算法的实现。算法的实现需选择合适的存储结构，这里我们选用顺序存储结构。因为哈夫曼树只有度为0和度为2的结点，由二叉树的性质可知no~n2十1，而总结点数为tln+n2。即2-1。叶结点数no若用n表示，则二叉树的结点总数为2n-1。向量的大小定义为2n-1。存储结构类型描述为：" ID="4">
          <fptr EndPN="00000119" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="structoodeh" ID="5">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="{intdata;" ID="6">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="intlch,rch;inttag;/*teg二。表示结点独立.ii+二1表示结点已并人树中.／含。" ID="7">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="哈夫曼算法实现如下：" ID="8">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineMAX50" ID="9">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="inthuffmatt(struct二dehr[MAX])" ID="10">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="{inti,j,n,tn1,tn2,xl:x2，砚t二日可〔”解％d＆n）；／，n为叶结点个数，／for（j，1；j＜，n；j＋＋）{scanf％d&amp;r(jI.data/*人各叶结点的权值。／r[jtag=0;r[jI.1ch二。；r[jrch一。；／.各叶结点的标志域及左、右孩子域均置初值。。／卜" ID="11">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="L-0;while(iCn一”／，合并n-1次，2{xl=0;m1二32?67;ml为最小值单元，xl为下标.／x2=O;m2=32767;%，m2为次小值单元，x2为下标，／for(j-1；j＜今n＋1oj＋＋）{ifr[jI.data&lt;tnlr[jtag二＝0" ID="12">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="{m2=m1.xE二xl;" ID="13">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="》elseifr[jdata&lt;m2r[jtag二～0" ID="14">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="{m2=r[jI.data;" ID="15">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="｝}/，for循环是求最小权值和次小权值的结点。／r[xlI.tag二1:r[x2I.tag二1:i-／笼tnt＋助，／r{nriI.tag二Osr[niI.lch=xl;r[n+irch=x2;｝t=2+n-1;t是指向哈夫曼树根结点的指针（下标号）。／" ID="16">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="YQturn(t);第‘章树111该算法的时间复杂度为O(nZ)o" ID="17">
          <fptr EndPN="00000120" StartPN="00000119"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000120" TITLE="6.8.3  哈夫曼树的应用" TYPE="Chapter">
        <fptr LogicalPageNum="120" PhysicalPageNum="120"/>
        <Paragraph CONTEXT="1.最佳判定树在许多实际问题中，需要进行连续判断，才能确定等级或分类。例如在考试中，根据考试成绩x分等级：优（x＞二90)、良（80＜二x&lt;90)、中（70&lt;°x&lt;80)、及格（fi0x&lt;70)、不及格（x&lt;60）五个等级。若不考虑学生考试分数的分布概率，程序判定过程易写成如图6.33(a)所示的流图.假设学生考试成绩按不及格、及格、中等、良好和优秀的分布概率分别为5°0,15°0.403010°°.显然按图fi.33(a）设计的判定树是不合适的.应当按哈夫曼树的特性来设计最佳判定树，即分布概率越大的叶结点离根结点越近，分布概率越小的叶结点应当离根结点越远.这样可使大部分的分数值经过较少的比较次数就能确定其相应的等级，如图6.33(b)所示。由于这里每个判断框要比较两次，反而降低运行效率。所以我们采用折衷方法，经调整后得到图fi.33(c）所示的判定树。" ID="1">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="2.哈夫受编码哈夫曼编码具有广泛的应用，利用哈夫曼树构造的用于通信的二进制编码称为哈夫曼编码。例如：有一段电文“CAST&quot;TATASA&quot;。统计电文中字符出现的频度f:$Picture[00000120\00000120_new\0018.jpg]Picture$$Picture[00000120\00000120_new\0019.jpg]Picture$用频度《1,2,3,3,4}为权值生成哈夫曼树，并在每个叶子上注明对应的字符。树中从根到每个$Picture[00000120\00000120_new\0021.jpg]Picture$叶子都有一条路径，对路径上的各分支约定指向左子树根的分支表示码，指向右子树根的分支表示“1”码，取每条路径上的“0”或，&quot;1”所构成的序列作为与各个叶子对应的字符的编码，112数据结构这就是哈夫曼编码。对应图fi.34的哈夫曼树.上述字符的哈夫曼编码为" ID="2">
          <fptr EndPN="00000121" StartPN="00000120"/>
        </Paragraph>
        <Picture URL="00000121\00000121_new\0004.jpg">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Picture>
        <Picture URL="00000121\00000121_new\0005.jpg">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Picture>
      </div>
      <Paragraph CONTEXT="1as数据结构" ID="1">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000121" TITLE="6.9  二叉树建立与遍历的C源程序示例" TYPE="Chapter">
      <fptr LogicalPageNum="121" PhysicalPageNum="121"/>
      <Paragraph CONTEXT="对于二叉树的建立和遍历下面给出完整的c语言源程序示例。#include&quot;stdia.h&quot;" ID="1">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="#include&quot;stdlilxh&quot;defineDATATYPEintstructnode" ID="2">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="{DATATYPEdata:structrode、1ch，二rch;};Structnode+Hoot;i二根结点为全局变量，／intm=0;a统什叶结点数.初值置。。／structnode‘cresti。建立二又树，／{structnode*tq,*s[401;tnti,J,x;" ID="3">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="Printf（”仁，x＝”）.scanf0od%d8-i,xJ:«i是按满二叉树编号,i是数据城值为x的结点编号，／while(i二0&amp;t`.x！二d}{qstructnode，)malloc(sizeof(structnodeqdata=xq-ylch=NULL;q-rch二NULL;s[司，q，if（i华今1）t＝q。／，t为树根结点，／else{1=i/2t«j为i的双亲编号。／" ID="4">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="if（（1％2）＝＝0），口〕～Ic卜二qt" ID="5">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="elses[jrch=q:" ID="6">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="｝printfi,x二”scanfd%d8-ix);｝第6章树113returtt(t);" ID="7">
        <fptr EndPN="00000122" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="）voidpreorder(structnode*p)/，先根递归遍历。／{if(p1=NUI-L)" ID="8">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="{printf5dplch" ID="9">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="preorder(p申lch);" ID="10">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="prearder(p～rch);" ID="11">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="12">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="｝voidinnrder(structnode*p)/，中根递归遍1j5“/{ip1=Ai[JLL){inorder(p申lch);｝Voidpostorder(structnode#p)/，后根递归遍历‘／{if(p1=MJ1,L){postorder(plch；" ID="13">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="14">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="main(){intcord;do{printffin主菜单＼nprintf1.建立二叉树＼n'，)printf2.先根递归遍历、nprintf3.中根递归遍历＼nprintf4.后根递归遍历，求叶结点数、n)printf5。结束程序运行＼npnntf******，二＼n”）；printf{&quot;请输人您的选择（1,2,3,4,5scarf%dcord};$Picture[00000122\00000122_new\0036.jpg]Picture$printf(”建立二叉树程序已执行完。,ni114数据结构break;" ID="15">
        <fptr EndPN="00000123" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="case3;irorder(raot);printfn中根递归遍历程序巳执行完nbreak;" ID="16">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="case4;postorder{rootprintfn后根递归1历程序已执行完.1abreakscase5:printf{’本次结束程序执行，再见！\n，，)aexit(6)" ID="17">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="18">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="}while{mnd5);" ID="19">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="》" ID="20">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000123" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="123" PhysicalPageNum="123"/>
      <Paragraph CONTEXT="1.指出图6.35所示树T的深度、度、分支结点和叶结点。" ID="1">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="2.已知一棵树的边集为1CI,MI,NCE,lB,EB,DA,B" ID="2">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="G,J&lt;G,K&lt;C,G&lt;C,F&gt;CH,L&lt;C.H&lt;A,C&gt;},试画出这棵树，并回答下列间题：" ID="3">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="(9)树的深度是多少？" ID="4">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Picture URL="00000123\00000123_new\0007.jpg">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Picture>
      <Paragraph CONTEXT="(10)以结点C为根的子树的深度是多少？" ID="5">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对于三个结点A,B,C，可组成多少种不同的二叉树？请画出.竺哩」匕一一―＿＿.5i9出图6.36和6.37所示二叉树的三种遍历次序的结点序列" ID="6">
        <fptr EndPN="00000124" StartPN="00000123"/>
      </Paragraph>
      <Picture URL="00000124\00000124_new\0004.jpg">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Picture>
      <Picture URL="00000124\00000124_new\0005.jpg">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Picture>
      <Paragraph CONTEXT="5.已知某二叉树的先根和中根谊历序列分别为ABDECFGH和DBEAGFHCe试画出这棵二叉树，并给出其后根追历序列。" ID="7">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="6.试给i图6.36的二叉链表和三叉链表存储结构以及顺序存储结构。" ID="8">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="7，试画出图fi.36示二叉树的先根、中根、和后根线索化树的逻辑表示图。＆将16.38fff示树转换为二叉树." ID="9">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="9.试分别给出图6.39所示树的先根、后根和层次遍历的结点访问序列。图6.38树T1，图6.39树TW封6.40森林F.1.若输人序列是〔3,5,1,9,4,10,2,8,7,6}，试画出生成的二叉排序树。116数据结构i4.给定一组权值｛7,18,3,32,5,26,12,8}，试构造相应的哈夫曼树并计算其WPL的值。1哎月Ff.5rl惬三!4!一wtar仁rra大rx占玉n志掩＿水姑占lrS" ID="10">
        <fptr EndPN="00000125" StartPN="00000124"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000125" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="125" PhysicalPageNum="125"/>
      <Paragraph CONTEXT="1.内容：二叉树" ID="1">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="2.目的：重点掌握二叉树的性质、存储结构及其基本操作。" ID="2">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="3.题目：二叉树的建立与遍历。给定数据集合d一｛57，48，76.53.25，87，70，73，51，37，95，17，55，84，66｝。实现下列基本" ID="3">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="操作算法：（D依次取d中各数据.构造一棵二叉排序树；" ID="4">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）分别按先根、中根、后根遍历该二叉树，输出相应的结点序列，" ID="5">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）给定x值，在该二叉排序树中查找值域为x的结点，并返回指向该结点的指针。第7章图ll7" ID="6">
        <fptr EndPN="00000126" StartPN="00000125"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="价、勺之冲。勺钧出，右冲勺力冲。勺6海己命冲6海6命之海6冲6海。冲。饰。切乃谭。匀。.念刁念却。谕乙勺细知气、勺室矛二，上＿杏＿二＿，“＊才老平草索品:“1.一入代浏多平帆硒’、乙少一入刊浏巡厉一入例州付才" ID="1">
      <fptr EndPN="00000092" StartPN="00000092"/>
    </Paragraph>
    <Paragraph CONTEXT="落储结构，(4’树、森林和二叉树之间的转换二叉排序树哈夫受树及其哎" ID="2">
      <fptr EndPN="00000092" StartPN="00000092"/>
    </Paragraph>
    <Paragraph CONTEXT="汾应用·》71种遍历方法；(3）重点掌握二叉树的链式存储结构及其墓本操作；(4)熟悉树，u扩盯扭）j，／J么’、刃里品子牡一八们盯“健八忙’.匆“，仄六杏平探’卜t产淞芯们’才扩森林和二叉树之间的转换方法；（5）掌握二叉排序树的定义及其基本操作：（6）才篇能灭沽运用啥天受树处理头杯1月题.盆到目前为止，我们前面所研究的数据结构都属于线性结构，即数据元素之间存在前后次序。本章将介绍树形结构，它是一种非常重要的非线性结构，其数据元素之间既具有分支关又具有上下层次关系。树形结构在客观世界中普遍存在，如人类社会的族谱和各种社会组系，又具有上下层次关系。" ID="3">
      <fptr EndPN="00000092" StartPN="00000092"/>
    </Paragraph>
    <Paragraph CONTEXT="织机构的表示等等，都广泛使用树形结构。" ID="4">
      <fptr EndPN="00000092" StartPN="00000092"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000126" TITLE="第7章  图" TYPE="Chapter">
    <fptr LogicalPageNum="126" PhysicalPageNum="126"/>
      <div ORDERLABEL="00000126" TITLE="7.1  图的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="126" PhysicalPageNum="126"/>
        <div ORDERLABEL="00000126" TITLE="7.1.1  图的定义" TYPE="Chapter">
        <fptr LogicalPageNum="126" PhysicalPageNum="126"/>
        <Paragraph CONTEXT="118数据结构" ID="1">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Picture URL="00000127\00000127_new\0002.jpg">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Picture>
        <Picture URL="00000127\00000127_new\0003.jpg">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Picture>
      </div>
        <div ORDERLABEL="00000127" TITLE="7.1.2  图的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="127" PhysicalPageNum="127"/>
        <Paragraph CONTEXT="1.无向图对于一个图G，若边集E(G）为无向边的集合，则称该图为无向图。如图7.1(a)所示G1为无向图。" ID="1">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="2.有向图对于一个图G，若边集E(G）为有向边的集合称该图为有向图.如图7.11b)所示G2为有向图。" ID="2">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="3.端点和郁接点在一个无向图中，若存在一条边‘vv，则称v;、v;为该边的两个端点，并称它们互为邻接点。在图7.1(a〕中，顶点1和2是边（1,2)的两个端点，它们又互为邻接点。" ID="3">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="4.起点和终点在一个有向图中，若存在一条边（vv则称该边是顶点v；的一条出边和顶点v;的一条人边；称v;为起点，v;为终点，并称v；和v;互为邻接点.图7.1(b)中，对于边＜1,2&gt;，该边是顶点11F4&gt;yi.Tip占2Fti人物。同时.丽占i砍'li占布古，揍‘鼓六" ID="4">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="5.度、入度和出度在无向图中，一个顶点v的度是指以该顶点为一个端点的边的数目，记作D(V)。如图7.1(a）中，D(1D(2D(52,D(3D(43,在有向图中，顶点v的度分别出度和人度，分别记作OD(v)和ID(v)。出度是以该顶点为®7.1(b）中。7占3IiItT7C哭)=n＿人FillCl=2kfrTlr7、=nnr二＿，二上而顶点S的出度OD(52.人度ID(51，故顶点5的度D(50D(5）十IDC5）二2+1=3," ID="5">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="6.子图第7章图119$Picture[00000128\00000128_new\0002.jpg]Picture$$Picture[00000128\00000128_new\0003.jpg]Picture$$Picture[00000128\00000128_new\0004.jpg]Picture$$Picture[00000128\00000128_new\0005.jpg]Picture$图称为无向完全图，如图7.3(a)所示图为无向完全图。(a)图7.3无向完全图和有向完全图" ID="6">
          <fptr EndPN="00000128" StartPN="00000127"/>
        </Paragraph>
        <Picture URL="00000128\00000128_new\0013.jpg">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Picture>
        <Picture URL="00000128\00000128_new\0014.jpg">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Picture>
        <Paragraph CONTEXT="8.路径和路径长度及简单路径无向图GV,E)中，从顶点v到顶点v的路径是一个顶点序列（vvi：，v，，…，、＝" ID="7">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="v，其中（Vq一：，vg)EE,1&lt;Cm)；若G是有向图，则路径也是有向的.顶点序列应满足＜、一lvEE,1CCma路径长度是指路径上的边或弧的数目。例如在图7.1(b）中有路径（1,2,4,3)，其长度为" ID="8">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="3,若一条路径的顶点序列中不出现重复顶点，这样的路径称为简单路径。例如图7.1(a)中，路径12-3～5是一条简单路径；在图7.1(b)中，路径1～5-4-3也是一条简单路径。" ID="9">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="9.回路或环若一条路径上的起点和终点为同一顶点.则称该路径为回路或环。例如图1(a)中，路" ID="10">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="径1-2-3-4-5-3-4-1是一条回路或环。除了起点和终点之外，其余顶点均不重复的回眨妞rjEr?mF苗Cells乞甜ir.i7,elf-Frtfl[f!1f。lsCe吐1二7一健二哎二左二1一一」‘'i苗fnl败sP5路，称为简单回路或简单环。单环。120数据结构" ID="11">
          <fptr EndPN="00000129" StartPN="00000128"/>
        </Paragraph>
        <Picture URL="00000129\00000129_new\0002.jpg">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Picture>
        <Picture URL="00000129\00000129_new\0003.jpg">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Picture>
        <Picture URL="00000129\00000129_new\0004.jpg">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Picture>
        <Picture URL="00000129\00000129_new\0005.jpg">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Picture>
        <Paragraph CONTEXT="(a)G3" ID="12">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="11.强连通图和强连通分量在有向图G中，若任意两个顶点v;和v都连通，即从v;到v;和从v到v。都存在路径，止黑《(a)(b}(c)图7.5强连通图和强连通分量俄争云口压万J石盖r镶，rlear7a目.＿日片沁盛护士口匡！称为赋权图，也称为网。" ID="13">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000129" TITLE="7.2  图的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="129" PhysicalPageNum="129"/>
        <div ORDERLABEL="00000130" TITLE="7.2.1  邻接矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="130" PhysicalPageNum="130"/>
        <Paragraph CONTEXT="图的邻接矩阵是表示顶点之间相邻关系的矩阵，它是用一个二维数组来表示图中顶点之间的邻接关系.设图GV,E)有n(）1)个顶点，则G的邻接矩阵定义为如下的n阶方阵：例如，图7.1中的G1和G2的邻接矩阵分别为Al和A2，则有0100｝｝00111011｛AZ一｛00000101｝｝0010oll0JL0011图的邻接矩阵表示法具有以下特点：" ID="1">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）无向图的邻接矩阵一定是对称的，而有向图的邻接矩阵不一定对称.故用邻接矩阵来表示一个具有n个顶点的无向图则只需存人上（下）三角元素，且只需n（n＋1）／2个单元，而表示一个有向图时则需要护个单元来存储邻接矩阵。" ID="2">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）对于无向图，邻接矩阵的第1行（或第1列）中非零元素的个数恰好是第1个顶点的度" ID="3">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="数D（v‘）；对于有向图，邻接矩阵的第1行（或第1列）非零元素的个数恰好是第1个顶点的出度" ID="4">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="OD（节）（或人度ID（从））。" ID="5">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="假如用MAXV表示G中允许的最大顶点数，且给出宏定义：" ID="6">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="＃defineMAXV50" ID="7">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="voidCreatadjrnatrix（int。ost［M人X刃［MAXv］，intve。二，int二）" ID="8">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="／，cQst为G的邻接矩阵，vexnuxn为G的顶点数，enum为G的边数.／（inti，j，k，vl，论。化r（1二1；诬＜＝vexnum，1＋＋）for（j，1。j＜＝vexnomoj＋十）" ID="9">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000130" TITLE="7.2.2  邻接链表" TYPE="Chapter">
        <fptr LogicalPageNum="130" PhysicalPageNum="130"/>
        <Paragraph CONTEXT="i22数据结构邻接链表的向量部分，又称表头部分，用来存储n个表头结点，向量的下标指示了顶点的序号。这样我们通过表头结点可随机地访问任一顶点的链表.邻接链表的另一部分是链表，共有n个链表（。为顶点数），即每个顶点对应一个链表。每" ID="1">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="个链表由一个表头结点和若于个表结点组成。表头结点用来指示第i个顶点v;所对应的链$Picture[00000131\00000131_new\0006.jpg]Picture$$Picture[00000131\00000131_new\0007.jpg]Picture$$Picture[00000131\00000131_new\0008.jpg]Picture$个表结点实际上代表了一条依附于v;的边，链域指示了依附于v;的下一条边的结点.因此，第1个链表就表示了依附于表头结点V;的所有的边。对于有向图来说，第1个链表就表示了" ID="2">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="从v;发出的所有的弧。{a)G，的邻接链表{b)dx的邻接链表图7.7邻接链表" ID="3">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="一个图的邻接链表存储结构的类型定义：" ID="4">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="$tdefineMaxvertex50" ID="5">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructarcnode{intadjvex;.下一条弧（边）的终点的编号，／。甘.，～.八月。吕，‘抬南下.＿J‘叮的全鱿.蚌召／" ID="6">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="structarcnode" ID="7">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="}ArclYodeTP;typedefStructVexnode{intvertext/，顶点编号.／ArcNOdeTP«firstarct/指向第一条弧（边）指针，／}AdjList[Maxvertex]ttypedefstructgraph第7章图123建立邻接链表的算法如下：" ID="8">
          <fptr EndPN="00000132" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="VaidcreateAd)list(GraphTp二ga}" ID="9">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="{intn,e,i,j,k" ID="10">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="ArcNodeTP*p;scarfd％dt.n,e)，读人顶点数和边数，／ga一＞vexntAr=n;ga一＞ercnutn=e:for(i二l,iC=nii＋十）" ID="11">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="亏，一＞adjlist[ivertex二i;" ID="12">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="fir，tarc二NLJLL参" ID="13">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="卜" ID="14">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="for（k二1ok＜”e，k十＋）｛5抽nf尸％d％了，＆1，匀）；p二（ArcN比eTP二）皿llocts汪eaf（AicN浏drP））。p一＞adj、ex＝j；p一＞ne，＝，一＞adjliot［1」.n，ta二。ga一＞消hst［1〕.fiotarc二p；／。表结点的链人采用前插法.／" ID="15">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="｝、" ID="16">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="第7章图121" ID="1">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000132" TITLE="7.3  图的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="132" PhysicalPageNum="132"/>
        <div ORDERLABEL="00000132" TITLE="7.3.1  深度优先搜索" TYPE="Chapter">
        <fptr LogicalPageNum="132" PhysicalPageNum="132"/>
        <Paragraph CONTEXT="124数据结构$Picture[00000133\00000133_new\0002.jpg]Picture$$Picture[00000133\00000133_new\0003.jpg]Picture$假定v：是出发点，首先访问v,。因为v】有两个邻接顶点v2和v：均未被访问过，可以选择v2作为新的出发点，访问Vp之后，再找Vq的未被访问过的邻接顶点。同Vp相邻接的有VV4+VS，其中vt已被访问过，而vvs尚未被访问过，可以选择V4作为新的出发点，访问V4之后.再找V；的未访问过的相邻接的顶点Vg，从Vg作为新的出发点，访问Vg之后.再找与v$相接的顶点均已被访问过，故搜索退回到vg，而与ve相邻接的顶点Vg尚未被访间，故访间Vgo然后回退到Vg，由于Vg、V+V2都已被访间过，所以搜索过程继续地从Vg退回到V，再退回到" ID="1">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="Vg，最后退回到v;。这时选择vl的尚未访问过的邻接点V3，继续向前搜索，依次访问V3+Vfi+" ID="2">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="v，从而遍历了图中所有顶点。如图7.8{b}所示，在这个过程中得到的访问顶点序列为：" ID="3">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="V-V2-V～Vg～V5～Vg-V3～Vg-V7" ID="4">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="的Y'W'kim'." ID="5">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="tArcNodeTP*p;" ID="6">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="Printf（即荡了，v）。／.访间顶点。／visited[v1；/，置已访问标志.／P二g.adjlist[vfirstarc;" ID="7">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="firstarc；" ID="8">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="〔if（！板，iled〔p一＞碱vex」）Dfs（9，p一＞adj＊x）；P牛P一＞nextarc；｝" ID="9">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000133" TITLE="7.3.2  广度优先搜索" TYPE="Chapter">
        <fptr LogicalPageNum="133" PhysicalPageNum="133"/>
        <Paragraph CONTEXT="第7章图125次序，访问每一个顶点的所有未被访问过的邻接顶点，并均标记为已访问，依次类推.直到图首先从起点v；出发访间vloV；有两个未曾访问的邻接顶点vE和V3，先访问、，再访问、；然后再访问v：的未曾访问过的" ID="1">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="顶点Vg，最后访问Vg的未曾访问过的邻接顶点Vg。至此图中所有顶点均已被访问过。所得$Picture[00000134\00000134_new\0009.jpg]Picture$vl-V2ova-v-v5-vfi～v今ve-v9其广度优先搜索过程如图7.9所示。图7.9广度优先搜索过程在广度优先搜索过程中，若对V;的访问先于Vj，则对v;邻接顶点的访问也先于对v邻接顶点的访问。即是说，广度优先搜索邻接顶点的寻找具有“先进先出”的特征。因此，为了保证结点的这种先后关系，可采用队列来暂存那些刚访间过的顶点。VoidBfs(GraphTPg,intv){LQueueTPQ;/，说明一个链队列Q/ArcAlodeTP+p;initClueueQ);／二链队列初始化，／" ID="2">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="printf（，’％矛，v）。／，访问顶点‘／" ID="3">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="visited[vI;" ID="4">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="enQueue(PwQ,v}／二v人链队列*" ID="5">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="while(!emptyQueueQ))" ID="6">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="《outQueue（氏Q.色v）；" ID="7">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="p=g.edjlist[vI.firstarc;126数据结构" ID="8">
          <fptr EndPN="00000135" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="｝）同样，这里数组visited为非局部盆。在调用Bfs前，需将该数组的各元素初始化为a。算法中所用的类型定义LQueueTP和函数initQueue,enQueue,outQueue,emptyQueue请参阅点的访问顺序不同。" ID="9">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="给定一个图G＝（V，D和V（G）中的任一顶点v.欲要从v出发，访问G中的所有顶点。当G是连通图时，则从v出发，顺着G中的边可以访问该图中的所有顶点并对每个顶点访问一次且仅访问一次，这一过程称为追历图。图的追历要比树的遏历复杂.由于图的任一顶点都可能与其余顶点相邻接，故在访问了某个顶点之后，可能沿着某条边又访问了已被访间过的顶点。为了避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点。为此，需要设一个辅助数组讨sited［n＋1〕（顶点的序号从1开始）.用以标记顶点是否被访问过，其初始态为0（false）。一旦一个顶点vi被访问，则visited［1］二1（true）。图的遍历有两种基本方法：深度优先搜索和广度优先搜索。" ID="1">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000135" TITLE="7.4  图的生成树" TYPE="Chapter">
      <fptr LogicalPageNum="135" PhysicalPageNum="135"/>
        <div ORDERLABEL="00000135" TITLE="7.4.1  生成树" TYPE="Chapter">
        <fptr LogicalPageNum="135" PhysicalPageNum="135"/>
        <Picture URL="00000135\00000135_new\0003.jpg">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Picture>
        <Picture URL="00000135\00000135_new\0004.jpg">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Picture>
        <Paragraph CONTEXT="集合。显然，Gl！（V，A）是图G的子图，我们称子图Gl是连通图G的生成树。图的生成树不是唯一的。如图7.8（a）的无向图G。当按深度优先和广度优先搜索进行遍" ID="1">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="历时，就得到如图7.10所示的两棵不同的生成树，并分别称为深度优先生成树和广度优先生" ID="2">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="成树。（a）深度优先生成树1图.若在图G的生成树中任意加一条属于B（G）中的边，则必然形成回路。连通图。" ID="3">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000135" TITLE="7.4.2  最小生成树" TYPE="Chapter">
        <fptr LogicalPageNum="135" PhysicalPageNum="135"/>
        <Paragraph CONTEXT="第7章图127$Picture[00000136\00000136_new\0002.jpg]Picture$$Picture[00000136\00000136_new\0003.jpg]Picture${a)无向网络伪）有向网络图" ID="1">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="图7.11网络示例" ID="2">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="它们所对应的邻接矩阵分别为；" ID="3">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="50" ID="4">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="阵" ID="5">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="I6a" ID="6">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="‘coi2s" ID="7">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="coco6540cococo45coco52coco6552二503。421A，＝如申田阅" ID="8">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="一＿＿！‘蕊刁‘沉J‘‘xJ‘，刁" ID="9">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="co二7co" ID="10">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="coco3070的《渊J〔例JO吃〕〔蕊〕co4542二co" ID="11">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="2.最小生成树如果连通图是一个网络，网络中一裸生成树中所有边权总和称为这棵生成树的权。将网" ID="12">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="络中所有的生成树中其权最小的生成树称为最小生成树。例如，图7.12（a）所示的无向网络，" ID="13">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="有如图7.12（b）、（c）、（d）所示的几棵生成树，其中（b）的权为26，（。）的权为16，（d）的权为15，" ID="14">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="可以证明（d）是一裸最小生成树。求最小生成树有三种常用的算法：普里姆（prim）算法、克鲁可以证明（d）是一裸最小生成树。斯卡尔（Kruskal）算法和统观法。" ID="15">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000136" TITLE="7.4.3  求最小生成树的常用算法" TYPE="Chapter">
        <fptr LogicalPageNum="136" PhysicalPageNum="136"/>
        <Paragraph CONTEXT="128数据结构TE=。算法开始时，先从V中任取一顶点（假定取v，)，将它并人U中，此时U二＜vi然后只要U是V的真子集（即UCV)，那么在所有uEU,vEV-U的边（u,v)EE中，选择一条权最小的边，假定为(vv，将该边(vvi）和顶点v;分别并人TE和U，如此进行下去，每次$Picture[00000137\00000137_new\0007.jpg]Picture$＜" ID="1">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="。④④＠’”询④c87ro)c)(d⑦哎，只工nO⑥(e)(fl(g)(h)图7.13用普里姆算法求最小生成树过程为了便于在集合U和V-U之间选择权最小的边，建立两个数组closest和lowroste" ID="2">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="closest[i]表示U中的一个顶点，该顶点和V-U中的一个顶点i构成的边（(i,closest[i习）具有" ID="3">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="最小权的边；lowcost[i〕表示边（i,closest[i]）的权。开始，由于U的初值为｛1}，所以，closest" ID="4">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="「门＝飞月＝夕夕＿＿。＿面布.n，。.f杀目如门z内c,j习二，＿＿。" ID="5">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="本算法每一步扫描数组lowcost.在V-U中找出离U最近的顶点，令其为k，并打印边" ID="6">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="（k，。losest［k〕）。" ID="7">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="Est，标记k已经加人U。这里mat表示图的邻接矩阵，rnat第7章图l29closest[i1" ID="8">
          <fptr EndPN="00000138" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="}closest［1〕＝伪／，表示顶点1在U中.／far(i=2,i＜二N;i十＋）(min二lowcost[ik=itfor（j＝211＜毕N，j＋＋）if(lowcost[jminclosest[j=0){min二lowcost口」.k“j；｝printfdd)＼nclvsest[kkleoe,r4二n./Y习-sY7i.k4Ft$n1i丫‘1closest［目二0。if（mal〔k〕口J＜lowcos：口」乙＆.cl、［D〕！" ID="9">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="咬lowcos［［j〕＝mat［闭臼］；。1舀〕！k；｝“0）｝｝根据图7.12（a）给出调用上述函数的主函数：nlain（）" ID="10">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="裙inti，j，侧［N＋1〕［N＋1〕；" ID="11">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="for（1＝1；K＝N；1＋十）" ID="12">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Picture URL="00000138\00000138_new\0023.jpg">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Picture>
        <Paragraph CONTEXT="Pritn（net）；" ID="13">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="运行结果：" ID="15">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="（1，3）" ID="16">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="（3，6）（6，4）（3，2）130数据结构到并相州卒顶点.ci]" ID="17">
          <fptr EndPN="00000139" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="Ic，wcYS" ID="18">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="rkx+ast[i]" ID="19">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="lowccx+砚" ID="20">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="clc，x·stLif13I16I3！'6｝｝”·3·6，1“·，·”，.七汁一十州下厂｝｝。｝·妙，4《，·3·6二，）1‘2·5｝1｝，11圣｝二二岑井书一于一斗一月J一卜一斗一勺气1｝｝｝11｛l.描·4.2.5｝｝。图7.14州m算法对图7.12（a）的执行过程" ID="21">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="2.克香斯卡尔（Kruskal）算法克各斯卡尔算法的基本思想是：假设G“（V，E）是一个具有n个顶点的连通图，T（U，1下）是G的最小生成树，U的初值等于V，即包含有G的全部顶点.TE的初值为空集。将图G中的边按权值从小到大的顺序依次选取，若选取的边使生成树T不形成回路，则把它并人TE中，保留作为T的一条边，若选取的边使生成树T形成回路，则将其舍弃，如此进行下去，直到飞卫中含有nl条边为止，此时的T即为最小生成树。例如，用克鲁斯卡尔算法对于图7.13（a）求最小生成树的过程如图7.15所示。图中按边权值从小到大的顺序排列的边集为：（1，3）：50（2，4），65（5，6），70" ID="22">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="①①①①①①②＿叽⑦气戈。⑦叹叱尹劝第7章图i31通过分析可知，prim算法的时间复杂度为O(n)，而Kruskai算法的时间复杂度为O(e)," ID="23">
          <fptr EndPN="00000140" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="其中e为图G的边数。" ID="24">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="3.统观法;马盛奋ir月户-r之牵4帝[trrvpurntd‘由l/E，下S,毛甘L、曰、.，＝!$Picture[00000140\00000140_new\0009.jpg]Picture$$Picture[00000140\00000140_new\0010.jpg]Picture$$Picture[00000140\00000140_new\0011.jpg]Picture$$Picture[00000140\00000140_new\0013.jpg]Picture$$Picture[00000140\00000140_new\0014.jpg]Picture$$Picture[00000140\00000140_new\0015.jpg]Picture$仍连通，则删除它，这时得到图GZ。在图G：中，再寻找一条权最大的边（保留边除外），如此继续下去，直到求得图Gp，而图G。是连通的，且有n个顶点和n-1条边，则图味就是图G的" ID="25">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="4" ID="1">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000140" TITLE="7.5  最短路径" TYPE="Chapter">
      <fptr LogicalPageNum="140" PhysicalPageNum="140"/>
        <div ORDERLABEL="00000140" TITLE="7.5.1  最短路径的概念" TYPE="Chapter">
        <fptr LogicalPageNum="140" PhysicalPageNum="140"/>
        <Paragraph CONTEXT="132数据结构顶点到另一个顶点所经过的路径中边权之和最小的路径，即最短路径问题。我们在讨论中.结合有向网络图，交通网络是具有有向性的。例如，设A城到B城有一条公路，A城的海拔高于B城，若考虑到上坡和下坡的车速不同，则边＜A,B》和边（B,A》上表示最短路径问题分为两类：一是求从一个顶点到其他各项点的最短路径，二是求每对顶点之" ID="1">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000141" TITLE="7.5.2  单源最短路径" TYPE="Chapter">
        <fptr LogicalPageNum="141" PhysicalPageNum="141"/>
        <Picture URL="00000141\00000141_new\0001.jpg">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Picture>
        <Paragraph CONTEXT="co：t［。口」一｝钩毛C洲二】否则第7章图133他各顶点的最短路径长度。例如，对于图7.18所示的有向网络，采用狄杰斯特拉算法：$Picture[00000142\00000142_new\0006.jpg]Picture$自翔0口心‘.1田OOZU.二二60" ID="1">
          <fptr EndPN="00000142" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="图7.18有向网及其邻接矩阵" ID="2">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="初始时，5＝｛1｝，dis［2］＝10，dis仁3］“co，dis［4〕＝30，dis〔5〕二100。故第一次处理时，从" ID="3">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="生J会V一只二矛2＿又。乙。气、中引龙前＊二夕‘田币。厂夕〕着急，l、.舌行止臼下瓦占夕从V一只山翻1习卜日幸仁人众山" ID="4">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="；顶点2从V-5中删去且并人5中。" ID="5">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="1到V-5中各顶点的最短路径的长" ID="6">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="这时5＝｛1，2｝，而V-5＝｛3，4，5｝，然后修改调整源点1到V-5中各顶点的最短路径的长" ID="7">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="度，因为原来的dis［3〕＝co，然而山5［2〕＋。ost［2］［3］＝10＋50＝60，故从中选较小值修改dis" ID="8">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="〔3〕，使dis［a］＝60，而dis「4］和dis［5］的值不变。" ID="9">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="在狄杰斯特拉的算法实现中，需设置一个数组okset，当oksetli」＝1时，表示顶点1是5" ID="10">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="中的元素；当oksetli〕二0时，表示顶点1是V-5中的元素。并设计一个函数而ni。就，其功能是选择当okset［润为。时，使dis「润最小的m，并返回m的值。下面给出狄杰斯特拉算法的完整程序（结合图7.18示例）：" ID="11">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="特defineNS／，图G中顶点数＊／特defineMAX32000＃1二lude即。tdio.h’’vo记dijbtra（int二t［］［N十1］）长访ti，v，w，5二；134数据结构minicost(intdi。口，intokset" ID="12">
          <fptr EndPN="00000143" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="（in1i,m,tmp=fwltL)C;" ID="13">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=2;iN;i十＋）ifokset[i]0)$dis[i]Ctmp))笼t幻lp“dis［1习Im＝1；）" ID="14">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="return(m):" ID="15">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="16">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="n、日in" ID="17">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="{inti,j,adynet[N+11[ll+11," ID="18">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="For(i二l;i＜二N;i十＋）forij=1;j＜一N;j＋十）scanf%dadjnet[ij;" ID="19">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="dijkstra(adjnet);" ID="20">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="》运行：100010001000601000" ID="21">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="运行结果：" ID="22">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="1一一）z，zo" ID="23">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="1一一＞3：50" ID="24">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="1一一＞4，301一一＞5：60" ID="25">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000143" TITLE="7.6  拓扑排序" TYPE="Chapter">
      <fptr LogicalPageNum="143" PhysicalPageNum="143"/>
        <div ORDERLABEL="00000143" TITLE="7.6.1  AOV网" TYPE="Chapter">
        <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
        </div>
        <div ORDERLABEL="00000144" TITLE="7.6.2  拓扑排序" TYPE="Chapter">
        <fptr LogicalPageNum="144" PhysicalPageNum="144"/>
        <Paragraph CONTEXT="蛛编译原理C3,u课程之间的先后关系可用有向图表示，如图19所示。图7.”课程间先后关系示意图可以看出，{C1,3fvl,wfifCa+C!SCS+Cg+C9）是一个可行的线性序列。可见若C是G的前趋，则c;必排在c;前面.在AOV网中不允许出现环，因为环意味着某项子工程的开始将以本身工作完成为先决条件，这显然是不合理的。检测有环的一个方法是，把ALW网中全部顶点排成一个线性序列，使得在此序列中顶点之间不仅保持有向图中原有的次序关系，而且在有向图中所有无关系136数据结构可以排在一个拓扑有序序列中。一个AOV网的拓扑有序序列不是唯一的。例如，图7.19还可以得到另一个拓扑排序：对AOV网进行拓扑排序的基本步骤是：" ID="1">
          <fptr EndPN="00000145" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)从AOV网中选择一个没有前趋（人度为0)的顶点，并且输出它；" ID="2">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)从网中删去该顶点，并且删去从该顶点发出的全部有向边；" ID="3">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)重复上述两步，直到网中所有顶点全部输出而完成拓扑排序或者剩余网中再也没有$Picture[00000145\00000145_new\0011.jpg]Picture$$Picture[00000145\00000145_new\0013.jpg]Picture$l3a5(a)AOV网（b)邻接链表图7.2oAOV网及其邻接链表" ID="4">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="1。此时CC：的人度为d，选C,，删去C：及边QS.e4，调整Cs,C，的人度为0。从CG,C,中选C,，删去C：及边es调整Cs的入度为z。从CC4中选择C2rJCt及边e，调整q的" ID="5">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="人度为1。再选Cq,删去C4和边e7，调整C：的人度为。.最后输出CS。至此拓扑排序完成，且" ID="6">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="拓扑序列为" ID="7">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="（q，马，C】，Q，c’，蛛）" ID="8">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="拓扑排序算法以邻接链表作为存储结构，如图7.2d(b)所示，该算法的形式描述如下，" ID="9">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="TOPson(GraphTPg)" ID="10">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="｛建立人度为0的顶点钱S" ID="11">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="m=0;" ID="12">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="while&lt;！Emptysreck(S))第7章图137（w的人度一一；if{w的人度二二a)w人s栈；" ID="13">
          <fptr EndPN="00000146" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="w弃图g中顶点v的下一个邻接点；｝" ID="14">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="｝if(mCn)printf”图中有环！1n，，)I｝算法中以邻接链表作为存储结构，并设置一个链栈，将所有人度为0的顶点人栈。选择人度为。的顶点，只要从栈中弹出一个元素即可。删除边的操作转化为将以该顶点为弧尾，所有相应弧头所指顶点的人度减1。在邻接链表的表头中增加一个人度域in，如图7.2a{b)所示。下面给出拓扑排序算法的实现：#defineVNUMs0typedefstructarcrwode{intadjvex;/、下一条弧的始点编号，／structarcnode+nextarc;}AarNodeTP;typedefstructvexrrode{VertexTypeVertex;intin;ArcnodeTP铃firstarc;}Adjli9t[Vnum]typedefstructgraph{AdjListadjlist;intvexnum,arcnum;}GraphTP;／＊以下是拓扑排序算法，／TOPsort(GraphTPt){LStackTP*S，/*S说明一个链栈" ID="15">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="ArcNodeTP*p;mtm,i.v;1城ts切ck（5）；／。5初始化。／" ID="16">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=O;i&lt;g.vexnum;i十＋）" ID="17">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="if(g.adjlist[iI.in0)push&lt;s,i);m=0while(！Emptystack(S｛卯p（5，＆v），p6ntf（”％dv）m1P二g.adjlist[vI.firstarc138数据结构if(g,adjlist[p一＞adjvexin0)" ID="18">
          <fptr EndPN="00000147" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="push{S,p一＞adjvex);" ID="19">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一＞nextarc;" ID="20">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="）if(m&lt;g.vexnum)return(0／二图含有环‘／elsereturn{1);" ID="22">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="｝拓扑排序算法的时间复杂度为0{n十e)，其中n,e分别为网的顶点数和边数。" ID="23">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="7.s.IAov网在工程实践中，经常用有向图来表示工程施工的流程图或产品生产的流程图。一个工程项目一般可分为若干个子工程或子项目，我们把这些子工程或子项目称为“活动”。在有向图第7章图135施；而有些课程是专业基础课和专业课，必须在某些基础课程学完之后才能开始实施，因此存在先后关系，或者说，基础课是专业基础课和专业课的前导课程，在AOV网中，若从顶点i到顶点J有一条有向路径，则称i是」的前驱，并称j是i的后继。若Ci,j》是网中一条有向弧，则称i是」的直接前驱，并称j是i的直接后继。" ID="1">
        <fptr EndPN="00000144" StartPN="00000143"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000147" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="147" PhysicalPageNum="147"/>
      <Paragraph CONTEXT="1。什么是图？图有哪两种常用的存储结构？各自特点是什么？" ID="1">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="2." ID="2">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对于图7.22，求：" ID="3">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)每个顶点的人度和出度；(2）图的邻接矩阵；(3)图的邻接链表。" ID="4">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="4.对图7.23，从顶点1出发，分别按深度优先搜索和广度优先搜索遍历图." ID="5">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Picture URL="00000147\00000147_new\0008.jpg">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Picture>
      <Paragraph CONTEXT="5.对于图7.24，分别用深度优先搜索和广度优先搜索求出两棵不同的生成树。" ID="6">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="5。" ID="7">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="6。" ID="8">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="7.对图7。26，用狄杰斯特拉算法求从顶点1到其他各顶点的最短路径。" ID="9">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="8.写出将一个无向图的邻接矩阵转换成邻接锌表的算法。$Picture[00000147\00000147_new\0014.jpg]Picture$$Picture[00000147\00000147_new\0015.jpg]Picture$第7章图1as$Picture[00000148\00000148_new\0002.jpg]Picture$$Picture[00000148\00000148_new\0003.jpg]Picture$图7.24无向题图7.25权图" ID="10">
        <fptr EndPN="00000148" StartPN="00000147"/>
      </Paragraph>
      <Paragraph CONTEXT="10.试以邻接矩阵作为存储结构，分别写出连通图的深度优先和广度优先搜索算法。" ID="11">
        <fptr EndPN="00000148" StartPN="00000148"/>
      </Paragraph>
      <Paragraph CONTEXT="11。已知图G的如下邻接链表，如图7.27所示。顶点1为始点。试求：" ID="12">
        <fptr EndPN="00000148" StartPN="00000148"/>
      </Paragraph>
      <Picture URL="00000148\00000148_new\0008.jpg">
        <fptr EndPN="00000148" StartPN="00000148"/>
      </Picture>
      <Paragraph CONTEXT="(1)深度优先搜索的顶点序列及其所得到的一棵生成树；｝一2’｝二马一今｝’，｝二一砷｝瓜’ii巨工三一一二工困巨工习一今巨工习140数据结构$Picture[00000149\00000149_new\0003.jpg]Picture$图7.28AOV网1图7.29AOV网2" ID="13">
        <fptr EndPN="00000149" StartPN="00000148"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000149" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="149" PhysicalPageNum="149"/>
      <Paragraph CONTEXT="工.内容：图状结构，曰的。堂月层圆的左性姑幼冠石到习泊不图幼月除妇二.叮马；介矗，K庄肖么盼的甘习二" ID="1">
        <fptr EndPN="00000149" StartPN="00000149"/>
      </Paragraph>
      <Paragraph CONTEXT="2.3.题目：实习题一：给定图7.30，以邻接矩阵作为存储结构，从顶点1出发，试分别写出深度优先搜索和广度优先搜索算法的实现，并给出遍历的结果。图7.30图7.31无向赋权图实习题二：利用prim算法求图7.31的一棵最小生成树。" ID="2">
        <fptr EndPN="00000149" StartPN="00000149"/>
      </Paragraph>
      <Paragraph CONTEXT="4.要求：分别给出程序清单和运行结果.第S章查找141" ID="3">
        <fptr EndPN="00000150" StartPN="00000149"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="护知气也漆。漆巴冲。沐。钾气巴饰。与已；已导3诵已年为气气气气出，气气勺气为气、知气御气知御气飞矛一‘＝二二二＿，＿＊，二。J，＿、＊冲二分落图的最小生成树和最短路径；5，拓朴排序·玄求1)搞清有c嗯J概念，(2)掌握图的两种存储结构，{3)粤a图也是一种重要的非线性结构，称为图状结构或网状结构，它比树形结构更复杂。" ID="1">
      <fptr EndPN="00000126" StartPN="00000126"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000150" TITLE="第8章  查找" TYPE="Chapter">
    <fptr LogicalPageNum="150" PhysicalPageNum="150"/>
      <div ORDERLABEL="00000150" TITLE="8.1  查找的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="150" PhysicalPageNum="150"/>
      <Paragraph CONTEXT="142数据结构其中，C;为查找第i个记录所需比较次数，P;为查找第i个记录的概率。若查找每个记录的机会均等，贝IJ每个记录的P1n°在实际查找应用中，必须按一定的数据结构组织记录，然后选择合适的查找方法进行查本章主要介绍静态查找表和动态查找表的查找方法。" ID="1">
        <fptr EndPN="00000151" StartPN="00000151"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000151" TITLE="8.2  静态查找表" TYPE="Chapter">
      <fptr LogicalPageNum="151" PhysicalPageNum="151"/>
        <div ORDERLABEL="00000151" TITLE="8.2.1  顺序查找" TYPE="Chapter">
        <fptr LogicalPageNum="151" PhysicalPageNum="151"/>
        <Paragraph CONTEXT="顺序查找又称为线性查找，是一种最简单的查找方法。它是从线性表的一端开始，顺序扫描线性表，依次将扫描到的结点关键字值与给定值k相比较，若当前扫描到的结点关键字值与k值相等，则查找成功；若扫描整个线性表结束后，仍未找到关键字值等于k的结点，则查找失败。例8.1在关键字序列为｛3,9,1,5,8,10,6,7}的线性表中查找关键字值为5的元素。顺序查找的过程如下：开始：39158106?第。次比较：391581067么第1次比较：391581067" ID="1">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="杏" ID="2">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="第2次比较：391581067" ID="3">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="第3次比较：391581067查找成功，返回其位置3," ID="4">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="顺序查找的线性表，其类型定义如下：" ID="5">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineMAXITEM140" ID="6">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructretard第s章查找143" ID="7">
          <fptr EndPN="00000152" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="｝该算法的功能是：对已给定的顺序表的记录ro，r：，…，‘一：和给定值k依次比较，确定是否存在某个记录r;(OCi&lt;n-1)，使得r;·key=k，如果存在，则查找成功，并返回该记录的位置卜否则，查找失败，且返回特殊标志一to" ID="8">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="算法分析：" ID="9">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）在最坏的情况下，顺序查找需要比较n次，即MSL=no" ID="10">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)假定各记录的查；机会均等，即。一1n，由于查找第i个记录〔i一2，…，。一1)要比较i十I次，即Ci-f1，于是有名=o1=ennLG因此，最大查找长度和平均查找长度的数量级（即算法的时间复杂度）均为Cn)o" ID="11">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000152" TITLE="8.2.2  二分查找" TYPE="Chapter">
        <fptr LogicalPageNum="152" PhysicalPageNum="152"/>
        <Paragraph CONTEXT="二分查找又称折半查找，这种查找方法要求查找的线性表必须是有序表。即要求表中的结点（记录〕必须已按关键字值的递增＜或递减）顺序排列。由于有序表中所有结点按键值递增的次序排列，若将表中任一结点i的键值r[iI.Lcey与给定值k比较.其比较结果分为三种情况：{1)r[iI.keyk，查找成功.即r仁i为待查结点；" ID="1">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)r[ikey&gt;k，则待查结点若在表中，必定排在r[i」之前；二分查找法首先把要查找的k值与表的中间位置结点的关键字值相比较，这个中间结点把查我的线性表分成了两个子表。若比较相等，则查找成功。若不相等，再根据k值与该中间结点关键字值的比较大小确定下一步查找哪个子表，这样递归进行下去，直到找到满足条件的144数据结构查找成功，返回结果序号2.二分查找法的算法如下：" ID="2">
          <fptr EndPN="00000153" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="intbinsearchCsglistr,intn,intk}" ID="3">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="{int1aw.high,mid,find,i;" ID="4">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="｝该算法若查找成功，则返回待查结点的序号（即该数组元素的下标）；若查找失败，则返回-1,算法分析：二分查找的过程实际上是从二又树的根结点开始到被查记录结点所经历的一｝径。因此，比较的次数不会超过二叉树的深度d二L1agzn」十1，其中符号L」表示向下取条路径。因此，比较的次数不会超过二叉树的深度d-LI。歇n」十1，其中符号L」表示向下取" ID="5">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="救。目田In仇n比匕In岛。石斤口J＿一篇条力茹到含封、配，』之伙.刘公士仑J乙由，仪，翻r雀熟奋比了准雪赴玉启山往备咋刀难李少‘“书、习，八整，眼1092n少蒸10今no（109至n）。" ID="6">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="由此可知，二分查找比顺序查找速度快，但二分查找法需要对n个记录结点预先按键值进行排序。" ID="7">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000153" TITLE="8.2.3  分块查找" TYPE="Chapter">
        <fptr LogicalPageNum="153" PhysicalPageNum="153"/>
        <Paragraph CONTEXT="分块查找又称为索引顺序查找，是顺序查找的一种改进，其性能介于顺序查找与二分查找！。分块查找把线性表分成若干块，每一块中的元素存储顺序是任意的，但块与块之间必须之间。按关键字值大小排序。即前一块中的最大关键字值小于（或大于）后一块中的最小（或最大）关键字值。另外还需要建立一个索引表，索引表中的一个索引项对应线性表中的一块，索引项由第s章查找145序号：I2345678910111213141516图8.1块表和索引表$Picture[00000154\00000154_new\0006.jpg]Picture$的键值为48，其总的序号为9," ID="1">
          <fptr EndPN="00000154" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="索引表的结构类型定义如下：" ID="2">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="structindeztetm" ID="3">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="{keyTypekey;int1ow.high;李；typedefstructindextermindex[MAXITENI分块查找算法的实现如下：intblksearch(sglistr,indexidx,inrk,inthn)/，bn为块的个数＊／{inti,1ow1,highbn,midl,find=0,hb;WhileClowlhighl8!find){midllowl十highl2;" ID="4">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="5">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="local二midl;{ind二1书卜" ID="6">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="if（Iow1＜hn）／.k小于索引表内最大值，／谧i=idz[lowl1ow;hb二idxllowl1,high;" ID="8">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="｝，汉那翻刁佗份" ID="9">
          <fptr EndPN="00000155" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="L46一一＝―一一―分疾查找函数的功能：在线性表r中分块查找关。字值为k的记录结点，右：位乳镖瑰馨翼星靛进行两次查找，故整个算法的平均查找长度是”次平”，，J刁‘确产，F二／，产－一’－‘Sl夕名lo$2Cn/s-1)+s/2" ID="10">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="静态查找表又分为三种：顺序查找、二分查找和分块查找。" ID="1">
        <fptr EndPN="00000151" StartPN="00000151"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000155" TITLE="8.3  动态查找表" TYPE="Chapter">
      <fptr LogicalPageNum="155" PhysicalPageNum="155"/>
        <div ORDERLABEL="00000155" TITLE="8.3.1  二叉排序树" TYPE="Chapter">
        <fptr LogicalPageNum="158" PhysicalPageNum="158"/>
        <Paragraph CONTEXT="二叉排序树的插入也可写成如下递归算法：voidbstins(bstnade*s,bstnode二t)／。将新结点5插人到指针t所指的二叉排序树中。／" ID="1">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="elseif(，一＞keyCt一＞key)bstins(s,t一＞lch);elsebstins(s,t一＞rch);｝" ID="2">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="二叉排序树的动态插入过程也是二叉排序树的动态生成过程。因此，建立一棵二叉排序树的算法可描述如下：voidbstcreat(bstnode*t)" ID="3">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="／。输入一个键值序列，建立一棵二叉排序树，t指向根结点的指针，／" ID="4">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="{intx;" ID="5">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="bstnode#s;t=NULL;scant°%d&quot;.hi-x);while(x！二一32000)/，一32000为结束标志，／{s=(bstnode。&gt;rnalloc(sizeof(bsmode;，一＞1sey=x;s一＞lch=NULL;s一＞rch=NULL;" ID="6">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="bstins(s,t):i，插人新结点，／" ID="7">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="scant%d&amp;x);｝｝150数据结构$Picture[00000159\00000159_new\0002.jpg]Picture$。尹6广呱中(a)(b)(c){d)一(e)（幻（只）{h)(i)" ID="8">
          <fptr EndPN="00000159" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="3.二叉排序树的侧除从一棵二叉排序树上删除一个结点之后仍须保持一棵二叉排序树。－" ID="9">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)p为叶结点。只需置F的左指针为空，如图8.5所示。$Picture[00000159\00000159_new\0012.jpg]Picture$$Picture[00000159\00000159_new\0013.jpg]Picture$$Picture[00000159\00000159_new\0014.jpg]Picture$$Picture[00000159\00000159_new\0015.jpg]Picture${a）删除P之前（b)N1除P之后设待删结点为P，其" ID="10">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="双亲结点为F。图8.5二叉排序树上剧除叶结点" ID="11">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）p只有一棵非空子树。只需删去p并直接用p的非空子树的根结点取代p的位置。如图8.6所示。户（a）P只有左子树（b）删去p使P的左子树的（口P只有右子树（d）删去p使P的右子树第8章查找151况下，必须决定以哪个结点取代P的位置。一种较简单的办法是用A取代P。相应地，因P的右子树PR上的键值小于F且大于B，则可将PR改为13的右子树，这就保证了删除结果仍为一裸二叉排序树，如图8.7(ah）所示。当A无右孩子时，则用A取代P后.并将P的右子树" ID="12">
          <fptr EndPN="00000160" StartPN="00000159"/>
        </Paragraph>
        <Picture URL="00000160\00000160_new\0006.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Picture URL="00000160\00000160_new\0007.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Picture URL="00000160\00000160_new\0008.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Picture URL="00000160\00000160_new\0009.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Paragraph CONTEXT="ro)除P后的结果（c]删除P前A无右孩子（{d)除P后的结果" ID="13">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="图8.7二叉排序树上结点P有二棵非空子树时的剧除" ID="14">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000160" TITLE="8.3.2  平衡二叉排序树" TYPE="Chapter">
        <fptr LogicalPageNum="160" PhysicalPageNum="160"/>
        <Paragraph CONTEXT="1.平衡二叉排序树的定义一棵平衡二叉排序树（简称AVL树）或是一棵空树，或是一棵任一点的左子树与右子树的高度至多相差1的二叉排序树。即是说，形态匀称的二叉排序树称为平衡二叉排序树.其严格定义是：一棵空树是平衡二又排序；若T是一棵非空二叉排序时，其左、右子树分别为TL和TR，令hl和hr分别为左、右子树的高度.当且仅当TL,TR都是平衡二叉排序树，且｝hl-和TR，令hl和hr分别为左、右子树的高度." ID="1">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="hrl成1时.则T是平衡二叉排序树。" ID="2">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="所谓二叉排序树上任一结点的平衡因子是指该结点左子树的高度减去该结点右子树的高度之差。易知平衡二叉排序树上任一结点的平衡因子只可能是一1、。或1。反之，一棵二叉排序树上只要有一个结点的平衡因子不是一1、0或1，则此二叉排序树就不是平衡二叉排序树。152数据结构" ID="3">
          <fptr EndPN="00000161" StartPN="00000160"/>
        </Paragraph>
        <Picture URL="00000161\00000161_new\0002.jpg">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Picture>
        <Picture URL="00000161\00000161_new\0003.jpg">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Picture>
        <Picture URL="00000161\00000161_new\0004.jpg">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Picture>
        <Picture URL="00000161\00000161_new\0005.jpg">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Picture>
        <Paragraph CONTEXT="一～分～－一～－－－－～－－－－一―图8.8AVL树和非AVL树的示例又排序树特性的前提下.调整最小不平衡子树中各结点之间链接关系，以达到新的平衡.所谓最小不平衡子树是指：以离插人结点最近、且平衡因子绝对值大于1的结点作根结点的子树。为了简化讨论，不妨假设二叉排序树的最小不平衡子树的根结点为A，则调整该子树的规律可归纳为下列四种情况：{1)LL型平衡调整失衡原因：在A的左孩子B的左子树上插人新结点，而导致A的平衡因子由1变为2," ID="4">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="调整方法：提升B为新子树的根结点，将A结点从B的右上方旋转到B的右下侧而成为B的右孩子、同时将B原来的右子树BA调整为A的左子树。如图8.9(a）所示，这样调整所得的新子树仍为二叉排序树，并且是平衡的。&lt;2)RR型平衡调整失衡原因：在A的右孩子H的右子树上插人新结点，而导致A的平衡因子由一1变为-2,调整方法：提升B为新子树的根结点，将A下降为B的左孩子。同时将S原来的左子树第8章查找153" ID="5">
          <fptr EndPN="00000162" StartPN="00000161"/>
        </Paragraph>
        <Picture URL="00000162\00000162_new\0002.jpg">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Picture>
        <Picture URL="00000162\00000162_new\0003.jpg">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Picture>
        <Paragraph CONTEXT="区李(a)LL型调整$Picture[00000162\00000162_new\0006.jpg]Picture$$Picture[00000162\00000162_new\0007.jpg]Picture$$Picture[00000162\00000162_new\0009.jpg]Picture$$Picture[00000162\00000162_new\0010.jpg]Picture$(c)LR型调整协" ID="6">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Paragraph>
        <Picture URL="00000162\00000162_new\0014.jpg">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Picture>
        <Paragraph CONTEXT="二》(d)RL型调整图8.9AVL树四种调整示意图154数据结构例S.5设一组记录的键值按以下次序进行插人：14,15,17,12,11,13,16，其生成并调整为平衡二叉排序树的过程如图a,10所示。输入键值插入后调整平衡过程" ID="7">
          <fptr EndPN="00000163" StartPN="00000162"/>
        </Paragraph>
        <Paragraph CONTEXT="141q0，5叮，17-21151＿二15、‘夕尸，、2、$Picture[00000163\00000163_new\0010.jpg]Picture$卫些与" ID="8">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Paragraph CONTEXT="11214i17}0L$Picture[00000163\00000163_new\0014.jpg]Picture$LR型$Picture[00000163\00000163_new\0017.jpg]Picture$$Picture[00000163\00000163_new\0018.jpg]Picture$l6" ID="9">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Picture URL="00000163\00000163_new\0021.jpg">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Picture>
        <Picture URL="00000163\00000163_new\0022.jpg">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Picture>
      </div>
      <Paragraph CONTEXT="静态查找表一旦生成之后，则表的结构本身在查找过程中是固定不变的。叨一初怂宜科衣" ID="1">
        <fptr EndPN="00000155" StartPN="00000155"/>
      </Paragraph>
      <Paragraph CONTEXT="观不然，动态查找表的特点是，表的结构本身是在查找过程中动态生成的，即对记录结点经过于k的记录结点，则查找成功，否则插人关键字值等于k的记录结点。太节研介貂的树表一一气二叉排序树和平衡二叉排序树正是具有这种动态特性。第8章查找147根据二又排序树的这一基本特点，则二叉排序树具有下述重要性质：中根遍历一棵二叉排序树所得到的结点访问序列是键值的递增序列。如图8.2(a)所示二叉排序树的中根遍历序列为：4,5,6,7,8,9,16,18,200二叉排序树的结点结构类型可描述为：" ID="2">
        <fptr EndPN="00000156" StartPN="00000155"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstnactnode" ID="3">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="{keytypekey;键值及其类型" ID="4">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="datatypedata{‘其他数据域，／" ID="5">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="structnode赞lch,*rch;" ID="6">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="}bstnode;" ID="7">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="i.二叉排序树的查找算法假定指向二叉排序树根结点的指针为root，给定的键值为k，则查找算法可描述为：{1）置初值：q=root;{Z)如果k二gykey，则查找成功，算法结束；" ID="8">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)否则，如果k&lt;q一＞key，且q的左子树非空，则q=q一＞lch，转步骤(2)；若q的左子树为空，则查找失败，结束算法；" ID="9">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)否则，如果k&gt;q一＞key，且q的右子树非空，则q=q一＞rch，转步骤(2)。若9的右子树为空，则查找失败，结束算法。二叉排序树查找算法的实现如下：voidhstsearch(bstnode*root,bstnodeop,6stnade+q.intk){intflag;" ID="10">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="p=NC几Iq=root;flag=0;whileql=NULL)(flag二二0" ID="11">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="{printfsuccessadq一＞keyflag二" ID="12">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="{P°q:4=4一＞lch;}else{p二4‘q二q一＞rch｝if{flag0)printfnotfound;｝函数执行完后，若查找成功，则输出所找到的结点的键值，并且指针q指向所找到的结点，" ID="13">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="p指向它的父结点，如果查找失败，q=NULL,p为q的父结点指针。二叉排序树查找的递归算法：bsinode二hstsrch(bstnode，root,intk)" ID="14">
        <fptr EndPN="00000156" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="t=root;148数据结构｝该函数执行完之后，若查找成功，则返回指向所找到的结点的指针；否则返回空指针。二叉排序树查找算法分析：不难看出，在二叉排序树上查找其关键字值等于给定值k的结点过程，恰是走一条从根结点到该结点的路径过程，其关键字值的比较次数不会超过该二叉树率的情况下，其平均查找长度为：＿1石：、＿ni＝1其中n＝1十nZ＋…＋氏为二叉树的结点数。显然，当每层只有一个结点时，即d＝n，则ASL的值达到最大，且有1名.1，，.，.、＿n＋1＿。，、八勺L台一乙！污一气1州尸‘.卞j州卜“二州尸n，～一下千－只写U气n，ni＝In‘" ID="15">
        <fptr EndPN="00000157" StartPN="00000156"/>
      </Paragraph>
      <Paragraph CONTEXT="此时二叉排序树蜕化成线性链表。而当二叉排序树在生成过程中比较匀称时，ASL的值达到" ID="16">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="易.l、石浑份书不6日一可润仁良姗的着蒸，卜国区齿侧够此裕磨专n门" ID="17">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="2.二叉排序树的插入算法" ID="18">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="在二叉排序树中插人一个给定关键字值为k的新结点，应先查找树中是否已有关键字值" ID="19">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="为k的结点，只有当查找失败时，才将新结点插人到树中“适当位置”，插人后使之仍构成一棵" ID="20">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="二叉排序树，这个“适当位置”在查找算法中已被保留。故插人算法可描述为：" ID="21">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）调用查找过程bstsearch（root，p，q，k）；" ID="22">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）若查找失败.即q二卜川LL，则" ID="23">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="2）若root为NULL，则root＝r，" ID="24">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="3）若k＜p一＞key，则p一＞Ich二r，" ID="25">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="4）若k＞p一＞key，则p一＞rch＝r；" ID="26">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）算法结束。第8章查找149由于输人的先后顺序不同，则所得到的树的形态和高度可能完全不同。例如，对于关键字值集" ID="27">
        <fptr EndPN="00000158" StartPN="00000157"/>
      </Paragraph>
      <Picture URL="00000158\00000158_new\0004.jpg">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Picture>
      <Picture URL="00000158\00000158_new\0005.jpg">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Picture>
      <Paragraph CONTEXT="分别得到如图8.3(abc）所示的二又排序树。(a}(b)(c)" ID="28">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000163" TITLE="8.4  哈希表" TYPE="Chapter">
      <fptr LogicalPageNum="163" PhysicalPageNum="163"/>
        <div ORDERLABEL="00000164" TITLE="8.4.1  哈希表和哈希函数" TYPE="Chapter">
        <fptr LogicalPageNum="164" PhysicalPageNum="164"/>
        <Paragraph CONTEXT="为了实现不经任何比较，一次便能得到所查记录。那就必须在记录的存储位置与它的关键字值之间建立一个确定的对应关系H，使每个关键字值和查找表中的一个唯一存储位置相对应。因而在查找时，只要根据这个对应关系H就能找到给定值K的存储位置H(K)。因此，若查找表中存在关键字值和K相等的记录，则必定在存储位置H(K)＿上，而不需要进行比较便可直接取得所查记录.H(K）称为键值是K的记录的哈希地址或散列地址.我们称这个对应关系H为哈希（Hash)函数或散列函数，按此思想建立的查找表称为哈在理想的情况下，每个键值对应一个散列地址，且不同的键值对应不同的散列地址。但在$Picture[00000164\00000164_new\0012.jpg]Picture$式中，ch为关键字值k的首字母，ASC(ch）为。h的ASCII码。则有156数据结构询某个记录，只要重新计算H(k)，得到散列地址。便可直接到哈希表HT中的该位置去访问。然而。间题并非如此简单。假定在上面的记录中.再增加三个城市：Chengdu（成都）、Nang-Zh,ao（杭州）,Nanchang（南昌），结果发现：" ID="1">
          <fptr EndPN="00000165" StartPN="00000164"/>
        </Paragraph>
        <Paragraph CONTEXT="H(Chengdu)=3;H(Hangzhao)H(lianrhang）二i4,由于Chongqing记录已放在HT[3〕中，He(ei已放在HT[8〕中，Nanjing已放在HT[14」中，因此.Chengdu,Hangzhao,Na二hang不能存放到哈希表HT中，这就发生了冲突.冲突并不是我们所希望的，而如何避免或减少冲突.则取决于哈希函数的构造。一个好的突。然而，这并非是件容易做到的事。哈希函数的构造，与关键字的长度、哈希表的大小、关键字的取值状况等诸多因素有关，而且有的因素事前难以确定。实践已经证明，冲突是很难避免的，核心问题在于一旦发生了冲突应如何进行处理。关于如何处理冲突问题，我们将在后面详细介绍。" ID="2">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000165" TITLE="8.4.2  哈希函数的构造方法" TYPE="Chapter">
        <fptr LogicalPageNum="165" PhysicalPageNum="165"/>
        <Paragraph CONTEXT="构造哈希函数的方法很多，这里仅介绍几种常用的方法。" ID="1">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="1.直接地址法对于关键字是整型数据时.则哈希函数H可直接利用关键字求得哈希地址。" ID="2">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="H（Ki）“aKi＋b（a，b为常数）" ID="3">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="在使用时，为了使哈希地址落在给定的存储空间内，可以调整a和b。例如N(KK;" ID="4">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="x-10," ID="5">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="直接地址法的特点：哈希函数简单，对于不同的关键字不会产生冲突。但在实际应用中，" ID="6">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="由于关键字值很少是连续的，用该方法产生的哈希表会造成空间的很大浪费，因此，这种方法" ID="7">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="很少使用。" ID="8">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="2.数字分析法数字分析法又称数字选择法。适用于下列场合：事先知道所有可能出现的键值，并且键值麦frt-t-省frbrlfhfr-fafilir4'r二t望七石妇Jk乡1Gr飞扩.oTf±r4#翻#循百业亡才含侧比毖年才今云杯＿考牛方落荞冬吞.未今杖甘左甲记心的位数比散列地址的位数多。第S章查找157H(K586,H(K617,H(K728,H(K899," ID="9">
          <fptr EndPN="00000166" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="3.平方取中法一个数的平方的中间几位与这个数的每一位都相关。利用这一特点，平方取中法以键值改11生11乍nrTI污刀七」盛，祖的.劝，匆翻石L二告.＿月导勺上有平怕.傀书苗曰下不丁国里宜反一由t匕月tj层4t才占irh1.了片,4参]ttvKE1平方的中间J’I.位作为散列地址。这一方法计算简单且不需要事先掌握键值的分布情况。为平方取中能扩大键值差别，所得散列地址比较均匀。例如，有下列10个键值Kl～KI。，使用习匡士.习勺d」在」二右件蛋且劝16台创的.泊】扫由石卜六n，只.1省吞】1吞，袭j篇匕占台翻妇石卜夕号】知习snn～00、.这里，键值K平方之后，取左起第3-4位作为散列地址。然而究竟取中间多少位，要看哈希" ID="10">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="表的地址范围。如果表的存储地址是00～99，则上述H（K）的值就是存储地址。如果计算出的H〔K）的值不落在哈希表的地址范围内，则需乘上一个比例因子，使其落在哈希表的地址范围内。" ID="11">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="4.除余法$Picture[00000166\00000166_new\0014.jpg]Picture$一个适当的不大于哈希表长度的正整数P，以键值Ki除以P所得的余数作为其散列地址，即H（Ki）二KkMODP／，这里MOD为取模运算，／竺1一一一一一一一25H(125125°097二28410H(310310%97二1908H(108108%97‘11?7H(27）二27%x7二2732H(132）二132°097=35!68H(168i68%97=7195H(95）二95°097二95i87H(187187%97=90123H(123123%97二2fi170H(170170%97二？3263H(263263°097=69347H(347347%97=56由此可见，我们计算出的散列地址的分布是比较好的，所以除余法是经常使用的。" ID="12">
          <fptr EndPN="00000167" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="5.折迭法折迭法是将关键字值分割成位数相同的JL段（最后一段的位数可少些），然后将它们的迭加和（舍去最高进位）作为哈希地址。" ID="13">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000167" TITLE="8.4.3  处理冲突的主要方法" TYPE="Chapter">
        <fptr LogicalPageNum="167" PhysicalPageNum="167"/>
        <Paragraph CONTEXT="发生冲突并不是我们所希望的，但实际上是难以避免的。“随我们构造的哈希函数晏些较均匀的，也只能做到减少冲突，但不可避免冲突，因此，如何处理冲突是一个至关重要的间题。" ID="1">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="处理冲突的方法有两大类：开放地址法和链的址法。" ID="2">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="一、开放地址法假i'HTCI]，其地址区间为［[0,M一‘突是指由关键字得到的哈希地址7i‘。目夏M一”的位置上已存有记录，则‘’处理冲突”就是为该关键字的记录寻找另一个“空”些哈希地址。在处理冲突的过程中，可能得到一个地址序列H.,HZHk.即若求得一个哈希地址H；发生冲突，则再求下一个地址H。若H：仍然冲突，再求得H3，依次英推,直Jrtk巾假定记录r;和r;的关键字分别为k；和k;，当H(kH(kt时，则发生冲突，如果r" ID="3">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="已装入HT[t］中，那么r;就不能再装人HT[t〕中.但只要HT中还有空位，总可以把r，存六第8章查找159或H、二（H(Kd)°oM,i=1,2,k(k&lt;M-1)其中：H(K）为哈希函数，M为哈希表的表长，d。为增量序列。" ID="4">
          <fptr EndPN="00000168" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="构造后继哈希地址序列常见的有三种探侧方法。" ID="5">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="1.线性探浏法假设哈希表空间为HT[0二M-11，哈希函数为H(KMOD为取模运算。线性探测解d(d;一＋j)MODM(j=1,2,3,…)线性探测法的基本思想是：如果在位置t上发生冲突，则从位置t+1开始，顺序查找哈希满，需要进行溢出处理。线性探测法很容易产生堆聚现象。所谓堆聚现象.就是存人哈希表的记录在表中连助达到真正散列存储的目的.于是又有下面两种改进的较为有效的方法。所谓堆聚现象.就是存人哈希表的记录在表中连成一止产生的争夺现象。按照线性探测法处理冲突，若生成" ID="6">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="2.二次探测法二次探侧法的基本思想是：生成后继的哈希地址不是连续的，而是跳跃式的，以便为后继" ID="7">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="记录留下空间而减少堆聚。设哈希表空间为HT[。二M-11，表长为M,二次探测解决冲突要求“下一个”地址公式为：dH(Kdz(djMODMdz_(d，一j，）M（）DM（j“1，2，…）lso数据结构号为8的位置，如图11(b)所示。若采用二次探测法，则该记录应该填人哈希表中序号为4的位置，如图8.11(c）所示。若采用随机数法，假设随机数列为9，一，则该记录应填人序号为0123456789101112｛1f1｛’I181.3小。IIIIIi" ID="8">
          <fptr EndPN="00000169" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)第四个记录插人HT前" ID="9">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="1IIII11813215917011II" ID="10">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="(b)用线性探i法插人HT后｝一｝一｝一｝一170IJ8132｛59一｝’iii(c)用二次探洲法插人HT后" ID="11">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="｝！叫｛I二引引二｝二｝二｝二｝二｝(d）用随机数法（随机数列s,）插人HT后图8.11用开放地址法处理冲突的三种探侧法示例假定以线性探侧法解决冲突，在哈希表HT中查找键值为K的结点，其算法如下：definem106" ID="12">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructhash" ID="13">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="{keycypekey;}closehash;int1inehasha(keytypeK,closehashHT[m第8章查找lfilH'f’｝一＿＿Z不一里生犷吮牡州3一一二二下，巨业立」4一二兰一二，一二份甩型立！＿“‘一｝一叫汁一今｝l9｝八｝" ID="14">
          <fptr EndPN="00000170" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="7n一二二一一8一一二二一一，一全一一，.，" ID="15">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="la～一一二下汁！49｝八！" ID="16">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="11一‘1一＿＿＿＿" ID="17">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="l2-I'I二十-38卜十今I12卜一一，｝25,I图S.12链地址法处理冲突的哈希表下面给出在链地址法的哈希表上实现查找、插人和删除的算法。" ID="18">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="才definem100typedefstructnodes162数据结构NULL是正确的：(2}P一＞key二＝K，这说明p所指结点正是待查结点，故返回P也是正确的.因此.可以用同一条返回语句return(p）完成两种情况下的结果回传。" ID="19">
          <fptr EndPN="00000171" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="2.插入我们知道，插人算法应包含查找功能，当在查找失败时实施新结点的插人操作。为简单起之后、同义词单链表的原表首结点（若存在的话）之前。擂人算法如下：擂人算法如下：{hashnTP，q;if(Searchtash(K,HTNULL){i=H(Kq=(hashnTP份)tnalloc(sizeaf(hashnTP;q一＞key/，生成新结点，／q一＞next=HT[i];" ID="20">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="HT[iq;，前插法链人新结点。／" ID="21">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝" ID="22">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="3.侧除咧除算法要区分三种不同情况：" ID="23">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)同义词单链表为空表；" ID="24">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)待删结点位于单链表的表首；" ID="25">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)其它情况。" ID="26">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="对每种情况处理完时使用一条退出语句return," ID="27">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="删除算法如下：voiddelet二hash(keytypeK,hashnTPHT[m{inti;hashn&quot;1&quot;P*p.*q;" ID="28">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="i二H(K" ID="29">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="if{HT[i〕二二NULL）return;;，空表则退出。／" ID="30">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="i-t'iY11.if(p一＞key二二kl/。表首结点为待脱结点，／{HT[ip一＞next;free(p)t" ID="31">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="retum" ID="32">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="33">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="while(p一＞next!=i1LL)第8章查找163" ID="34">
          <fptr EndPN="00000172" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="35">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="下面对哈希法做个简单分析。从哈希表的查找过程可知：(1}虽然哈希表在关键字与记录的存储位置之间建立了直接映象.但由于“冲突”的产生，长度作为衡量哈希表的查找效率的量度。" ID="36">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)查找过程中需和给定值进行比较的关键字的个数取决于下列三个因家：哈希函数、处理冲突的方法和哈希表的装填因子。所谓哈希表的装填因子。定义为哈希表的长度印在一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子突的可能性越大。1(1'～1乙、1-al查找失败时，其平均查找长度为告it十万吕二）1+要乙而在查找失败时，其平均查找长度为比-e一“上述公式反映了哈希法的一个重要特性，即平均查找长度是：的函数，而不是已装入表中" ID="37">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="i己录个数n的函数。164数据结构嘉酬琳阻胖查找成功的平均查找长度为：aa" ID="38">
          <fptr EndPN="00000173" StartPN="00000172"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="第8章查找155记录。这就是将要介绍的哈希表。" ID="1">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000173" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="173" PhysicalPageNum="173"/>
      <Paragraph CONTEXT="1.顺序查找法适用于什么样的存储结构？" ID="1">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="2.采用顺序查找法查找长度为n的线性表时，其平均查找长度等于什么？2.3。否可以采用折半查找。" ID="2">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="4。对于长度为n的线性表，若进行顺序查找，则时间复杂度为＿；若采用二分法查找，则时间复杂度为＿：若采用分块查找，则时间复杂度为＿。" ID="3">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="5.对线性表进行二分查找时，要求线性表必须具备什么条件？" ID="4">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="6。设有一个有序文件，其中各记录的关键字为｛1，2，3.4，5，6，7，8，9，10，11。12，13，14，15｝，当用二分查找算法查找关键字为2、10、17时，其比较次数分别是多少？" ID="5">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="7.给定有序表（016，087，155，188，220.465，505，508，511，586，656，670，700，766，897，9o8）用二分查找法在该表中查找586，试用图示表示出查找过程.的表，采用分块查找法.每块的最佳长度是＿。" ID="6">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="9.给定表（19，14，22，01，66，21，83，27，56，13，10）。" ID="7">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）试按元素在表中次序将它们依次擂人一棵初始时为空的二叉排序树，画出插人后的二叉排序树；" ID="8">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="10.什么叫哈希法？在哈希法中处理冲突有哪些常用的方法？第8章查找1fi5" ID="9">
        <fptr EndPN="00000174" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="14.选取哈希函数H(K3K%11，用开放地址法处理冲突，dj＝H（K）。d。＝〔di一，＋7K写10＋1）％11，（1＝2，a，一）。试在。～la的散列地址空间中，对关键字集合｛22,41,53,46,30,13,O1,fi7｝构造哈希表，并求出等概&quot;况下查找成功的平均查找长度." ID="10">
        <fptr EndPN="00000174" StartPN="00000174"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000174" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="174" PhysicalPageNum="174"/>
      <Paragraph CONTEXT="一、内容：二分查找法与哈希表二、目的：掌握二分查找算法与哈希表的构造方法.三、题目" ID="1">
        <fptr EndPN="00000174" StartPN="00000174"/>
      </Paragraph>
      <Paragraph CONTEXT="1.假设有一组记录的关键字值按升序排列：9,12,14,22,35,38,42,44,47,48,58,60,75,7a,sz，若cl)采用二分查找法分别查找关键字值为$o和15的记录；cz）插人关键字值为50的记录，且插入后仍保持升序。" ID="2">
        <fptr EndPN="00000174" StartPN="00000174"/>
      </Paragraph>
      <Paragraph CONTEXT="2.设有键值序列：53,17,12,fi1,970,87,25,63.46,14,59,67,75H(KK%17采用开放地址法中的二次探测法解决冲突，试建立哈希表，并查找键值为70的记录位置." ID="3">
        <fptr EndPN="00000174" StartPN="00000174"/>
      </Paragraph>
      <Paragraph CONTEXT="四、要求166数据结构｛排·鬓｛牛藻认桨欺一3)#f(4)cz)卜：（垂矍芝篷童量芝矍霆：矍置置哭笙逻笠彗在数据处理中，排序是一种最基本的重要运算，是计算机工作者重点研究的课题之一。排实现快速查找。排序在很多领域中有广泛的应用，为了提高计算机的工作效率.人们提出了各种各样的排序方法和算法。这些算法的设计与实现充分体现出某些重要原则和高超技巧。因此，本章内容是十分重要的。" ID="4">
        <fptr EndPN="00000175" StartPN="00000174"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="f念斗气铆为气气‘为如勺为气如今今匆细如白冲。饰出争巴沐感沐。勺气御如气勺气热气气御电它‘二二山‘对＿二＿，、二＿、、二二.＿：、少" ID="1">
      <fptr EndPN="00000150" StartPN="00000150"/>
    </Paragraph>
    <Paragraph CONTEXT="老今早索品’、土夕双侄衣即垠律宣拭户一犷宜认八J户分状重执哈布矛哎表查找。老" ID="2">
      <fptr EndPN="00000150" StartPN="00000150"/>
    </Paragraph>
    <Paragraph CONTEXT="奋本章要求：（‘）理解各种查找方法的特性；(2）掌握顺序查找、二分查找和；" ID="3">
      <fptr EndPN="00000150" StartPN="00000150"/>
    </Paragraph>
    <Paragraph CONTEXT="爹分块查找的基本算法；C3’重点掌握构造哈希函数的方法和解决哈希冲突的基是" ID="4">
      <fptr EndPN="00000150" StartPN="00000150"/>
    </Paragraph>
    <Paragraph CONTEXT="幸＊牵仁？仁‘今‘仁，色牢今索今罕峥蜂峪坛怜悔气仁罕仁攀色＄食，仁‘食索七军套索仁常仁.怜纷娜份悔坛纷勺气研在很多实际应用中，查找是一种常用的基本操作运算.所谓查找又称检索，是指在某种数堪姑灼由夕心小右只县中』‘征的左坐占J红洲备劝.侧宙爪益络心卜少乙左吐；配，吞士六动.』匕刊妥由丫卜＿又尺翩，侧脸魂必、之卜｝构中找出满足给定条件的结点。若找到满足给定条件的结点，则查找成功；否则查找失例如，在职工档案表中查找某职工的学历；在工资表中查找某职工的基本工资；在图书馆旧文件中查找某种图书等。有多种查找算法，但查找算法的优劣对查找过程和效率影响败。" ID="5">
      <fptr EndPN="00000150" StartPN="00000150"/>
    </Paragraph>
    <Paragraph CONTEXT="的书目文件中查找某种图书等。" ID="6">
      <fptr EndPN="00000150" StartPN="00000150"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000175" TITLE="第9章  排序" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000175" TITLE="9.1  概述" TYPE="Chapter">
      <fptr LogicalPageNum="175" PhysicalPageNum="175"/>
      <Paragraph CONTEXT="排序又称为分类，意指将一批杂乱无章的数据序列重新安排成有序序列。排序的目的在" ID="1">
        <fptr EndPN="00000175" StartPN="00000175"/>
      </Paragraph>
      <Paragraph CONTEXT="排序是很多数据结构上的一种重要运算，其功能是将一组任意排列的数据元素（或记录）" ID="2">
        <fptr EndPN="00000175" StartPN="00000175"/>
      </Paragraph>
      <Paragraph CONTEXT="为了便于讨论，首先需要对排序下一个确切定义。" ID="3">
        <fptr EndPN="00000175" StartPN="00000175"/>
      </Paragraph>
      <Paragraph CONTEXT="{R】，Rz，一，Rn}其相应的键值序列为第9章排序I67稳定的。按照排序过程所涉及的存储设备的不同，排序可分为内部排序和外部排序两大类。内部排序是指在排序的整个过程中，全部数据存放在计算机的内部存储器〔主存）中，并且在内部存储器中调整记录间的相对位置，外部排序是指在排序过程中，数据的主要部分存放在外部存储器中.借助于内部存储器逐步调整记录间的相对位置。本章重点介绍各种典型的内部排序方" ID="4">
        <fptr EndPN="00000176" StartPN="00000175"/>
      </Paragraph>
      <Paragraph CONTEXT="内部排序的方法很多，主要分为插人排序、交换排序、选择排序和归并排序等四类。" ID="5">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="比较各种排序算法的优劣，还要分析算法的时间复杂度和所需附加空间的大小。" ID="6">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="在没有特别说明时，本章讨论的各种排序方法均为升序排序。并假定要排序的记与defineM11SIZE100为了并假定要排序的记录存放typedeFstructrecord{intkeys／二关链字域.／anytypedata;，其它数据城“／" ID="7">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000176" TITLE="9.2  插入排序" TYPE="Chapter">
      <fptr LogicalPageNum="176" PhysicalPageNum="176"/>
        <div ORDERLABEL="00000176" TITLE="9.2.1  直接插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="176" PhysicalPageNum="176"/>
        <Paragraph CONTEXT="直接插人排序是一种最简单的排序方法，它的基本思想是依次将每个记录插人到一个有" ID="1">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="序的子序列中去。168数据结构while(r[jkey&gt;r[0I.key){rCi+1〕二：GJ，i一一，｝" ID="2">
          <fptr EndPN="00000177" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="心+11-迁叼。）for(i=1;in;i十十）" ID="3">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="printf%6dr[ikey};$Picture[00000177\00000177_new\0010.jpg]Picture$fib72757780878892961图9.1直接插人排序过程" ID="4">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="调用上述函数的主函数如下：" ID="5">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="main(){intn=10,i;sglistsafor(i=1，应＜=n;i" ID="6">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="scanfOOd二，＆s[iI.keyinsertsort(s,n)｝执行本程序及运行结果如下：75$7s89288sl77968072,161687275778087889296直接插人排序算法是稳定的。该算法包含两层循环，外层循环执行n-i次，一般情况下内层循环平均比较次数的数量级为O(n)，所以算法总的时间复杂度为O(nZ}。从空间来看，它只需占用一个记录的附加空间，故空间复杂度为O(1" ID="7">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000177" TITLE="9.2.2  折半插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
        <Paragraph CONTEXT="第9章排序lb9置，然后插人。这种方法就是折半插人排序。折半插人排序算法如下：voidbinasort(sglistr,intn)(inti,j,mid,1,h;fox(i=2;in;i){r仁dr[i]s" ID="1">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="1二l;h二i-1;" ID="2">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="while(1＜二h)" ID="3">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="{midi+h2;" ID="4">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="if{r[01,key&lt;r[rnidI.key)h=mid-1:" ID="5">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="else1=mid十1;" ID="6">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=i-1,j＞二1,j一一）r口＋1〕牛心口，" ID="8">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="r[11=r[OJ;" ID="9">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="10">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="｝折半插人排序算法是稳定的。该算法中关键字的比较次数由于采用了折半查找而大为减故折半擂人排序的时间复杂度仍" ID="11">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000178" TITLE="9.2.3  希尔排序" TYPE="Chapter">
        <fptr LogicalPageNum="178" PhysicalPageNum="178"/>
        <Paragraph CONTEXT="希尔排序（Shellsort）又称为缩小增量排序方法.其基本思想是：将记录按下标的增量d分组，对每组记录使用插人排序方法进行排序，随着增量逐渐减小，所分成的组包含的记录越来越多，直到增量的值减小到1时，所有记录合成为一组，构成一组有序记录，则完成排序.具体做法是：先取一个正整数d,(dn)，将所有距离为d,的倍数的记录作为一组.然后在各组内进行插人排序；再取dz(dz&lt;dl)，重复上述分组和排序操作，直到取d;二1(i）l)，即所有记录成为一个组为止。一般选d，约为n/2,d2为d，／2，d：＝d：／2，…，d‘＝1." ID="1">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="例9.2已知键值序列《50,17,51,90,89,75,65,42,54,59,61,67,76,70,94}，试采用希" ID="2">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="尔排序法作升序排序。" ID="3">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="希尔排序的过程如图9.2所示。" ID="4">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="希尔排序算法如下：174数据结构" ID="5">
          <fptr EndPN="00000179" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="r［j＋d〕弃r〔0〕。" ID="6">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="J，J-d;" ID="7">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="8">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="elsej=0;" ID="9">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="争" ID="10">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="d=dr2;" ID="11">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="｝for(i°1;i＜二。，iprintf（二％fidr[ikeyprintf{&quot;fin;｝" ID="12">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="性攫纂鬓摹攀攀到SD17SI9089756S4254596167767094】初始序列：第1次d,S:第Z次，仁写攀里里车车里二纂华剑594" ID="13">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="第2次结果：50175142545961价76706590朋乃94第’次砂翘一笔里璧一里，苹理挥，马鬓军－皇一竿－望止1』4第」次结果：50175142弘5，61曰砧7076乃89卯9斗第月次份1：书’了肚份二’之辛.气，甲.荤孚＿二’户草…甲：30严排序结果：1742505154596165价707576899（）94图9.2希尔排序过程调用上述函数的主函数为。《intn二15，1冬第s章排序171" ID="15">
          <fptr EndPN="00000180" StartPN="00000179"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="插人排序的基本思想是：每步将一个待排序的记录按其关键字的大小，插人到前面已经排好序的序列中的适当位置，直到全部记录插人完毕为止。常用的擂人排序方法有：直接插人排序，折半插人排序、希尔排序等。" ID="1">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000180" TITLE="9.3  交换排序" TYPE="Chapter">
      <fptr LogicalPageNum="180" PhysicalPageNum="180"/>
        <div ORDERLABEL="00000180" TITLE="9.3.1  冒泡排序" TYPE="Chapter">
        <fptr LogicalPageNum="180" PhysicalPageNum="180"/>
        <Paragraph CONTEXT="冒泡排序（bubblesort〕就如同水中的气泡向上冒出一样，移到序列的首部。整个算法是从最下面的记录开始，对每两个相邻的键值进行比较，且使键值较小的记录与键值较大的记录交换位置，使得经过一趟冒泡排序后，键值最小的记录到达最顶端。接着，再在剩下的记录中172数据结构从图9.3可知，只需经过六趟冒泡即可排好序。因此，有时不需经过n-1趟冒泡就可排定。" ID="1">
          <fptr EndPN="00000181" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="冒泡排序算法如下：" ID="2">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="voidbubblesort(sglistr,intn)" ID="3">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="{inti,j;" ID="4">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="far(i二1;in-1;i" ID="5">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=n:ji+1;j一一）" ID="6">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Picture URL="00000181\00000181_new\0010.jpg">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Picture>
        <Paragraph CONTEXT="printfsortresu)t=\n" ID="7">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=1;in:i十十）" ID="8">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="printf0/a6dr[ikey)" ID="9">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="Printf（”＼n，，）；" ID="10">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="｝冒泡排序算法是稳定的，该算法的时间复杂度为O(nz" ID="11">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000181" TITLE="9.3.2  快速排序" TYPE="Chapter">
        <fptr LogicalPageNum="181" PhysicalPageNum="181"/>
        <Paragraph CONTEXT="快速排序是冒泡排序的一种改进，又称为分区交换排序。快速排序的基本思想是：在待排序的n个记录中任取一个记录（通常取第一个记录），以该记录的键值作为基准.又称控制字，将所有记录分为两组，使得第一组中各记录的键值均小于控制字，第二组中各记录的键值均大于控制字。然后把该控制字记录就排在这两组的中间位" ID="1">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="置〔最终位置），这称为一趟快速排序。对所分成的两组分别重复上述过程.直到所有记录都排第9章排序173）万互砚8" ID="2">
          <fptr EndPN="00000182" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="(0)" ID="3">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="r[01=65" ID="4">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)" ID="5">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)(3}{4)" ID="6">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)[45562042jb5[4384721562042］65［958420〕45［56〕65［95842042生556肠［9584" ID="7">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="2042455665728495" ID="8">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="快速排序的算法如下：vaidquick，ort（sq［istr，ints，intt）／二把蛇习至汇门的记录进行快速排序二／Iinti＝5r，：仁03＝走司；" ID="9">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="祠山e（Kj）" ID="10">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="11">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="wh漩（j＞1＆＆迁。〕.key＜r〕］，key）j一一；" ID="12">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="汪（1芍〕" ID="13">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="丈：〔11二心〕；计＋，｝174数据结构含" ID="14">
          <fptr EndPN="00000183" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="调用上述函数的主函数：" ID="15">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="nvan()" ID="16">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="{inti,n;" ID="17">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="sgtista;" ID="18">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="scan{d&amp;nfor(i=1;iC=n;i十十）scan{%d&quot;.&amp;a[iI.key);quicksort(a,1,n" ID="19">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="print{nfor(i=1;iC=n;i＋一）print{(6da[iI.keyprint{n;" ID="20">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="）从平均时间性能来看，快速排序最佳，其时间复杂度为UCnlog2n}。但在最坏情况下，即乎是排好序的输人序列，该算法的效率很低，近似为p(nz}。另外，该算法对于较大的n对几乎是排好序的输人序列，该算法的效率很低，近似为0（nz）。另外，该算法对于较大的n值，效果较好。在对于记录键值无序时的多种排序方法中，快速排序被认为是一种最好的排序方法。应当指出，快速排序是不稳定的。161715O1215②18〔12」15.［15①〕1617〔18］" ID="21">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="15.［15①］161715②1501617从上例可以看出，快速排序是不稳定的。" ID="22">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="所谓交换，是指根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置。交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动，直到全部满足顺序要求为止。本节将介绍两种交换排序方法：冒抱排序和快速排序。" ID="1">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000183" TITLE="9.4  选择排序" TYPE="Chapter">
      <fptr LogicalPageNum="183" PhysicalPageNum="183"/>
        <div ORDERLABEL="00000183" TITLE="9.4.1  直接选择排序" TYPE="Chapter">
        <fptr LogicalPageNum="183" PhysicalPageNum="183"/>
        <Paragraph CONTEXT="第9章排序175" ID="1">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=1;in-1;i" ID="2">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="{k=i;" ID="3">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=i+1;jn;j十十）" ID="4">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Picture URL="00000184\00000184_new\0005.jpg">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Picture>
        <Paragraph CONTEXT="1" ID="5">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="printfsortresultn" ID="6">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="for{i=1;in;i" ID="7">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="printf6dr[iI.key" ID="8">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="少intf（”＼n.）；" ID="9">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="｝$Picture[00000184\00000184_new\0012.jpg]Picture$关于直接选择排序算法，由于该算法的主要部分为二重for循环，很显然，其时间复杂度）（矿）。直接选择排序是稳定的。" ID="10">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="为U(nz)a" ID="11">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000184" TITLE="9.4.2  堆排序" TYPE="Chapter">
        <fptr LogicalPageNum="184" PhysicalPageNum="184"/>
        <Paragraph CONTEXT="从直接选择排序的过程可以看出，许多比较是多次重复进行的，即是说，没有把前一次的比较结果保留下来，这无疑降低了排序的效率。而树形选择排序能克服这一缺点。树形选择排序的基本思想是：首先对n个记录的键值进行两两比较。然后在其中［要价自较小者之间再进行两两比较。如此反复，直至选出最小键值的记录为止。可用一棵树来表示这一排序过程。树中的n个叶结点代表待排序记录的键值；叶结点上面一层是叶结点两两比17s数据结构$Picture[00000185\00000185_new\0002.jpg]Picture$$Picture[00000185\00000185_new\0003.jpg]Picture$$Picture[00000185\00000185_new\0006.jpg]Picture$树形选择排序比直接选择排序的速度有了较大提高.但要增加n-1结点的存储空间以保f面的比较结果。另外，排序的结果还需要另外开辟存储区，因此，其空间效率较低。" ID="1">
          <fptr EndPN="00000185" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="存前面的比较结果。堆排序是树形选择排序的一种改进。乙Ik;簇k" ID="2">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="tk;簇ks1+i$Picture[00000185\00000185_new\0016.jpg]Picture$堆可看成是一棵以k,为根的完全二叉树。由定义，在这棵二叉树中.任一结点的值都不大于它的两个孩子的值（若存在孩子的话）。因此，在一个堆中，k,（即二又树的根）是堆中最小的元素，并且，这样的二叉树的任一子树本身也是一个堆.例如，键值序列（15,24,26,58,94,若在输出堆顶的最小键值之后，使得剩余的n-1个键值又n第9章排序177堆，此时可能会反复调整某些结点，直到i=1为止，则初建堆完成。素上移到堆顶和恢复成堆的步骤，直到全部元素输出完为止。" ID="3">
          <fptr EndPN="00000186" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="例，.6设有9个记录的键值分别为" ID="4">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="因为经过第一" ID="5">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="只要重复执行输出堆顶元素、堆尾元" ID="6">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="k,kzk3kak;k6k,k8k9574038111332487525试对它们进行堆排序。先依键值序列建一棵完全二叉树。初建堆。因为n-9，故从‘一L9-2」一4开始。ke，故不用调整，如图9.8(a)所示。当i二3时，其左、右孩子分别为k6,k,，因玩＞k6f3&lt;k7s故应进行调整，如图9.8(b)所示。当i=2时，其左、右孩子分别为14.ks，因为kz&gt;k，kzKrfrr别比i@Qc_inE4EIaal1f杯石子若各匕1_t'1匕望匕不玄与乙hLI.Wrr.十brllL尹-=风，故应进行调整，如图9.8〔c）所示。最后1＝1，其左、右孩子为kk’3" ID="7">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="52，因为kl＞kkl＞k‘3，故要进行调整，最后形成堆，如图9.5（d）所示。（a）伪｝（c）（d）" ID="8">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="图9.8初建堆过程示例ins数据结构irCi］二" ID="9">
          <fptr EndPN="00000187" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="i～;1" ID="10">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="j-2，i;" ID="11">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="12">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="｝ri（片t:/*rk]放人适当位置，／全" ID="13">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）输出ll,40上移，恢复堆（(2）输出13,7S上移，恢复堆{3）输出25,48上移，恢复堆（(2)输出32，48上移，恢复堆荔" ID="14">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="－－－－争{5）输出38,57上移，恢复堆（(6)输出40,75上移，恢复堆户" ID="15">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="一一扣" ID="16">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Picture URL="00000187\00000187_new\0018.jpg">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Picture>
        <Picture URL="00000187\00000187_new\0019.jpg">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Picture>
        <Picture URL="00000187\00000187_new\0020.jpg">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Picture>
        <Paragraph CONTEXT="(7）输出48,7S上移.恢复堆（8}输出57,7S上移，恢复堆《9}最后输出7S俨一尹⑥一，卜" ID="17">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="下面给出堆排序算法如下：voidheapsort&lt;sglistr,intn)$Picture[00000187\00000187_new\0027.jpg]Picture${inti$Picture[00000187\00000187_new\0029.jpg]Picture$$Picture[00000187\00000187_new\0030.jpg]Picture$第9章引卜序179for(i=nj2;i&gt;，1:i一一）91ft(r,L，心、／‘从第可2个记录开始筛选.完成初建堆。／for(i=n;i2:i一一〕{printf5dr[lkey／。j出堆顶元求r堆顶与堆尾元素对换，／" ID="18">
          <fptr EndPN="00000188" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="书／" ID="19">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="，printf5dr[11,key李" ID="20">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="而heapsart中对sift的调用次数的数量级为n.故整个堆排序的时间复杂度为（a(nlagn7,还应指出，堆排序是不稳定的。例如，设有一组键值{8,9,6',3,6Q,12经排序后的结果为｛3,6。,68,9,12}，其排序过程如下：" ID="21">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="1.初建堆$Picture[00000188\00000188_new\0018.jpg]Picture$$Picture[00000188\00000188_new\0019.jpg]Picture$$Picture[00000188\00000188_new\0020.jpg]Picture$$Picture[00000188\00000188_new\0021.jpg]Picture$一一，一－－卜" ID="22">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）愉出3,12上移，恢复堆（输出612上移，恢复堆" ID="23">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="矛－" ID="24">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)出6.9上移，恢复堆(4)'出8,12上移，恢复堆$Picture[00000188\00000188_new\0027.jpg]Picture$$Picture[00000188\00000188_new\0028.jpg]Picture$$Picture[00000188\00000188_new\0029.jpg]Picture$丫、一了、：幸了一、扩" ID="25">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="选择排序的基本思想是：每步从待排序的记录中选出关键字值最小的记录，顺序放在已排" ID="1">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000188" TITLE="9.5  归并排序" TYPE="Chapter">
      <fptr LogicalPageNum="188" PhysicalPageNum="188"/>
        <div ORDERLABEL="00000189" TITLE="9.5.1  两个有序序列的合并" TYPE="Chapter">
        <fptr LogicalPageNum="189" PhysicalPageNum="189"/>
        <Paragraph CONTEXT="设有两个有序子序列中的记录分别记作为as，‘和,ti，a，将这两个有序子序列进行合并，从而形成第三个有序序列凡，…，凡.其基本思想是：设i.j分别表示两个子序列中记录的下标.c1)当i&lt;m，且j（n时，比较a[i]和a口〕键值的大小.将其中键值较小的记录取出并送入R[k]，同时修改i或J值；" ID="1">
          <fptr EndPN="00000189" StartPN="00000189"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)当ism或j＞n时，将另一子序列中的剩余部分抄到第三个序列的末尾。算法如下：voidmerge{sglista,sglistR,1RL5.intm.intn)／‘将两个有序序列a…,、和‘＋.，…，氏合并成一个有序序列凡，…，风、／" ID="2">
          <fptr EndPN="00000189" StartPN="00000189"/>
        </Paragraph>
        <Paragraph CONTEXT="亏inti.k.1;i=s;k=s;j=m+1,while{(i&lt;二m）＆乙（i＜＝n））;RLk]二aCiJ十＋；｝" ID="3">
          <fptr EndPN="00000189" StartPN="00000189"/>
        </Paragraph>
        <Paragraph CONTEXT="‘十＋；，nhile{i＜二tn)盔处k］1］；1＋＋。k＋＋；｝while(j＜二n)（处k］“a口］；j＋＋；k＋＋；｝争该算法的时间复杂度为Cn-s+1)e" ID="4">
          <fptr EndPN="00000189" StartPN="00000189"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000189" TITLE="9.5.2  归并排序" TYPE="Chapter">
        <fptr LogicalPageNum="189" PhysicalPageNum="189"/>
        <Paragraph CONTEXT="所谓归并排序是将两个或两个以上有序序列合并成一个有序序列的过程。归并排序的基本思想：若序列有n个记录，可把它看成n个子序列，每个子序列中只包括第9章排序181初始序列：75876892886177968a72h=1：[751[8刀.[bs丁[921gas]r611r771r46I8a]r7z、一‘、＝一7一～－丫＝一一、.二一，一、‘一气产＝－J、es‘一r‘－‘h=2：75-871[6一四b-881～[77V一四[72801h=4；迫生7587921[617788一兰回[72801h一“：68-75一一T7-87,88＿＿92一」'61[72一鲤图9.1。归并排序的过程利用前面介绍的合并两个有序序列的算法merge，可写出执行一趟归并排序的算法repass。该算法把数组a中长度各为h的相邻两个子序列合并成长度为2h的一个子序mergePass。该算法把数组a中长度各为h的相邻两，" ID="1">
          <fptr EndPN="00000190" StartPN="00000189"/>
        </Paragraph>
        <Paragraph CONTEXT="列，把归并的结果存人数组b，n是a中记录的总个数。voidmergepa吕5（sqlis咤a，闪115‘b，int。，inth）悦inti，1；乏‘1‘" ID="2">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="whjle（1＜二n-2二h＋1）Im以ge（a山，1，1＋h-1，1＋2，h-1）；1＋＝2oh；｝if（1十h-1＜n）／，一个长度为h的部分与一个长度小于h的部分合并，／" ID="3">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="m。电e（a，b，1.1＋卜一1，n）；dseZ，只剩下一个长度不大于h的部分，将其复制到b中、／fo：（：！1；t＜一n；t＋＋）卜〔t〕二a［t］；全" ID="4">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="下面给出主体归并排序算法：" ID="5">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="voidme了9osort（Sqlista，intn）" ID="6">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="｛inth＝1番" ID="7">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="w卜1掩（h＜n）" ID="8">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="《merge那55（a，h.n，h）；" ID="9">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="h劳，2；" ID="10">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="rn七rgeP朋，（b，a，刀，h）书" ID="11">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="h.，2；｝｝182数据结构" ID="12">
          <fptr EndPN="00000191" StartPN="00000190"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="tsa数据结构列组成。归并排序就是将这些有序的子序列进行合并，从而得到有序的序列。因此，归并排序的基础是合并." ID="1">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000191" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="191" PhysicalPageNum="191"/>
      <Paragraph CONTEXT="i.已知键值序列｛70,83,100,65,1x,32,7,9)，试采用直接插入排序法对其进行升序排序时每一趟的结果。" ID="1">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="2.已知键值序列X503,17,512,908.170.897,275,653,426.154,509,fi12,677,765,703,94}，采用希尔排序法（d8)对其进行升序排序，并给出每一趟结果。" ID="2">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对于给定的一组键值｛83,40,63,13.84,35,96.57,39,79,61.15}，采用冒泡排序法、快速排序法进行排序.并画出各趟结果。" ID="3">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="4。利用第3题中给定的键值序列，试采用直接选择排序法、堆排序法进行上升排序，并分" ID="4">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="5.已知键值序列（10,18,4,3.6,12,1,9,18,8？，请给出采用归并排序法对该序列做升序排序时每一趟的结果。" ID="5">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="6.举例说明本章介绍的各种排序方法中哪些是不稳定的？" ID="6">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="7.相对于树形选择排序来说，直接选择排序和堆排序有何优缺点？" ID="7">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
      <Paragraph CONTEXT="8.试比较直接插人排序、直接选择排序、快速排序、堆排序、归并排序的时间性能。" ID="8">
        <fptr EndPN="00000191" StartPN="00000191"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000191" TITLE="实习参考题" TYPE="Chapter">
      <fptr LogicalPageNum="191" PhysicalPageNum="191"/>
      <Paragraph CONTEXT="第9章排序183" ID="1">
        <fptr EndPN="00000192" StartPN="00000192"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="00000192" TITLE="第10章  文件" TYPE="Chapter">
    <fptr LogicalPageNum="192" PhysicalPageNum="192"/>
      <div ORDERLABEL="00000192" TITLE="10.1  文件的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="192" PhysicalPageNum="192"/>
        <div ORDERLABEL="00000192" TITLE="10.1.1  文件及其基本运算" TYPE="Chapter">
        <fptr LogicalPageNum="192" PhysicalPageNum="192"/>
        <Paragraph CONTEXT="文件也是一种数据结构，它是由性质相同的记录组成的集合。记录是文件中可存取的基本数据单位，它由若干数据项组成。" ID="1">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="数据项是文件中最基本的不可再分割的最小数据单位。数据项有时也称字段或域，是用来描述记录的某种属性。关键字是指能够区别文件中各记录的域。把能唯一标识各个记录的关键字称为主关键184数据结构文件的基本运算有两类：检索和修改。" ID="2">
          <fptr EndPN="00000193" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="文件的检索有三种方式：" ID="3">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)顺序存取：依次顺序存取一个逻辑记录。" ID="4">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(2〕直接存取：直接存取第i个逻辑记录。" ID="5">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)按关键字存取：存取键值等于给定值的记录。" ID="6">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="文件的修改有三种运算：" ID="7">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)插入运算：将一个新职工的记录插人到职工文件中。" ID="8">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)删除运算：将一个职工的记录从职工文件中删除。" ID="9">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)更新运算：修改某职工记录一些数据项的内容。" ID="10">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000193" TITLE="10.1.2  外存储器简介" TYPE="Chapter">
        <fptr LogicalPageNum="193" PhysicalPageNum="193"/>
        <Paragraph CONTEXT="文件在存储介质（如磁盘和磁带）上的实际组织方式称为文件的存储结构或物理结构。为了橄明寸件的拍坦古律＿牛普葱夺翔一下琳撰左祛哭和猫舟右祛哭的右弟匆牛p端。磁带是一种启停设备，为适应启动时的加速和停止时的滑动，磁带上块与块之间留有间隙。间隙是一段空白区，不存放信息。磁带存取信息的示意图如图10.1所示。一个信息块就是一个物理记录。通常一个信息块可存放多个逻辑记录。" ID="1">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="磁带存储器是一种顺序存储设备.其优点是存储容量大.它的主要缺点是读写速度慢。第9章排序185" ID="2">
          <fptr EndPN="00000194" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)寻找盘块号：使磁头定位到要读写的扇段，即要读写的物理记录。" ID="3">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Picture URL="00000194\00000194_new\0004.jpg">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Picture>
        <Picture URL="00000194\00000194_new\0005.jpg">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Picture>
        <Paragraph CONTEXT="磁盘示意图如图10.2所示。图10.1磁带存取信息示意图图10.2磁盘示意图与磁带存储器相比，磁盘存储器的优点是存取速度快，既适应于顺序存取，又适应于随机存取。文件在外存储器上的组织结构主要有三种：顺序文件、散列文件、索引文件。下面分别做" ID="4">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000194" TITLE="10.2  顺序文件" TYPE="Chapter">
      <fptr LogicalPageNum="194" PhysicalPageNum="194"/>
      <Paragraph CONTEXT="顺序文件是文件的一种常见的组织形式。在顺序文件中，所有逻辑记录在存储介质上的实际顺序与它们进人存储器的顺序相一致。顺序文件适宜顺序存取和成批处理。顺序文件特别适应于磁带存储器，也适应于磁盘存储器。顺序文件的检索方法如下：186数据结构" ID="1">
        <fptr EndPN="00000195" StartPN="00000194"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000195" TITLE="10.3  散列文件" TYPE="Chapter">
      <fptr LogicalPageNum="195" PhysicalPageNum="195"/>
      <Paragraph CONTEXT="散列文件是指用哈希法组织的文件。对磁盘文件来说，记录通常是成组存放的.每个存储单位存放若千个记录，这种存储单位称为桶。桶既可以磁道为单位，也可以盘块为单位。按桶寻址一次I操作可把一个桶的全部记录读人到内存缓冲区，或从内存缓冲区写人外存。H{K）把关键字值转换为桶地址。rn个互为同义词的记录可存放在同一地址的桶中。当第m通常采用拉链法解袂滋出问题。当发生“.出”时，需要将第m1个同义词存放到另一个桶中，通常称此桶为“滋出桶”.i+h（欣前.n/卜FIVi用XlrisEr捅'kt&quot;耸t西&quot;弓廿FN点石iiiftE-ihHiG7i'iTal田手些决于妇相对地，称前二个同义词存放的桶为“基桶”。链接。当在基桶中没有找到待查记录时，则顺指针所指到溢出桶查找。" ID="1">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="例如，某文件有18个记录，其键值分r为：292,123,077,930,604,184,519,269,022,083," ID="2">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="6-ur4e、二lro、，o/76r引昆扮bsf弋'L左A'v+参幻firr1JInZhT" ID="3">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="数H（k即）二key％7。" ID="4">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="捅编号" ID="5">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="基桶滋出桶" ID="6">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="盛巨一八”’" ID="7">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="0" ID="8">
        <fptr EndPN="00000195" StartPN="00000195"/>
      </Paragraph>
      <Paragraph CONTEXT="I3456第s章排序187" ID="9">
        <fptr EndPN="00000196" StartPN="00000195"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000196" TITLE="10.4  索引文件" TYPE="Chapter">
      <fptr LogicalPageNum="196" PhysicalPageNum="196"/>
      <Paragraph CONTEXT="索引文件是由索引表和主文件两部分构成.索引表是一张指示逻辑记录的键值与物理记录存储地址（指针）对应关系的表.其形式如下：表中为关键字值.R。表示关键字值为k;的记录，A(Rw）为记录R;的存储地址。为索引表，其中的每个偶对（icA(R)）则称为索引项。具有索引的文件称为索引文件.索引文件的存储分为两个区：索引区和记录区。主文件" ID="1">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="口矛玄公‘白书有毒卜不专习毕己.月撼钊J月峥己！r以去七;胃.善翻合at,习匕柱妥场-ttik8dftr/勿t;口后丢翻6a巴白rx" ID="2">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="建立时，系统自动建立索引表，其索引项是按记录输人的先后次序排列的。连" ID="3">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="后，再对索引表按键值由小到大排序，使索引项按键值有序，如图10.4所示。" ID="4">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Picture URL="00000196\00000196_new\0011.jpg">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Picture>
      <Paragraph CONTEXT="工号姓名一键值地址键值地址" ID="5">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="0029王平0002120400291201" ID="6">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="0005马力0005120300051203" ID="7">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="0042朱光oal71210000212oa" ID="8">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="0038林昌0029120100381205oal周庆ooa31209oal71210I88数据结构建立一个索引项，又称索引块，用以登记该索引块内最大的关键字值和该块的地址（块号），这" ID="9">
        <fptr EndPN="00000197" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="引块，确定记录的地址，最后读取记录，如图10.s所示。图ia.s非稠密索引查找表的结构" ID="10">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Picture URL="00000197\00000197_new\0008.jpg">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Picture>
      <Picture URL="00000197\00000197_new\0009.jpg">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Picture>
    </div>
      <div ORDERLABEL="00000197" TITLE="10.5  ISAM文件" TYPE="Chapter">
      <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
      <Picture URL="00000197\00000197_new\0001.jpg">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Picture>
      <Paragraph CONTEXT="计的索引顺序文件组织方式。ISAM文件由主索引、柱面索引、磁道索引和主文件组成。文件的记录在同一盘组存放时，应尽量先放在一个柱面上，然后再顺序存放在相邻的柱面上。在同每个柱面建立一个磁道索引，每个磁道索引项由两部分组成：基本索引项和锐出索引项，如图10.6所示。第9章排序189录所在柱面的磁道索引，最后从磁道索引找到记录所在磁道的第一个记录的位置，由此出发在该磁道上进行顺序查找，直到找到为止；反之，若找遍该磁道都没找到，则说明该文件中无此记磁道索引月" ID="1">
        <fptr EndPN="00000198" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="在插人记录时，要发生溢出时，每个柱面上还开辟一个滋出区，磁道索引项中有溢出索引" ID="2">
        <fptr EndPN="00000198" StartPN="00000198"/>
      </Paragraph>
      <Paragraph CONTEXT="项。由于ISAM文件中，记录是按关键字顺序存放的，则在插人记录时，需移动记录并将同一" ID="3">
        <fptr EndPN="00000198" StartPN="00000198"/>
      </Paragraph>
      <Paragraph CONTEXT="磁道上最末一个记录移至溢出区，同时要修改磁道索引。" ID="4">
        <fptr EndPN="00000198" StartPN="00000198"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000198" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="198" PhysicalPageNum="198"/>
      <Paragraph CONTEXT="190数据结构" ID="1">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="4.什么是索文件和索引顺序文件？什么是稠密索引和非稠密索弓I？各自特点是什么？" ID="2">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="5.简述磁带和磁盘存储信息的特点是什么？" ID="3">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="5.6。" ID="4">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="存放？" ID="5">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="7，对于索引顺序文件采用非稠密索引，其查找表的结构是什么？Q翻编二老TQ八k，，石咭生配1奋日劝口乡北拐1右1剑匕七卜4口后离叹1咨汁拍巨第9章排序191" ID="6">
        <fptr EndPN="00000200" StartPN="00000199"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000200" TITLE="参考文献" TYPE="Chapter">
      <fptr LogicalPageNum="200" PhysicalPageNum="200"/>
      <Paragraph CONTEXT="190数据结构" ID="1">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="4.什么是索文件和索引顺序文件？什么是稠密索引和非稠密索弓I？各自特点是什么？" ID="2">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="5.简述磁带和磁盘存储信息的特点是什么？" ID="3">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="5.6。" ID="4">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="存放？" ID="5">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="7，对于索引顺序文件采用非稠密索引，其查找表的结构是什么？Q翻编二老TQ八k，，石咭生配1奋日劝口乡北拐1右1剑匕七卜4口后离叹1咨汁拍巨第9章排序191" ID="6">
        <fptr EndPN="00000200" StartPN="00000199"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="以上各章讨论的数据都是存放在内存储器中，在计算机的众多应用领域中，数据处理占有非常重要的地位。所谓数据处理就是对各类大批量的数据进行收集、存储、排序、检索、计算、的特点是数据量大，在计算机内存容量有限的情况下，通常将它们存放到外存储器（如磁盘）中。为便于长期保存原始数据和加工处理的结果数据一般将这些数据以文件的形式存放在外存储器上。本章主要介绍文件的基本概念和几种常见的文件组织形式。" ID="1">
      <fptr EndPN="00000192" StartPN="00000192"/>
    </Paragraph>
  </div>
  
</METS>
