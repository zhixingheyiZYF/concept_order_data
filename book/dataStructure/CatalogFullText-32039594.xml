<?xml version="1.0" encoding="utf-8" standalone="no"?>
<METS xmlns:METS="http://www.loc.gov/METS/" xmlns:gdm="http://sunsite.berkeley.edu/GDM/" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" TITLE="Zhejiang University.jdl.China-America digital library project" TYPE="Section" xsi:schemalocation="http://www.loc.gov/METS/http://www.loc.gov/standards/METS/METS.xsd">
  
    <div ORDERLABEL="00000015" TITLE="第1章  绪论" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000015" TITLE="1.1  常用术语" TYPE="Chapter">
      <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
      <Paragraph CONTEXT="·2·数据结构傲据元素·" ID="1">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="素（DataElement）简称元素.它是一个数据整体中相对独立的单位。如对于.说，每个记录就是它的数据元素：对于一个字符串来说，每个字符就是它的数据记录（DataRecord）简称记录.它是数据处理领域组织数据的基本单位，一个数据记录由一个或多个数每个记录表" ID="2">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="t-图书目录i" ID="3">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="－「―一一" ID="4">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="－二二一1，一甲刁不下下几二二二二" ID="5">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="，t。诗目主rgs｝书名一举进‘.去‘出1定价：元之花石不一五凡场P·二。｝。什峙一徐爪一瑞华＊拭一’：6币、。卜；。P.、.：）r.1，洁，’）’学不不第1章绪论·3引入了记录的关键项和关键字后，为简便起见，在以后的讨论中，经常利用关键顶.替所有记录，利用关键字来代替所在的记录，而把记录中的其他项忽略掉.象是现实世界的事物及其活动，都是在一定意·响的，所以数据之间必然存在着联系.数据之间白$Picture[00000017\00000017_new\0013.jpg]Picture$称为数据的逻辑结构.在计算机中存储数据时，不仅要存储数据洲之间的联系（即逻辑结构）.一种数据结构在存储器中的存储方式年存储结构。由于存储方式有顺序、链接、索引、散列等多种形式，可以根据处理的需要表示成任一种存储结构或它们的组合结构。我结构是反映在不同层面（即现实世界层面和计算机世界层面）上姿它称为数据结构，具体含义从上下文不难理解。数据之间的相互联系，被为了更确切地描述数据的逻辑结构.通常采用二元组表示为：K＝＝｛七11蛋1毛妻0）" ID="6">
        <fptr EndPN="00000017" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="其中k,表示集合K中的第i个数据元素，，为K中数据元素的个数，特别地，若" ID="7">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="n，则If是一个空集，此时B也就无结构而言，有时也可以认为它具有任一结构：R" ID="8">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="表示集合R中d`1sj个二元关系（以后均简称夭系），m为R中关系的个数，特别地，若" ID="9">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="m，则R是一个空集，表明不考虑集合K中的元素之间存在任何关系。彼此是独立。4。数据结构，别一｝，卜一出生日‘，＿＿’‘一‘’一1‘’八表1-2中共有la条记录.每条记录都由6个数据项所组成，由于每条记录的职工号各不相同，所以可把每条记录的职工号作为该记录的关键字。并在下面的例子中，我们将用记录的关键字来代表整个记录。" ID="10">
        <fptr EndPN="00000018" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="例1.1一种数据结构set=(K,R)，其中" ID="11">
        <fptr EndPN="00000018" StartPN="00000018"/>
      </Paragraph>
      <Paragraph CONTEXT="xal.oz,03,04.as.ob.m,os.09.1o}R}在数据结构Set中，只存在着元素的集合，不存在有关系的集合，表明我们只考虑表1-2中的每条记录，并不考虑它们之间的任何关系。我们称具有此种特点的数据结构为集合结构。对于集合结构.元素之间按任何次序排列都是允许的，如可以按关键字的升序排列.也可以按关键字的降序排列.等等.这可棍据处理问颐的需要仟竞揍宁。例1.2一种数据结构linearity=(K.R}，其中xol.oz.03.a4.os.06,m.oa.09,1a}R(D5.D1(Dl,D3(d3,OB(08,Q2(Q2,07(07,D4(04,06).(06,09).(09,1d)。戒乡代弓一0～＠一C曰9一＠～0叫3第1章绪论·5·在数据结构”neazity中.每个数据元素有且仅有一个直接前驱元素（除结构中第一我们把具有这种特点" ID="12">
        <fptr EndPN="00000019" StartPN="00000018"/>
      </Paragraph>
      <Paragraph CONTEXT="的数据结构叫做线性结构。" ID="13">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="例1.3一种数据结构仃忱＝（兀，R），其中K＝！01.02.03。04，05.06，07.05，伪.10）" ID="14">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="R＝硬（01，02），（01.03），（01，04），（02，仍）。（似，06》，（03，07）." ID="15">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="对应的示意图如图1.2所示.图12数据的树结构示意图没有后继的节点叫做树叶节点，除树根和树点外），但可以有任意多个后继节点（树叶节点可看做为具有0个后继节点）.这种数" ID="16">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="据结构的特点是数据元素之间的1对N（l：N）联系（N）0）.即层攻关万.我们把具" ID="17">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="（N）0），即层次关系，我们把具$Picture[00000019\00000019_new\0019.jpg]Picture$有这种特点的数据结构叫做树结构，简称树。$Picture[00000019\00000019_new\0021.jpg]Picture$例1.4一种数据结构graph＝（K.R），其中K＝《01，02，03，04。05，06，07》R＝｛（01，倪》，（呱01），（01，俱），（04，01），（傀，03），（03，02），（位，伪》，（低02），（呱0707，m》.（03，q7），＜07.03》，帆肠呱供05，0’7》，＜价，仍》1对应的图形如图1.3所示。从图L3可以看出，R是弃三序对（x，刃或（y，x）来代替；在示意图中，我们把x节点和y。6。数据结构$Picture[00000020\00000020_new\0002.jpg]Picture$$Picture[00000020\00000020_new\0003.jpg]Picture$图1.3数据的图结构示意图图1.4图1.3的等价表示从l1.3或l.4可以看出，节点之间的联系是f1对N(M：N）联系（M.4,N.0即网状关系，也就是说，每个节点可以有任意个前驱节点和任意个后继节点。我们把具有这种特点的数据结构叫做图结构，从图结构、树结构和线性结构的定义可知，树结构是图结构的特殊情况，线性结构为了区别于线性结构，我们把树生结构。线性结构和非线性结构相对于集合来说都是有结构" ID="18">
        <fptr EndPN="00000020" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="即元素之间无任何联系。" ID="19">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="的，而集合结构为无结构，" ID="20">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="例1.5一种数据结构BK.R)，其中K二Iki.kz,ka.14.ks.kb}RRI,Rz)为树结构，若只考虑关系凡则为线性结构。当一组数据中包含有多个二元关系时.通常把它们看做多个数据结构来分别分析和I11,5带有两个关系的一种数据结构示意图第1章绪论，7字节，则整数表示范围在一21521，一1，即一32768～327b7之间：若采用4个字节.则整下或助伍坛笠.双目加、减、委、除、取禅等运耸.双目等" ID="21">
        <fptr EndPN="00000021" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="YY/WkY..1.-r】-'r_her-Y_.I_Y_.1.Y_AhY_A7」R-勺./LL二小于等于等关系（比较）运算，以及赋值运算。字〕兰攻立g间巨-门Ci宁rn_new口‘瑞1白七白匆二匕盆目夕.斗，二‘备4，" ID="22">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="符类型在机器中通常用一个字节表示，" ID="23">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="字符进行编码，对字符类型的数据允1通常用一个字节表示，无符号表示范围在0～255之间，能够至多对256种值，对字符串的操作主要有求串长度、串复制、两串连接、两串比较等。r分为简单类型和结构类型两种.简单类型中的每个数据（即简单数据》型为字符类型的顺序排列结构，串类型中的一个值，对字符串的操作主要有求串长度、通常只作为整体使用，如一个整数、实数、字符、引都可以通过下标运算" ID="24">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="弓.每个数据都可以通" ID="25">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="分.如数组就是一种结构类型，它由固定个数的同一类型顺序排列而成，每一个数组值包含有固定个数的同一类型数据，每个数据（元素）都可峻接访问.记录也是一种结构类型，它由固定个数的不同（也可以相同〕.g·数据结构按数组下标的个数.可把数组分为一维、二维、三维等。一维数组中的每个元素只包含有一个下标.二维数组中的每个元素包含有两个下标，第一个称为行下标，第二个二维数组可看做是一维数组的推广或嵌套，即首先把它看做是按仃下标顺序排列的一维数组，该数组中的每个元素又都是按列下标顺序排列的一维数组。如对于一个二维数组b[mn]，可看做为一维数组b[m所含元素依次为b[l.b[11,b[m-11，其中每一个元素b[i]{O蕊i蕊m-1)又都是一个含有n个元素的一维数组，所含元素依次为b[i0b[i1I.b[i[n-l]o曰蜂：二毋粉公维数组是一维数组的三层嵌套结构。如对于一个三维数组c[11[m][n]，首先可看做是一维数组c[p所含元素依次为c[al,c[11,。二，c[p-11.其中每一个元素c[k](OckCP一”又，c［kl沁一1］，这里沮.所含元素依次的每一个元素clkl［l1（0成1续m-1）也都是一个含有数组的存储结构是顺序结构，即姿即数组中第1＋l个元素紧接着存储在第‘个元素的存储位置的后面。如对于一维数组alnl.则每个元素alil的存储位置的首字节地址为：Address（a【1」）二b义（a）＋1＊L（0毛1镬刀一1）其中Loc（a）表示数组a的存储空间的首地址.L表示数组a中元素类型的大小，即每个元素所占用的字节数，可用sizc。氏alil）计算。由上述公式可知：元素a［0］的存储地址为全a［0」的存储地址为a［2］的存储地址为Loc（a）＋2＊L，…，a［n-1］的存储地址为Loc（a）械n-1）＊L。对于一个二维数组b［m］Inl，每一行元素b［门的存储位置（即存储该行n个元素的首字节地址）为：第.章绪论·9·对于三维或更高维数组，其每个元素的存储位置（即首字节地址）也容易计算出如对于三维数组c印］伽］［n］，其相应的一维数组元素、二维数组元素和三维数组元素" ID="26">
        <fptr EndPN="00000023" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="来。的存储位置）人ddress[c[k]）二Loc(ck*mpn-L(Ogk蕊P-1)Address(c[ic][iI.oc(cksm-n-L+iwnwL(O〔kcp-1,t)（l毛At-1）(O镬k《p-1,O返r脚一1.tjCn-1)上述介绍的是以行序为主序对多维（即二维和二维以上）数组进行存储分配的情斤左按斗醉的但3Ed15h31hhFgfl't卜而吐右.下曰名奋望.7之谁划匕山" ID="27">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="由一组数据和在该组数据上的操作集" ID="28">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="，但含义比一般数据类型更广、更抽" ID="29">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="部分，具体可以采用如下格式进行描" ID="30">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="述。" ID="31">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="ADT（抽象数据类型名》15" ID="32">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Picture URL="00000023\00000023_new\0018.jpg">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Picture>
      <Paragraph CONTEXT="Data:（数据描述》Operations:〔操作声明》end（抽象效据类型名）的简单类型、数组类型或记录（结构）类型来描述，对其操作部分通常采用计算机语言（过程）定义来描述：在面向对象的程序设计中，" ID="33">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="我们可以把矩形定义为一种抽象数据类型，·1o·数据结构Hate:" ID="34">
        <fptr EndPN="00000024" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="float1ength,width;" ID="35">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="Operations:" ID="36">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="voidInitRettangletRectangle&amp;r,float1en,floatwid" ID="37">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="floatCircumference(Reetangie&amp;r" ID="38">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="floatAreaRectangle&amp;rendRECtangle其中参数r的类型名Rectangle表示一个用户定义的记录（结构）类型，它包括矩形翻#盛rl月勿日右二,耘君;t;口番.典映9FIIt〕习比夕台-ik;素1w3dy.角Alfiflyjlk9F+Jt片.rdhMfri甲Ott41田的长度和宽度两个域，该记录类型用来统一描述此抽象数据类型所含的数据部分，用" ID="39">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="C/C+＋语言定义如下：" ID="40">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="structRectangle{" ID="41">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="float1ength,width;初始化矩形数据的函数定义如下：voidInitRectangle(Rectangle&amp;r,float1en,floatwid)" ID="42">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="r.length=len;把len值赋给r的length域.1" ID="43">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="r.width二wid;把wid值嗽给r的widthf｝该函数把两个值参len和wid的值分别赋给引用参数r的length域和width域，实现对一个矩形rki`J初始化。floatCircumference(Rectangle&amp;r}{" ID="44">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="return2r.lengtfl+r.width" ID="45">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="46">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="floatArea(Rectangle&amp;r)" ID="47">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="returnr.length*r.width;}回披引用矩形的周长和面积。第1章绪论·11$Picture[00000025\00000025_new\0002.jpg]Picture$看做是对应的调用参数〔即实参〕的别名，将为它分配存储空伺，对值参的访问与对应的实参无关，兰间。在C语言中不能使用引用参数，针参数可以实现引用的功能.用OC什语言编写出完整的程序如下：" ID="48">
        <fptr EndPN="00000025" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="序1-l.cpp*1" ID="49">
        <fptr EndPN="00000025" StartPN="00000025"/>
      </Paragraph>
      <Paragraph CONTEXT="finclude(iostream.hl在C语言中用#indude(stdio.h}代替.»/structRectanglejfloat1ength,width;｝；voidInitRectangle(Rectangle&amp;r,float1en,floatwid函数声明＊*1floatCircutnfetettce(Rectangle&amp;r函数声明＊*1floatArea(Rectangle&amp;r1*函数声明＊slvoidmain(void)ffloatx,y;用于从键盘上输入一个矩形的长和宽*1Couta“请输入一个矩形的长和宽！&quot;acendl;在C语言中用prittf(“请输入一个矩形的长和宽！”代替＊slcin;vxny;1*在C语言中用scanfl4bf4bfxy代替＊*1InitRectengle{a,x,y1*对矩形a进行初始化＊*1p＝Circumfencnce(a/。计算矩形a的周长＊5＝A茂a（a）；1＊计算矩形a的面积＊*1c即比”矩形的周长为户火亡。山；CoUt&quot;矩形的面积为：&quot;《SdCCRdI;·12·数据结构voidInitRectangle(Rectangle&amp;r,float1en,floatwid){" ID="50">
        <fptr EndPN="00000026" StartPN="00000025"/>
      </Paragraph>
      <Paragraph CONTEXT="r.iength=len;" ID="51">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="r.width=wid;" ID="52">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="｝floatCircumference(Rectangle&amp;r){" ID="53">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="return2r.length+r.width｝floatArea(Rectangle&amp;r){" ID="54">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="returnr.iength＊r.width;}在C语言中只使用一种注释形幻，而在Ci-F语言中若注释在行尾或者单独占据一行，则还可用双斜线刀引出注释。如对于上面主函数中的求矩形面积的赋值语句行可改写如下：s二Area(a11计算矩形a的面积C语言能够兼容C语言，也就是说，用C语言书写的程序可以原封不动地在C语言环境下运行，而C什对C做了许多改进和增强，如在输入、输出、参数定义、函数舌刹含考关僧.全尔侣片刹釜云替公石米么自味犷R石石件冈田尸二二名五性全盛白惬三配任日召邑茉自肠记七尸召五飞梦石不书些〕；重载、运算符重载、模板、类等方面，运行。对于仁而的程序，若要在C语言环境下运行，除了修改输入、输出等语句外，还要把引用参数修改为指针参数，把对应的实参修改为取地址的表达式。改写后得到的C程" ID="55">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="序如一卜：" ID="56">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="#include(stdio.h)" ID="57">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="structRectangle{" ID="58">
        <fptr EndPN="00000026" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="们。at1ength,width;｝：voidinitRectangle(Rectanglerr,float1en,floatwidfloatCircumference(Rectangle.r第l章绪论·13voidtnainU(11在C十＋语言中空参数表可以使用保留字void标记floatx,y;" ID="59">
        <fptr EndPN="00000027" StartPN="00000026"/>
      </Paragraph>
      <Paragraph CONTEXT="floatp,s;" ID="60">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="Rectanglea;printff”请输入一个矩形的长和宽scarf%t%fxy" ID="61">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="IaitRectanglea,x,y" ID="62">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="pCinrwnference(8ta" ID="63">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="拼A叹冶（＆a）；" ID="64">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="州n试“切“）；，切斌“矩形的周长为：％细’户.P1“矩形的面积为：％n幻众}voidInitRectangle{Reetangle*r,float1en,floatwid){rlengW=len;" ID="65">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="rwidth二wid;" ID="66">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="｝floatCircumference(Rectangle.r)return2rlength+rwidth}" ID="67">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="floatArea(Rectangle*r){" ID="68">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="returnr-alength＊r-＞width;" ID="69">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="l(DataObject)简称对象。它属于一种数据类型中的特定实例。如25为一$Picture[00000027\00000027_new\0027.jpg]Picture$旨‘人’蛋一木空件粉坦材金‘落翻户卜，r心。七一本空娜婚抖对免＿·14·数据结构算法（Algorithm）就是解决特定问题的思路和方法。一个算法可以采用文字叙述，用一种程序设计语言来描述。作为一个算注应具各以下下个特性，但要在计算机上实现." ID="70">
        <fptr EndPN="00000028" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)有穷性。一个算法必须在执行有穷步之后结束。" ID="71">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）确定性。算法中的每一步都必须具有确切的含义，无二义性." ID="72">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)可行性。算法中的每一步都必须是可行的，也就是说，每一步都能够通过手工或机器可以接受的有限次操作在有限时间内实现。" ID="73">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)输入。一个算法可以有4个、i个或多个输入量，在算法被执行之前提供给算法。(5》输出。一个算法执行结束后至少要有一个输出量，它是利用算法对输入量进行需要人们解决的特定问题可分为数值的和非数值的两类。解决数值问题的算法叫做ffuck:LJ华£rt下石9;4-fir'一'ri.dEr91ick4tF门.iKlr才占怕'y士.Irnd坠BglilKr/台'4口2、不怒合理吞把淘IJL.数值算法，科学和工程计算方面的算法都属于数值算法，如求解数值积分，求解线性方" ID="74">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="程组，求解代数方程.求解微分方程等。在各种数据结构上进行的排序算法、查找算法、插入算法、删除算法、遍历算法等为非数值算法。数值算法和非数值算法并没有严格的区别.一般说来，主要进行各种算术运算。另一方面，特定的问题可能是递归的，也可能是非递归的，因而解决它们的算法就有递归算法和非递归算法之分。当然.从理论上讲，" ID="75">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="代〕、堆栈等技术转化为非递归算法。通过学习数据结构这门课程.要能够根据实际数据处理问题的需要，抽象出所涉及的数据，建立数据模型（即逻辑结构），选择合适的存储结构存储到计算机系统中，进而按照结构化、模块化以及面向过程或面向对象的程序设计方法设计出进行数据处理的、" ID="76">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000028" TITLE="1.2  算法描述" TYPE="Chapter">
      <fptr LogicalPageNum="28" PhysicalPageNum="28"/>
      <Paragraph CONTEXT="第1章绪论“巧." ID="1">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）如果a;x则将氏赋给x，否则不改变x；寺，古喇目，他效通只古巷火台份冲林扮的解右导司毕$Picture[00000029\00000029_new\0004.jpg]Picture$的值，这仁的最大值：(7》转向第（4)步继续执行。若要使一个算法在计算机上实现，" ID="2">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="则最终必须采用一种程序设计语言进行描述。如对于上述算女上4当习区田r长亘侣'f2k;未fiIII石TLf4启'三暇t3irrrT$I程序卜2.c*1" ID="3">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="tkinclude(stdio.h)#dafinenn10假定nn常t为整数10.1intFindMax(intaiotn)从数组a的n个元素中求出最大值.kl屯" ID="4">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,x;图6求。个元素中的最大值" ID="5">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="x月[01;1把第一个元素a[0】的值斌给x*I" ID="6">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="i=1;把第二个元素a[11的下标1赋给i*1whileGn1叹a［11＞x）x封［1］；" ID="7">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="i" ID="8">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="告returnx;1返回数组a中n个元素的最大值＊1}voidmain(vaid)" ID="9">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="｛inti，x，alnn］；加用a[01^a[nn-11保存a，a元素＊1printfC”请输入％d个整数；nn肠di司；i＜nn二玉什）·16·数据结构在C语言中定义符号常量只能使用#define宏命令定义，而在C语言中通常使用更优越的const语句定义符号常量，因为它能够为符号常量指定数据类型.如对于上面程序中的#define命令，在C语言中被改写为：constintnn=1Q;在C语言中，通过使用包含文件iostream.h，就可以很方便地使用其中定义的输入插入操作符《向屏幕窗口输出数据（即表达式的值），使用其中定义的符号常量endl作为（即表达式的值），换行符‘恤’。如对于上面主函数中的最后一条输出语句，在C什语言中可改写如下：coutanna”个整数中的最大值为：&quot;aaceendl;" ID="10">
        <fptr EndPN="00000030" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="若把上面整个程序改写为C+＋程序，则如下所示。ll序I-2.cpp#includc(iostrcam.h)" ID="11">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="conslininn=10;11定义符号常量nn等于1D" ID="12">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="intFindMax{intaintn)（inti,x;x=a[01;11把第一个元素a[01的值赋给x" ID="13">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="i=1;11把第二个元素a[11的下标1给i" ID="14">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="while(i＜n" ID="15">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="if{a[i]＞x)x二a[il:i+币；｝" ID="16">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="returnx;11返回数组a中n个元素的最大值" ID="17">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="1voidmain(vaid)不inti,x,a[nn11用a[0］一a[nn-11保存a：一、元素" ID="18">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="cout”请输入‘户atn“个整数：’飞fat{i阅;i＜nn;i第1章绪论·I7coutannac”个整数中的最大值为：&quot;acx:endl;｝" ID="19">
        <fptr EndPN="00000031" StartPN="00000030"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000031" TITLE="1.3  算法评价" TYPE="Chapter">
      <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <div ORDERLABEL="00000031" TITLE="1.3.1  正确性" TYPE="Chapter">
        <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <Paragraph CONTEXT="正确性（Correctness）是设计和评价一个算法的首要条件，如果一个算法不正确.既不能完成或不能较好地完成所要求的任务，其他方面也就无从谈起。一个正确的算法是" ID="1">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="指在合理的数据输入下，能够在有限的运行时间内得出正确的结果。通过采用各种典型" ID="2">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="指在合理的数据输入下，的输入数据上机反复调试算法，使得算法中的每段代码都被测试过，若发现错误及时修正，最终可以验证出算法的正确性。当然，要从理论上证明一个算法的正确性，并不是正，" ID="3">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="一件容易的事，" ID="4">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000031" TITLE="1.3.2  健壮性" TYPE="Chapter">
        <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <Paragraph CONTEXT="误数据的处理一般包括打印出错误信息、调用错误处理程序、返回标识错误的特定信" ID="1">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000031" TITLE="1.3.3  可读性" TYPE="Chapter">
        <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <Paragraph CONTEXT="。1a·数据结构" ID="1">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000032" TITLE="1.3.4  时间复杂度" TYPE="Chapter">
        <fptr LogicalPageNum="32" PhysicalPageNum="32"/>
        <Paragraph CONTEXT="(TimeComplexity）又称计算复杂度（ComputationalComplexity)。它是$Picture[00000032\00000032_new\0003.jpg]Picture$（如赋值、比较、计算、转向、返回、输所需的时间与算法中进行简单操作次数的乘积。需的时间随机器而异，它是由机器本身硬软件环境决定的，与算法无关，所以我们只讨不管一个算法是简单还是复杂，最终都是经过编译后分解成简单操作来具体执行的，因此，每个算法都对应着一定的简单操作的次数。显然，在一个算法中。进行简单操作的次数越少，其运行时间也就相对地越少；次数越多，其运行时间也就相对地越多。所以，通常把算法中包含简单操作次数的多少叫做算法的时间复杂度，用它来衡量一个算法的运行时间性能或称计算性能.若解决一个问题的规模为n.则算法的时间复杂度通常是n的一个函数，假定记为" ID="1">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="n)。下面通过例子来分析算法的时间复杂度。" ID="2">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="算法1.1累加求和" ID="3">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="int5um(intb[J,intn}" ID="4">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="5">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,s二0;" ID="6">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="几代1司：1＜n：1＋＋）" ID="7">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="sb[ij;returns;｝计算机执行这个算法时，第1条定义并赋初值语句和第3条返回语句都各执行一次简单操作，第2条for循环语句所包含的简单操作的次数可进行如下分解计算：ice;们次markif(i＞=n)gototttark2;11叶1次肿＝b【1］；湘次i11n次第1章绪论·]4把第2条语句分解后的每一条简单语句的执行次数加起来，就得到了它包含的简单操作的次数，即为4耳十2。因此，算法1.I的时间复杂度为：算法1.2矩阵相加voidMatrizAdd(inta[MSMSintb[MSMSintc[MSMSintn)11实现矩阵a[a,a]和b[n,n]的加法，其和存入c[n,a]中朋M$为大于等于。的常量【" ID="8">
          <fptr EndPN="00000033" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j;" ID="9">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="加洲1切；1＜n；1＋＋）" ID="10">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="fotij＝O;j＜n;j" ID="11">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="c【i］U】幼【11口】＋b［i］口1；}运行此算法需要执行的简单操作的次数就等于双重for循环语句所包含的简单操作的次数，对该语句可进行如下分解计算：ice;111次markl:if(ixn}gatomark4;11a+1次jam;11n次mark2二if{jxr)gotomark3;11n（叶1)次cEilGl司[il[Il+bLil[Il:Iln*n次j11n+n次gotomark2;11n«n次ntark3:i升；lln次gotomarkl;11n次mark4把分解后的每一条简单语句的执行次数加起来，就得到了算法1.2所包含的简单操作JCnb4n2+Sn+2算法，.3简单选择排序·so·数据结构《" ID="12">
          <fptr EndPN="00000034" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,jc,x;" ID="13">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i习;inn-l;i" ID="14">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="15">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="k二i;允丙＝1＋ljoj＋＋）if{b[jlb[kl)kj;x=b[i" ID="16">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="b(ib(k" ID="17">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="bLkl=x;" ID="18">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="19">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="｝此算法包含有双重far循环。外层for循环的循环变量为1，它从a取值到n-2.对于￡的每一取值，首先通过脸ii初值语句和内层far循环语句，在b7至b[re-11之间顺序查找出具有最小值的元素b[k然后通过三条斌值语句交换b7和b{k]的值，使得b[i为b[z找出具有最小值的元素b［k］.然后通过三条斌值语句交换b［t1和blkl的值，至bln-1］之间的最小值。这样，当算法执行结束后，数组b中的”要计算出该算法包含的简单操作的次数，可将双重for循环语句分解如下：1切；111次" ID="20">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="m.傲1：1式卜n-l）goton挂Irk4；Iln次k＝1；lln-1次j＝i＋l；lln-1次1均，）。otonu甘k3；11艺（n-1）＝（n＋2）伽一1冲次11艺（n一卜1）＝n（n-1滩次1代b口1＜b［叼）k：j；升＋；Iln（n-1边次名oton公汀kZ；lln（n-1胜次nu址k3：x＝b［1］；lln-1次bli］＝b【k］；lln-1次blk］＝x；如一1次1＋＋；Iln-1次9以。markl；lln-1次第1章绪论·21把分解后的每一条简单语句的执行次数加起来，就得到了算法1.3所包含的简单操作的次数.算法1.3的时间复杂度为：从以上分析可以看出，一个算法的时间复杂度的计算是相当烦琐的，特别对于较复，算法更是如此。实际上，一般也没有必要精确地计算出算法的时间套杂度.只要大杂的算法更是如此。实际上，一般也没有必要精确地计算出算法的时间复杂度，只璧致计算出相应的数量级（C扮山叮）即可。下面接着讨论时间复杂度f(n)的数量级表示.致计算出相应的数量级（C扮山叮）设f(n〕的一个辅助函数为g(n)，定义为当ri大于等于某一足够大的正整数yn时，存gt月）数量级函数.把六动表示成数量级的形式为：f(n)_0(g(n（即数量级）一福其中大写字母0为英文orate（即数量级）一词的第一个字母。这种表示的意思是指班动同f(n)只相差一个常数倍。g(nn;在算法1.2电当。.2cp取、为2，时，4‘4nSn+2z均成立，则中的其余项和最高次幕的系数都无关。若把算法T.1、算法1.2和算法1.3的时间复杂度分别用数量级的形式表示.则分别为以”）、O（矛）和o（矛）。算法的时间复杂度采用数量级的形式表示后，将给求一个将给求一个算法的f（n）带来很大方·22·数据结构被称为线性算法，其运行时间与n成正比.如对一个表进行顺序查找时，其时间复杂度就是Q(n)。有一些算法的时间复杂度为以吨班），即与”的对数成正比，如在有序表上i#行二分杳粗的笠续献县加此。对教织讲行排序的各种简单算法为以n朽数母级的.当n进行二分查找的算法就是如此。对数组进行排序的各种简单算法为以n今数量级的，当。加倍时，其运行时间将增长4倍；对数组进行排序的各种改进算法为O（n.los生n）数量级的，当。加倍时，其运行时间只是原来的‘气之下）倍·做两个”阶矩阵的乘法运算时，其时间复杂度为以矿）。求具有n个元素集合的所有子集的算法，其时间复杂度应为列的算法的时间复杂度为以川），因为它共含有川种不同的排列。表卜3给出了对于不同的n值，各种典型的数量级所对应的值。从息n较大时，若时间复杂度为指数或阶乘数量级，则相应的算法是无效的，从表中可以看出，当行的.如假定一台计算机每秒能够做1亿次简单操作，则j是大不相同的，对数的值的增长速度最慢，线性值较之快些，几二：气丁－一飞一一一，丁一一一了－－一一－一气丁――16！Ml“$Picture[00000036\00000036_new\0028.jpg]Picture$2％｝冷1飞2‘1" ID="21">
          <fptr EndPN="00000036" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="。｝.024一" ID="22">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="。。一！一｛不蔺" ID="23">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="6、｝4、二。第1章绪论·23fainti司;rrn;i11在C中允许在for语句的第一个表达式中" ID="24">
          <fptr EndPN="00000037" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="ifa[il＝盘oy)returnis" ID="25">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="re-1;" ID="26">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｝此算法的时间复杂度主要取决于for循环体被反复执行的次数。最好情况是第一个元素a[01的值就等于item，此时只需要进行元素的一次比较就查找成功，相应的时间复杂度为O(1}：最差情况是最后一个元素a[n-11的值等于item素的比较才能查找成功，相应的时间复杂度为U(n)；平均情况是；每一个元素都有相同的概率（即均为火）等于给定值证口，则查找成功需要同元素进行比较的平均次数为1全i=1{n+1相应的时间复杂度为(t)，它同最坏情况具有相同的数量级，因为它n二r‘们之间的比较次数只在系数项和常数项上有差别，而在n的指数上没有差别。当在数组a上顺序比较n个全部元素后仍找不到等于给定值item的元素，则表明查找失败，这种情况所对应的时间复杂度也为O(n)o在一个算法中，最好情况的时间复杂度最容易求出，但它通常没有多大的实际意" ID="27">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="义，因为数据一般都是随意分布的.出现最好情况分布的概率极小；最差情况的时间复" ID="28">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000037" TITLE="1.3.5  空间复杂度" TYPE="Chapter">
        <fptr LogicalPageNum="37" PhysicalPageNum="37"/>
        <Paragraph CONTEXT=".24·数据结构算法的输入／输出数据所占用的存储空间是由要解决的问题所决定的.是通过参数表由调用函数传递而来的.对于引用参数将不占有这方面的空间，而对于值参数将占有这-rrfotr方ra76kL`l.4ixbtr4当7门蔺R-田己r田金粉甜组抖j尧新减，1洲击田拾盘困脸" ID="1">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="方面的空间。所以在允许的情况下，尽量采用引用参数或指针参数，减少使用值参数，针月p断坦坐刑裕磨十rr盘x-百,sshrlw$Picture[00000038\00000038_new\0007.jpg]Picture$存储算法本身所占用的存储空间与算法书写的长短成正比，间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变.我们称这种算法是“就地”进行的，是节省存储的算法，如这一节中介绍过的几个算法都是如此：有的算法需要占用的用较多的存储单元.例如将在后面排序一章中介绍的快速排序和归并排序算法就属于这种情况。都比较简短，算法本身所占用的存储空间较小，但运行时需要一个附加堆栈，从而占用" ID="2">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="较多的临时工作单元：若写成非递归算法，一般可能比较长，算法本身占用的存储空间" ID="3">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="较大，但运行时将可能需要较少的存储单元。" ID="4">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="一个算法的空间复杂度通常只是考虑在运行过程中为局部变量分配的存储空间的大" ID="5">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="小，它包括为参数表中值参变量分配的存储空间和为在函数体中定义的局部变量分配的第1章绪论·2S省本章，1、结" ID="6">
          <fptr EndPN="00000039" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="1.数据结构研究的是数据的表示和数据之间的关系.从逻挥上讲.数据有集合结构，线性结构、树结构和图结构四种。从物理实现上讲，数据有顺序结构、桩接结构、索引结构和散列结构四种.理论上，任一种数据逻挥结构都可以用任一种存储结构来实现。" ID="7">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="z.在集合结构中：不考虑数据之间的任何次序.它们处于无序的、各自独立的状态.在线性结构中，数据之间是i对i的关系。在树结构中，数据之间是i对多的关在图结构中，" ID="8">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="3.一个数组占有一块连续的存储空间，每个元素的物理存储单元是按下标位1从a开始连续编号的，相郁元素之间其存储位1也相郁.对于任一种数据的逻样结构，若能够把元素之间的逻辑关系对应地转换为数组下标位！之间的物理关系，列挽能够利用数组来实现其顺序存储结构." ID="9">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="a.抽象数据类型是数据和对数据进行各种操作的集合体.这里所说的数据是广义的，是带有结构的数据，它可以其有任何逻挥结构和存储结构.$Picture[00000039\00000039_new\0017.jpg]Picture$健壮性，可读性和有效性呀个方面.有效性又包括时间复杂度（性）和空间复杂度（性）两个方面.若一个其法的时间和空间复杂度越好。即越节省时间和空间，别表明越有效." ID="10">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="b.算法的时间复杂度和空间复杂度通常用数全级的形式表示出来，数童级的形式可，常全级、对数级、线性级、平方级、立方级等多个级别.当数据处理t较大时，处分为常全级、" ID="11">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="于前面级别的葬法比处于后面级别的算法更有效." ID="12">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="叠习题1L1单选厦" ID="13">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="1.一个数组元素a[i]与（）的表示等价." ID="14">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="A.a+i)B.a+iG*a+iD.dta+i" ID="15">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="2.若一个数据具有集合结构，则兀素之间具有（）。A线性关系B.层次关系C.网状关系D.无任何关系.26.数据结构" ID="16">
          <fptr EndPN="00000040" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="4.下面程序段的时间复杂度为（）.fot(intice;iam;ifpr(intjam;j＜n;j" ID="17">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="a[7fjN*j;" ID="18">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="A.O(rn2)B.O(n)C.O(m.n}D.O(rn+n)" ID="19">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="5.执行下面程序段时，执行S语句的次数为（）。for(inti=l;in=n;ifor(intj二1;ja=i;j" ID="20">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="S;" ID="21">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="A.nB.nr2C.n(n+1)D.n[n+1Z" ID="22">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="6.下面算法的时间复杂度为（）。intflunsignedintn)(if(n＝司IIn二二二1)return1;Elserenrnn*tYn-1｝" ID="23">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="A.O(13B.fi(n)C.IXnI)D.D(n" ID="24">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="7.使用心）调用下面算法时.该算法被调用的总次数为（）.irnP[unsignedintn)" ID="25">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="if[n二刃)+etum1;Elsereturnn*tn-i｝" ID="26">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="A.1B.2C.5D.61.2坟空瓜" ID="27">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="1.数据的逻辑结构被分为＿、＿＿＿＿「、＿“曰二旧.－＿二和」」四种。" ID="28">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="2.数据的存储结构被分为＿、＿、和四种." ID="29">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="3.在线性结构、树结构和图结构中，前驱和后继节点之间分别存在着次仕软住结构、材结构和图结构中，丽犯和后继节点之间分别存在着＿，＿＿＿.和的联系。第l章绪论·27" ID="30">
          <fptr EndPN="00000041" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="5.当一个形参类型的长度较大时，应最好说明为＿，以节省参数值的传输时间和存储参数的空间." ID="31">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="6.为了避免通过形参改变实参的值，则必须把形参说明为＿参数。" ID="32">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="7.在函数中对引用形参的修改就是对相应＿的修改。对＿形参的修改只局限在该函数的内部，不会反映到对应的实参上." ID="33">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="S.一个记录r理论上占有的存储空间的大小等于所有域的＿，实际上占有的存储空间的大小通过―计算得到。" ID="34">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="9.在GC语言中，一个数组a所占有的存储空间的大小即数组长度为＿，下标为i的元素a[门的存储地址为＿。输出一个二维数组" ID="35">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="11.在下面程序段中.s=s+p语句的执行次数为＿，" ID="36">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="P'ti语句的执行次数为＿，该程" ID="37">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="序段的时间复杂度为＿。" ID="38">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="inti巴0,ate;" ID="39">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="w怕1试＋＋1《司）【" ID="40">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="加tp=1;for(intj=1;jip*j;牛书+p;资" ID="41">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="12，一个算法的时间复杂度为（3nZ+2nlogZn+4n-75n)，其数&gt;级表示为＿。" ID="42">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="13.一个算法的时间复杂度为（(n3+15n100n+2403a+5b}，其中。和b为常量，则数量级表示为.1＿＿." ID="43">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="14，从一个数组a(141中顺序查找元素时，假定查找每个元素的概率都相同，则进行一次查找运算时的平均查找长度（即同元素的平均比较次数〕为＿." ID="44">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="15.从一个数组a[71中顺序查找元素时.假定查找第一个元素a[O]的概率为113，查找第二个元素a[11的概率为114，查找其余元素的概率均相同，则在查找成功时同元素的平均比较次数为l3i算且" ID="45">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="有下列几种用二元组表示的数据结构.试画出它们分别对应的图形表示（当出现多个关系时.对每" ID="46">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="个关系画出相应的结构图），并指出它们分别属于何种结构。。28。数据结构" ID="47">
          <fptr EndPN="00000042" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="2.B试K，R），其中卜【a.b.c，d，e，大窟，hlR(a,b),(b.c),(c.d)，(d.e)，(e.f),(f,g),(g.h)}3C斌K，R），其中K=ia,b,c,d,e,f,g,h}R(d.b).(d,g),(b,a).(b,c),(g,e)，(g,h).(e,f)14.17K,R)，其中" ID="48">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="K二《1,2,3,4,5,6}R1,2(2,3(2,4(3,4(3,5(3,6(4,5(4,6" ID="49">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="5.卜(K,R)，其中X48,25,64,37,82,36,75,43}RRRz,R31Rr(48,25)，(25,G4),(64,57J，(57,82),(82,36).(36,75).(75,43)}RZ(48,25).(48.64).(64,57).(64,82).(25,36).(82,75).(36,43)}R3(25,36(36,43).(43,48).(48,57),(57,64).(64,75),(75,82)}lA算法分析瓜指出下列各算法的功能并求出其时间复杂度。" ID="50">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="t.intPrime(intn}" ID="51">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="t" ID="52">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="inti=1;" ID="53">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="intxint)sgrt{n" ID="54">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="whilei＜=x}iflfn%i＝城）)break;ifi＞x)return1;" ID="55">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn0;" ID="56">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="57">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="2.intsuml(intn)" ID="58">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="59">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="intp=1,sue;for(inti=1;in=n;iP" ID="60">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="＊二i;" ID="61">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="针二P.第1章绪论·24比切m‘；" ID="62">
          <fptr EndPN="00000043" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="乡" ID="63">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="3.intaum2(intn)" ID="64">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="65">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="ints二0;加式亩彼1＝1；1分；1＋＋）｛int户l;far{intj=1;ji;j十十＞" ID="66">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="P'荀:" ID="67">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="tip;" ID="68">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="69">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="悦加rns;" ID="70">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="71">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="4.intfun(intn)" ID="72">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="《" ID="73">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="inti=1二1;" ID="74">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="while(ea" ID="75">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="5＋＝十＋】；" ID="76">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="沈turnis" ID="77">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="78">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="5.voidmtable{intn)" ID="79">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="王fot{itrti=l;i‘n;i" ID="80">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="fattintj=i;jr-n:j" ID="81">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="《setw(2)®cirj《&quot;1setw(2)指定i*j值的输出宽度为2coutrcendl;" ID="82">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="》}" ID="83">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="6.voidcmaaix(inta[1141[I+Jintd)111和N为全局整型常f{" ID="84">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="fodimis4;iHi;杆＋）。30。数据结构享" ID="85">
          <fptr EndPN="00000044" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="7.voidmatttimult(inta[MNintb[NLimc[ML" ID="86">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="IIM.N和L均为全局整型常量" ID="87">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="88">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k;" ID="89">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="fot(i0;iGM;i" ID="90">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j司;jcLj" ID="91">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="c[ilL司:" ID="92">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="forties;i[M;i" ID="93">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="允响闭J＜L；j＋＋）" ID="94">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="fork二fl;kaN;k" ID="95">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="96">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="1.5算法设计斑" ID="97">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="1.设计二次多项式axe+bx+c的一种抽象数据类型，假定起名为QUAdratic，该类型的数据部分为三个系数项a,b和c,假定在记录类型Quadratic中定义，操作部分为：(I）初始化一个多项式9的三个数据成员a.b和C.每个数据成员的默认值为0void1ttitQuadratic(Quadratic&amp;q,floataa＝＝0,floatbbd,floatcc二0" ID="98">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)做两个多项式加法.即使对应的系数相加，返回相加结果。QuadraticAdd(Quadratic&amp;q1.Quadratic&amp;q2" ID="99">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）根据给定x的值，计算多项式的值并返回.floatEval[Quadratic&amp;q,floatx" ID="100">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）计算方程澎＋加如，刃的两个实数根并引用返回，对于有实根、无实根和不是二次方程（即a二0)这三种情况都要返回不同的整数值.以便调用函数能够做不同的处理。intRoot{Quadratic8tq,float&amp;rl,float&amp;i'l左照ax＊＊2+hx+c的格式（x2用：s*2表示）输出二次多顶式.(S）按照ax＊＊2＋bx＋c的格式（护用：。＊2表示）输出二次多顶式.在输出时要注愈去掉系数为。的" ID="101">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="项，并且当b和c的值为负时，其前不能出现加号。voidPrin宜（QUad面ic＆q）；请写出上面每一个操作的具体实现。第1章绪论·31'分别返回“＞”.“＝”和“＜”字符。假定简单类型用5impleType表示，它可通过typedef语句定义为任一简单类型。" ID="102">
          <fptr EndPN="00000045" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）将一个字符申中的所有字符按相反的次序重新放置." ID="103">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）求一维double型数组[n]中的所有元素之乘积。" ID="104">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="月" ID="105">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)计算菩击的值·(s）假定一维整型数组a{n]中的每个元素值均在【a,200」区间内，分别统计出落在[0,2a[za,so[s0,so[so.i3a[13a,za01各区间内的元素个数。" ID="106">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)从二维整型数组afmn]中查找出最大元素所在的行、列下标." ID="107">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="3.设计集合的一种抽象数据类型。集合是由若干个同一类型元素组成的、元素之间不存在任何关系的一种数据结构。在数学上.一个集合用一对花括号括起来，元素之间用逗号分隔。一个集合中的元素来自于一个数据集，并且不允许出现重复的元素.如对于1n之间的整数集，它共包含有2&quot;个不同的集合，其中{！表示空集，{1.2,二，n}表示全集.假定一个整数集为一3.则在它之上可以构成的g(23)个集合为：{1{2{3{1,2{1,3{2,3{1,2,3}在GC语言中，可用一个整型数组来表示一个集合，若一个数组元素的值为0，则表示相应元素不在集合中，若为1则表示相应元素存在于集合中.如对于整数集16之上的一个集合4,s}，则用整型数组al刀表示〔a[a]元素未用）为；0i23455｝…｝二＿1二J.。二｝“”1二｝t,I,,,····I对于集合运算通常有并（u)、交（门〕和属于〔‘）等。两个集合的并的结果仍为一个集合，它包含有两个集合中的所有元素，当然不允许出现重复。两个集合的交的结果也仍为一个集合，它中的每一个元素同时属于两个集合。属于运算是判断一个元素是否存在于一个集合之中.若存在则返回真&lt;t，否则返回假(false)。假定华硬1.4，51，产砚2，4卜则xuy1,2,4.5xfly＝{41ex为真，2ex为假。'i定在]SLTSU_E整数集〔f:kVa为一个整型全局常里）上建立集合。抽象数据类型名用sEr表示，该类型的数据部分为一个整型数组m(Sl?TS1ZE+1}，用于保存一个集合，操作部分为；cl)对一个集合中的所有元素清v.该操作就是对m数组中的每个元素置o.voidInitSet{intm" ID="108">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）利用整型数组a[n]初始化集合to，即置m[a71为i(O〔i毛n-1)。如假定数组al3卜11.3，6卜则集合数组m中的元素m[11,m[3II1m[61被相应里为1，其余元素被置为0.voidInitSet{intmintaintn" ID="109">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)实现两个集合ml和m2的并运算，由m3带回运算结果。。32。敬据结构voidSetUnion(intmlintm2intm3p由m3带回运算结果。voids比In妞“姆（intml［］，intmZ［］，1爪m3［］瓦" ID="110">
          <fptr EndPN="00000046" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）判断一个元素是否属于一个集合.若属于则返回1否则返回0.int义tls（intmfl，inti匕m）：" ID="111">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="（6）向一个集合中加入一个元素，若成功则返回1否则返回0.intsetlnsert（intmtl，inti沈m）；" ID="112">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="（7）从一个集合中姗除一个元素，若成功则返回1否则返回00认tset〔比比证（int城lintiteln）；哆代国" ID="113">
          <fptr EndPN="00000047" StartPN="00000046"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="对于解决同一个问题，往往能够编写出许多不同的算法.例如，对于排序问题，在排序一童将介绍名种算法。讲行耸法评价的目的.既在于从解决同一问顾的不同耸" ID="1">
        <fptr EndPN="00000031" StartPN="00000031"/>
      </Paragraph>
      <Paragraph CONTEXT="后面排序一章将介绍多种算法。进行算法评价的目的，法中选择出较为合适的一种，也在于知道如何对现有攀伪合适的一种，也在于知道如何对现有算法进行改进，一般从以下五个方面对算法进行评价." ID="2">
        <fptr EndPN="00000031" StartPN="00000031"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000039" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
      <div ORDERLABEL="00000039" TITLE="习题1" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000047" TITLE="第2章  集合" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000047" TITLE="2.1  集合的定义和运算" TYPE="Chapter">
      <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <div ORDERLABEL="00000047" TITLE="2.1.1  集合的定义" TYPE="Chapter">
        <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <Paragraph CONTEXT="集合（撇）又称集合结构.它是由具有相同属性的数据元素按任何次序排列而成该集合中数据元素的个数称为集合的长度，'定用n表示，二）a。当n时则为空的。集。{a.一‘er+n'二，y}" ID="1">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="其中每个元素的下标为对该元素的编号，它是为了区别而任意标注的，不代表任何；。因为集合中的元素可以按任何次序排列，假定就按元素前后位置编号的次序排次序。因为集合中的元素可以按任何次序排列，列，那么a就是集合中第一个元素，S2就是第二‘" ID="2">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="列，个集合的长度是变化的，当向它抽入一个元素后其长度就增加1，当从中爪除一个元素" ID="3">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000047" TITLE="2.1.2  集合的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <Paragraph CONTEXT="。34.数据结构标识符S表示。操作部分包括对集合进行的各种常用运算.如初始化集合为空，向集合中插入一个元素，从集合中删除一个元素，从集合中查找一个元素，修改集合中的一个$Picture[00000048\00000048_new\0004.jpg]Picture$指宁元素.判断一个元素县否属干奥合.刻断集合县否为申.隶出集合中元青个教.输指定元素，判断一个元素是否属于集合，判断集合是否为空，求出集合中元素个数，输山咭翻吞由成右口二妻份任石木舍吞的生上椒奋刁石月卜J住适卜的众椒么七二姿洁品当已翻自当匕场良佳出集合中所有元素，合，清除集合中的所有元素使之变为空集等。" ID="1">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="集合的抽象数据类型定义如下：A17TSETisData:" ID="2">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="一个集合S,假定用标识符5以表示抽象存储类型" ID="3">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="Operation:voidInitSet(SetdcS" ID="4">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="刀初始化集合为空boolInsertSet(Set6tS,ElemTypeitem" ID="5">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="!1向集合中插入一个元素bool17eleteSetiSet&amp;S,ElemTypeitem" ID="6">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="11从集合中删除一个元素bowlFindSet(Set&amp;S,E1emType&amp;itrrt" ID="7">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="11从集合中查找一个元素井由item带回boolModifySet(Set&amp;S,tonerElemTypeBcitem;厅修改集合中的一个指定元素" ID="8">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="poolInSet(Set&amp;5,ElemTypeitemu1断一个元素是否属于集合" ID="9">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="boolEmptySet{SetBcSu」断集合是否为空" ID="10">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="intLenthSet(Set&amp;S刀求出集合中元素个数" ID="11">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="voidDutputSet(Set&amp;S了摘俞出集合中所有元素" ID="12">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="SetUnionSet(Set&amp;S1,Set&amp;S2万求两个集合的并集第z章集合·33刀按元素的值或关键字对集合排序voidCiearSet(SetdtS" ID="13">
          <fptr EndPN="00000049" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="劝青除集合中的所有元素" ID="14">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="endSET在以上列出的各种运算操作中，第1,2,3,5,12,13种运算需要改变集合S的状态（值〕，所以S必须为引用参ti(，而其他运算不需要改变S,可以为引用也可以为值参.为了节省为形参分配存储空间和传递参数值的时间，通常使用引用参数较好，同时为了保护引用参数值不被改变，可以使用常量引用.即在参数前加上.nst保留字。" ID="15">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000049" TITLE="2.1.3  集合运算举例" TYPE="Chapter">
        <fptr LogicalPageNum="49" PhysicalPageNum="49"/>
        <Paragraph CONTEXT="例2.f假定一个整型数组a[5125,38,19,42,33x州i0,r42，则对集合r的一组运算如下：lnitSet(rIC初始化r，使之为一个空集for(intice;ia5;iInsertSet(r,a[i向集合r中插入数组a中所有元素，：变为}25,38,19,42,33}DeleteSet(r,38从集合r中}除元素38.r变为‘25,19,42,33}bootb=InSet{r,y11判断Y是否属子集合r的元素，该函数返回真couta:LenthSet(r1出集合r的长度，其值为4InsertSet(r,x11向集合r中插入x元素，r变为《25,19,42,33,60资SartSet(r刀对集合r中的元索按值排序，使得值较小的元素序号C址arset（r）；刀清除r，使之变为空集{)例2.2假定课程（Course)记录的结构为；structCowie{clearName[201;11课程名称intCredit;11课程学分charTercher[lU11任课教师以Course为ElemType元素类型的一个集合s所含元素如表2-1所示..·数据结构" ID="1">
          <fptr EndPN="00000050" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="表2-1课程计划安排襄_l:拓函玉石二舀一一几万瓜丁石‘一1一一‘舀石二屯一丁丁一一一不二石‘石.―蛋耘翻gK习41xu―土一一一一一止‘一一一一一土下面给出对集合5进行的一组操作，首先定义具有C口盯SC记录结构的x，y.z对象并对其赋初值。course，1匆程序设计基础、刀给x的N知m。域赋初值" ID="2">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="cou队y－I勿英语.，6广劝曲沙加a“1；11给y赋初值cou二，1’‘数据结构”.5.户xuying.卜刀给：赋初值P劝以5峨5。x）；11从集合5中查找元素的关键字（即N吟域的值）刀等于x的N价域值的元素，由x返回该兀素的刀完整值，即1即程序设计基础“。4.匆x妞Ying即1Mod勿5以5，y）；ll用y值修改：中课程名称为“英语“的元素值.刀使得该元素值被修改为‘，英语丹，6，.ZhangHua.1Insen5et（‘欢11向集合。插入一条在2中保存的记录以上操作结束后，集合。的状态如表么2所示。衰2·2对5裸作后的结果" ID="3">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000050" TITLE="2.2  集合的顺序存储结构和操作实现" TYPE="Chapter">
      <fptr LogicalPageNum="50" PhysicalPageNum="50"/>
      <Paragraph CONTEXT="集合的顺序存储就是定义一个数组类型的对象来存储集合元素，同时要定义一个整第2章集合.37对象的定义假定如下：constintMaxSiz，20;11定义存储集合元素的数组的长度F1emTy}xaet[MzxSize11定义存储集合所有元素的数组int1en;11定义保存集合当前长度的变盆，取值在1-Max5izo之间集合中的元素可以按任何次序存入到set数组中，不妨按照元素在集合中的位置次序.之皇.望室荃11寸d.1台；千月毕由日n食食＿曰水石不.月络粗2健定葵11.1：去荟扭，八创，；井书毕0.f『nl由食自一月、；书刁毕之.相应保存到对应元素中.即第一个元素保存到下标为0的元素setlo】中，为了对集合的操作方便，可以把set数组和len变量封装在一个结构类型中，假别" ID="1">
        <fptr EndPN="00000051" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="构类型名用SetS表示，具体定义如下：" ID="2">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="所以若有新添的" ID="3">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="便假定结，回以女tsf" ID="4">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTy件Set［MaxS让" ID="5">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="卜若要对存储集合的数组空间采用动态分配，并且其数组长度能够随之改变.则可以定义出如下的结构类型：劝”ctset匆1E卜川了y件＊城未" ID="6">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="Ilset指向动态分配的数组空间。38·数据结构下面以SetSq为集合的顺序存储类型，给出每个集合运算的算法（即具体实现）." ID="7">
        <fptr EndPN="00000052" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="1.初始化集合为空此操作应把set指针置为空，同时分别把len和lu1siT置为0.表示建立一个空集合，并且不带有动态存储空间。" ID="8">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="void1nitSot(SetSq&amp;S)" ID="9">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="10">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="S.set=NULL;" ID="11">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="S.len=S.Max$iu闭;" ID="12">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="｝若初始化集合为空时，让s？指向动态数组空间，以便以后保存集合元素，则与上面函数重截（即函数名相同，但参数表不同，这是C语言新增功能，在C语言中必须使：名相同，但参数表不同，这是C＋＋语言新增功能，在Cvofdln滔et（SetSq及5，1ot叫）刀毗用于初始化MaXsi劝，叫的值要大于等于1｛" ID="13">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="1代砒。0）｛即川《”ms值非法.dl；e浏1）；111执行exi叹1）函刀数时退出程序运行，此函数包含于系统头文件就d】ib力中" ID="14">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="s.MaxS滋二陇；11盆集合空间大小为心" ID="15">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="5，胶卜们ew赚mTypellus］；11动态存储空间分配试！s.肥幻《11分配失败退出运行ce幻阿‘“存储空间用完！’r能耐1；" ID="16">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="cxit（1）；" ID="17">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="18">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="＆Ien二0；11初始里为空集合" ID="19">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="若存在则不能插入，返回第a章集合·39" ID="20">
        <fptr EndPN="00000053" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）集合长度增1;" ID="21">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="!cl;石Iei准犷习匕石书吩未xKtsri," ID="22">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）对应的算法描述如下：bOOllnse此e叹Sct匆及5.ElemTyl碑1咖）" ID="23">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="若inti；fb式1＝O；i＜s.len；i卡＋）刀元素已存在.返回假表示不用插入1氏5.sct［11＝幼妞动代切mfaise；试s.len二s.MaxS址）【11对空间用完进行处理口，一甲.一一。，口1.币甲.（、，一仁1。，，左3怕】翻的衡旧.上电七n.Ele.Ty讲气军mewElemType［2.5加七“Size＋1］；斌！P）《11分配失败退出运行cou峨“存储空间用完！“叼议泊dl；" ID="24">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="e欢（1）；l允di二0；1＜5.俪；1＋＋）刀把原空间内容复制到新空间中pli］资.Setlil；由1毗［］s.set；II释放原集合空间" ID="25">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="s.Set冲；刀使喊指向新集合空间" ID="26">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="5.Maxsi亦2’SMaxsi玲＋1；刀把集合空间大小修改为新的长度乡" ID="27">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="s.sct［s.Icn］＝1让m；II在末尾插入新元素" ID="28">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="s.len＋＋；刀集合长度增1比加m奴uc；刀返回真表示插入成功吞磨储1书石同盲习昌景翻1径尧诸什。芯不左" ID="29">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="l.bool〔七】以以让t（Sctsq＆5.欧田T月珍ite闹" ID="30">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="I" ID="31">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="化式inti二习；1＜5.1加；1＋＋）·40·数据结构if(i＜S.len)(11删除set[i］元素" ID="32">
        <fptr EndPN="00000054" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="S.set[i]绍.set[S.len-11;" ID="33">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="S.len一；爬扣m如粼刀删除成功返回真｝" ID="34">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturnfalse;删除失败返回假｝" ID="35">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="4.从集合中查找一个元素此算法首先从集合中顺序查找值等于待查值item的元素.item引用参数带回，并返回真表示查找成功；若不存在，通常传递给item的待查值是一个元素的关键字，把该元素的完整值赋给item带回，以便使用，如可以踢$Picture[00000054\00000054_new\0016.jpg]Picture$如可以通过item得到某个学生的成绩，某个产品的价格等。" ID="36">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="baolFindSet(SetSq&amp;S,ElemType＆itett｛for(inti二0;iS.len;iifiS.set[iitem}break;11若按某个域的值进行查找，则应比较该域的值.如S.set[iI.key二item.key比较的是Bey域的值." ID="37">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="刀特别地，若元素或域值为字符串时，则应使用字符串函数比较" ID="38">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="if(icS.len){" ID="39">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="item=S.set[i" ID="40">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="returntrue;" ID="41">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="42">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturnfalse;第2章集合.41boolModifySct(SetSq&amp;S,const©emType&amp;item){for(ird.ice;icS.len;i斗斗）11通常比较的是某个域的值。为算法" ID="43">
        <fptr EndPN="00000055" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="it(S.set(iitem)break;11简便起见则直接使用元素值比较if(i＜S.1en)t" ID="44">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="S.set[iitem;" ID="45">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="抢n肚刀臼ue;" ID="46">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="资" ID="47">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="48">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="returnfalse;" ID="49">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="》" ID="50">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="6.判断一个元素是否属干集合此算法比较简单.就是一个顺序比较查找的过程，此算法比较简单.就是一个顺序比较查找的过程，若找到则表明该元素属于这个集虎令肠后】官二王翩r刁（曰闷声书含木椒吞亩褥同舰合，boolIaSet(SetSgBtS,ElemTypeium]" ID="51">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="！for(intice;i＜S.len;i" ID="52">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="iP(S.set(iitem}returntrue:" ID="53">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="returofalse;l" ID="54">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="7.判断集合是否为空此算法很简单，若集合长度为0则返回真表示空，否则返回假表示非空." ID="55">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="baolEmptySet(SetSq&amp;S3" ID="56">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="【州比urnS.len&gt;州】;}" ID="57">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="8.求出集合中元寮个数.少·一一鱼鱼些到鱼一一一一returnS.len;" ID="58">
        <fptr EndPN="00000056" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="59">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="9.输出集合中所有元素依次输出S集合中set域保存的每个元素值即可。voidOutputSet(SetSq&amp;5)王" ID="60">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="for(intice;icS.len;icoutaS.set[i]《”," ID="61">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="coot«endl;" ID="62">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="63">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="10.求两个集合的并集该算法求两个集合S1和S2的并集，并返回这个并集。为此需要在算法中定义一个集合保存并集，假定为S。接着要对S进行初始化，使之带有用于保存集合的动态数组空间，再接着把集合51复制到V中，然后把S2中的每个元素依次插入到集合V中.当iii&quot;(Ki7r素不可能林捅入.最后存5中I到了51A7JJL的并集，把它返回即可。" ID="64">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="SetSqUnivnSct(SetSq&amp;St.SctSgdtS2)‘InitSet(S,Sl.ien始化S为空集，集合数组初始长度等于S1集合长度" ID="65">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;for{i习;i¢S1.len;i1151集合中的全部元素依次复制到5中" ID="66">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="S.set[i]＝S]set[i" ID="67">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="S.len二Sl.len;11里集合S的长度为St的长度for(i幼;iS2.len;i11向集合S中依次插入集合S2中的每个元素]nsertSet(S,S2.set[i二turn5;11返回并集S第2章集合·43每一个元素，利用它去查找S1集合，看是否存在，若是，则把它写入交集S中，这样写" ID="68">
        <fptr EndPN="00000057" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="a，二二习萝曰rl留口已n,nF3』已。n卫红.二竺=口I,1。日nSetSqIntet赎Set(SetSq&amp;S1.SetSq&amp;S2)" ID="69">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="70">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="SetSqS:int1cn;if(Sl.lencS2.len)1en＝51.len;olse1en=52.ien;initSet(S,1on交集的长度不会超过两集合中的最小长度" ID="71">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;" ID="72">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="ElcmTypcx;" ID="73">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="fot{l＝O;ic52.len;i{" ID="74">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="x二S2.set[iboosb=FindSet{S1,xittb);S.setCS.lenx;S.len)" ID="75">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="76">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="比加rnS;l对顺序存储的集合（数组）进行排进行排序分为升序和降序两种，通常是指按升序排rj大的次序排列数组元素，使之成为一个有序表.排序，即按元素或关键字的值从小到大的次序排列数组元素，开始时有序表中只有一个元素a[fl（一个元素自然为有序的）.无序表中包含有。一1" ID="77">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="把它插入到前面有序表中的.q,q·数据结构根据以上思路，编写出集合排序的算法如下：voidSottSet(SetSq&amp;S)" ID="78">
        <fptr EndPN="00000058" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="79">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j;" ID="80">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypex;for(i二1;icS.len;i11共循环n-t次【x=S.set[i11把无序表中的第一个元亲暂存xfar(j二i-1;jr-0;j一）11向前顺序进行比较和移动" ID="81">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCxaS.set[jj)" ID="82">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="83">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="S.set[j+11=x;11把x写入到己经空出的j+1位1｝" ID="84">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="争" ID="85">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="13.清除集合中的所有元紊在Set5q集合类型的对象中，由于集合数组空间是动态分配的，所以在清除集合时，voidC1earSet(SetSq&amp;S)" ID="86">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="87">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="if{S.setNiJiL){deleteS.set;IIY放动态数组空间" ID="88">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="S.set三NULL;1/置set指针为空" ID="89">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="S.len=S.MaxSize0;11里ten和iuaxsi的值同时为0｝" ID="90">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="｝在以上算法中，第1,7.8,13算法的时间复杂度为ocl)，第2,3,4,5,6,9算法的时间" ID="91">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="复杂度为O(n第10,11算法的时间复杂度为O(nln2)，第12算法的时间复杂度为10.11第s章集合。仍·" ID="92">
        <fptr EndPN="00000059" StartPN="00000058"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000059" TITLE="2.3  集合的链接存储结构和操作实现" TYPE="Chapter">
      <fptr LogicalPageNum="59" PhysicalPageNum="59"/>
      <Paragraph CONTEXT="集合的顺序存储结构是通过数组实现的，而集合的链接存储结构是通过存储节点之蛙注止雨的雄注瑕谕的姑且敌去翻生悴害若构成链接表中的每个存储节点包含有一个值域和一个指针域，而指针域指向的是下一个存储节点，则称该链接表为单链表.在一个单链表中，第一个节点被称为表头节点，指向第一个节点的指针被称为表头指针，最后一个节点被称为表尾节点，表尾节点在一个单链表中，除表头节点外，每个节点都由前一个节点的指针域所指向，第一当访问一个单链表时，只能从表头指针出发，首-e但err一水节占的灿tt卜住兽弓大闪技一木节先访问第一个节点，由第一个节点的指针域得到第二个节点的地址，接着访问；推，当一个集合利用单链表存储时，集合中的每个元素对应单链表中的一个节点，把这个元素存储到相应节点的值域中.由于集合中的元素是无序的，所有在单链表中可以按所有在单链表中可以按是把它插入到表头，即插入到第一个节点的前面，使它成为新的表头节点，而原来的表头节点" ID="1">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="成为第二个节点，此时只需要修改新插入节点的指针域，使其指向原来的表头节点，再" ID="2">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="修改表头指针，使其指向新插入的节点。由此完成节点的插入过程。当从单链表中删除" ID="3">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="一个节点时，就是把该节点的指针域的值（即后一节点的地址）赋给其前一节点的指针域即可，若它本身为表头节点，则应把该节点的指针域的值赋给表头指针.6R'奄习匕d8h2安启鑫成kX节1.ll咤之JV六nT.structsNode{ElemTypedata;）；" ID="4">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="其中sNode为节点类型，data为存储元素值的节点值域，next为存储下一个节点地。46。数据结构集合的链接存储结构示意图如图2.2所示。“一叫训粉｝.zI粉“·州a，l.洲知.1＋心一叫°&quot;按照集合的抽象数据类型的定义，假定集合存储采用单链表结构.由表头指针Head表示，下面给出对集合的各种操作在单链表上的实现." ID="5">
        <fptr EndPN="00000060" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="1.初始f空集合，即盆裹头指针为空voidInitSet(sNodeHead)11因为需要带回对实参的修改所以定义为引用{" ID="6">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="Head=NULL;" ID="7">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="8">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="2.向集合中播入一个元紊boolInsenSet(sNode+giHead,ElemTypeitettil【护隋可能改变表头指针并且需带回所以定义为引用11建立值为item的新li点" ID="9">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode+tp=newshade;" ID="10">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="iftp){" ID="11">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="coutac'‘内存无动态存储空间可用！&quot;acendl;" ID="12">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1" ID="13">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="14">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="tpdata=ium;11从单链表中顺序查找是否存在值为ium的节点sNode*p=Head;" ID="15">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pNULL){" ID="16">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="if(pdata=巴item)break;" ID="17">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="elsep刊少&gt;nexr" ID="18">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11若不存在则把新节点插入到表头并返回真，否则不插入并返回假if（户=NULL){" ID="19">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="tp-next=Head;" ID="20">
        <fptr EndPN="00000060" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="Head二tp;第2章集合。47" ID="21">
        <fptr EndPN="00000061" StartPN="00000060"/>
      </Paragraph>
      <Paragraph CONTEXT="化n肚”杠U侣；" ID="22">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="23">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturnfalse;" ID="24">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="25">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="3.从集合中删除一个元素bootDe!eleSetLsNodeHead,ElemTypeium){11从单链表中顺序查找是否存在值为item的节点sNode*p=Head,*q=NULL;whilc(pNULL){" ID="26">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="试卜洲加.司记m)break;" ID="27">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="dse{9=P；P二pnext;}｝It若不存在则返回假，表明删除失败ifCp=二NULL}returnfalse;刀从单链表中别除己找到的P节点，若它是表头节点则让表头指针指向刀它的后继节点，否则让它的前驭q节点的指针域指向它的后继节点if(q二=NULL}Headp-＞next;elseq-＞mxt叫少arext;" ID="28">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="刀删除P节点后返回真" ID="29">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="deletep;" ID="30">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="爬加m妞Ue；" ID="31">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="32">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="4.从集合中查找一个元紊boolFindSet{sNade*Head,ElemType&amp;item){II从单链表中顺序查找是否存在值为item的节点sNode*prliead;" ID="33">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="wluletp！二NULL{" ID="34">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="it(p-adata，item)break;" ID="35">
        <fptr EndPN="00000061" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="elsep二pnext;·48·数据结构｝11若存在由item带回已查找到的元素并返回真，否则返回假if(pNULL){" ID="36">
        <fptr EndPN="00000062" StartPN="00000061"/>
      </Paragraph>
      <Paragraph CONTEXT="iterrt=p一＞data;re加rntrue;｝" ID="37">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturnfalse;" ID="38">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="39">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="4.修改集合中的一个指定元紊bootModifySet(sNode*Head,constElemType&amp;item)（11从单链表中顺序查找是否存在值为item的节点sNade*p=Head;" ID="40">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pNULL){" ID="41">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="if{p-dataitem)break;" ID="42">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="elsep=p-＞nezt;" ID="43">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11若存在由item修改已查找到的元素并返回真，否则返回假if(p！一NULL)" ID="44">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="P-data二item;" ID="45">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="returntrue;" ID="46">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="47">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturnfalse;" ID="48">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="49">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="8.判断一个元素是否属于集合boolInSetisNade*Head,ElemTypeitem){" ID="50">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode*p=Head;" ID="51">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pNULL?{" ID="52">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="if（卜data=item)returntrue;" ID="53">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="elsep=p一＞next;" ID="54">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="｝第2章集合·49n鱿umfalse;" ID="55">
        <fptr EndPN="00000063" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="乡" ID="56">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="7.判断集合是否为空，为空返回真，否则返回假boolEmptySet(sNode-Head){returnHead-NULL;｝" ID="57">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="8.求出集合中元亲个数intLen山Set(sNode+Head}{" ID="58">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="intnom;sNode*p=Head:while(pNULL}{" ID="59">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="n十十；" ID="60">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="p=p-》nezt;｝" ID="61">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="抢扣mn;" ID="62">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="63">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="9.输出集合中所有元紊voidOctputSet(aNode+Head)《sNade*prFiesd:while(pNULL{" ID="64">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="coutacp-dataa;" ID="65">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="&gt;留p能欢｝" ID="66">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="cout《endl;" ID="67">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="｝i0，求两个集合的井集sNode*Uttion5et(sNock*Iieadl,sNode*Hcad2).‘50一鳌鱼&gt;一一一一一一一！11定义并集的表头指针Head并初始化为空sNode+Head二NULL;11把Head1集合单链表复制到Head集合单链表中sNode，p=Headl;" ID="68">
        <fptr EndPN="00000064" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pNULL){11建立新节点井赋值为pdata" ID="69">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode*newp=newsNode;" ID="70">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="newp一＞data=pdata;11把新节点插入到Head集合单链表的表头" ID="71">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="newp一＞next=Head;" ID="72">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="Headnewp:使P指向下一个节点" ID="73">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="p=p-＞next;" ID="74">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="}1巴Head2集合单链表中的每个元素插入到Head集合单链表中p=Head2;" ID="75">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pNULL){" ID="76">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="InsertSet(Head,pdata" ID="77">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="p=pnext;" ID="78">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="}11返回并集的表头指针HeadreturnHead:" ID="79">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="80">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="11.求两个集合的交集slYode*interseSet{sNode*Headl,sNode*Head2){11定义交集的表头指针Head并初始化为空sNode*Head二NULL;11把Head1集合与Head2集合中共同的元素插入到Head集合中ElemTypex;" ID="81">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="sNodewp=Head2;" ID="82">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="while{p！二NULL){第z章集合·siu将p-data赋给x" ID="83">
        <fptr EndPN="00000065" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="兀别卜习.场：" ID="84">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="11用x查找Headl集合" ID="85">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="饭泊1卜药n心以H改日1，x）；若查找成功则把x插入到Head集合中itCb)FaseitSet(Head,x" ID="86">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="11使p指向下一个节点" ID="87">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="p月少》川Rt" ID="88">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="89">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="万返回交集的表头指针价耐" ID="90">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="[UIIIHead;" ID="91">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝，Z.按元紊的位或关健字对集合排序此方法与在顺序表上实现有所不同。它首先建立一个空的单链表，作为生成的结果有序表，然后使集合单链表中的每个节点依次取出并插入到该结果有序表中。使得每次插入后仍然有序.当厦有的典合单锌表为空时，表明所有节点已插入到结果有序表中，至此排序结束。为了实现向有序单链表插入一个节点后仍然有序，首先要从表头开始为插入节点顺姆山摇久衍晋＿共右良苗胜妻七方跪大给入嘴七占记由右占.I.a二志五一幼占的才古油隆经史关人成七序查找出插入位置，若有序单链表为空或插入节点的值小于表头节点的值，则待插入节" ID="92">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="占1tia3Erf会全不Ir14AY4sp点层W左#'rl1trra#占8h.h4'.I.二口全tA#kX{h.l专扁eW介再?否则继续向后比较，直到待插入节点的值小于某个节点的值或比较完所有节点为止，此时待插入节点应插入到已找到的某个节点的前面或表尾。voidSort5et(sNode*dtHead){/1定义结果单链表的表头指针HeadX并初始化为空sNode*HoIdX目NULL;礴组用跳耐集合单链表中的节点建立有序的HeadX集合单链表目网侧犯＊产H。目；while(pNULL){-52·数据结构if(HeadX=NULL}{q一＞next-NULL;HeadX=q;}11若q节点小于HeadX的表头节点则q节点也作为表头节点插入elseitq一＞dataHeadXdata}{qnea声HeadX;HeadX;}ll#L'q节点插入到HeadX有序集合的适当位置else{11为了顺序查找q节点的插入位置·设np指向待比较节点，1/即指向其前驱节点，初始使ap指向HeadX的表头节点.11使np指向ap的后继节点sNode*ap=HeadX,*np=apnext;11进行顺序查找，循环结束后得到9节点的插入位置在llap节点和np节点之间，np节点可能为空while(npNULL)" ID="93">
        <fptr EndPN="00000066" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCq一＞datacnpdata)break;" ID="94">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="else{ap=np;np=npnext;}把q节点插入到ap节点和np节点之间qnext=np;" ID="95">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="apnext=q;" ID="96">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="97">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="｝把HeadX赋给Head，使Head带回已排序的集合Head=HeadX;" ID="98">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="99">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="13.清除集合中的所有元素，释放占有的动态存储空间voidClearSet(sNodeHead)" ID="100">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="！" ID="101">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="llp指向Head单链表" ID="102">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode*p=Head.*q;1/动态回收Head集合中的每个节点while(p！二MULL){第z章集合。53.qp-ncx七11q指向P的后继节点deletep;IIN1除P节点" ID="103">
        <fptr EndPN="00000067" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="p=q;11使P指向原来的后继节点" ID="104">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="；" ID="105">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="1/使Head为空" ID="106">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="H七创城呻山J七" ID="107">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="108">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="还可以进行散列存储和索引存储，应地也能够编写出在集合抽象数据类型中规定的各种操作的算法.相" ID="109">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="并且都比较容易写当然在实际应用中还接存储结构，从集合顺序表或单链从任一存储结构的集合中查找具有把一个顺序表或单链表表示的集合按某一条件分解为两个集合对其他任何操作的算法将不难编写出来。省；" ID="110">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000067" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="67" PhysicalPageNum="67"/>
      <Paragraph CONTEXT="l.集合是具有相同属性并能通过值或关健字相互区别的一组数据，数据之间不考虑存在任何联系，它们可以按任何次序排列." ID="1">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="2.时一个集合可以进行多种运算，如添加元素、侧除元素、查找元素。两集合并.两集合交等." ID="2">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="3.由于集合元素之间不存在任何逻辉联系，所以在计葬机中可以来用任一种存储结构进行存储，即顺序.链接、索引、散列等存储结构都适合午存储集合." ID="3">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="4.来用顺序存储结构存储一个集合时需要一个数组空间和一个长度指针，它们可以·抖·数据结构元素的位！即可，从健接表示的集合中侧除元素只要把后继节点链接到它的前软节.蔽即可。" ID="4">
        <fptr EndPN="00000068" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="7.数据的顺序存储结构又称为顺序表，桩接存储结构又称为桩接表。本幸讨论的是集合数据：以后将要讨论线性表.树、图等数据，它们都有相应的顺序表和链接表.叠习。2" ID="5">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="2.i通杯月" ID="6">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="1.在一个长度为二的顺序存储的集合中查找值为x的元素时，在等概率情况下.查找成功时的平均查找长度为（）." ID="7">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="A.nB.n/2C(n+lN2D.in-1)I21在一个长度为n的链接存储的集合中查找值为x的元素时，算法的时间复杂度为（）." ID="8">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="A.OiI)B.O(n)C.O(n*n)D.O(lo$zn)" ID="9">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="3.已知一个元素x不属于一个长度为。的顺序或链接存储的集合S中的元素，把它插入集合S的时间复杂度为（）." ID="10">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(1)B.o(logzn)c.O(n)D.oU*n1" ID="11">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="4.从一个长度为n的顺序存储的集合5中删除第k个元素“（k蕊n)时，其时间复杂度为（）." ID="12">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(1)B.O(iogzn)C.O(n)D.OfR*n)" ID="13">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="5.从一个长度为九的链接存储的集合S中姗除第k个元素（(1Skcn}时，其时间复杂度为（）." ID="14">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(1)B.Oiing，)CO(n)D.On)" ID="15">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="6.从一个顺序存储的集合S中形除第k个元素（(1簇k续5.len）时，所进行的操作为《）。.S.set(1ckSet[S.len-1LS.len一；" ID="16">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="13.S.set[kS.aet[S.kn-l5.len一：" ID="17">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="C.S.set(lc-lI.S.set[S.knS.1.一；" ID="18">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="D.S.lea一；S.set[k-1}S.sct[S.lcn-1？.己知一个元素苏不属于顺序存储的集合5中的元素：把它插入集合S的操作为《）。" ID="19">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="A.S.lenS.set[S.lankx;B.S.setS.len卜祝;" ID="20">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="C.S.set[S.len-1)nc;S.len十D.S.aet[S.lenx;S.kn只如一木荞丧，不尼4活睡士扭，奋续的生今公山的荞套U月牛" ID="21">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="8.己知一个元素x不属于,r.v.储的集合S中的元素，fiend为该集合的表头指针，把x擂入集合5的操作为（）.第2章集合·弱·" ID="22">
        <fptr EndPN="00000069" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="B.knewsNode;p-datax;少）nextRHead;Head;" ID="23">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="C.p=newsNode;padata=x;p-》鹅川卜Head-＞nezt;Headanext-p;" ID="24">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="D.p=nswshade;p-data=x;p-anexHead;Head=Head-riext;已知一个元素x属于链接存储的集合S中的元索，由P指向了，.已知一个元素x属于链接存储的集合5中的元索，由p指向了值为x的节点，由q指向了该节点的前驱节点.则从5中侧除元tx的操作为（）。" ID="25">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="A月－＞加笼怡卜》nex七山砚以eP；" ID="26">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="B.血1周匕p；今》此xl利卜＞加xt；" ID="27">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="C.卜＞nex怡叼，＞next；山且烈比哪" ID="28">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="D.q～＞nex怡p＞呱t；山】州暗p一＞next；育一个链接存储的集合5，HOKI洲" ID="29">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="10.育一个链接存储的集合5，HOKI为它的表头指针，若从中侧除第一个元素.则进行的操作为" ID="30">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="（）。" ID="31">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="A.H加d二H.日～知ex七山1州比H口日；" ID="32">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="B.H自日＝H。日.洲.笼咬；由如比H妇幻.》nex此" ID="33">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="C.卜H‘日；H。日二HoId.＞听欢创比P；" ID="34">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="D.少H政记。脱xt；业1州始H七翻d；He睡＞此又怡甲；" ID="35">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="11.有一个链接存储的集合5，H.日为它的表头指针，若从中删除p指针所指向节点的后继节点.则进行的操作为（）。＾.卜》n既件p＞胎双.＞next；山】引比p；" ID="36">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="B.妒卜加ext；介，献t阅。鹅茸仁del.p＞能欢" ID="37">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="CP－》。eXt钊卜》解xt.＞next；山1日比卜＞朋七0.中p.冲。斌介》n.戈同。解双；血1出q；工2城空瓜" ID="38">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="1.向顺序存储的集合中插入元素是把该元素插入到―." ID="39">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="2.向链接存储的集合中插入元素是把该元素的节点插入到―." ID="40">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="3.从顺序存储的集合中删除一个元素时只需要移动―一元幸。" ID="41">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="4.一个顺序存储的集合5的长度为＿，求集合5长度的时间复杂度为＿。" ID="42">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="5.求链接存储的一个集合的长度。的时间复杂度为＿." ID="43">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="6.由集合51和集合52的并得到的结果集合，其长度一参与运算的任一个集合的长度." ID="44">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="7.由集合51和集合52的交得到的结果集合，其长度一今与运算的任一个集合的长度." ID="45">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="8.设集合5的长度为几二判断x是否属干典合5的时闻百秦碑为" ID="46">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="8.设集合5的长度为爪.36.数据结构" ID="47">
        <fptr EndPN="00000070" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="12.假定开始建立的一个顺序存储的集合S为空.即S.len二S-MaxSizel，在向该集合不断插入元素的过程中，S.MaxSiu的值可能多次被修改，则第3次被修改后的取值为＿.ZJ运算越" ID="48">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="1.假定一个集合S二！23,56,12,49,35}采用顺序存储，若按照教材中的相应算法先向它插入元素72,再从中删除元素56.请写出运算后的集合Sa" ID="49">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="2，假定一个集合S23,56,12,49,35,48】采用顺序存储，若按照教材中的相应算法依次从中删除元索Sb和23,写出运算后的集合S3.12定一个集合S23,Sb,12,49,33}，若按照集合5中所给元素的次序通过调用擂入算法建立链接存储，即得到相应的单链表.再向它依次插入元素72和删除元素56，则给出运算后得到的对应集合S" ID="50">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="4.假定集合S123,56,12甲49,35｝和集合S223,12,60,38）均采用顺序存储，若按照教材中集合并的算法对S1和S2进行并运算，写出并运算后的结果集合。" ID="51">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="S.假定集合S123,56,12,49,35｝和集合S2二｛23,12,b38}均采用顺序存储，若按照教材中集.G交的算法对S1和S2进行交运算，写出交运算后的结果集合。石.假定两个集合单链表对应的集合分别为SI二{23,56,12,49,35｝和S2二！23,12,60,38}，若按照教材中集合并的算法对它们进行并运算，并运算后得到一个结果单链表，写出该单链表所对应的集合，" ID="52">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="7.定两个集合单链表对应的集合分别为S123,Sb,12,49,35}和52二{23,12,60,38}，若按照教材中集合交的算法对它们进行交运算，交运算后得到一个结果单链表，写出该单链表所对应的集合.2A算法分析瓜" ID="53">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="写出下面每个程序段的运行结果." ID="54">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="1.5etSqa;" ID="55">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="InitSet(a" ID="56">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="intr[811,5,90,5,7,25,34,16" ID="57">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;" ID="58">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i三4;ic8;iInsertSetl(a,r[i" ID="59">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="17eleteSet(a,zs" ID="60">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="DeleteSetfa,90" ID="61">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="OutputSet(arnatacEmptySet(a)a''ad.en山Set{a)endl;" ID="62">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="2.SetSqa;InitSet(a" ID="63">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="SetSqb;[ttit5et[b第2章集合·57inti,r[811,5,90,S,7,25,34,I6intr][6j二(5,6(1,16,30,34,8foe{i幻;it13;iInsert5etl(a,r{ifor(i司;i‘G;i1nscrtSctl(b,rl[iSetSq俘InterseSct(a,bOutput5et(c" ID="64">
        <fptr EndPN="00000071" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="ClearSex{c" ID="65">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="3.sNode*a;" ID="66">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="InitSet(aintr[1311,5,90,5,7,25,34,16inti;for(i＝O;i＜8;iInsertSet(a,r[iIklexeSet(a,25" ID="67">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="OutputSet(a" ID="68">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="4.slVode+a;IaitSet(ainti,r[8］二(1,5,90,5,7,25,34,15for{i动;i＜8;iIrtsertSet(a,r[isNode*b;InitSet(hintrl[51二{5,60,16,30,Sfor(i-0;i&lt;5;i＋十）InsertSel{b,rl(i]l:sNode*c=UnianSet(a,bOutputSet(c" ID="69">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="2占算法设计遨1‘修改从顺序存储的集合中删除元素的算法，当删除一个元素后检查集合数组空间的大小，若空间利用率小于4fl，同时数组长度大于10时则释放一半空间。" ID="70">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="2.编写一个算法，根据数组a中月个元素建立一个顺序存储的集合S" ID="71">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="3.编写一个算法，返回一个顺序存储的集合S中所有元素的最大值." ID="72">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="4.编写一个算法实现两个集合的差运算，假定集合采用颇序存储表示，分别为51和52，要求在·ss·数据结构s就地进行.即从中删除掉与sz集合中所有相同值的元素。" ID="73">
        <fptr EndPN="00000072" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="s.编写一个算法实现两个集合的差运算，假定集合采用链接存储表示，分别由Headl和hcad2表头指针所指向.要求在ilw单链表上就地进行，即从中,除掉与Head2单链表中所有相同值的节点。" ID="74">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="V.编写一个算法修改集合中值为x的元素，使它的值为原值的4倍。假定该集合采用链接存储结构，由表头指针H创日所指向。一衬邀" ID="75">
        <fptr EndPN="00000073" StartPN="00000072"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000068" TITLE="习题2" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000073" TITLE="第3章  线性表" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000073" TITLE="3.1  线性表的定义和抽象数据类型" TYPE="Chapter">
      <fptr LogicalPageNum="73" PhysicalPageNum="73"/>
        <div ORDERLABEL="00000073" TITLE="3.1.1  线性表的定义" TYPE="Chapter">
        <fptr LogicalPageNum="73" PhysicalPageNum="73"/>
        <Paragraph CONTEXT="线性表是具有相同属性的数据元素的一个有限序列。该序列中元素的个数称为线性‘磨蜂kf名.rF前LIE,n日日亡木rsn今之亨江翩；干害葬排抖志毛＿木表长度.线性表长度可以为0，表明它是一个空表，即不含有任何元素.若线性表为一个" ID="1">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="非空表，则一般表示为：（al如二，习线性表中的第一个元素al称为表头元素，‘称为表尾元素，线性表长度月大于等于" ID="2">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="即用一个标识符表示，此标识符通常采" ID="3">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="肠以国几山州峨及）" ID="4">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="其中·60·数据结构Rgar,tll成i城n-1}" ID="5">
          <fptr EndPN="00000074" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="对应的逻辑结构图如图3.1所示。线性表的逻辑结构是线性结构，它是线性结构的一种简略表示.如对于第1章中讨(O3,O1,03,08,02,07,04,06,09,10)因此，以后对线性表的讨论就代表了对任何线性数据结构的讨论。如人事档案表、职工工资表、学生成绩表、图书目录表、列车时刻表等。每一种这样的表通常都以记录登记的先后次序排列，或以关键字〔即某个域的值）升序或降序排列。如职工工资表按职工号字段的升序排列.学生成绩表按学生号字段的升序排列，列车时刻表按开出时间字段的升序排列等。线性表中的元素通常是变化的，但元素之间的逻辑关系应保持不变.当从一个位置上删除一个元素时，其后的所有元素都要依次前移一个位置，同样当向一个位置插入一" ID="6">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="个元素时，该位置及以后的所有元素都要依次后移一个位置。这是线性表同集合的区别所在，从集合中删除一个元素后，不需移动元素，只需简单地用最后一个元素来填补：向集合中插入元素不需要考虑插入位置，因而不需要移动任何元素，只要简单地放到尾部即可。" ID="7">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000074" TITLE="3.1.2  线性表的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="74" PhysicalPageNum="74"/>
        <Paragraph CONTEXT="线性表的抽象数据类型同样由数据和操作两个部分组成。数据部分为一个线性表，" ID="1">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="用标识符L表示，它可以采用任一种存储结构实现.操作部分与对集合的操作类" ID="2">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="假定用标识符似，包括插入、删除、查找、修改、排序、遍历输出等典型运算。利用这些典型运算的第3章线性表·blOperation:" ID="3">
          <fptr EndPN="00000075" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="voidInitList{List&amp;L" ID="4">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="初始置空线性表ElemTypeC,etElemLististBcL,intposy;得到线性表中第po：个元素的值" ID="5">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="intFindList(List&amp;L,ElemTypeitem万从线性表中查找第一个元素，返回该元素位置" ID="6">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="baolModifyList(List&amp;L,constElemType&amp;item川李改线性表中的第一个指定元素" ID="7">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="voidInsettI.ist(List6tL,ElemTypeitem11向线性表中插入一个元素" ID="8">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="6001DeleteList{List&amp;L,ElemTypeitem11从线性表中删除第一个值为item的元素" ID="9">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="toolEmptyList{List&amp;L" ID="10">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="11判断线性表是否为空" ID="11">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="intLenthList(List&amp;L" ID="12">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="刀求出线性表长度" ID="13">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="voidOittputList(List&amp;L" ID="14">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="刀遍历输出线性表" ID="15">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="voidSortList(List&amp;L刀按元素的值或某个域值对线性表排序" ID="16">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="voidCiearList(List&amp;L" ID="17">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="11清除线性表中的所有元素endSIaT" ID="18">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000075" TITLE="3.2  线性表的顺序存储结构和操作实现" TYPE="Chapter">
      <fptr LogicalPageNum="75" PhysicalPageNum="75"/>
      <Paragraph CONTEXT="同集合的顺序存储结构一样，线性表的顺序存储结构也是利用一个数组来实现的，为了保存线性表的长度也需要定义一个整数变量，同样也需要定义一个整型常量或变量来存储数组类型的长度，亦即所能表示的线性表的最大长度。这三个对象可以定义如下：·62数据结构线性表中的每个元素将依次被存入到一维数组list中，具体地说，线性表中第一个元.被存入到listf01中，第二个元素a被存入到listf11中，依次类推，最后一个元素‘被素a：被存入到list【0］中，第二个元素匆被存入到listlll中，依次类推，左入封1“。.rlo.＿.1山书守挂公桩习旨异去令间的捻杜右，良兰玄r日n御相置之间的下标顺序自然地反映出来，即11毗1］的前驱元素是它的前一个下标位置上的元素.耘fr；＿”居撰子妻早亡的层一木左启会衍弓睁卜的福于姿.：时r：‘11，口摇毛n的；带月俘侧斗右箭口目" ID="1">
        <fptr EndPN="00000076" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="Iist［卜11，后继元素是它的后一" ID="2">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="下标为len一的元素没有后继。" ID="3">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="为了对线性表操作的方便，通常把list数组和len变t定义在一个结构类型中，假定结构类型名用ListS表示，其定义如下：" ID="4">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="5公uctListS【intlen；告；若要对存储线性表的数组空间采用动态分配，并且其数组长度能够随之改变，则可以定义出如下的结构类型：stluctLis啊｛ElemTyl军＊list；11存线性表元素" ID="5">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="intl即；左存线性表长度】；使用此结构类型定义一个线性表对象之后，要使list指针指向大小为MaxS运的动态" ID="6">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="数组空间。" ID="7">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="以Listsq为类型的一个对象是线性表的顺序存储结构的实现，又称为该线性表的顺" ID="8">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="门二花井翻生d」宁尸吞」兰韶仁目巨乙评，1日币凶遥解岁公么‘任：圣去1卜J盗李二月之编南山，书刁1沪J，奋盗备阵困匕妇尾」七八人心自众主" ID="9">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="序表。第3章线性表·63下面给出重载的第二种置空线性表的算法.此算法带有动态存储分配.voidIaitList(ListSgBtL,intms)" ID="10">
        <fptr EndPN="00000077" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="《刀检查幽是否有效，若无效则退出运行if(mac0)[coot«&quot;。值非法！”心耐：ex城1）；｝11里线性表空间大小为ms" ID="11">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="L.MaxSizc二ms;了励态存储空间分配.若分配失败则退出运行" ID="12">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list+newElemType[ms" ID="13">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="1代！L.U动互" ID="14">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="份n阴眨“动态存储分配失败e”山幕" ID="15">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1" ID="16">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="17">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="刀初始t线性表为空" ID="18">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="L.len-0;" ID="19">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="20">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="2.得到线性表中第pos个元紊的值娜的有效值应大于等于1和小于等于线性表的实际长度。此算法的ElemTypcCietEiemList(ListSgdtL,intpos){" ID="21">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="刀检查州值是否在有效范围内，它应大于等于I同时小于等于线性表长度" ID="22">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="讯post1IIposL.len){" ID="23">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="coutac“所给元素下标值无效！即嘴Jendl;" ID="24">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="czit{l" ID="25">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11返回线性衰中第1个元'`的值.·数据结构头或表尾开始依次比较每个元素，直到查找成功返回该元素的位置。或者比较完所有元素没有挂到待杳元素.饭回一崎叫寺宁值〔如一1)表示杳找到失败为止。若线性表中的元素是按待比较的元素值或某个域值有序排列的，则可采用二分查找，$Picture[00000078\00000078_new\0005.jpg]Picture$二分查找只能在顺序存储的按待比较元素或某个域有序的有序表上进行，的查找方法。其查找过程是：首先让待查值同有序表的中点元素：比较，若相等则查找成功返回该元素的下标，结束查找；否则若待查值小于中点" ID="26">
        <fptr EndPN="00000078" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="则只需要在有序表的中点元素之前的半个有序表中继续进行二分查找即可.完全，点元素的后半个有序表中查找，因为待查值小于中点值的元素若存在只可能落在｝，或称左区间内，不可能落在右区间内；同样若待查值大于中点元素的值。则只二表的中点元素之后的半个有序表（即右区间）中继续进行二分查找即可。这样，：比较后都缩小一半的查找区间，当某一次比较时若相等则返回元素下标结束查元素）进行比较，元素的值，不需要在中点元素的后半个有序表中查找，前半区间内，或称左区间内，不可能落在右｝需要在有序表的中点元素之后的半个有序表征进行一次比较后都缩小一半的查找区间，找，若查找区间变为空.即不含任何元素，幻" ID="27">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="若查找区间变为空.即不含任何元素，则表明查找" ID="28">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="G成功，最差情况是经过lagZn次比较后成" ID="29">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="喇沁县奋，于.月毛，铭，盆全：丫当日阮.户次名胃乙丈止r卜._LLf3s" ID="30">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="功，平均情况的比较次数小于但接近lOg2n，查找不成功情况也必须经过1092。次比较。片耳二J一丈戈2凡士杆创朽厄衬，着基自台泊j到巨侧r故，口汁伦刃唯牙戈仁1鑫1晚，习，n自。.＿.、毛含业之岌七渔梦划巨1石配飞满准e平均情况的比较次数小于但接近logZn，查找不成功情况也必须经，二分查找的平均、最差和失败的时间复杂度均为0（logZn）。这联时证明此结论。由此可知.它比顺序查找的速度要快得多。如当。" ID="31">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="找最多需要比较11】刃次，而进行二分查找最多只需要比较10次。在类型为Listsq的线性表上进行顺序查找的算法描述为：" ID="32">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="所以，第3章线性表.6511求出中点元素的下标" ID="33">
        <fptr EndPN="00000079" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="intmidlow十‘ghU2;" ID="34">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="11查找成功返回元素下标位里if{item=L.list[midreturnmid;11继续向左半区间进行二分查找elseit(itemdlist[midhigh=mid-1;11继续向右半区间进行二分查找" ID="35">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="else1ow=mid+1;" ID="36">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="37">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="11查找失败返回一1" ID="38">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="代Uurn一】；｝假定进行顺序存储的有序表为〔12,15,24,36,40,48,G2,68,76,88)，则二分查找过下标0I23456789IS24364048626816881李1ow{二idfhigh[12IS24361404862687b8815243614048626876甘8奋mld［121524」6幻拐62鸽76朋l今h‘沙尽81介坛皿h朋24」6幻拐争而d121524肠们［拐62韶761215洲肠翻【相621“76，‘一，“·t56·数据结构" ID="39">
        <fptr EndPN="00000080" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="4.修改线性表中的第一个指定元素此操作要求从顺序存储的线性表中首先查找出满足查找条件的第一个元素，然后用该元素新的给定值修改原有值。查找过程可以根据具体情况选择顺序查找或二分查找。此操作的算法只要在相应查找算法的基础上略加修改即可得到。如采用顺序查找修改得到的第一个元素的算法描述如下：boolModifyList(ListSq&amp;L,toner©emType&amp;item)｛" ID="40">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="111序查找值为item的第一个元素井修改后返回" ID="41">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="比切口枉tte;" ID="42">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="矛" ID="43">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="刀修改失败返回假netutnfalse;" ID="44">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="5。向线性表中插入一个元紊向线性表中插入一个元素通常分为两种情况，－；条件插入，插入后线性表仍保持原来的有序性。一是按所给的元素位置插入，二是按" ID="45">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="羲奈翻十国与生丢岌七毛匕2‘」法a〕眨rn." ID="46">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="有序条件插入，插入后线性表仍保持原来的有序性。线性表插入与集合插入不同，它允" ID="47">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="许元素值或某个域值重复，所以在插入前不需要查找线性表。" ID="48">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="下面先给出在线性表的给定位置上插入新元素的算法." ID="49">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="voidNumberlnsertList(ListSq&amp;L,ELemTypeitem,intauttil" ID="50">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="51">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="11检查num的合法性" ID="52">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="if(numlIInum7L.len+1)[第3章线性表·67itClp){11分配失败退出运行" ID="53">
        <fptr EndPN="00000081" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="couta'‘存储空间用完！&quot;endl;" ID="54">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="CX11.1" ID="55">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="｝for(intice;iaL.len;i把原空间内容复制到新空间中" ID="56">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="p【1】礼.list【1」；deleteL.list;11放原线性表空间" ID="57">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list=p;11使if1指向新线性表空间" ID="58">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="L.MazSize=2+L.MaxSize+1;1/把线性表空间大小修改为新的长度｝11把新元素插入到线性表的第num个位t上for(inti=L.len-1;ixnum-1;i一）" ID="59">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list[i+l1=L.list[i" ID="60">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="L.liet[num-11=ium;" ID="61">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="L.len" ID="62">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="}假定线性表的长度为n，其插入位置有n+1个，当插入到第i个位置（l簇1续。＋l）时，需要后移，一i+1个元素，所以进行每次插入平均需要移动元素的次数为一，二L(n一己＋1＝二月＋lt1由此可知，此算法的时间复杂度为O(rt)下面再给出按元素值进行有序插入的算法，即在顺序存储的有序线性表上进行插入的算法。voidOrderlnsertList(ListSq&amp;L,ElemTypeitem)（11检查有无空闲位置，若己满则可退出运行.也可采用上面算法中11的处理方法，重新分配较大的存储空间if(L.lett-二L.MaxSixe){" ID="63">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="oouta“线性表空间满endl;exit{1】·68·数据结构，－－－－－－－－－－－－－，，" ID="64">
        <fptr EndPN="00000082" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="拍代1司：1＜Llen；1＋＋）itYitemL.Iist[ibreak;II相应元素后移，为新元素插入腾出位里" ID="65">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="for(」一ien-1;ji;j一）" ID="66">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list[j+11=L.list[j刀捅入元素后把线性表长度加1" ID="67">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list[iitem;" ID="68">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="L.len＋十；｝在该算法中，无论item的值最终插入到任何位置，假定在下标为i的位置，Q眨i" ID="69">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="L.len，则进行比较和移动元素次数之和不变，即为线性表的长度L.len加1，其中比较i+1次，移动n-i次.所有该算法的时间复杂度在最好、最差、平均等所有情况下均为O（陀），" ID="70">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="6.从线性表中删除满足条件的第一个元素从线性表中删除一个元素，可以是删除给定元素序号或下标位置的元素，也可以是删除具有给定值或关键字的元素.后一种情；置的过程。下面给出后一种情况的算法描述.boolDelateList(ListSq&amp;L,ElemTypeitem)｛" ID="71">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j;11顺序查找待删除的元素for(i动;icL.len;iit(L.list[i］二item}break;刀删除失败返回假if(i=L.len)returnfalse;11从下标i+1元素至表尾元素均前移一个位里" ID="72">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="for(j二i+l;jL.leo;j" ID="73">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list[j-IJ＝L·listlj］；第3章线性表·69-执行此算法时，为顺序查找待删除元素需要比较i+l次（(O簇i簇L.len-1为填补空一才户，粗醉进豆上乡；军.月毕令r司配，获公加十当乙玄）哎万卜国晚花宜白自台毛之刹－二，洲阮；井月穿右己冲；妥书亩匀晚出的位置，保持元素之间的线性关系不变，需要向前移动L.len-i-1个元素，要平均比较生里（‘十，）＝华个元索，需要平均移动生里（。一‘一1n^1个元素，比较和n高1n两1" ID="74">
        <fptr EndPN="00000083" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="移动的总次数不变，即为线性表的长度n.。等于L.len。所以此算法的时间复杂度为O（作）。" ID="75">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="7.判断线性表是否为空" ID="76">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="此算法要求若线性表为空则返回真，否则返回假。" ID="77">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="baolEmptyList{ListSq&amp;L)" ID="78">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="79">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="代扣mLlend;}" ID="80">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="8.求出线性表长度" ID="81">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="此算法返回线性表L的len域的值，即线性表长度." ID="82">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="intLentbLiat{I,iatSq&amp;L)" ID="83">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="84">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="retttrnL.len;二" ID="85">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="9.绝历输出线性表" ID="86">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="此算法要求依次访问线性表中的每个元素并输出它的值。在顺序存储中就是从下标0" ID="87">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="通尤拢，扇右瓦舌石钊的11蕊1目汁角岛山组瓦洲今，〕盯由于才分，月睁卜通见之宝配1于户瑞路矛肴." ID="88">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="开始，" ID="89">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="voidOutputList(I,istSq&amp;L)" ID="90">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="91">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="fot(inti-0;idlen;icoutacL.list[i]a''.。o·数据结构相同，要说区别只是在使用标识符上不同，但这是无关紧要的，因为它是人为命名的。书客阁受们堆精针椒吞的挑良曹妹白络千始旧山时蛛桩志的址序曾棘" ID="92">
        <fptr EndPN="00000084" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="11.清除线性表中的所有元紊.释放占有的动态存储空间" ID="93">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="voidC1earListlListSgdrL)" ID="94">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="95">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="ifl(L.listNULL){" ID="96">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="deleteL.list;" ID="97">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="L.list＝＝0;" ID="98">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="L.len二L.MeucSize幼;" ID="99">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="1｝" ID="100">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="上面只是介绍了对线性表操作的一些典型算法，同学们完全可以举一反三，编写出习比仁1门p勺目产J山乙卜匀‘钊目叨备名二二IJ.，山，子矛二Y卫二二AOh`J.Imh'Liy3碑甲ALb.ItLJ二/J.IYY.r=」匕hY41i.itlN.表进行其他任何运算的算法。如建立一个线性表的顺序存储结构（即麦之石名小；上J＿‘片、益肚加企习岛d匕空拿尹之‘食吞4.J乙力生占6于共，盛孚洲入翻斤配1怕1乏t月山浓全＿训入获把韶扣顺序表）的算法，统计出一个线性表中符合给定条件的元素个数的算法，删除一个线性位置上的元素值交换）的算法，按一定条件把两个线性表合并为一个线性表的算法等。" ID="101">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000084" TITLE="3.3  线性表的链接存储结构和操作实现" TYPE="Chapter">
      <fptr LogicalPageNum="84" PhysicalPageNum="84"/>
      <Paragraph CONTEXT="线性表的链接存储结构与集合的链接存储结构相同，都是通过单链表来实现的.线" ID="1">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="性表中的每个元素对应单链表中的一个节点，并且每个节点的指针域的值为其后继元素" ID="2">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="并且每个节点的指针域的值为其后继元素" ID="3">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="针域可以访问到后继节点，即后继元素所在的节点。存储线性表的单链表，其节点类型假定仍采用存储集合元素的节点类型，重写如下：structsNode{第3章线性表‘71相应的元素值。线性表中元素之间的线性关系通过单链表中节点指针域的链接关系反映出来。按照线性表的抽象数据类型的定义，下面给出在线性表的链接存储结构（即单链ruI3r，J团笋}l_，L····、Lr_1+，t1bsllw.14JJlad4表，，.初始t空线性表.即把对应单链裹的裘头指针t空" ID="4">
        <fptr EndPN="00000085" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="voidInitLisKsNode+dtHI" ID="5">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="f" ID="6">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="HIrNUiL;｝对单链表中的节点只能顺序存取，扫即访问前一个节点后才能接着访问后一个节点，直接〔即按下标）存取。所以要访问单链表中的不像顺序表〔数组）中的元素那样可以直接〔即按下标）存第p0&amp;个节点的值（即对应线性表中的第Pag个元素的值），第pos个节点的值（即对应线性表中的第pos个元素的值），必须从表头指针开始依次访" ID="7">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="门右王2凡成专占古劝1书去翩蟹～。式、嘴禽占牛.卜当～的洁，l’月p.甜十二「.蜂桩妻的裕亩叶＿丽1" ID="8">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="直到访问第pos个节点为止.当Pos的值小于1或大于线性表的长度时，则山熟声二千2弓流.志4石后1佑.。。月卜幼古的倩取值无效应退出运行，" ID="9">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="E晓叔y娜0即日e沉以献sN以k＊班内int详冷）" ID="10">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="11">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode.户HL；" ID="12">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="inti司；11从单链表HL中顺序查找第po‘个节点whit两！＝NULL）《1找1今卯5）加巴山；沪介＞next；" ID="13">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="｝·72·数据结构" ID="14">
        <fptr EndPN="00000086" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="3.从线性表中查找满足条件的第一个元素，该元素位由引用参数带回无论单链表中的节点是否按值或某个域值有序，也就是说，无论是有序单链表还是" ID="15">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="无序单链表，由于对节点只能按照链接方向顺序访问，不能随机访Pp7和直接存取，所以" ID="16">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="只能采用顺序方法查找单链表.而不能采用二分查找方法查找单链表.从单链表中查找" ID="17">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="到的元素可以由引用变量带回，也可以返回节点值或地址，这里假定由引用变量带回，并且当查找成功时返回真，查找失败时返回假。此算法与在集合单链表上进行查找的算" ID="18">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="4.修改线性表中的第一个指定元紊此算法也与修改集合单链表上一个指定元素的算法相同。" ID="19">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="向线性表插入一个元紊" ID="20">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="向线性表插入一个元素可以插入到任何指定位置或满足一定条件的位置，若对插入第3章线性表·73" ID="21">
        <fptr EndPN="00000087" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="HL-newP;" ID="22">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="沈turn:" ID="23">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="）11从单链表YL中顺序查找值为item的节点shade+4=M'P°4-next;while(p二NULL){" ID="24">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="ifl(item《p-data)breslk;" ID="25">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="q二p；" ID="26">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="p=p-》next:" ID="27">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="｝1/把新节点插入到9节点和P节点之间，P可能为空，此时9指向尾节点tiewp-＞next甲;" ID="28">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="ganext二newp;" ID="29">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="30">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="8.从线性表中姗除一个元素此算法与在集合单链表上删除一个元素的算法相同，当然使用的一些标识符不同，请同学们自己编写出来。" ID="31">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="7.判断线性表是否为空boolF.mptyLst(sNodef-IIf" ID="32">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="rcturnHL=NUI工；" ID="33">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="34">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="8.求出线性表长度在线性表的链接存储结构中没有定义保存线性表长度的地方。所以要求其长度.必然后返回统计结果.此算法就" ID="35">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="9.遮历翰出线性裹此算法与输出集合单链表中每个节点值的算法相同，当然有些标识符命名不同。" ID="36">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="voidDutputList{sNodc+1-IJ·74·数据结构sNode*NHL;" ID="37">
        <fptr EndPN="00000088" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="while(pNULL?" ID="38">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="coutap-data峭‘‘’," ID="39">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="}＝卜＞next;" ID="40">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="41">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="cout司‘endl;" ID="42">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="43">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="10。按元素的值或关键字对线性衰排序$Picture[00000088\00000088_new\0011.jpg]Picture$行两种不同要求的排序。一种是就地进行，即仍毛阵序。一种是就地进行，即仍使用原有存储1另一种是按原有节点的值重新产生新节点，的链接关系实现；表。第一种情况在上一章对集合单链表的排序中已经给出，法。sNnde*SortList(sNodeMHL)" ID="44">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="套11定义一个新单链表的表头指针并初始化为空sNode.HLX;" ID="45">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="InitList(HLX11根据原单链表HL建立新的有序单链表HLX" ID="46">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode*p=i-IL;whiletp！二NULL}" ID="47">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="11把P节点的值t入到结果有序单链表HLX中" ID="48">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderInsertList(HLX,pdatallp指向下一个节点" ID="49">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="p=p-＞next;" ID="50">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="｝返回结果有序表HLXreturnHLX:第3章线性表·75！" ID="51">
        <fptr EndPN="00000089" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="sNod七.沪HL，阅；" ID="52">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="while(p！二N[JC,Lq=p;11由q指向待删除节点，以便系统回收" ID="53">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="p，卜》next;IIp指向下一个节点" ID="54">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="deleteq;11释放q所指节点的存储空间" ID="55">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="56">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="HL=NULL;" ID="57">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="58">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000089" TITLE="3.4  线性表的其他链接存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="89" PhysicalPageNum="89"/>
      <Paragraph CONTEXT="线性表的链接存储结构有单链表结构和双向链表结构两种。就单链表结构而言，上循环单锥裹.即单琳表的夫尾节点的指针域不是空。而是指向表头节点的指针.如图3.3(b)而是指向表头节点的指针，所示。变种之二是带附加头节点的单链表，它的表头指针不是直接指向表头节点（即第一个节点），而是指向一个“无意义”的节点，节点的非空单链表和空单链表分别如图3.3(c)和图3.3(b)所示。变种之三是带头节点的循环单链表，它同带头节点的单链表的区别仅在于表尾节点的指针域不是空而是指向头节点.带头节点的循环单链表的非空表和空表分别如图3.3(e}和图3.3(f)所示。ca）一舰形式的单桩农。76·数据结构分表头节点和非表头节点的情况，因为都不涉及修改表头指针的问题.另外.当遍历一个带头节点或不带头节点的循环单链表时，判断是否访问完最后一个节点的条件，不是双向链表也是线性表的一种存储结构。在双向链表中每个节点除了具有保存元素的用以指向其后继节点.双向链表也可以带头节点，head" ID="1">
        <fptr EndPN="00000090" StartPN="00000089"/>
      </Paragraph>
      <Picture URL="00000090\00000090_new\0012.jpg">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Picture>
      <Paragraph CONTEXT="似），头节点的双向.耳空农" ID="2">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="‘神为伍优熙全箕蓦" ID="3">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="(e）带头节点的侧环双向健夜" ID="4">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="图3.4各种形式的双向链表" ID="5">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="对任一种形式的双向链表很容易进行插入和删除，假定要在P指针所指向的节点之后" ID="6">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="插入一个9指针所指向的节点，并假定它前后均存在节点.则操作步骤为：门、柿。节占的庆傲节占比去。常占的居嫩啥占.一一一一一一」绝皇.竹." ID="7">
        <fptr EndPN="00000091" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="链接表画法." ID="8">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Picture URL="00000091\00000091_new\0004.jpg">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Picture>
      <Paragraph CONTEXT="P（.），汇卫口津〔匡巳娜二亚女一" ID="9">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="(C)图3.5在双向链表中插入节点的示意图当插入点的前面或后面不存在前驱或后继节点时，操作步骤有所不同，请同学们思现.考。" ID="10">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="当删除P所指向的节点，并假定存在其前驱和后继节点时，则操作步骤为：" ID="11">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="盘忆r比七人人谧嗜r介口J全J匕诵沪、.子‘召匕去儿J曰睁才目‘.‘占卜.声，」礴J卜山‘一一‘一‘使之指向P节点的后继节点：p-rightalefh争aleft;血】创比p:当要求删除P节点的前驱节点或后继节点时，请同学们给出相应的操作步骤。当被侧映节占干前璧节占赤居胜节占时＿到几作牛璐右.彭下曰；出曰理，介，困书" ID="12">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="请同学们思考." ID="13">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="实际上还可以采用数组·78·数据结构由数组元素构造单链表的所属数组类型可定义为：typedefALNodeALirelcList[MaxSi二］；即ALinlcList被定义为包含有MaxSize个元素的、元素类型为ALIiOde的数组类型.；类型的对象（即数组）存储单链表时，通常下标为0的元素不作为单链表中的节点MaxSize-1个节点.另外.当一个节点无后继节点时，数组最多能够为建立单链表提供其指针域应被赋予数值d.表示空图3.6(a）就是利用ALinkList类型的数组建立单链表的情况，表头指针为下标a位置中next域的值4，图3.6(b)为单链表的结构示意图，表头指针用f表示，每个指针上图3.6利用数组建立单链表示意图从图3.6(b)可以清楚地看出，该单链表中各数据元素之间的逻辑顺序为：" ID="14">
        <fptr EndPN="00000092" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="44,50.57,62,68.75,83,94" ID="15">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="在由数组建立一个单链表时，通常还需要把所有空闲元素链接起来构成一个空闲单链$Picture[00000092\00000092_new\0018.jpg]Picture$空闲单链表的表头指针也需要用一个元素节点的指针域保存起来，假定使用1号（即为1)的指针域。在这种数组中链接存储的线性表的长度至多为MaxSize^2，因为0,号元素均被表头指针所占有。当对整个数组进行初始化时，不仅需要置单链表为" ID="16">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="表，下标为" ID="17">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="号和" ID="18">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="空，即把0赋给0号元素的指针域，而且要把全部MaxSizc-2个空闲节点链接起来构成空闲单链表.同时把它的表头指针（即2)赋给1号元素的指针域。对数组进行初始化后第3章线性表·79元素单链表中删除一个元素节点时，首先从元素单链表中取出（摘下）这个节点，然后再把该节点插入到空闲单链表的表头。数组中的元素单链表和空闲单链表的节点总数，在任何时候都等于MaxSize-2，当空闲单链表为空时，则元素单链表为满，此时无法再向它插入新节点。例如，在图3.8所示的数组中.链接存储的线性表为（35,68,57,26,70)，空闲单链表中依次包含有3,5,8号元素节点.这里假定MaxSiz.e＝1001234S6189慧日洲侧洲洲洲一赶步盔图3.8元素单链表和空闲单链表的变化状态由于下标为0的元素节点的指针域保存元素单链表的表头指针，所以该节点成为元由此构成带表头附加节点的循环单链表。空闲表的最后一" ID="19">
        <fptr EndPN="00000093" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="个节点的指针域也应置为整数0表示空指针，的循环空闲表。对于独立分配存储空间的节点，通常由伟" ID="20">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="通常由指针所指向。假定使用的指针为p，则＊P就表示该节点。：节点。卜洲组扭和妙next就分别表示该节点的数值域和指针域。对于数组中的元" ID="21">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="。，它是由数组名和下标值标识的，假定数组名为a，下标值为k，则alkl就表示该" ID="22">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="a阅.data和a压］.ncxt就分别表示该节点的数值域和指针域，元素单链表的表头指针1刀exl，空闲单链表的表头指针为alll.next。了解独立节点和元素节点在访问上的差素节点，节点，为a［0」刀exl，空闲单链表的表头指针为alll.next。了解独立别后，" ID="23">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000093" TITLE="3.5  线性表应用举例——多项式计算" TYPE="Chapter">
      <fptr LogicalPageNum="93" PhysicalPageNum="93"/>
      <Paragraph CONTEXT="由数学知识可知，一个多项式烈力的一般表示为：·gp·数据结构doublePolySuml(I.istSgBcP,doublex)《11用，um计算累加和.首先把常数项匈的值赎给它作为其初值doublesum二P.list[01;11用w计算x的次幕，初值为1doublew=1;ll加计算多项式的值fot(inti=1;i＜P.len;i计算出x的i次幕" ID="1">
        <fptr EndPN="00000094" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="wX；刀把一个新的累加项街：‘的值累加到：，中" ID="2">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="sum＋二P.11哎1］＊w；｝刀返回求出的多顶式的值returnsum;" ID="3">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="咨若多项式线性表采用链接存储结构，则算法描述为：doublePolySuml(sNode*P,doublex)【刀用t指向多项式单链表的表头节点sNada+t二P;11用sum计算累加和，首先把常数项eo的值赋给它作为其初值doublesum二tdata;11用w计算x的次幂，初值为1doublew=1;刀使：指向第二个节点，即值为a，的节点t-t-＞next;/1累加计算多项式的值while(t二NULL){" ID="4">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="ll便w票乘x" ID="5">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="W＊二笼：护肥一个新的累加项的值果加到aum中" ID="6">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="sum+一data*w;第3章线性表·81方使t指向下一个节点" ID="7">
        <fptr EndPN="00000095" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="t＝＝tnext;" ID="8">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="}刀返回求出的多项式的值returnsum;" ID="9">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="）假定一个多项式为5+3x2-6x+2a，对应的线性表为（5,d,3，一6,d,2}，若采用链接存储，" ID="10">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="voidmain" ID="11">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="12">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="3N侧ie*a;" ID="13">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="InitList(adoubler[615,0,3，一6,0,2inti;fodi=5;ir0;i一）FirstInsertListia,r[i!1按逆序依次在" ID="14">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="刀表头插入，得到按正序链接的单链表伪”摊“线性表a：”,a:," ID="15">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="OutputList(acoutLenthList{a}aendl;doubley二Poly$uml(a,2cout炙y《endl;" ID="16">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="ClearList(a" ID="17">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="乡" ID="18">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="则得到的运行结果为：" ID="19">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="线性表a:503-602" ID="20">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="6" ID="21">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="33在一个多项式中，往往会出现许多缺项，如Pr1+6af-3x12+7x60，其中只有4项，示，该线性表·82·数据结构升序排列，它是按指数有序的一个有序表。卜抉解介之YSr,才f.i;寺劫公叔卜月昌国旨；菩牛＿" ID="22">
        <fptr EndPN="00000096" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="1,0{6,53,12{7,60若把线性表中的元素类型定义为几n的结构类型，则描述为：" ID="23">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="structTerm{" ID="24">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="doublecoef;11系数" ID="25">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="intexp;11指数" ID="26">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="" ID="27">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="通过如下的定义语句：typedefTermElemType;就把Term类型与通用的线性表元素类型E]emType联系起来。下面给出利用顺序存储结构存储这种线性表的多项式求值的算法。doublePolySum2(ListSq&amp;P,doublex)！" ID="28">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="给作为累加变量的sum赋初值为0" ID="29">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="doublesumma;" ID="30">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="累加计算多项式的值" ID="31">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="for&lt;inti=0;i＜P.len;i{" ID="32">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="刀把一个新项的，的指数赋给Y" ID="33">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="inty二P.list[iexp;sum+二P.list[iI.coef*pow(x,y" ID="34">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="pow是求x的y次幂的函数.在math.h头文件中有定义" ID="35">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="36">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="u返回所求结果returnsum;｝下面再给出利用链接存储结构存储这种线性表的多项式求值的算法.第3章线性表·83sNode，tP;" ID="37">
        <fptr EndPN="00000097" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="doublesum=0;" ID="38">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="while(tNULL)" ID="39">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="inty=t-＞dsta.eap;" ID="40">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="sum》data.coef+powGt,y" ID="41">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="t二比.＞n巴Xt；" ID="42">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="43">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="returnsum;" ID="44">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="｝假定采用下面主函数来调用求顺序存储的多项式的值的算法.voidmain" ID="45">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="百" ID="46">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="ListSqal,a2:LritList(al,5InirList(a2,5Termrl[415,0{3,2！一6,3{2,5Termr2[41二1,0{6,53,12{7,60inti;fot{i闭;ic4;i＋十）NutnberInserrList(al,rl[ii+1fot{i闭;ic4;iNumberInsettList(a2,i2[ii+1couta“线性表：1:t7utputList(alCout”线性表a2,utputList(a2doubley1三PolySum2(al.2doubley2-PolysumZ（aZ。2）；coutv:yl《'ay2®:endl;ClearList(alC1earList(a2｝执行这个主函数将得到的结果为：线性表a1:5032-6325线性表a2:1065-312760330704Se+018·84·数据结构当然，由于把结构类型Term作为线性表中的元素类型ElemType使用，所以在整个程序中必须包含有相应的运算符重载函数的定义.使得元素之间的小于、等于，插入等运算是有效的。若是在C语言环境下运行，因为不支持运算符重载函数的功能，所以必" ID="47">
        <fptr EndPN="00000098" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="须修改相应的算法，让进行比较的是元素的某个域的值（如exp域的值），而不是整个元改相应的算法，让进行比较的是元素的某个域的值（如exP域的值），而不是整个元.让输出的依次是元素的每个域的值，同样不允许输出整个结构元素的值。素值.项式。项），则把它直接复制到结果中。如：尸la）＝5＋3尹一口＋厅" ID="48">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="PZ曰＝3科x一趾2斗犷一厅＋gxe因为每个单链表都是按指数域的值有序的单链有序表‘所以此相加过程就是两个单’序表的合并过程，当然要遵循多项式相加的合并规则。链有序表的合并过程，型要设计此题的算法，和tZ分别指向两个多项式单链表PI和PZ" ID="49">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="P3作为结果单链表：接着当tl和tZ所指" ID="50">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="节点非空时，" ID="51">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="值插入到P3单链表中，让fl和口指针作适当后移，以便向下继续比较和处理；最后当第3章线性表.那.}11将t2所指节点的值按指数有序插入到p3单链表中elseif(t1-data.expt2-data.exp)" ID="52">
        <fptr EndPN="00000099" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderlnsetL.ist(p3,t2一＞data" ID="53">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="t2-t2一＞next;" ID="54">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="｝1J将tl和t2所指节点的值合并后按指数有序插入到p3单链表中else{" ID="55">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="doubleatl一＞data.coef+t2-xIata.coef;" ID="56">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="ifa？司}{" ID="57">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="乡" ID="58">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="t1=t1anext;" ID="59">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="d二已一冲e从；" ID="60">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="61">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11将pl单链表中的刹余节点复制到p3单链表中while(tlNULL){" ID="62">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderInsertList(p3,tIadata" ID="63">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="t1=t1-next;" ID="64">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="资11将p2单链表中的剩余节点复制到p3单链表中while(t2！二NULL){" ID="65">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderlnsertList(p3,t2-＞data" ID="66">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="仓司公》帐沐七" ID="67">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="68">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="返回结果单链表的表头指针p3" ID="69">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="花turnp3;" ID="70">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="}此算法需要依次扫描两个单链表中的每个节点，并每次把一个节点的值或两个对应节点的合并值按指数有序插入到结果单链表中.设两个加数多项式的单链表长度分别为·86·数据结构因为每次都插入到结果单链表的表尾，整个算法的时间复杂度为以伽栩))若每次向结果单链表插入时不是调用OcderInsertList函数。而是设法记住结果单链表的表尾节点的位置，直接把新节点链接到表尾.这样插入每个节点的时间复杂度为o(I)，整个算法的时间复杂度就变为O(m+n)，从而大大提高了算法的时间效率。下面的算法就是按这个思路设计的。" ID="71">
        <fptr EndPN="00000100" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode.PolyAdd2(sNode*pl,sNode*p2)｛11定义结果单链表F3，并让它指向附加头节点，这是为处理上的方便" ID="72">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode«p3;" ID="73">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="p3=newsNode:11分别定义tl,t2和t3指针.初始分别指向p1.p2和p3单链表shade*t1=pl,*t2印2,wt3=p3;" ID="74">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="11当两个表同时不空时的处理过程" ID="75">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="IPAtl所指节点的值赋给t3节点的值域.tl指针后移" ID="76">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="if(tlclataexptt2data.exp){" ID="77">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="t3=t3一＞nex怡newaNode二11p3单链表的尾部插入一个新节点，并使t3指向它t3data=tldata;" ID="78">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="tl.l一＞next;" ID="79">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="80">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="11将t2所指节点的值徽给t3节点的值域，t2指针后移" ID="81">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="elseif(t]一》data卜exp&gt;t2-daUl.exp)t3减3next=newsNode;日一闭.恤二叹）司.试" ID="82">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="t2减2一＞next;" ID="83">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="}第3章线性表·87" ID="84">
        <fptr EndPN="00000101" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="85">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11将pl单链表中的剩余节点复制到g3单链表中whilc{t1){" ID="86">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="t3二t3nextnowsNodo;" ID="87">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="t3-datat卜＞data;" ID="88">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="tl=t1next;" ID="89">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="）11将P2单链表中的L.余节点复制到p3单链表中while(t2){" ID="90">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="t3二口一&gt;nezt=newsNode;" ID="91">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="t3data-己data;" ID="92">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="t2二t2-next;" ID="93">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="l将p3单链表的表尾节点的指针域置空t3-＞next=NULL;1/让。指向P所指的附加头节点，以便删除t3=p3;11使g3指向结果单链表的第一个元素节点p3＝＝3一＞next;" ID="94">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="川译放原附加头节点deletet3;11返回结果单链表的表头指针g3" ID="95">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="re加mp3;l花五寸汗竺男习匕口+ar,妇乌a,Ifh心皇r七xm岁当亩女洲入;Y右O'兰纽c今弓它日frn3L#kmi该全ika,tom-1苗盆活：习匕飞，目今使P3单链表又成。SB·数据结构voidmain" ID="96">
        <fptr EndPN="00000102" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="97">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="shade*a,*b;InitList(aInitList(bTermra[41{5,a{3,2{-6,3{2,5}Termrb[b{3,0{4,12,2{3,3【一2，5｝.毛9，6｝）；inti;for(i二3;i»0;i一）FrstInsertIist(a,ra[ifor(i=5;i＞司;i一）1=1rstlnsertList{b,rb[icout“线性表a:”,OutputList(acoutac”线性表b,OutputList{bshade*c-PolyAdd2(a,b11st者使用PalyAddl(a,b）调用cout”线性表c:”,putputList{cC1earList(aC1earList(bC1earList(c}主函数执行后的结果如下：线性表a:5032-6325线性表b:3041-2233-2546线性表c:804112-334b" ID="98">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000102" TITLE="3.6  广义表" TYPE="Chapter">
      <fptr LogicalPageNum="102" PhysicalPageNum="102"/>
        <div ORDERLABEL="00000102" TITLE="3.6.1  广义表的定义" TYPE="Chapter">
        <fptr LogicalPageNum="102" PhysicalPageNum="102"/>
        <Paragraph CONTEXT="广义表（Lists〕简称表.它是线性表的推广。一个广义表是n(ntea)个元素的有限序列，当n时则称为空表.这同线性表的定义是一致的。但在一个非空的广义表中，其元素可以是某一确定类型的对象（这种元素被称做单元素）.也可以是由单元素构成的表定义是递归的，广义表是一种递归的数据结构.第3章线性表·89设街为广义表的第i个元素，则广义表的一般表示与线性表相同：（a1，处，…，称取1，·…‘）即广义表中所含元素的个数，其中n表示广义表的长度，即广义表中所含元素的个数，n）0a同线性表一样，也可以用一个标识符来命名一个广义表，如用IS命名上面的广义表，则为：'LS城ai,az,a.ar+a,‘一，a)为了把单元素同表元素区别开来，" ID="1">
          <fptr EndPN="00000103" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="在广义表的讨论中.为了把单元素同表元素区别开来，一般用小写字母表示单元" ID="2">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="田1一它生之召年习旨福落幼落石口." ID="3">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="素，用大写字母表示表，如：A}Be)C二（a,(b,c,dDMA,B,C(e(a,(b,c.d今（（氏（氏b），（（a，b），c）））其中A是一个空表，其长度为a:B是一个只含有单元素e的表，其长度为l;c中只、二二月匕＿训凡曰＿白与二二若层.＿「1＿试凡目目致二二月毕，‘＿J、门人人夕－目‘习闷内六日，.云二一2、二二有两个元素，一个是单元素a，另一个是表元素（b,c,dC的长度为2:D中有三个元" ID="4">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="素，其中每个元素又都是一个表，D的长度为3;E中只含有一个元素，该元素是一个" ID="5">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="表，该表中包含有三个元素，其中后两个元素又都是表。把每个表的名字（若有的话）写在其表的前面也是（若有的话）写在其表的前面也是一种表示广义表的方法，对于上A()B{c)C(a,(b,c,d以（a.（a，b），（（a，b），c）））若用圆圈和方框分别表示表（表元素）和单元素，并用线段把表和它的元素（元素而的罕韦树峙常占冲丰苗于丧当今倪性称的户汀丰抹习雪卜卜·如·数据结构即一个空表，表尾为（B,C)，它还可以分解为表头和表尾：E的表头为（(a.(a,ba,bc，表尾为空表（）。图3.9五个广义表的图形表示一个表的深度是指该表中括号嵌套的最大次数，在图形表示中，则是指从树根节点到每个树枝节点（即表节点）所经过的节点个数的最大值。如表A和H的深度为1，表" ID="6">
          <fptr EndPN="00000104" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="C,D,E的深度分别为2,3和40" ID="7">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000104" TITLE="3.6.2  广义表的仔储结构" TYPE="Chapter">
        <fptr LogicalPageNum="104" PhysicalPageNum="104"/>
        <Paragraph CONTEXT="广义表是一种递归的数据结构，因此很难为每个广义表分配固定大小的存储空间." ID="1">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="在一个广义表中，其数据元素有单元素和子表之分，所仁$Picture[00000104\00000104_new\0004.jpg]Picture$存储节点也有单元素节点和子表节点之分。对于单元素节点，所以在对应的存储结构中，其" ID="2">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Picture URL="00000104\00000104_new\0007.jpg">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Picture>
        <Picture URL="00000104\00000104_new\0008.jpg">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Picture>
        <Paragraph CONTEXT="素节点和子表节点之分。对于单元素节点，应包括值域和指向其后继于子表节点，应包括指向子表中第一个节点的表头指针域和指向其后为了把广义表中的单元素节点和子表节点区别开来，还必须在每个节" ID="3">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="域，让标志域取两种不同的值，从而区分两种不同的节点。节点的指针域：对于子表节点，继节点的指针域。" ID="4">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="点中增设一个标志域，" ID="5">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="根据分析，广义表中的节点类型在c或c+＋语言中可定义为：stnectGLNode｛第3章线性表·91）：其中tag作为标志域，取false时表示单元素节点，使用无名联合中的!l:T域，用来存储元素值，取仃ue时表示子表节点，使用无名联合中的sublist域，用来存储子表的表其后继节点的指针域.通过它把表中的所有节点依次链接起来。图3.10给出了上面五个广义表的链接存储结构的示意图." ID="6">
          <fptr EndPN="00000105" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="s一位区囚c一圆只耘户画图3.10五个广义表的链接存储结构若把整个广义表也同样用一个表节点来表示的话，则应在每个广义表的表头节点（即表中第一个节点）之前增加一个表节点（称此为表头附加节点），此表节点的sublist『点）之前增加一个表节点next域为空，表头指针则1域指向表头节点，next域为空，表头指针则指向这个表节点。例如，若在广义表A，B，C的表头节点之前增加这样的表节点，则对应的示意图如图3.11所示。·92·数据结构" ID="7">
          <fptr EndPN="00000106" StartPN="00000105"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000106" TITLE="3.6.3  广义表的运算" TYPE="Chapter">
        <fptr LogicalPageNum="106" PhysicalPageNum="106"/>
        <Paragraph CONTEXT="广义表的运算主要有求广义表的长度和深度，向广义表插入元素和从广义表中查找！除元素，建立广义表的存储结构，打印广义表等。由于广义表是一种递归的数据结" ID="1">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="所以对广义表的运算一般采用递归的算法。全面介绍广义表的各种运算的算法，超或删除元素，构，出了本课程的教学要求，这里只讨论其中一些较简单的算法。" ID="2">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="1.求广义表的长度在广义表中，同一层次的每个节点是通过next域链接起来的，所以可把它看做为是由next琏接起来的单链表。这样，求广义表的长度就是求单链表的长度，经介绍过的求单链表长度的方法求其长度." ID="3">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="个节点的指针域均指向一个单链表（称为诊" ID="4">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="链表的第一个节点＜即表头节点），所以求J" ID="5">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="递归的终止条件。" ID="6">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="刃求GL所指向的广义表的长度毛if(GIr=N[JLL)return0;$Picture[00000106\00000106_new\0020.jpg]Picture$elsereturn1＋Lenth(GL-）next｝此算法的每次调用，无论是从外部对它的非递归调用，还是从内部对它的递归调第3章线性表·妇·公别扮翻麒+1因一个表不包含任何子表时，其深度为1，所以max的初值应为Oa下面是求一个广义表深度的算法：" ID="7">
          <fptr EndPN="00000107" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="妞跳帅（GUNode+GL)刀求GL所指向的广义表的深度Iintmax=0;11给幻pax斌J值dwttileiLhN[JLL)/lid历表中的每一个节点I" ID="8">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="试G卜洲摊户川川e）｛刀递归调用求出子表的深度intde少Depth(GL-》sublistl;！让maa始终为同一层所求过的子表中深度的最大值" ID="9">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="ifl(depmax]max=dop二｝6卜心L伽能对；刀使GL指向同一层的下一个节点贾tenonmax+l;/r返回表的深度｝从这个算法可以看出，当GL为一个空表或仅由单元素组成的线性表时，不进入下一层次的递归调用，而结束本次调用并返回1，当GL含有子表时才会进入求子表深度的递域不会被重复访问，所以此算法的时间复杂度为以”），其中n为广义表中所毕" ID="10">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="数。该算法的空间复杂度为O(m}，假定m为广义表的深度。本层次的并且每个节点中的每个" ID="11">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000107" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
      <Paragraph CONTEXT="·94·数据结构向的动态分配的数组空间用于存储线性表中的所有元素，第二个为len城，用于存储线性表的当前长度，即线性表中当前所含元素的个数，第三个为MazSize城，用来存储list所指动态数组的大小." ID="1">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="3.线性表的链接存储是通过定义节点类型和表头指针实现的，各节点按照所存元素之间的线性关系依次链接起来并通过表头指针标识，这样扰构成了线性表的健接存储结构." ID="2">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="4.单链表中的节点类型定义为sNode，它包含有两个城da.和next，用于分别存储一个元素和一个指向后继节点的指针." ID="3">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在线性表的顺序存储和链接存储结构上，都能够实现在线性表的抽象数据类型中定义的所有操作." ID="4">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="6.在线性表的顺序存储结构上某个位1插入或删除元素需要移动后面的所有元素，而在线性表的链接存储结构上某个位置插入和侧除节点不需要移动任何元素（节点）.在线性表的顺序存储结构上可以按元素编号直接存取到相应元素，而在线性表的桩接存储结构上必须从表头指针开始依次访问前面每个节点之后，才能够访问到相应编号的元素〔即节点值）." ID="5">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="7.若让单链表的表尾节点的指针域指向表头节点，则就构成了循环单链表；若让双向链表的表头节点的左指针left域指向表尾节点，让表尾节.级的右指针城指向表头节点，则就构成了循环双向链表.在链表前都可以加上一个头节点，构成带头节点的链表或循环链表。这些特珠形式的涟表往往给一些运算带来方便." ID="6">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="8.广义表是线性表的嵌套结构，即每个元素仍可以是一个表.广义表所含元素的个数称为广义表的长度，嵌套的最大层数称为广义表的深度.如广义表（(a,(b,cde)）的长度和深度均为3.9.广义表的存储结构采用动态链接存储结构，对于单元素节点和表元素节.级，虽然具有相同的节点类型，但具有不同的节点结构，一个含有存储元素值的数据城data，另" ID="7">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="10.由于广义表是递归结构，所以时广义表的各种运算采用的是递归算法.本章只介绍了广义表的简单运算，若需要了解更多的运算，请参考书后所列《数据结构实用教程》一书的相应部分的内容.分活已" ID="8">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="鲍到习题" ID="9">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="3" ID="10">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="3.1单选瓜" ID="11">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="1.在一个长度为n的顺序存储的线性表中，向第i个兀素（t1蕊i提n+l位置插入一个新元素时，第3章线性表·朽·需要从后向前依次后移（）个元素。人.月一in-i+1C.”一i-lD.i" ID="12">
        <fptr EndPN="00000109" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="2.在一个长度为。的顺序存储的线性表中，删除第‘个元素(lei&lt;n)时，需要从前向后依次前移（）个元素。" ID="13">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.n-i”一i+1C.”一r-1D.i" ID="14">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="3.在一个长度为n的线性表中顺序查找值为x的元素时，在等概率情况下，查找成功时的平均查找长度为（）." ID="15">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.nB.n/2C.{n+lU2D.(n-1)12" ID="16">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="4.在一个长度为n的线性表中.1N！除值为x的元素时需要比较元素和移动元素的总次数为（）。" ID="17">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.{n2B.n12C.nD.n+1" ID="18">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在一个顺序表的表尾插入一个元素的时间复杂度为（入" ID="19">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(n)B.O(1)C.O(n*n)D.O(lo$2n)" ID="20">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="6.在一个顺序表中任何位t插入一个元素的时间复杂度为〔）." ID="21">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(n)B.(n2)C.O(1)D.O(n" ID="22">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="T.在一个单链表中删除P所指向节点的后继节点时，其时间复杂度为（）。" ID="23">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(n)B.(nR)C.O(1)D.O(n" ID="24">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="8.线性表的链接存储比顺序存储最有利于进行（）。" ID="25">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.查找B.表尾插入或！除C.按值插入或删除D.表头插入或删除" ID="26">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="9.线性表的顺序存储比链接存储最有利于进行（）." ID="27">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.查找B.表尾插入或删除C.按值插入或删除D.表头插入或删除" ID="28">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="10.在一个单链表中，若要在P所指向的节点之后插入一个新节点，则需要相继修改（〕个节点的指针域的值." ID="29">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.lB.2C.3D.4It。在一个单链表中.若要在P所指向的节点之前插入一个新节点，则时间复杂度为（）.enl1nnlrnlnn!r1" ID="30">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.0（n）" ID="31">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="12。在一个带头节点的循环双向链表中，若要在p所指向的节点之前插入一个新节点，则时间复杂度为（）。＾.以月）B.（破）c.0（1）0.0（石）" ID="32">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="13.在一个表头指针为曲的单链表中，若要在指针q所指节点的后面插入一个由指针p所指向的节点.则执行（）操作。" ID="33">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.q.＞nexl二卜＞next；卜＞next叫；B，卜＞next翎户＞ncxt；q二p；" ID="34">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="C.q‘＞nexl二p＞nexC卜＞next月；D.卜＞next刊·＞next；q一＞next即；在一个带头节点的循环双向链表中，若要在指针p所指向的节点之后插入一个q指针所指向的·％·数据结构" ID="35">
        <fptr EndPN="00000110" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="A.pleftB.prightC.prightrightD.p~nleftleft在一个带头节点的循环双向链表中，若要在指针P所指向的节点之前插入一个q指针所指向的" ID="36">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="15.节点.则需要对pleftright值为（）." ID="37">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="A,qB.pC.prightD,plcft3.2坟空压：对一个线性表分别进行遍历和逆里运算，其时间复杂度分别为和" ID="38">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="2.若经常需要对线性表进行插入和删除运算.表进行查找运算，则最好采用＿存储结构。" ID="39">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="3.访问一个线性表中具有给定值元素的时间复杂度为＿。3.4.由n个元素生成一个顺序表，若每次都调用插入算法把一个元素插入到表头，则整个算法的时间复杂度为＿，若每次都调用插入算法把一个元素插入到表尾，则整个算法的时间复杂度为" ID="40">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="5.由n个元素生成一个单链表，若每次都调用插入算法把一个元素插入到表头。则整个算法的时间复杂度为，若每次都调用插入算法把一个元素插入到表尾，则整个算法的时间复杂度为＿口" ID="41">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="6.对于一个长度为，的顺序存储的线性表，在表头插入元素的时间复杂度为＿，在表尾插入元素的时间复杂度为＿。" ID="42">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="在表头插入节点的时间复杂度为＿，在表尾插入节点的时间复杂度为＿." ID="43">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="8.在线性表的单链接存储中，若一个元素所在节点的地址为p.则其后继节点的地址为＿。" ID="44">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="9.在一个循环单链表中，表尾节点的指针域与表头指针的值―." ID="45">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="10.在以HL为表头指针的带表头附加节点的单链表和循环单链表中，链表为空的条件分别为" ID="46">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="11.在一个单链表中删除指针p所指向节点的后继节点时，需要把一一一的值赋给p一能xt指针域。" ID="47">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="12.分别访问一个顺序表和单链表中第1个元素（节点）的时间复杂度为和1飞七一小习台亚叫离占防船翻二苗尝宝事山七韦引一姻呈入石称喇睦怡众甘肠才含要介居入石移翻4睦甘翻且作分盖日13－是的。" ID="48">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="14.一个广义表中的元紊分为元素和元素两类。" ID="49">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="15.在广义表的存储结构中，每个节点均包含有＿个城。15.16.在广义表的存储结构中，单元素节点与表元素节点有一个域对应不同，各自分别为＿域第3章线性表·973.3算法分析且" ID="50">
        <fptr EndPN="00000111" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="1.voidAA(ListSq&amp;L)I/L为一个线性表的顺序存储对象｛" ID="51">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="InitList(L,5NumberlnsertList(L,30,L.lsn+lNumberIaserrList(L,SD,1inta{415,8,12,15" ID="52">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;for(i习;i3;iNumberInsertList(L,a[iL.len+1fodi=l;i4;iNumberInsertList(L,a[i1}该算法被调用执行后，LT存储的线性表为：" ID="53">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="2.voidAB(ListSgdtL)11L为一个线性表的顺序存储对象仁NumberIttaertList(L,3D,4NumlxrInsertList(L,50,1DeleteList{L,12NumberInsertLsst(L,28.2}假定调用该算法时L，存储为线性表是（(5,8,12,15)，则调用返回后，L存储的线性表变为：一口" ID="54">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="3.voidAC(sNode+＆HL)IIHI为一个存储线性表的单链表的表头指针长" ID="55">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="InitList(HL" ID="56">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="Orderlnscrtl.ist(HL,20" ID="57">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderInsertList{HL,Sainta[S15,8,9,26,12for(inti司tiLS;iOrdsrInsertList(HL,a[iDeleteListII15" ID="58">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="}该算法被调用执行后.扭J所存储的线性表为：一一＿＿川二" ID="59">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="4.voidAl7(sNade*及HL)NHL为一个存储线性表的单链表的表头指针｛·48·数据结构intx=CretEleml.ist(HL,3" ID="60">
        <fptr EndPN="00000112" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="DeleteList{HL,x" ID="61">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderlnsertList(HL,60" ID="62">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="OrderlnsertList(HL,GetElernList(HL,310" ID="63">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="outputList(HL'" ID="64">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="}假定调用该算法时HL所存储的线性表为（巧，26,37,48,55)，则调用返回后HL所存储的线性表变为：" ID="65">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="3.4算法设计瓜" ID="66">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="1.分别编写在顺序存储的线性表上和带头节点的单链接存储的线性表上统计出值为x的元素个数的算法，统计结果由函数值返回。" ID="67">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="2.分别编写在顺序存储的线性表上和带头节点的单链接存储的线性表上删除其值等于x的所有元素。" ID="68">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="3.分别编写在顺序存储和单链接存储的线性表上删除具有重复值的多余节点，使每个节点的值均不I司。如将所存的线性表（2,8,4,2,5,5,6,8,7,2）变为（2,S,4,5,6,7).4分别编写在顺序存储和单链接存储的线性表上使元素逆序排列的算法。如线性表中元素的原有次序为a1,a…,aR，则逆序排列后变为‘.‘一,…,alo" ID="69">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="S.向带表头附加节点的循环有序单链表中插入一个元素，使得插入后仍然有序。" ID="70">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="6.从带表头附加节点的循环有序单链表中删除等于给定值的第一个元素，若删除成功返回1，否则返回0.7.编写一个算法，使用带表头附加节点的循环单链表解决约瑟夫（Josephus）问题。其问题是：设有，。个人围坐在一张圆桌周围，现从某个人开始从1报数，数到m的人出列（即离开坐位，不参加以后的报数〕，接着从出列的下一个人开始重新从1报数，数到脚的人又出列，如此下去直到所有人都出列为止，试求出它们的出列次序。例如，当n=8,m=4时.若从第一个人《假定每个人的编号依次为1,2,n)开始报数，则得到的出列次序为：4,R,5,2,1,3,7,60此算法要求以n,，和，‘假定从第：个人开始第一次报数）作为值参。" ID="71">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="8.假定有一种带表头附加节点的链表.每个节点含三个域：data,next和range，其中data为整型值域，next和“uge均为指针域，现在所有节点己经由next域链接起来，试编一算法，利用range域把所有节点同时按照其值从小到大的顺序错褚起来，当然由此域锥接得到的单链表的表头指针保存在表头附加节点的range域中。" ID="72">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="9.编写一个从广义表中六找单元素字符等于给定值的算法，若查找成功则返回数值t.否则返回数il'ia一彰器找和队列部城于线性表.但由于对它们操作的特殊性.并且是级常用的线性数据结构.lf以盂要专门迸行讨论。" ID="73">
        <fptr EndPN="00000113" StartPN="00000112"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000108" TITLE="习题3" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000113" TITLE="第4章  栈和队列" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000113" TITLE="4.1  栈" TYPE="Chapter">
      <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <div ORDERLABEL="00000113" TITLE="4.1.1  栈的定义" TYPE="Chapter">
        <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <Paragraph CONTEXT="栈(Stack）又称堆栈。它是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算.人们把对栈进行运算的一端称为钱顶.找顶的第一个元素被称为栈顶元索，相对地，把另一端荆该元素放到栈顶元素的上面，｝洗盘子时.依次把每个洗净的盘子放到当于出栈。又如向枪支弹夹里装子弹时，子弹被一个接一个地压入，此为子弹出栈。后进栈的元素必定先出栈，所以又把$Picture[00000113\00000113_new\0013.jpg]Picture$栈称为后进先出衰（LIFO,LastInFirstOut)e。100。数据结构" ID="1">
          <fptr EndPN="00000114" StartPN="00000113"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000114" TITLE="4.1.2  栈的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <Paragraph CONTEXT="栈的抽象数据类型中的数据部分为具有Eiem'I+pe元素类型的一个栈，它可以采用任一种存储结构实现，假定用Stack标识符表示栈对象类型：操作部分应包括元素进栈、元" ID="1">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="素出栈、读取栈顶元素、检查栈是否为空等.下面给出栈的抽象数据类型的具体定义。ADTSTACKisData二" ID="2">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="一个栈S.定用标识符Stack表示栈对象类型。" ID="3">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="伪阵耐帕，voidInitStack(Stack&amp;S" ID="4">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="11初始化找S，即把它里为空voidPash(Stack&amp;S,E)emTypeitem)刀元素item进栈，即插入到栈顶" ID="5">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypePop(Stack6tS)1i1除栈顶元素并返回之" ID="6">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypePeek{Stack&amp;S)刀返回S的栈顶元素的值.但不移动栈顶指针" ID="7">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="boosEmptyStack(Stack&amp;S11判断S是否为空，若是则返回uue，否则返回falsevoidC1carStack{Stack&amp;SendSTACK对于判断栈是否为空和返回栈顶元素这两种操作，由于它们不改变栈的状态，所以义符const，也可以取消引用定义，改为值参定义.门9而全冬山捆田卜决操坦称的一此翩罕假定栈a的元素类型为int," ID="8">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="{1)InitStack(a11把栈a置空" ID="9">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)Push(a,IS" ID="10">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="C3)intx=46;Push(a,xx的值ir进栈第4章栈和队列·lolCS)EmptyStack(a11因栈非空，应返回false" ID="11">
          <fptr EndPN="00000115" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="(9)oout峭袱Pap(a)cendl;11栈顶元素l$退栈并输出C10)x=EmptyStack(a11因栈为空，返回true（对应整数1)赋给x" ID="12">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000115" TITLE="4.2  栈的顺序存储结构和操作实现" TYPE="Chapter">
      <fptr LogicalPageNum="115" PhysicalPageNum="115"/>
      <Paragraph CONTEXT="栈的顺序存储结构同样需要使用一个数组和一个整型变量来实现。利用数组来顺序1栈中的所有元素，利用整型变量来存储栈顶元素的下标位置。假定栈数组用" ID="1">
        <fptr EndPN="00000115" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="MaxSize]表示，指示栈顶位置的整型变量用top表示，则元素类型为ElemType的栈" ID="2">
        <fptr EndPN="00000115" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="存储栈中的所有元素，" ID="3">
        <fptr EndPN="00000115" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="stacklMaxs此』表示，指示（的顺序存储结构可定义为：曰e川Types“‘k附肛51踌］；其中，Maxsize为一个整型全局常量，需事先通过const语句定义.由它确定顺序栈（即顺序存储的栈）的最大长度，又称为深度，即栈空间最多能够存储的元素个数；" ID="4">
        <fptr EndPN="00000115" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="于吻用来指示栈顶元素的位置，所以把它称为栈顶指针." ID="5">
        <fptr EndPN="00000115" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="栈的顺序存储结构所使用的栈数组和栈顶指针同样可以定义在一个记录类型中，" ID="6">
        <fptr EndPN="00000115" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="假定该记录类型用stacksq表示，则定义为：5OuCtS以ksqfElemTyl姆‘恤比附axs泳」；1成切p；1：若要对存储栈的数组空间采用动态分配，则stacksq结构类型可定义为：stIUCtS以ksql跳mT”姆.s比k；刀存栈元素intMaxsi欢；11存stack数组长度，亦即所能存储栈的最大长度·102数据结构性表）的表尾进行的，其时间复杂度为oua赶满处理，如分配更大的存储空间满足插入要求.或输出栈满信息top的值已经等于一1，则表示栈空，通常利用栈空作为循环结束的新元素时就需要进行栈满处理，告知用户等；相反，若tOP的值户等；相反，若tOP的值已经等于一1，表明数据己经处理完毕。条件，设一个栈5为（a，b，c，d，e），对应的顺序存储结构如图4.】（a）所示。若向5中插4.1（c）所示.若依次使栈5中的所有元素出栈，则5变为空，如图4.14.1（c）所示.若依次使栈5中的所有元素出栈，则5变为空，如图4.1（d）所示。宅底在下." ID="7">
        <fptr EndPN="00000116" StartPN="00000115"/>
      </Paragraph>
      <Paragraph CONTEXT="图4.1栈的顺序存储结构和操作过程示愈图" ID="8">
        <fptr EndPN="00000116" StartPN="00000116"/>
      </Paragraph>
      <Paragraph CONTEXT="置空又为存储栈动态分配数组空间.此操作也包括两种情况，一种是只置空。另一种是既第4章栈和队列.1Q3voidIrutStack(StackSgBcS,intms}{11查ma是否有效.若无效则退出运行if(ms4-Q){couta&quot;ms值非法.日1；exit（l）；111置栈空间大小为ms" ID="9">
        <fptr EndPN="00000117" StartPN="00000116"/>
      </Paragraph>
      <Paragraph CONTEXT="S.MaxSizw-ms;刀动态存储空间分配，若分配失败则退出运行" ID="10">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="S.atackr-newF.lemType[msif(lS.stack}{" ID="11">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="cerr«“动态存储分配失败！&quot;《endl;" ID="12">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(l" ID="13">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="资" ID="14">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="刀初始t栈为空" ID="15">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="＆协产一1;" ID="16">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="17">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="2.元紊item进栈，即插入到栈顶voidPush{StackSgBcS,ElemTypeitem}硬刀若栈空间用完则退出程序运行ifCS.tapS.MaxSizal}{" ID="18">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="cetr《&quot;Stackoverflow《endl;" ID="19">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1" ID="20">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="｝刀栈顶指针后移一个位置" ID="21">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="S.top" ID="22">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="刀将新元素插入到栈顶" ID="23">
        <fptr EndPN="00000117" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="S.etack[S.top]dtem:｝在这个算法中，对栈满的处理方法是显示提示信息并中止程序运行，此方法简单，但不够完美，最好是动态扩人栈空间，使得插入操作能够顺利完成。为此，可把if条件·104·数据结构重新分配动态存储空间比原空间增加1倍加1ElemType.p=newElemType[2.S.MaxSize+11;ifp){11分配失败退出运行｝11把S栈中的原有内容复制到F所指空间中fot(intice;i＜=5.top;ip[iS.stack[i11释放S栈中的原有动态空间deleteS.stsck;使stack指向新分配的栈空间" ID="24">
        <fptr EndPN="00000118" StartPN="00000117"/>
      </Paragraph>
      <Paragraph CONTEXT="S.stack=p;11把栈空间大小修改为新的长度" ID="25">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="S.MaxSize＝2*S.MaxSize+l;｝" ID="26">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="3.iJ除栈顶元紊并返回" ID="27">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypePop(StackSq&amp;S)" ID="28">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="29">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="11若栈空则退出运行" ID="30">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="if{S.top二一i)" ID="31">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="ccrrat&quot;Stackisemptya:endl;" ID="32">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(U;" ID="33">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="34">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="11栈顶指针减1表示退栈" ID="35">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="stop一：" ID="36">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="u返回原栈顶元素的值" ID="37">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="returnS.stack[S.top1;" ID="38">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="｝注意：做出栈操作时，栈顶指针下移，但原栈顶位置中保存的元素依然存在，仍可以被口具不晨干当亩介操由的干妥.己斤户当箭姆由的异姿毛U烤丽rl妈,少rdt,u右异姿" ID="39">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="利用，" ID="40">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="4.读取栈顶元素的值一一一一一一进匕夏壁」些业1一竹一cos-Iu若栈空则退出运行" ID="41">
        <fptr EndPN="00000119" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="ifi(s.top-i){" ID="42">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="cerr叫‘&quot;Stackisemptysend" ID="43">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1｝刀返回栈顶元素的值returnS.stack[S.topl;}此算法只访问栈项元素，而不改变栈的状态，即不修改找顶指针的值." ID="44">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="5.判断8是否为空，若是则返回true，否则返回falsebaoiEmpryStack(StackSq&amp;S}{returnS.tap1;}" ID="45">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="6.淆除栈ti中的所有元素，释放动态存储空间voidC1earStack(StackSgdtS)" ID="46">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="47">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="if{S.stack){" ID="48">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="山】以e［玲.由uck;" ID="49">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="S.atack司;" ID="50">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="Stop1;" ID="51">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="S.1VIaxSize＝＝0;" ID="52">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝若采用下面主函数调试栈的各种操作算法。" ID="53">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="voidmain" ID="54">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="仁" ID="55">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="StackSqa;·1{16·数据结构intaJ二｛3,5,17,9,34,15,22inti;for{i习;i＜8;iPush(s,a[iJcouta:Pap(scout«《Pop(s)®:endl:push（5，68）；couta:Peek(scout''ariPop(s)cendl;whilet!F_mptyStack(scout味Pop(s}acoutaendl;" ID="56">
        <fptr EndPN="00000120" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="C1esrStack(s" ID="57">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="58">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
      <Paragraph CONTEXT="则得到的运行结果如下：" ID="59">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
      <Paragraph CONTEXT="2215" ID="60">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
      <Paragraph CONTEXT="b$68" ID="61">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
      <Paragraph CONTEXT="30917583" ID="62">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000120" TITLE="4.3  栈的链接存储结构和操作实现" TYPE="Chapter">
      <fptr LogicalPageNum="120" PhysicalPageNum="120"/>
      <Paragraph CONTEXT="删除元素时，是把找顶元$Picture[00000120\00000120_new\0006.jpg]Picture$节点。当从一个链栈中删除元素时，是把找顶元使栈顶指针指向原找顶节点的指针域所指向的节素节点删除掉，即取出栈顶元素后。点。由此可知，对链栈的插入和删除操作是在单链表的表头进行的，其时间复杂度为ou）a设一个栈为（a,b,c)，当采用链接存储时，对应的存储结构示意图如图4.2(a）所示，其中HS表示栈项指针，其值为存储元素c节点的地址。当向这个栈插入一个元索d后.对应如图4.2(b〕所示。当从这个栈依dieHJ&amp;两个元素后.对应如I4.2{c)所后.对应如图4.2（b）所示。第4章栈和队列·]07" ID="1">
        <fptr EndPN="00000121" StartPN="00000120"/>
      </Paragraph>
      <Picture URL="00000121\00000121_new\0002.jpg">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Picture>
      <Picture URL="00000121\00000121_new\0003.jpg">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Picture>
      <Paragraph CONTEXT="1.初始化链栈voidInit5tack(sNadeH5)！HS=NI,JIL;11将链栈置空.}" ID="2">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="2.向链栈中播入一个元紊voidPush(sNodeHS,coastEiemType&amp;item)！11为插入元素获取动态节点sNode*newptr=stewsNode;if(Inewptr){" ID="3">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="cerr&quot;Memoryallacadonfailateaendl;" ID="4">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="exit" ID="5">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="6">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="刀给新分配的节点赋值" ID="7">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="newptrdata二item;" ID="8">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="向栈顶插入新节点" ID="9">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="newplrnex怡H5;" ID="10">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="HS=newptr;" ID="11">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="12">
        <fptr EndPN="00000121" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="3.从链栈中剧除一个元素井返回它ElemTypePop(aNode*8cHS)·i08·数据结构（if(HS分NULL){不能从空栈栩除" ID="13">
        <fptr EndPN="00000122" StartPN="00000121"/>
      </Paragraph>
      <Paragraph CONTEXT="terra&quot;Linkedstackisempty咭cndl;" ID="14">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="cxitft" ID="15">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="｝sNodC*p=NS;11暂存栈顶节点指针HS=HSnext;11使栈顶指针指向其前一节点ElemTypetemP＝梦&gt;data;11暂存原栈顶元素deletep;11回收原栈顶节点味turntemp:刀返回原栈顶元素}" ID="16">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="4.读取栈顶元素ElemTypePeek(sNode*HS)IIHS为值参或引用形参均可｛if(HS=NULL){11无法从空栈中操作" ID="17">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="terra&quot;Linkedstackisemptyacendl;" ID="18">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1" ID="19">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="}returnHS-data;1/返回栈顶节点的值}" ID="20">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="5.检查链栈是否为空baolEmptyStack(sNode*HS)" ID="21">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="/MS为值参或引用形参均可｛" ID="22">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="rewrnNS=NULL;" ID="23">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="24">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="6，清除链栈为空voidCiearStack(sNodeHS)《" ID="25">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode*cp,*np;第4章栈和队列·109cp=HS;11给cp指针赋初值，使之指向栈顶节点while(cpNULL)(/1从栈顶到栈底依次删除每个节点" ID="26">
        <fptr EndPN="00000123" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="npzp-next;" ID="27">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="deletecp;" ID="28">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="心gyp;" ID="29">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="}HS=NULL;11里链栈为空｝" ID="30">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000123" TITLE="4.4  栈的简单应用举例" TYPE="Chapter">
      <fptr LogicalPageNum="123" PhysicalPageNum="123"/>
      <Paragraph CONTEXT="例4.1从键盘上输入一批整数，然后按照相反的次序打印出来。根据题意可知，后输入的整数将先被打印出来，这正好符合栈的后进先出的特点。所以此题很容易用栈来解决。假定采用顺序栈，其参考程序如下：hnclude(iostream.h)ittclude(atdlib.h)typedefintElemType;11定义元素类型为整型suuctStackSq{EkmTypewstack;11存栈元素inttop;11存栈顶元素的下标位置intMaxSiu;存stack数组长度，亦即所能存储栈的最大长度include&quot;atackSq.cpp&quot;11j定对顺序$操作的算法已经存于”stackSq.cpp”程序文件中" ID="1">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="voidmain" ID="2">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="3">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="StackSqa;" ID="4">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="lnitStaclc(a,5" ID="5">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="斌狱ctn洲卜x;" ID="6">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="while{x!＝一1)(11假定用一1作为终止键盘输入的标志·i10·数据结构" ID="7">
        <fptr EndPN="00000124" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="d比arx;" ID="8">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="｝while(lFmptyStack(a11栈不为空时依次退栈打印出来" ID="9">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="cout《R平（a）" ID="10">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="cout《endl;" ID="11">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="12">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="假定从键盘上输入为：" ID="13">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="786345829134-1" ID="14">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="则输出为：" ID="15">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="34418245b378例4.2堆栈在计算机语言的编译过程中用来进行语法检查，试编写一个算法，用来检查一个C/C＋十语言程序中的花括号、方括号和圆括号是否配对，若能够全部配对则返，否则返回0需要扫描待检查程序中的每一个字符，当扫描到每个花、中、圆左括号时，令其进栈，当扫描到每个花、中、圆右括号时.则检查栈顶是否为相应的左括号，若是则作退栈处理，若不是则表明出现了语法错误，应返回0。当扫描到乖" ID="16">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="‘，若栈为空则表明没有发现括号配对错误，应返回i，否则表明栈中还有到" ID="17">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="应返回0。另外，对于一对单引号或双引号内的字符不进行括号配对检查。" ID="18">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="根据分析.编写出算法如下；尾时，号，intBracketsCheck(char+frame)1I对由frame所指字符串为文件名的文件进行括号配对检查{" ID="19">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="ifstreamifsp{fname,iosin!iosaocreats" ID="20">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="11用文件输入流对象ifstr打开以fnam。所指字符串为文件名的文件." ID="21">
        <fptr EndPN="00000124" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="IIC的系统头文件flreein.h中定义有文件输入流类ifStCamif(lifstr)(没有找到相应的物理文件则退出运行。已na&quot;File&quot;《&quot;、《fnamra&quot;、《&quot;eotfaund《endl;第4章栈和队列·11卜charch;while(ifatrch)11顺序从文件中得到一个字符到ch变最中《itCcf=39)j11单引号内的字符不参与配对比较whilc(ifstr.ch)ifich39)1139为单引号的ASCII值" ID="22">
        <fptr EndPN="00000125" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="break;itiifstr)11已读到文件尾代恤rn0;！elseifch=34)（双引号内的字符不参与配对比较whilt{ifstrvch)itYch=34)/134为双引号的FyI值" ID="23">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="b瑞叭；试！诉心）抢加m。；}" ID="24">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="，幼忱h（比）" ID="25">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="26">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="case'[" ID="27">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="‘.阴‘［‘：" ID="28">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="case'('Push（：，ch）；11出现以上三种左括号则进栈b花止" ID="29">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="case'}'斌R笼k（a卜＝‘｛‘圣" ID="30">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="1?op(al;/1栈顶的左花括号出权elsereturn0;break;" ID="31">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="cast'1'ifl(Pee以公带）" ID="32">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="Pop(e11栈顶的左中括号出找elsereturn0;break:" ID="33">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="。明e。112数据结构" ID="34">
        <fptr EndPN="00000126" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="if(Peek(a）一')" ID="35">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="elsereturn0;" ID="36">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="37">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="咨" ID="38">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCEmptyStack(a" ID="39">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="return1;" ID="40">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="41">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="return0;" ID="42">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="｝例4.3把十进制整数转换为二至九之间的任一进制数输出.由计算机基础知识可知，把一个十进制整数x转换为任一种r进制数得到的是一个；" ID="43">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="整数x除以基数r，得到的整余数是；进制数y的最低位yo，接着以x除以r的整数商作" ID="44">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="：｝、2，：巨2生，巴名匕0余吸对应的八进侧救位二”。tr二，sy.第4章找和队列·113aNpde.a;11利用顺序或链接栈都可以。假定使用链栈卜止巴比k《a）；邓切始化栈while(num！司){由低到高求出r进制数的每一位并入栈" ID="45">
        <fptr EndPN="00000127" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="intk翻um96r," ID="46">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="1?ush(a,k" ID="47">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="nom/二r," ID="48">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT=")while(！EmpryStack(a由高到低翰出r进制数的每一位" ID="49">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="cuta:Pop(a门以礴努.山；" ID="50">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="｝假定用下面的主程序调用Transform过程.include(ioatresm.h)tiinclude(atdlib.h)typedefintEiemType;动m以吕N侧加《" ID="51">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypedata;" ID="52">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="sNode+next;" ID="53">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="】；Finclude&quot;atacki.k.cpp&quot;11定该程序文件中保存着对链栈的各种操作的算法voidTransfnrm(longnom,intr11实际运行时需要加上函数体voidmain0" ID="54">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="lc皿t《&quot;342，的八进制数为Transform{3425二gcoots&quot;3425的六进侧数为Transform(3425,bcout明拭&quot;3425的四进制数为Transform{3425,4cout喊c&quot;3425的二进制数为Tra目.form(3425,2·114。数据结构则得到的运行结果如下：" ID="55">
        <fptr EndPN="00000128" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="3425的八进制数为：6541" ID="56">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="3425的六进制数为：235053425的四进制数为：3112013425的二进制数为：110101100001" ID="57">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000128" TITLE="4.5  算术表达式的计算" TYPE="Chapter">
      <fptr LogicalPageNum="128" PhysicalPageNum="128"/>
        <div ORDERLABEL="00000128" TITLE="4.5.1  算术表达式的两种表示" TYPE="Chapter">
        <fptr LogicalPageNum="128" PhysicalPageNum="128"/>
        <Paragraph CONTEXT="通常书写的算术表达式是由操作数（又叫运算对象或运算量）和运算符以及改变运序的圆括号连接而成的式子。操作数可以是常量、变量和函数，同时还可以是表达算次序的圆括号连接而成的式子。在该操作数的前面，双目运算符要求有两个操作数，并被放在这两个操作数的中间。单目运算符为取正“＋”和取负“一”，双目运算符有加“十”，减“一”，乘“＊”和除“1”“＋”和取负“一”，双目运算符有加“十”，减“一”，乘“＊”和除“1”等。为了简便起见，在我们的讨论中只考虑双目运算符。并且仅限于“十、一、＊、／”这四种运算.如对于一个算术表达式2＋5＊6，乘法运算符“＊”的两个操作数是它两边的5和6：" ID="1">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="加注坛嫂恃“＋”的两个操作数.一个县喻前而的2.另一个县喻后而的5＊6的结旦对于加法运算符“＋”的两个操作数，一个是它前面的2，另一个是它后面的5＊6的结果0。我们把双目运算符出现在两个操作数中间的这种习惯表示叫做算术表达式的中级：这种算术表达式被称为中级算术表达式或中级衰达式。中缀表达式的计算比较复杂，它必须遵守以下三条规则：即30。第4章栈和队列·113一个中缀表达式中哪个运算符最先算，哪个次之，……哪个最后算并不困难。但通过计那么，能否把中缀算术表达式转换成另一种形式的算术表达式，使计算简单化呢？二具告京的＿愉任私受宕占书谢雄吞仃二‘.多日曰台奋月巨山甲翻食习卜习比J壬少的且＿缀表达式12040-051，其中w0”字符表示成分之闻的空格，因减法运算符在前，除:算符在后，所以应先做减法，后做除法；减法的两个操作数是它前面的12和4，其叫一个数12是被减数.第二个数4是减数：除法的两个操作数是它前面的12减4白" ID="2">
          <fptr EndPN="00000129" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="采" ID="3">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="不存" ID="4">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="盆.整个" ID="5">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="对于后" ID="6">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="除法运" ID="7">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="其中第" ID="8">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="4是减数：除法的两个操作数是它前面的12减4的差咤月，径弘圳犷（即8）和5，其中8是被除数，" ID="9">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="中缀算术表达式转换成对应的后缀算术表达式的规则是：把每个运算符都移到它的两个长甘针必的层而＿钦居翻1睦沽成右.的妊县能石了" ID="10">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000129" TITLE="4.5.2  后缀表达式求值的算法" TYPE="Chapter">
        <fptr LogicalPageNum="129" PhysicalPageNum="129"/>
        <Paragraph CONTEXT="·11b·数据结构处理，若它是运算符，则表明它的两个操作数已经在栈5中，其‘$Picture[00000130\00000130_new\0003.jpg]Picture$后一个操作数.栈顶元素的前一个元素为运算符的前一个操作数，应运算并保存到一个变t（假定为z)中，否则，扫描到的字符必止从此开始的浮点数字符串转换为一个浮点数并存入数（即x的值）压入到栈S中.依次向下扫描每一个字符并进行上述处理，直到遇到字" ID="1">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="符串结束符（即ASCII为U7字符）为i卜.表明后绷表伏式计篮完毕.最终结奥4存（即AScll为0的空字符）在栈中，并且栈中仅存这一个值，doublecomputc（cbar＊str）11计算由str所指字符串的后缀表达式的值百刀用5栈存储操作数和中间计算结果，元素类型为面ubleStacksqS；刀初始化栈5，预分配5个浮点数空间，以后自动增长" ID="2">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="Initstack（5.5）；11定义从y用于保存浮点数，定义1用于扫描后缀表达式doublex，y；" ID="3">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="inti司；刀扫描后缀表达式中的每个字符，并进行相应处理喃ile（strti］）诬" ID="4">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="刀扫描到空格字符不做任何处理if（s吐11＝＝”）｛1＋＋；continue：1" ID="5">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="脚1助（，tr［1］）case’十‘：" ID="6">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="x二POp（5）十POP（5瓦第4章栈和队列·117刀做栈项两个元素的乘法.积赋给xCage'卜x二Pop(SPap(Sibreak;刀做栈顶两个元素的除法，商赋给xcase:x=Pop(S11弹出除数itx！司.0}" ID="7">
          <fptr EndPN="00000131" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="x=Pop(Sx;11弹出被除数else;11除数为。时终止运行" ID="8">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="ceiraDivideby0eendf;" ID="9">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(l" ID="10">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="11">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="杆干；b怡吐；刀扫描到的是浮点数字符串，生成对应的浮点数default:刀利用x保存扫描到的整数部分的值义二0;whiie(str[iIISstr[i]＜57){" ID="12">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="x=x+lb+str[i］一48;i+H;）11利用Y保存扫描到的小数部分的值iP(str[i]二‘.'){" ID="13">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="祖十千；" ID="14">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="yam:" ID="15">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="doublej=10.0;11用j作为相应小数位的权值" ID="16">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="while(str[i]＞二48＆＆5吐1］＜巧7）《" ID="17">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="18">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="xy;11把小数部分合并到整数部分x中)" ID="19">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="｝刀把扫描转换后或进行相应运算后得到的一个浮点数压入栈S中·1ib·数据结构Push(S,x" ID="20">
          <fptr EndPN="00000132" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="}whileend" ID="21">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="!1若计算结束后栈为空则中止运行" ID="22">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="itYEmptystack(S" ID="23">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="ceaat&quot;Stackisempty！”《endl;" ID="24">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1" ID="25">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="1ri若栈中仅有一个元素.则它就是后缀表达式的值，否则为出错z=Pop(S" ID="26">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="iftEmptyStack(Srctumx;" ID="27">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="28">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="terra&quot;expressionerroraceadi;" ID="29">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1" ID="30">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="31">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="奋此算法的运行时间主要花在while(str[i]）循环上，它从头到尾扫描后缀表达式中的侮的大小：显然，它的最大深度不会超过表达式中所含操作数的个数，因为操作数的个数与运算符的个数多1，所以此算法的空间复杂度" ID="32">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="也同样为0（n）。" ID="33">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="假定一个字符串a为：chara［30】＝”103.5-4.32.48＋.51对应的中缀算术表达式为（10-3，5）＊（4.3＋2.48）l5，则使用如下语句调用上述函数得到" ID="34">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="的输出结果为＆814.cout《CoInPu1e（a）。ndl；在进行这个后缀算术表达式求值的过程中，每处理一个操作数或运算符后，栈5中" ID="35">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000132" TITLE="4.5.3  把中缀表达式转换为后缀表达式的算法" TYPE="Chapter">
        <fptr LogicalPageNum="132" PhysicalPageNum="132"/>
        <Paragraph CONTEXT="设中缀算术表达式已经保存在51字符串中.转换后得到的后缀算术表达式拟存于52串中.由中缀表达式转换为后缀表达式的规则可知：转换前后，表达式中的数值项第4章栈和队列·119(fl+fel'(b)5图4.4栈5中数据的变化的次序不变，而运算符的次序发生了变化，由处在两个运算对象的中间变为处在两个运算对象的后面，同时去掉了所有的括号。为了使转换正确.必须设定一个运算符栈，并在栈底放入一个特殊运算符，假定为“＠”字符，让它具有最低的运算符优先级，假定为数值0，此找用来保存扫描中缀表达式得到的暂不能放入后级表达式中的运算符，待它的两个运算对象都放入到后缀表达式以后，再令其出栈并写入到后级表达式中." ID="1">
          <fptr EndPN="00000133" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="把中缀表达式转换为后缀表达式算法的基本思路是：从头到尾地扫描中缀表达式中" ID="2">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="的每个字符。对于不同类型的字符按不同情况进行处理.若遇到的是空格则认为是分隔" ID="3">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="符，不需要进行任何处理；若遇到的是数字或小数点，则直接写入到Sa中，并在每个数值的最后写入一个空格；若遇到的是左括号，则应把它压入到运算符栈中，待以它开始已经扫描完毕，把从栈顶直到保存着的对应左括号之间的运算符依次退栈并写入Sz串中；若遇到的是运算符，当该运算符的优先级大于栈顶运算符的优先级（加减运算符的" ID="4">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="优先级设定为i，乘除运算符的优先级设定为z，在栈中保存的特殊运算符“＠”和·120·数据结构11将字符串sl中的中缀表达式转换为：2字符串中的后绷表达式（11定义用于暂存运算符的栈R并初始化，该找的元素类型为charStackSqR;" ID="5">
          <fptr EndPN="00000134" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="InitStack(R,51/给栈底放入‘＠’字符，它具有最低优先级0Push{R＠'11定义i,j分别用于扫描sl和指示s2串中待存字符的位置inti=0,jam;11定义ch保存sl串中扫描到的字符.初值为第一个字符charch二s1[i11依次处理中缀表达式中的每个字符while{ch10')" ID="6">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="【11对于空格字符不做任何处理，顺序读取下一个字符1代ch＝“）ch书1【＋＋1」；" ID="7">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="11对于左括号，直接进栈" ID="8">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="elseitCch}{" ID="9">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="Push(R,chchi1ji｝刀对于右括号，使括号内的仍停留在栈中的11运算符依次出栈并写入到s2中日sei取h＝＝’）’）1" ID="10">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="while{Peek{R二r（’）52臼什1二Pop(R" ID="11">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="Pop(R1111}9除栈顶的左括号" ID="12">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="ch＝51【＋＋1】；" ID="13">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="}11对于四则运算符.使暂存在$顶的不低于ch优先级11的运算符依次出栈并写入到s2中elseitjchIIch=’一‘llch＝‘.‘llch＝＝‘1‘）【" ID="14">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="charw=Peek(R" ID="15">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="while(Precedence{w}=Precedence{ch" ID="16">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="{11Precedence(w）函数返回运算符形参的优先级第4章栈和队列·121" ID="17">
          <fptr EndPN="00000135" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="：2口什」＝w；Po杯R）；" ID="18">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="w=Peek(It｝Push(R,ch11把ch运算符写入栈中chi1i" ID="19">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="}11此处必然为数字或小数点字符，否则为中缀表达式错误else{11若ch不是数字或小数点字符则退出运行ifch0'IIclv'4ch.{" ID="20">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="coutd[“中缀表达式表示错误endl;" ID="21">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1" ID="22">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="}11把一个数值中的每一位依次写入到a2串中whilech＞二’0’＆＆ch＜＝’9’）”ch一‘.‘）｛" ID="23">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="s2[jxh;" ID="24">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="ch二s1il被放入s2中的每个数值后面接着放入一个空格字符s2[j二" ID="25">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="26">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｝刀把暂存在栈中的运算符依次退栈并写入到。2串中ch=Pop(R" ID="27">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="while{ch＠'}{" ID="28">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="1血h升‘（‘）1cena&quot;expressionermrl“《endl;exit(1" ID="29">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="30">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="31">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="s2Uxh;" ID="32">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="ch二Pop(R" ID="33">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="34">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｝·t。数据结构u在后级表达式的末尾放入字符串结束符sz什1二‘w" ID="35">
          <fptr EndPN="00000136" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｝其中.求运算符优先级的Precedence函数定义为：intrecedsnce(charop){I1返回运算符oP所对应的优先级数值switcn(ap){" ID="36">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="case'" ID="37">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="。习se，一，：" ID="38">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="case'«'" ID="39">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="case':" ID="40">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="case':" ID="41">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="case'＠'" ID="42">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="default:" ID="43">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="44">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="子在这个转换算法中.中缀算术表达式中的每个字符均需要扫描一遍，对于从sl中扫描得到的每个运算符，最多需要进行入R栈、出R栈和写入s2后缀表达式这三次操作.对于从sl中扫描得到的每个数字或小数点，只需要把它直接写入到s2后缀表达式即可。Qrl`1.ii'itRhi'信7F1,n11,居f翻习怒;十d‘山旦之全牛仪IJ刁、知暇r令方招守众士璧伫.赶/r#F{a所以，此算法的时间复杂度为以”），n为后缀表达式中字符的个数。个运算符栈，需要的深度不会超过中缀表达式中运算符的个数.所以此算法的空间复杂度至多也为0（n）。利用表达式的后缀表示和堆栈技术只需要两遍扫描就可完成中缀算术表达式的计" ID="45">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="算，显然比直接进行中缀算术表达式计算的扫描次数要少得多。" ID="46">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在计算机中进行算术表达式的计算是通过栈来实现的。这一节首先讨论算术表达式种表示方法，即中缀表示法和后缀表示法.接着讨论后缀表达式求值的算法，最后的两种表示方法，讨论中缀表达式转换为后缀表达式的算法。" ID="1">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000136" TITLE="4.6  栈与递归" TYPE="Chapter">
      <fptr LogicalPageNum="136" PhysicalPageNum="136"/>
      <Paragraph CONTEXT="第4章栈和‘队列·123止向下递归，从而使月整个问题。解决递归位间接地调用算法木身，" ID="1">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="下递归，从而使最小的问题得到解决，然后再依次返回解决较大的问题，最后解决伺题。解决递归问题的算法称为递归算法，在递归算法中需要根据递归条件直接或她调用算法木身，当满足终止条件时结束递归调用。当然对于一些简单的递归问例4.4采用递归算法求解正整数n的阶乘（(n由l4h理跪$7tiI7oT4xt_14f117f1y'dilklVim.tea二.3" ID="2">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="由数学知识可知，耳阶乘的递归定义为：它等于n乘以十1的阶乘，即川劝x（n-1）！，" ID="3">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="并且规定0的阶乘为1。设函数f（n）期！，则j（n）可表示为：" ID="4">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="（凡二0）" ID="5">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="在这里月司为递归终止条件，使函数返回1，月阅实现递归调用，由n的值乘以了（n-1）的；石曰力雪击山子r.、的估】加吕跪献n）｛1氏。＝刃）民奴比奴unn.《n-1）；。12A·数据结构回到调用函数心）的位置继续向下执行口" ID="6">
        <fptr EndPN="00000138" StartPN="00000137"/>
      </Paragraph>
      <Picture URL="00000138\00000138_new\0004.jpg">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Picture>
      <Paragraph CONTEXT="‘一4'fZ3)$Picture[00000138\00000138_new\0009.jpg]Picture$表示。在计算机系统内，执行递归函数是通燕才由田公亦企翻的烤巾的幕本获去过自动使用栈来实现的，图4.5利用《4}调用f(n)递归函数的执行流程其他的每个域是用于存储其值的实际存储空间.每次进行函数调用时，退栈操作，使得上一次调用所使用的参数成为新的栈顶，继续被使用。例如，对于求n阶乘的递归函数f(n)，当调用它时系统自动建立一个栈，该栈中的元第4章找和队列·125用时，，栈顶元素中的值参n域保存的值为4.返回地址域保存的值为rl，当执行f{4)调月时，栈顶元素中的值参n域保存的值为3，返回地址域保存的值为左，当调用f(3)当调用f{n)算法时，系统所使用栈的最大深度为n+1,n为首次调用时传送来的实妻" ID="7">
        <fptr EndPN="00000139" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="间复杂度为ocl)，执行整个算法求出n！的值需要进行n+1次调用，所以其时间复#r当执行f《4）调用结束（即执行到函数体的右花括号结束符）后，就返回到rl的位置执行。又如当执行f（3）$Picture[00000139\00000139_new\0012.jpg]Picture$宁国田沐于云妇下币；子习鉴d〕台6才占盛泛.七君刃只夕牛配，才古习肠1奋石『石1翻，书卜于击进见护节配，老台J鑫二叭心屠】〕1右tl、奋全当调用f（3》结束后，为首次调用时传送来的实参其时间复杂度为0（1），执行整个算法求出川的值需要进行n＋l次调用，所以其时间复杂度也为0伽）。由于采用循环算法求解祀的问题，其空间复杂度为0（1），时间复杂度为0伽），并且省去进出栈的烦琐操作，显然比采用递归算法更为有效.这里对求。阶乘采用递归算法，只是为了详细说明系统对递归算法的处理过程，以便能够理解更复杂的递.口他全幸么例4.5求解迷宫问题＿木4尖合翻今右一牙千丫，用1表示墙壁，即不可通点的坐标为（1，1），出口点的坐标为（成动，当然入口点和出口点的值应均为0，即均可通行。从迷宫中的某一个坐标位置向东、南、西、北任一$Picture[00000139\00000139_new\0031.jpg]Picture$方向移动一步（即一个方格）时，若前面的小方" ID="8">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="格为0，则可前进一步，否则通行受阻，不能前" ID="9">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="格为。，则可前进一步，否则通行受阻，不能前‘a）砷6x8的迷宫" ID="10">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="进，应按顺时针改变为下一个方向移动.求解迷。南自石石石自白号.!26数据结构一一一一－－－－－－－－于当前位置的位移量（包括行位称备和列价称登）肺着前讲古向ai丫田习拦二遥」位移量依次为(4,1(1,0(0，一1）和（一1,Q)。假定用一个4X2的整型数组move来存储位移量数据，则move数组的内容如图4.8所示。其中move[0］一move[31依次存储向东、南、西、北每个方”于向移动一步的位移量。如move[11[01和move[11[1］分别为从当前图4.8Move数组内容位置向南移动一步的行位移量和列位移量，其值分别为1和Oe组，假定用标识符mark表示，用它来标识迷宫中对应位置是否被访问过。该数组每个元表示迷宫中的所有位置均没有被访问过。每访问轰数组中对应元素置1，表示该位置已经被访问过，这样才能够探索新的路径，避免重走己经走不通的老路。为了寻找从入口点到出口点的一条通路，首先从入口点出发，按照东、南、西、北" ID="11">
        <fptr EndPN="00000140" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="各方向的次序试探前进，若向东可通行，同时没有被访问过，则向东前进一个方格；否" ID="12">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="则表明向东没有通向出口的路径，接着应向南方向试着前进，―一一里坚匕生竺吐丝一一下面给出求解迷宫问题的递归算法，其中m和n为全局整型常量，分别表示迷宫的行数和列数，亦即出口点的坐标，maze和mark分别为具有〔m+21[n+21大小的全局整型数,、口11山市们大冰肯扮倪翻抢翻‘；口毛目右rdir”十.hfrFt4P4鹅刑5'I-i.田安t" ID="13">
        <fptr EndPN="00000141" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="组，分别用来保存迷宫数据和访问标记，" ID="14">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="存向每个方向前进一步的位移量。tool5eelcParh(intx,inty)u从迷宫中坐标点（x,y)的位里寻找通向终点（m,n)的路径，若找到则返回true.否则返回false,(x,y）的初始值通常为（cl.1)（lli作为循环变量，代表从当前位里移到下一个位里的方向inti;llg和h用做为下一个位置的行坐标和列坐标" ID="15">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="intg,h;" ID="16">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="11到达出口点返回true结束递归if(arny-nreturntrue;u依次按每一个方向寻找通向终点的路径，IriO,1.z,3分别表示东，南、西、北方向" ID="17">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="伪式1印；1《4；1＋＋）长求出下一个位置的行坐标和列坐标" ID="18">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="9欲＋movellllo］；h＝y＋moveli］11」；IJ若下一位置可通行同时没有被访问过，则从该位里起寻找ifmaze[g][hl=刃mark[gl[h}二＝＝0｛11里nurk数组中对应位置为1，表明己访问过marigl[h]二1;11当条件成立（即返回true)时，表明从（g,h）到终点存在11通路.应输出该位置坐标，同时返回ism结束递归.否则进入下一轮循环，向下一个方向试探" ID="19">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="if(SeelcPath(g,h" ID="20">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="21">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="cout‘暇”（”《9喀出《“）·128·数据结构" ID="22">
        <fptr EndPN="00000142" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="23">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="24">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="｝u当入口点的所有方向都访问完后.表明没有通向终点的路径，/应打印出没有路径信息ifx1y1tout«&quot;Nopathendl;11从当前位置（(x,y）没有通向终点的路径，应返回falsorctumfalse;" ID="25">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="｝当用户调用这个递归算法时，系统将自动建立含有值参x和Y域，局部变量1,和h域以及返回地址r域的一个栈，每次递归调用时都自动进行进栈操作，每次算法执行结束（包括执行到return语句或算法最后的花括号）后都自动进行出栈操作.若算法执行时1ra;r日1积理暇李甘Ffol+ak+r41〕〕r7习件Ynditrnfvlr;的da;田沐十获11钻1认，4苗白宁国田ani3次递归调用前系统栈的变化状态如图4.9所示。对于系统栈的以后变化，读者可继续分析。图4.9调用义比P别由（1，1）算法时系统栈开始阶段变化的情况" ID="26">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="该算法的运行时间和使用系统栈所占有的存储空间与迷宫的大小成正比，在最好情" ID="27">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="况‘一下的时间和空间复杂度均为0（m＋n），在最差情况下均为o（m＊n），平均情况在它们之间。第4章栈和队列·129intmaze[m+ZJ[n+21;II定义保存迷宫数据的数组intmark{m十21【叶21;定义保存访问标记的数组intmave[41[21{0,1{1,0{01｛一1,a}u行下标0,1,2,3分别代表东，南，西，北方向intSeekPath(intx,inty}" ID="28">
        <fptr EndPN="00000143" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="{/1函数体在此省略" ID="29">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="》" ID="30">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="voidnoain(vaid}" ID="31">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="32">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j;" ID="33">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="2瀚入迷宫数据" ID="34">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i司;iun十2;i" ID="35">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="ftn(j闭;jn+2j" ID="36">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="cin卜maze{i]U" ID="37">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="I初始化m川业数组" ID="38">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i习;iam+2;i" ID="39">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="fot{j二0;jn+2;j" ID="40">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="mark[ij]＝0;" ID="41">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="I！置入口点对应的访问标记为1" ID="42">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="mark[II1;从入口点（1,1）开始调用求解迷宫的递归算法itCSeek.Path(l,1oout长“《I《acl《”aendl;/1从入口到出口的路径" ID="43">
        <fptr EndPN="00000143" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="刀按所经位里的相反次序输出，最后需要输出入口点的坐标）当按图4.7输入迷宫数据后，则得到如下输出结果（在第8个坐标后的回车是另加的）。(6,S(6,7(5,7(4,7(4,6(3,6(3,5(3,4(3,3(2,3(2,2{1,2(1,1}例4.6求解汉诺塔(TowerofHanai）问题。大意是：有三个台柱，分别编号为A,·t3o。数据结构并且每次只能搬动一个圆盘，同时必须保证在任何柱子上的圆盘在任何时候都要按序码放，即大的在下，小的在上：当把若干个圆盘从一个柱子搬到另一个柱子时，第三个柱" ID="44">
        <fptr EndPN="00000144" StartPN="00000143"/>
      </Paragraph>
      <Paragraph CONTEXT="放，即大的在下，小的在上：当把若干个圆子作为过渡使用；分析：若一个柱子上只有一个圆盘，则不需要使用过渡台柱，直接把它放到目的柱上即可。若一个柱子上有两个圆盘，则先把一个（只能是上面一个）放到过渡柱子上，再把另一个放到目的柱上，最后把过渡柱上的一个圆盘放到目的柱上，到此完成搬动过" ID="45">
        <fptr EndPN="00000144" StartPN="00000144"/>
      </Paragraph>
      <Paragraph CONTEXT="程。若一个柱子上有三个、四个、……又如何解决呢？必须找出适应于任意多个（即大" ID="46">
        <fptr EndPN="00000144" StartPN="00000144"/>
      </Paragraph>
      <Paragraph CONTEXT="于等于z个）情况的通用方法或规则才行。由此可能想到递归，即先把原柱子上的n-1" ID="47">
        <fptr EndPN="00000144" StartPN="00000144"/>
      </Paragraph>
      <Paragraph CONTEXT="个圆盘设法搬到过渡柱上，再把原柱子上剩下的最后一个圆盘直接搬到目的柱上，最后设法把过渡柱上的n-1个圆盘搬到目的柱上，从而完成全部搬动过程：当把n-1个圆盘" ID="48">
        <fptr EndPN="00000144" StartPN="00000144"/>
      </Paragraph>
      <Paragraph CONTEXT="从一个柱子搬动到另一个柱子时。若它的值不是一个，又需要使用第三个柱子作为过第4章栈和队列‘]31················" ID="49">
        <fptr EndPN="00000145" StartPN="00000144"/>
      </Paragraph>
      <Paragraph CONTEXT="voidHanoi(intn,inta,intb,intc)｛II当只有一个盘子时.直接由a柱搬到c柱后结束一次调用if(n-1)cout吠a&quot;&quot;心6Cndt;" ID="50">
        <fptr EndPN="00000145" StartPN="00000145"/>
      </Paragraph>
      <Paragraph CONTEXT="11当多于一个盘子时，向下递归clse;11首先把n-1个盘子由值参a所表示的柱子搬到由值参6所表示11的柱子上。用值参c所表示的柱子作为过渡Hanol(R-1,8,c,bll由值参a所表示的柱子上的最后一个盘子搬到由值参c所" ID="51">
        <fptr EndPN="00000145" StartPN="00000145"/>
      </Paragraph>
      <Paragraph CONTEXT="刀表示的柱子上。叱卜东滋.”礴公《即dl；11最后把n-1个盘子由值参b所表示的柱子搬到由值参。所表示11的柱子上，用值参e所表示的柱子作为过渡" ID="52">
        <fptr EndPN="00000145" StartPN="00000145"/>
      </Paragraph>
      <Paragraph CONTEXT="Hanai(n-i,b,a,c" ID="53">
        <fptr EndPN="00000145" StartPN="00000145"/>
      </Paragraph>
      <Paragraph CONTEXT="资乡假定采用Harwi(3,1,2,3)去调用该递归函数，则得到的整个递归调用关系如图4.ia所VA+g,fJMzF7A7J3C个树HT17R下面的输[Tr是执行itn-1)子句中输出语句的结果，示，它是一棵树结构，』士誉乙泊出i.a.ta-21.出1-s图4.I0执行Hanvi(3,1,2,3)时的递归调用关系树调用上述递归算法时，若实参n的值为1则算法被执行1次，若值为2则被执行3。132。数据结构若采用Hanoi(4,1,2,3)调用上述递归函数，则得到的输出结果如下，其中为了节省i-21-32-31～23～13～21～2I-32-321312～31～21～323" ID="54">
        <fptr EndPN="00000146" StartPN="00000145"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000146" TITLE="4.7  队列" TYPE="Chapter">
      <fptr LogicalPageNum="146" PhysicalPageNum="146"/>
        <div ORDERLABEL="00000146" TITLE="4.7.1  队列的定义" TYPE="Chapter">
        <fptr LogicalPageNum="146" PhysicalPageNum="146"/>
        <Paragraph CONTEXT="队列（Queue）简称队，它也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，除的一端称做队首（front)。向队列中插入新元素称为进队或入队：新的队尾元素；从队列中删除元素称为离队或出队，元素离队后，" ID="1">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="首元素。由于队列的插入和删除操作分别是在各自的一端进行的，入的次序离队，所以又把队列称为先进先出表（FIFO,FirstInFirst所以又把队列称为先进先出表（R田0，F如tlnF此tout）.；中，人们为购物或等车时所排的队就是一个队列，新来在日常生活中，人们为购物或等车时所排的队就是一个队列，新来购物或等车的人接到队尾（即进队），站在队首的人购到物品或上车后离开（即出队），当最后一人离队$Picture[00000146\00000146_new\0011.jpg]Picture$后，则队列为空。例如，假定有a.b，c，d四个元素依次进队，则得到的队列为（a。b，c，d），其中字符a为队首元素，字符d为队尾元素。若从此队中删除一个元素，则字符a出队，字符b成为新的队首元素，此队列变为（b，c，d）；若接着向该队列插入一个字符e，则e成为新的队尾元素，此队列变为（b，c，d，e）；若接着做三次删除操作，则队列变为（e〕，此时只有一个元素e，‘已既是队首元素又是队尾元素，当它被删除后队列变为空." ID="2">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000146" TITLE="4.7.2  队列的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="146" PhysicalPageNum="146"/>
        <Paragraph CONTEXT="队列的抽象数据类型中的数据部分为具有EIomTyPe元素类型的一个队列，它可以采：一种存储结构实现：操作部分包括元素进队、出队，读取队首元素、检查队列是否用任一种存储结构实现：操作部分包括元素进队、" ID="1">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="为空等。下面给出队列的抽象数据类型的具体定义：第4章栈和队列·t33-" ID="2">
          <fptr EndPN="00000147" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="11初始化队列Q.即里Q为空voidEnQueue(Queue&amp;Q,ElemTypcitem" ID="3">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="11将新元素item的值插入到队尾" ID="4">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypeQutQueueLQueue&amp;Q" ID="5">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="刀从队列中删除队首元素并返回之" ID="6">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="L1emType1?eekQueue(QueueT'ype&amp;Q" ID="7">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="11返回队首元素，但不改变队列状态UaolEmptyQueue{Queue&amp;Q" ID="8">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="若是则返回true，否则返回false" ID="9">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="voidC1earQueue(QueueType&amp;Q刀清除队列Q中的所有元素，使之成为一个空队endQUE[71;假定有一个队列q，其元素类型为整型'tnt，下面给出调用上述操作的一些例子。{1)InitQueue(q" ID="10">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)EnQueue(q,3511元素35进队" ID="11">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)intz=12;EnQueue(q,2*x+311元素2＊x+3的值27进队了力、七.r、，.了月＿1‘、.11石补习毕＿1‘乌业叹人1降口矛Rlil,l1c，7_tC\" ID="12">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）EnQueue匆，一16）；11元素一16进队，止r《、幸刀p～卜n”户d：11翻翻山吐名白弓于瑞导飞《" ID="13">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）cout心尹eCkQueue（q）欲ndl；" ID="14">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="（7）whi1e（！EmPtyQueue（u））cout《outQueue（u）刀依次输出队列q中的所有" ID="15">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000147" TITLE="4.7.3  队列的顺序存储结构和操作实现" TYPE="Chapter">
        <fptr LogicalPageNum="147" PhysicalPageNum="147"/>
        <Paragraph CONTEXT="队列的顺序存储结构需要使用一个数组和两至三个整型变量来实现，利用数组来顺·!34·数据结构ElemTypequeue[MaxSize11MazSize为己定义的常tintfront,rear,1en;其中MaxSize的值确定了queue数组所能存储队列的最大长度。假定该记录类型用" ID="1">
          <fptr EndPN="00000148" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="QueueSq表示：则定义为：" ID="2">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="structQueueSq" ID="3">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypequeue[M3xSize" ID="4">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="intfront,rear.1en;｝；若要对存储队列的数组空间采用动态分配，则QueueSq结构类型可定义为：" ID="5">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="structQueueSq{" ID="6">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemType+queue;11指向存储队列的数组空间" ID="7">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="intfront,rear,1en;11队首指针、队尾指针、队列长度变量intMaxSizc;queue数组长度，即queue所指数组空间的大小）；每次向队列插入一个元素，需要首先使队尾指针后移一个位置，" ID="8">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="面仍存在空闲的位置，则表明队列未占满整个数组空间，下一个存偏" ID="9">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="的空闲位置，因此，" ID="10">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="首先要使队尾指针指向下标为4的位置，然后再向该位置写入新元" ID="11">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="［队列又称为循环队列。在循环队列中，其存储空间是首尾循环利用" ID="12">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="后一个存储位置时，下一个所求的位置自动为数组空间的开始位置素。通过语句re水‘rear＋l）％Maxsize可使；$Picture[00000148\00000148_new\0027.jpg]Picture$下不6片1业翻丽超邑护贫云会自如忱L而！口笼全从，李居祝友R几万.1环，毛素时，若队列非空.则首先把队首指针后移，使之指向队第4章找和队列·135" ID="13">
          <fptr EndPN="00000149" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="1.初始化队列第一种情况是不进行动态存储空间分配voidInitQueue(QueueSq&amp;Q)" ID="14">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="《" ID="15">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.queue＝0;" ID="16">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.len司;" ID="17">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.frontQ.reaz二幻;" ID="18">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.MaxSizaD;}第二种情况是带有动态存储空间分配voidInitQueue{QueueSgdcQ,iatms)【11检查ms是否有效，若无效则退出运行if(ms司}{cout&quot;ms值非法e泪1；e浏1）；｝11置队列空间大小为ms" ID="19">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.MaxSiz亡＝rtts;11动态存储空间分配，若分配失败则退出运行" ID="20">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.queue二newElemType[rUSl;" ID="21">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="ift!Q.queue){" ID="22">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="cerr“内存空间用完！“«endl;" ID="23">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1" ID="24">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="25">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="初始里队列为空" ID="26">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.len＝O;" ID="27">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.front目Q.rear二0;｝" ID="28">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="2。向队列插入元素，若队列已满需皿新分配更大的存储空间voidEnQueue(QueueSq&amp;Q,ElemTypeitem)【·136·数据结构if(Q.len二阅.MaxSize){11新分配原数组空间大小2倍加1的存储空间ElemType«p=rewElemType[2‘Q.MaxSize+lifp){" ID="29">
          <fptr EndPN="00000150" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="cerr”内存空间用完！&quot;aP.ndl;" ID="30">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1" ID="31">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="｝刀把原队首到队尾的满队列中的元素复制到新空间中，11它分为下标Q.front+l至Q.Max$ize-1的前半部分和lIU至Q.rear的后半部分，此时Q.rear等于Q.frontinti,j=1;for(i二Q.front+l;iQ.MaxSize;i" ID="32">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="pGl＝Q.9ueue[i11复制队列的前半部分for(i闭;i=Q.rear;i什）" ID="33">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="p[jQ.queue[i11复制队列的后半部分11置队首指针为0，因为队首元素为下标1位置" ID="34">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.ftnnt台0;即Q.len的值" ID="35">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.rear=Q.len;修改MaxSize域的值为原值的2倍加1" ID="36">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.MaxSize=2+Q.MaxSize+1;" ID="37">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="ui]除原队列空间deleteQ.queue;使queue指向新分配的队列空间" ID="38">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.queue=p;" ID="39">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="}刀求出队尾的下一个位置Q二arQ.二ar+1Q.MaxSize;把item的值赋给新的队尾位置" ID="40">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="¢yueue[Q.rear]二item;" ID="41">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="11队列长度增1" ID="42">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.ien第4章栈和队列·137" ID="43">
          <fptr EndPN="00000151" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="3.从队列中删除元素并返回ElemTypeOutQueue(QueueSgBcQ){" ID="44">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="刀若队列为空则终止运行" ID="45">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="if（Q.len＝司）！" ID="46">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="terra'‘队列已空，无法删除！&quot;aendl;" ID="47">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="exit{1" ID="48">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="）刀使队首指针指向下一个位置" ID="49">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.front二（(Q.front+l)96Q.MaxSiu;u队列长度减I" ID="50">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.len一二" ID="51">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="11返回队首元素returnQ.queue[Q.fraut}" ID="52">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="4.读取队首元紊，不改变队列状态EkemTypePeekQueue(Q二二gq＆Q)！刀若队列为空则退出程序运行if(Q.len＝刃){" ID="53">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="ceirK'‘队列已空，无法读取！&quot;《endl;" ID="54">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="exit{1" ID="55">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="资11队首元素是队首指针的下一个位里中的元素rtiturnQ.queueQ.front+l)96Q.MaxSize}" ID="56">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="5.检查一个队列是否为空，若是则返回true，否则返回falsebootF.mptyQueue(Que二Sq&amp;Q)｛" ID="57">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="returnQ.len二＝0二" ID="58">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="｝·138·数据结构" ID="59">
          <fptr EndPN="00000152" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="6.清除一个队列为空.井释放动态存储空间voidC1caQucuc(QueueSq&amp;Q}" ID="60">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="【" ID="61">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="ifl(Q.queueNULL){" ID="62">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="63">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在顺序队列中进行任何操作的时间复杂度均为Q，当然若考虑到队满时需要重新*ilil''坐If盾fCl万dbl71k,IIIlEIGytfl李未afk`I+lt#eb'禧?I‘甘pal'f'4F$°'L,11ll分配存储和复制原队列的情况，则在这种插入的特殊情况下，表示队列的长度。在上述队列的顺序存储结构中二若省略长度len域也是可行的，但此时的长度为MaxSiza的数组空间最多只能存储长度为MaxSize-1的队列，也就是说必须有一个位置空闰兽待且田去功匀油田奉立反入浦。，e二，一木才六月睁左鹉全R人simr=rti替翻aa良frterter-闲着。这是因为.若使用全部Max5ize个位置存储队列，个位置时，也可能为空队，也可能为满队，洲阵月吟居.口茫f击币，破一才钊台月早配下之室启主注3r只有牺牲一个位置的存储空间，而利用队尾指针加1并对Max:" ID="64">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="的条件，而利用队面又追上了队首）作为判断满队的条件。存储结构的算法，主要做以下修改：" ID="65">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）从QueueSq结构中删除len域：" ID="66">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）" ID="67">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）" ID="68">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）把相应算法中判断满队的条件Q.len＝Q.Maxsize改为（Q.～1）％Q.Maxsize$Picture[00000152\00000152_new\0034.jpg]Picture$第4章栈和队列·l39" ID="69">
          <fptr EndPN="00000153" StartPN="00000152"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000153" TITLE="4.7.4  队列的链接仔储结构和操作实现" TYPE="Chapter">
        <fptr LogicalPageNum="153" PhysicalPageNum="153"/>
        <Paragraph CONTEXT="队列的链接存储结构也是通过由节点构成的单链表实现的，此时只允许在单链表的rear指向队尾〔即表尾》节点的存储位置。用于存储队列的单链表简称链接队列或链队。假定链队中的节点类型仍为以前定义的单链表节点类型sN以址，那么队首和队尾指针为sNode＊指针类型。" ID="1">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="若把一个链队的队首指针和队尾指针定义在一个结构类型中，并假定该结构类型用标识" ID="2">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="游亡、，.，动卜妻丽分kll｝目徐宁卿六n下。" ID="3">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="功”CtQUeueL上《" ID="4">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="目阿侧加＊hOnt，l队首指针" ID="5">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="吕N以如＊r份鱿11队尾指针" ID="6">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="卜" ID="7">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="其中sNDde节点类型重写如下：" ID="8">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="：truct：N侧e硬" ID="9">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="ElelllTy伴山切；11值域一个链接存储的队列如图4.11所示。‘口枢刃一乌卿" ID="10">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="茂叮匕J一一一～―――" ID="11">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="图4.11链队的示意图在类型为叼归。ucL盆的链队HQ上进行队列的各种操作的算法如下：" ID="12">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="t.初始化链队·140·数据结构.门，川，户，月" ID="13">
          <fptr EndPN="00000154" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="2.向链队中播入一个元素void6nQueue(QueueLlc&amp;HQ,ElemTypeitem){1/得到一个由二wPtr指针所指向的新节点sNode*newptr=newshod已；" ID="14">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="it{newptr=NUI,I{" ID="15">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="eerr“内存空间用完！&quot;aendl;" ID="16">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1｝11把item的值赋给新节点的值域，把新节点的指针域置空" ID="17">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="newplr-xlatslitem;newptrnextNULL;11若链队为空，则新节点既是队首节点又是队尾节点" ID="18">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="itCHQ.rear=NULL)HQ.ftont=HQ.tear=newptr;" ID="19">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="汰非空，则依次修改队尾节点的指针域和队尾指针" ID="20">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="若链队非空，" ID="21">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="使之指向新的队尾节点else" ID="22">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="HQ.rear=HQ.rrar-＞next=newptr;｝" ID="23">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="3.从队列中剧除一个元素" ID="24">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="61emTypet7ittQueue(QueueLkBcHQ)" ID="25">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="26">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="11若链队为空则中止运行" ID="27">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="if(HQ.front今Ni,JLL{" ID="28">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="cerra”链队为空，无法'除！&quot;acendl;" ID="29">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1｝第4章栈和队列.141sNade*奸HQ.front;万使队首指针指向下一个节点HQ.front^pnext;万若删除后链队变为空，则需同时使队尾指针变为空itCHQ.front=NULL)HQ.rear二NULL;返回被删除的队首元素" ID="30">
          <fptr EndPN="00000155" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="deletep;" ID="31">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="returntemp," ID="32">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="33">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="4.读取队首元紊F1emTypePeekQueue(QueueLkBtHQ)" ID="34">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="35">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="刀若链队为空则中止执行" ID="36">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="if(HQ.front=二NULL)" ID="37">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="38">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="。。灯《”链队为空无队首元素！“翻诫：" ID="39">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="exit{1" ID="40">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="41">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="11返回队首元素" ID="42">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="returnHQ.fmntdata;" ID="43">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="44">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="5.检查链队是否为空boolEmptyQueue(QueueLk&amp;HQ)砚" ID="45">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="returnHQ.front=NULL;刀判断队首或队尾任一个指针是否为空即可l" ID="46">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="6.清除链队中的所有元素，使之变为空队voidC1eatQueue(QueueLk＆HQ)·142·数据结构" ID="47">
          <fptr EndPN="00000156" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="）除清除队列操作外，其余对链队操作的时间复杂度均为O(1)，清除队列操作的时间复杂度O(nn表示队列的长度." ID="48">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000156" TITLE="4.7.5  队列的应用简介" TYPE="Chapter">
        <fptr LogicalPageNum="156" PhysicalPageNum="156"/>
        <Paragraph CONTEXT="在后面的章节中将会看到队列在具体算法中的应用，这里仅从两个方面来简述队列在计算机科学领域所起的作用。第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例作一下简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，山白台瑕沙」年七七冲月已a晌i;-洲卜招xttir山侧动法居能案斤们红角新中往丰赫且抽的立槽。灯印知献打印机就$Picture[00000156\00000156_new\0010.jpg]Picture$从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求，主高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。对于第二个方打印数据缓冲区中所存储的数据就是一个队列。第4章#和队列·143号，用以表示其优先级别。在优先级队列中，优先级最高的元素必须处在队首位置，因此，每次向它插入元素时，都要按照一定次序调整元素位置，确保把优先级最高的元素调" ID="1">
          <fptr EndPN="00000157" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="整队列中的有关元素，确保把优先级最高的元素调整到队首。优先级队列在操作系统的各种调度算法中应用广泛，它需要使用第6章介绍的堆结构来实现，故在此不做讨论。" ID="2">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="省；" ID="3">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000157" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="157" PhysicalPageNum="157"/>
      <Paragraph CONTEXT="1.找是一种运算受限的线性表，它只允许在找顶进行插入和删除等运算，各种运葬时间复杂度为均a1）." ID="1">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="2.找也适合采用顺序和健接这两种存储结构.通过钱顶指针能够访问到找顶元素和进行插入、侧除等运算." ID="2">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="3.算术表达式具有中级和后级两种表示.对于后级表示的算术表达式，进行运算的" ID="3">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="次序与每个运算符出现的先后次序相同.通过一遥扫描即可完成." ID="4">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="4.把中级表达式转换成后级表达式雷要使用一个运算符找，用来哲存已经扫描到但不能随时放入到后级表达式中的运算符；求后级表达式的值常要使用一个操作数栈，用" ID="5">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="来存储扫描得到的操作数和利用找顶数据进行每个运葬符运葬的结果." ID="6">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="5.计算机执行递归葬法时雷要自动建立和使用一个找，用来存储每次调用后的返回" ID="7">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="地址、形参变全和局部变童的位，每结束一次调用都要按找中保存的返回地址返回到调用位！向下执行，并自动做一次退找处理操作。" ID="8">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="6.队列是一种只允许在一端插入、而在另一端侧除元素的线性表，进行插入的一端" ID="9">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="叫做队尾，而进行侧除的一端叫做队首，插入和删除操作的时间复杂度均为IX1，.队列也适合采用顺序和桩接这两种存储结构.在顺序队列中，存储空间是首尾相" ID="10">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="接的一个环，故称为摘环队列。若用于存储队列的数组空间大小为。，则在不设队列长度" ID="11">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="变量的情况下，其所存队列的最大长度为。一1," ID="12">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
      <Paragraph CONTEXT="8.在顺序队列中，若队尾指针落后于队首指针一个元素位笠。则表示队满；若队首" ID="13">
        <fptr EndPN="00000157" StartPN="00000157"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000157" TITLE="习题4" TYPE="Chapter">
      <fptr LogicalPageNum="157" PhysicalPageNum="157"/>
      <Paragraph CONTEXT="·ta4·数据结构" ID="1">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.栈顶B.栈底C.任意位里D.指定位置" ID="2">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="2.当利用行小为N的数组顺序存储一个栈时.假定用姆详＝N表示栈空，则向这个找插入一个元素时，首先应执行（）语旬修改P指针·" ID="3">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.topB.top一；C.top=0;D.top;" ID="4">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="3.假定利用数组a[N】顺序存储一个栈，用娜表示栈顶指针。官op=＝一i表示栈空，并已知栈未满，当元素x进栈时所执行的操作为‘）." ID="5">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.a卜一topx;B.atop一］=x;C.atopx;D.a[topx;" ID="6">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="4.假定利用数组a[M顺序存储一个栈，用top表示栈顶指针，tap=＝一l表示栈空，并己知栈未空.当退栈并返回栈顶元素时所执行的操作为〔）." ID="7">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.returna【一topB.returnaEtop-1," ID="8">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="C.returnatopD.rewrna[top" ID="9">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="5.假定一个链栈的栈顶指针用P表示，当P所指向的节点进#c时，执行的操作为（）。" ID="10">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.pnext=top;tap=topnext;B.top=p;pnext减op;" ID="11">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="C.pnext=topnext;topnextp;D.pnexbtop:to护p:假定一个链栈的栈顶指针用top表示.当进行退栈时所进行的指针操作为（" ID="12">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="6.假定一个链栈的栈顶指针用1叩表示.当进行退栈时所进行的指针操作为（）." ID="13">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A，to卜＞ncxt二tOP；B注叩减呼闭.试" ID="14">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="C.加少勿卜＞nc双；D.帕p＞呱t＝＝t0P一＞oext.＞呱t；" ID="15">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="7.若让元素.，2，3依次进栈，则出栈次序不可能出现（）种情况。" ID="16">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.3，2，IB.2，1，3C.3，1，ZD.1，3，2" ID="17">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="8.在一个顺序队列中.队首指针指向队首元素的（）位里。" ID="18">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.前一个B.后一个C.当前D，后面" ID="19">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="9.当利用行小为N的数组顺序存储一个队列时，若设有队列长度的变量，则该队列的最行长度为（）。" ID="20">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.N-ZB.N-IC.ND.N十1" ID="21">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="10.当利用行小为N的数组顺序存储一个队列时.若不设有队列长度的变量.则该队列的最行长度为‘）。" ID="22">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.N-ZB.N-IC.ND.N十1" ID="23">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="11.从一个顺序队列删除元素时，首先需要（）。" ID="24">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.队首指针循环加IB，队首指针循环减1" ID="25">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="C.取出队首指针所指位置上的元素D.取出队尾指针所指位置上的元素" ID="26">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="12.假定，个不设队列长度变最的顺序队列的队首和队尾指针分别为f和r，则判断队空的条件为（）." ID="27">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.f＋！二rB.r＋】＝fC.宜七以）D.卜时第4章栈和队列.145" ID="28">
        <fptr EndPN="00000159" StartPN="00000158"/>
      </Paragraph>
      <Paragraph CONTEXT="A.front二二xearB.front！二NULLC.rearNULLD.frD»片＝NULL" ID="29">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="14.假定利用数组a(N]循环顺序存储一个队列，用f和r分别表示队首和队尾指针，并已知队未满.当元素x进队时所执行的操作为（）。" ID="30">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="A.ar96NJ二剐8.alr＋＋％阅＝x；C.al-r96N]二；D.a[rN]c;" ID="31">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="15.假定利用数组a[N]循环顺序存储一个队列，用f和r分别表示队首和队尾指针.并已知队未空，当进行出队并返回队首元素时所执行的操作为（）." ID="32">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="A.returnar95NJ;B.returna［一r9bN" ID="33">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="C.muma[十十fgbND.returna[f96NJ;" ID="34">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="16.假定一个带头节点的循环链队的队首和队尾指针分别用fron宜和syr表示，则判断队空条件为（）." ID="35">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="A.frontrearB.restNULLC.frontNULLD.front=二=roar" ID="36">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="17.在一个长度为N的数组空间中，顺序存储着一个队列，该队列的队首和队尾指针分别用front和rear表示.则该队列中的元素个数为（）。" ID="37">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="A.{tray-front)46NB.{～自front+N)96N" ID="38">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="C.{tear十N)96ND.(front+N)96N招城空月" ID="39">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="1.队列的插入操作在＿进行，州除操作在―进行." ID="40">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="2.栈又称为.＿…表.队列又称为表." ID="41">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="3.向一个顺序栈擂入一个元素时，首先使…＿.后移一个位置，然后把待插入元素到这个位置上。" ID="42">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="4.从一个顺序栈删除元素时.首先取出.，然后再使栈顶指针" ID="43">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在一个不设队列长度变最的顺序队列Q中，判断对空的条件为＿，判断队满的条件为一." ID="44">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="6.在一个链队中，若队首指针与队尾指针的值相同，则表示该队为或该队，.向一个链栈插入一个新节点时，首先把栈顶指针的值斌给＿，然后把新节点的存储位置赋给＿。" ID="45">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="8.从一个链栈中删除一个节点时，需要把校顶节点的值斌给" ID="46">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="9.当用长度为N的数组顺序存储一个栈时，假定用to护＝N表示找空，则表示栈满的条件为＿＿＿口" ID="47">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="10.向一个栈顶指针为HS的链栈中插入一个新节点＊*p时，应执行和＿操作。" ID="48">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="11.中缀表达式3.（x＋2卜5所对应的后缀表达式为＿。" ID="49">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="12.后缀表达式“45*32＋一”的值为＿。13甲在求解迷宫问题的递归算法中，输出一条通路上的每个位健的坐标是按照从入口到出口的·146·数据结构―－一进行的.14在进行函数调用时.需要把每个实参的值和调用后的―传送给被调用的函数中.15‘当被调用的函数执行结束后，将自动按所保存的＿所指位里执行。" ID="50">
        <fptr EndPN="00000160" StartPN="00000159"/>
      </Paragraph>
      <Paragraph CONTEXT="16.设元素1,2,3,4,5依次进S栈，若要在愉出端得到序列34251，则应进行的操作序列为push(s,1push(S.2＿，pop{Spush{S,4pop(s―，―，pop(spop(S)e" ID="51">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="17.设元素a,b,c,d依次进S栈，若要在输出端得到序列!M1，则应进行的操作序列为push(S,apush(S,bpush(S,c＿,，一pop(Spop(S)o43算." ID="52">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="l.有6个元素A,B,C,D,E,F依次入栈，允许任何时候出栈.能否得到下列的每个出栈序列，若能，给出栈操作的过程，若不能。简述其理由。" ID="53">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)CDBEFA(2)ABEDFC(3}DCEABF{4)BAEFCD" ID="54">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="2.有4个元素a,b,c,d依次进栈，任何时候都可以出栈，请写出所有可能的出栈序列和所有不存在的序列。" ID="55">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="3.假定用一维数组a[71顺序存储一个循环队列，队首和队尾指针分别用front和rear表示.当前队列中已有5个元素；23,45,67,S0,34.其中23为队首元素，from的值为3.请画出对应的存储状态，当连续做4次出队运算后，再让15,36,48元素依次进队，请再次画出对应的存储状态.4.4算法分析且" ID="56">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="1.intAE(intaintn}" ID="57">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="58">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="if(n=习)return0;elsereturna[n-11+AE{a,n-1｝" ID="59">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="请写出该递归算法的功能。" ID="60">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="2.intAF(intk,ints)11第一次使用AF{0,0}调用此算法{" ID="61">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="if(s=1000)returnk-1;" ID="62">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="63">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="k第a章栈和队列·147s十＝k*k;returnAF{k,s含" ID="64">
        <fptr EndPN="00000161" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="）清写出该递归算法的功能。" ID="65">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="3.voidTransform{longnum)11num为正整数！" ID="66">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="Stacka;" ID="67">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="InitStack(a" ID="68">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="while{num！司){intk二num9b16;Push(a,k" ID="69">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="num1G;" ID="70">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="，whileEmptyStack{a))《" ID="71">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="intx＝助酥a）；" ID="72">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="if(xlb)" ID="73">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="cvutax;" ID="74">
        <fptr EndPN="00000161" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="else{switch{x)I·148·数据结构}" ID="75">
        <fptr EndPN="00000162" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="76">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="77">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="couto;endl;" ID="78">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="79">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="请写出该递归算法的功能。" ID="80">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="4.写葬法设计月" ID="81">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="1.设计一个递归算法，返回1至a之间的所有整数平方的和。" ID="82">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="2.设计一个递归算法.把任一十进制正整数转换为S进制（(2镬5簇9)数输出." ID="83">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="3.裴波那契（Fibon月〔ci)数列的定义为：它的第1项和第2项分别为a和1，以后各项为其前两项之和。若裴波那契数列中的第。项用Fib(n)表示，则计算公式为.IFiNn-11本Fihln-711n、71（n＞2）试编写出计算Fib认）的递归算法和非递归算法。" ID="84">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="4.假定在一个链接队列中只设置队尾指针.不设置队首指针.并且让队尾节点的指针域指向队首节点（称此为循环链队）.试分别写出在循环链队上进行插入和删除操作的算法。" ID="85">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在一个数组空间5“‘k【5撅侧从旅size］中可以同时存放两个顺序栈，栈底分别处在数组的两端.当第一个栈的栈顶指针tOPI等于一1时则栈1为空，当第二个栈的栈顶指针tOPZ等于Maxs读时则栈2为空。两个栈均向中间增长，当向栈1插入元素时，使toPI增1得到新的栈项位里，当向栈2插入元素时，.lJ使伯PZ减1才能够得到新的栈顶位置.当娜1等于幻pZ-1或者tOPZ等于tOPI＋l时，存储空间" ID="86">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="用完，无法再向任一栈插入元紊。用于双栈操作的顺序存储类型可定义为：" ID="87">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="stluctBo比5.ckl" ID="88">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTyl邓5加‘k【Maxsi沈】；第4章栈和队列.149双栈操作的抽象数据类型可定义为：" ID="89">
        <fptr EndPN="00000163" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="DATBSTACKis" ID="90">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="Data:采用顺序结构存储的双栈，其存储类型为BothStackOperations:voidInitStack(BothStack&amp;BS,intk11初始化栈.当k或2时对应置栈I或栈2为空，llk=3时t两个栈均为空.voidC1earStack(BathStack&amp;BS,intk)清除栈。当lc=l或2时对应$1或$2被清除，刀k合3时两个栈均被清除。toolStackEmpty(SothStack&amp;BS,intk)11判断栈是否为空。当k=1或2时判断对应的栈1II或栈2是否为空，k=3时判断两个栈是否同时11为空。若1断结果为空则返回。ue，否则返回falseElemTypePeek(BothStack&amp;BS,intk)ll（栈顶元素。当k=1或2时对应返回栈1或栈2的找顶元素。voidPush(BothStackdtBS,intk,tonalElemType&amp;item}11进栈。当k=1或2时对应向找1或$2的顶a压11入元素itcmElemTypePop(BothStack&amp;BS,intk)11退栈.当krl或2时，对应使栈1或栈2退找并返从团栈顶元素." ID="91">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="EodBSTACK试写出上述抽象数据类型中每一种操作的算法." ID="92">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="6.根据代数中的二项式定理，二项式(x+yY'的展开式的系数序列可以表示成图4.12那样的三角形，其中除每一行最左和最右两个系数等于1以外，其余各系数均等于上一行左右两系数之和。这个系数三角形称做杨辉三角形。设C(n,k)表示杨辉三角形中第。行〔n多0)的第k个系数(0`k簇n)，按照二项式定理.C(n,k)可递归定义为：＿，，、（1{k=09Sck=n)·150·数据结构(x+j)'I613261361I72t3535217II828Sb70562881图4.12杨辉三角形" ID="93">
        <fptr EndPN="00000164" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)写出计算C(n,k)的递归算法；$Picture[00000165\00000165_new\0001.jpg]Picture$$Picture[00000165\00000165_new\0002.jpg]Picture$第口章一············$Picture[00000165\00000165_new\0006.jpg]Picture$树和二叉树抓····.‘" ID="94">
        <fptr EndPN="00000165" StartPN="00000164"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="00000165" TITLE="第5章  树和二叉树" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000165" TITLE="5.1  树的概念" TYPE="Chapter">
      <fptr LogicalPageNum="165" PhysicalPageNum="165"/>
        <div ORDERLABEL="00000165" TITLE="5.1.1  树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="165" PhysicalPageNum="165"/>
        <Paragraph CONTEXT="并且树的根节$Picture[00000165\00000165_new\0005.jpg]Picture$$Picture[00000165\00000165_new\0006.jpg]Picture$显" ID="1">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="然，树是一种递归定义的数据结构。e41S1一理'T_v由用rA节点的左下部和右下部，和C是A的后继；$Picture[00000165\00000165_new\0012.jpg]Picture$·152·数据结构树.则为：" ID="2">
          <fptr EndPN="00000166" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="Tree(K,R)" ID="3">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="K二｛k;l1（i成n,n）0,k;eFlemType}其中n为树中节点数，n0则为空树。n0则为非空树。对于一棵非空树，关系R应满足下列条件：(1}有且仅有一个节点没有前驱，该节点被称为树的根。" ID="4">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）除树根节点外，其余每个节点有且仅有一个前驱节点；" ID="5">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）包括树根节点在内的每个节点，可以有任愈多个（含0个）后乡材干阅嘴1成采的姗，r＿芒垂田一干拍书呆＿戚1节占的生合F知r卜" ID="6">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="上二元关系R分别为：孟片｛A。B，C，D.E，EG，H。11R＝｛（A.B），（A，C）.（B.D），（B，E》，（B.F），（C，G）.（E.H），（E，1）｝其中A节点无前驱节点，被称为树的根节点；其余每个节点有且仅有一个前驱节点。在所有节点中，B节点有三个后继节点，A节点和E节点分别有两个后继节点，C节点有一个后继节点，其余节点均没有后继节点。在日常生活和计算机领域，树结构广泛存在。例5.1可把一个家族看做为一棵树，树中的节点为家族成员的姓名及相关信息，树中的关系为父子关系，即父亲是儿子的前驱，儿子是父亲的后继。图5.2（家族树.干庭贵有两个Jl、子干万胖和干万利.下万胖又有三个JI.子下家新、家族树，王庭贵有两个儿子王万胜和王万利，王万胜又有三个儿子王家新、王家中和王穷国例5.2可把一个地区或一个单位的组织结构看做为一棵树，树中的节点为机构的名称及相关信息，树中的关系为上下级关系.如一个城市分为若干个区，每个区又分为若例5.3可把一本书的结构看做为一棵树，树中的节点为书、章、节的名称及相关信息，树中的关系为包含关系。图5.2（b）是一本书的结构，第，章树和二叉树“153包含有若干个子目录项和文件项.每个子目录下又包含有若干个子目录项和文件项，依" ID="7">
          <fptr EndPN="00000167" StartPN="00000166"/>
        </Paragraph>
        <Picture URL="00000167\00000167_new\0005.jpg">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Picture>
        <Picture URL="00000167\00000167_new\0006.jpg">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Picture>
        <Picture URL="00000167\00000167_new\0007.jpg">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Picture>
      </div>
        <div ORDERLABEL="00000167" TITLE="5.1.2  树的表示" TYPE="Chapter">
        <fptr LogicalPageNum="167" PhysicalPageNum="167"/>
        <Paragraph CONTEXT="树的表示方法有多种.图5.1和S.2中的树形表示法是其中的一种，也是最常用的一种，图5.1和5.2中的节点是从上向下展开的，有时也需要树中的节点按从左向右展开的。在树形表示法中，头（即方向），但它并不是无向的，而是有向的，其方向隐含为从上向下或从左向右，即连线的上方或左边节点是下方或右边节点的前驱，下方或右边节点是上方或左边节点的后继.树的另一种表示法是二元组表示法。除这两种之外，通常用广义表表示法，每棵" ID="1">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="树的根作为由子树构成的表的名字而放在表的前面，图5.1树T的广义表表示为：" ID="2">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="n(Bcn,E（H,1,c(c" ID="3">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000167" TITLE="5.1.3  树的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="167" PhysicalPageNum="167"/>
        <Paragraph CONTEXT="1.节点的度和树的度树中每个节点具有的非空子树数或者说后继节点数被定义为该节点的度（degree)" ID="1">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="所有节点的度的最大值被定义为该树的度。如在图5.1的树T中，B节点的度为3,二节点的度均为2.c节点的度为1，其余节点的度均为o因所有节点的最大的度为·134·数据结构节点或非终端节点。在分支节点中，每个节点的分支数就是该节点的度数，如对于度为1的节占甘跳古粉告1断！，1山止玉至令吩菌篇谷古常占。什月p磨蛋，的常占甘-4Ir,的节点，其分支数为1，所以被称之为单分支节点；对于度为2的节点，所以被称之为双分支节点，其余类推.如在图5.1的树T中，D，H，1，F，点；A，B，C，E是分支节点，其中C为单分支节点，A和E为双分支节点，B为三分支节" ID="2">
          <fptr EndPN="00000168" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="点。" ID="3">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="3.子节点、双亲节点和兄弟节点在一裸树中，每个节点的子树的根，或者说每个节点的后继，被习惯地称做该节点白台男宜二莽.！与已石称与阵刁毕了。卜n月、去月1找岁栩，书素嘴专占二出书全月治二己成今古配.勺勺鱼芯戒）昌邑石e魂》去体儿子或子女（c城d〕，相应地，该节点被称做子节点的双亲、父亲或父母、具有同一双亲的孩子互称兄招（brothe路）。每个节点的所有子树中的节点枯森（parent）。具有同一双亲的孩子互称兄弟（brothe巧）。做该节点的子孙。每个节点的祖先则被定义为从整个树的根节点到达该节点的路径上经过的所有分支节点。如在图5.1的树T中，B节点的孩子为D，E，F节点，双亲为A节点，D，E，F互为兄弟，B节点的子孙为D，E。H，1，F节点，1节点的祖先为A，B，E节点，对于树T中的其他节点亦可进行类似的分析。" ID="4">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="由子节点和双亲节点的定义可知；在一棵树中，根节点没有双亲节点.叶子节点没有子节点，其余节点既有双亲节点也有子节点。如在图5.1的树T中，根节点A没有双亲，叶子节点D，H，1，F，G没有孩子。" ID="5">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="4.节点的层数和树的深度树既是一种递归结构，也是一种层次结构，树中的每个节点都处在一定的层数上。节点的层救（leve】）从树根开始定义.根节点为第一层.它的子节点为第二屏。以此斗根节点为第一层，它的子节点为第二层，以此类推。树中节点的最大层数称为树的深度（山，山）或商度（height）。如在图5.1的树T巾.A节占朴千笔一尽.Rr节占朴干笛一早.nppn节占b卜千笙＝早＿目r节占b卜于第四层。H，1节点所处的第四层为树T中节点的最大层数，所以树T的深度为4。" ID="6">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="5.有序树和无序树若树中各节点的子树是按照一定的次序从左向右安排的，则称之为有序树，否则称第5章树和二叉树.155－一········理，所以以后若不特别指明，均认为树是有序的。" ID="7">
          <fptr EndPN="00000169" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="B.森林森林是m(m〕U)棵互不相交的树的集合。例如，对于树中每个分支节点来说.其子树的集合就是森林。如在图5.1的树T中，由A节点的子树所构成的森林为《Ti,TZ由B节点的子树所构成的森林为｛Tai,Tiz.Tls}，等等." ID="8">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000169" TITLE="5.1.4  树的性质" TYPE="Chapter">
        <fptr LogicalPageNum="169" PhysicalPageNum="169"/>
        <Paragraph CONTEXT="性质1树中的节点数等于所有节点的度数加1」丫。口七目召良叔于r亡心旨口叻二一创卫毛廿山咫盏七廿创日胃布声根据树的定义，在一棵树中，除树根节点外，每个节点有且仅有一个前驱节J片杭人萦占匕也白亡的一水关冬古一一补扁断图陈树幻节占少林的节占猫点，也就是说，每个节点与指向它的一个分支一一对应，所以除树根节点之外的节点数榷丫解古效古砧八古粉，日口商黔iu而ar.去廿由bhp'占粉竺干断右节占的磨纷加t＿砚的分支数（即度数），从而可得树中的节点数等于所有节点的度数加to右I,r.6Er{山r:LF-不之泊，1J-1T占ri性质'r度为k的树中第‘层上至多有f一’个节点（1〕1）。对于第一层显然是成立的，因为树中的第一层上只有一个节点，即整个树的根节点，而由1－1代入砂’计算，也同样得到只有一个节点，即犷‘＝kl一’＝尸司。假设对于第1-1层（1＞1）命题成立，即度为k的树中第卜1层上至多有尸一’习娜一2个节点，则根据树的度的定义，度为k的树中每个节点至多有k个孩子.性质3深度为h的k叉树至多有少一1）1深度为h的k叉树至多有少一1）l（k-1）个节点。改然当深度为h的无叉树（即度为k的树）－显然当深度为h的无叉树（即度为k的树）上每一层都达到最多节点数时，所有节点的总和才能最大，即整个k叉树具有最多节点数。为.156数据结构.白～············" ID="1">
          <fptr EndPN="00000170" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="亡立＜，簇旦二三" ID="2">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Picture URL="00000170\00000170_new\0005.jpg">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Picture>
        <Paragraph CONTEXT="可变换为：砂一trn(k-11蕊kp如x的值为4和4.3时，向上取整结果分别因此得到具有。个节点的一般k叉树的最小深度为「log(r(k-11)0例如，对于二叉树，求最小深度的计算公式为「lag2(R+1)，若月二2" ID="3">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="付于三叉树，求最小深度的计算公式为log3(2n+1)，若，20，则最，5：对于三叉树，求最小深度的计算公式为n吃3（2。＋l）1，若，20，则最小深度为40" ID="4">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000170" TITLE="5.2  二叉树" TYPE="Chapter">
      <fptr LogicalPageNum="170" PhysicalPageNum="170"/>
        <div ORDERLABEL="00000170" TITLE="5.2.1  二叉树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="170" PhysicalPageNum="170"/>
        <Paragraph CONTEXT="它是一种树结构，在计算机领域有A节点的左下部，B毛位于A节点的右下部：BT.又由根节点B和左子树BT.；（它树）所组成：对于B几树也可进行类似的第5章树和二叉树·l57" ID="1">
          <fptr EndPN="00000171" StartPN="00000170"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000171" TITLE="5.2.2  二叉树的性质" TYPE="Chapter">
        <fptr LogicalPageNum="171" PhysicalPageNum="171"/>
        <Paragraph CONTEXT="二叉树具有下列一些重要性质。证明：设二叉树上终端节点数用no表示，单分支节点数用n表示，双分支节点数用洲r、比竺门已苗浦冬含次今占圳r俪闷石衷立的寸叮八古针占珊日n竺日阵.二，.＿th树的和主篇1石丫即等于nl＋2n2。由树的性质1可得：询栩1＋外2＝川＋Zn妙1即no翎沙1例如，在图5.4的二叉树BT中，度为2的节点数为2个，度为0的节点数为3个，它比度为2的节点数正好多1个。性质2二叉树上第1层上至多有2‘一’个节点（1）1）。由树的性质2可知：度为k的树中第1层上至多有砂’个节点。对于二叉树，树的度为2，性质3深度为h的二叉树至多有妒一1个节点.由树的性质3可知：深度为h的k叉树至多有少一1）j（k-1）个节点。对于二叉树，树的度为2，将花二2代入沪一1）Ite-1）即可得到此性质3.在一裸二叉树中，当第1层的节点数为2‘一1个时，则称此层的节点数是满的，当树中的每一层都满时，则称此树为满二叉树。由性质3可知，深度为h的满二叉树中的节点1右蛤曰讼叨旦断U.l、勇｝十曰一巨U七封1七的方良材尔木书占排好确县。158·数据结构完全二叉树的特例。图5.5{b）为一棵完全二叉树，它与等高度的满二叉树相比，在最后一层的右边缺少了5个节点。该树中每个节点上面的数字为对该节点的编号。1性质4" ID="1">
          <fptr EndPN="00000172" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)若i成Ln/2J，即2i蕊n，则编号为i的节点为分支节点，否则为叶子节点。表达式LXJ表示对x进行向下取整。如当x为4或4.8时得到的运算结果均为40" ID="2">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）若。为奇数，则树中每个分支节点都既有左孩子，又有右孩子：若n为偶数，则编号最大的分支节点（编号为应）只有左孩子，没有右孩子，其余分支节点左、右孩子都有。" ID="3">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)若编号为i的节点有左孩子，则左子节点的编号为2i：若编号为i的节点有右孩子，则右子节点的编号为2i+1，即遵循对一般二叉树的编号规则。" ID="4">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)除树根节点外，若一个节点的编号为i，则它的双亲节点的编号为【nrzJ.也就是说，当i为偶数时，其双亲节点的编号为i/2，它是双亲节点的左孩子，当i为奇数时，其双亲节点的编号为（i-12，它是双亲节点的右孩子。例如，在图5.5(b)所示的完全二叉树中，因树中节点数n=a，所以编号小于等于s的节点为分支节点，大于5的节点为叶子节点。它的左孩子是编号为4的节点D,性质5具有，个cno）节点的完全二叉树的深度为logZ(n十1)1或L1asZnJ+lo）h，由完全二叉树的定义可知，它的前h-1层都是山1Ff3crf-hnT不竺可变换为：2-1aa+1蕊2`还可表示为：取对数后得h-1`log2n¢h，即log协rh.logyt+l第S章树和二叉树·159$Picture[00000173\00000173_new\0003.jpg]Picture$$Picture[00000173\00000173_new\0004.jpg]Picture$$Picture[00000173\00000173_new\0005.jpg]Picture$(a)(b)圈5.6理想平衡树和普通二叉树" ID="5">
          <fptr EndPN="00000173" StartPN="00000172"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000173" TITLE="5.2.3  二叉树的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="173" PhysicalPageNum="173"/>
        <Paragraph CONTEXT="二叉树的抽象数据类型的数据部分为一棵二叉树，操作部分包括初始化二叉树、建" ID="1">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="立二叉树、遍历二叉树、查找二叉树、输出二叉树、清除二叉树等一些常用操作。" ID="2">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="给出二叉树的抽象数据类型的具体定义。DATBinaryTreeisData:采用任一种方式存储的二叉树.假定其存储类型用BTreeTyi”标识符表示." ID="3">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="该类型的一个对象〔即二叉树）用BT标识符表示。q衅.石的5voidInitBTree(BTreeType&amp;BT刀初始化二叉树.即把它置为一棵空树。voidCreateBTzee(STreeType&amp;BT,char+a" ID="4">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="boolBTreeEmpty(BTreeType&amp;BT若是则返回true，否则返回falsevoidTrave二BTYoe(BTisceTypeBtBT}方按照一定次序泊历一裸二叉树，·t6o·数据结构intBT二Depth(STreeType&amp;BT刀求出一裸二叉树的深度。voidPrintBTree(BTrreType&amp;BT刀按照树的一种表示方法输出一棵二叉树.刀清除二叉树中的所有节点，1" ID="5">
          <fptr EndPN="00000174" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="使之变为一棵空树。endBinaryTtee" ID="6">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000174" TITLE="5.2.4  二叉树的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="174" PhysicalPageNum="174"/>
        <Paragraph CONTEXT="同线性表一样，二叉树也有顺序和链接两种存储结构." ID="1">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="1.顺序存储结构顺序存储一棵二叉树时，首先对该树中每个节点进行编号。然后以各节点的编号为日，左成大舌卜山七.6台洲，魂争启介亘名么谈禽占配，子白工王中，（.）沙）图5.7带节点编号的二叉树$Picture[00000174\00000174_new\0010.jpg]Picture$$Picture[00000174\00000174_new\0011.jpg]Picture$树，则两数组中各元素的值如图5.8所示。D1234567891D第5章树和二叉树.161标为i的元素），其双亲节点的下标为LJ；若存在左孩子，则左子节点的下标为2！：若存在右孩子，则右子节点的下标为2i+1二叉树的顺序存储结构对于存储完全二叉树是合适的，二叉树的顺序存储结构对于存储完全二叉树是合适的，它能够充分利用存储空间，但对于一般二叉树，特别是对于那些单支节点较多的二叉树来说是很不合适的，因为可能只有少数存储位置被利用，而多数或绝大多数的存储位置空闲着.因此，对于一般二" ID="2">
          <fptr EndPN="00000175" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="2.链接存储结构在二叉树的链接存储中，通常采用的方法是：在每个节点中设置三个域：值域、左其中data表示值域，用于存储对应的数据元素，left和right分别表示左指针域和右指针域，用以分别存储左孩子和右子节点的存储位置（即指针）。链接存储的另一种方法是：在上面的节点结构中再增加一个parent#·162·数据结构带双亲指针的链接存储结构（称做带双亲指针的二叉链表）如图5.9(c）所示。其中伦为树根指针。同单链表相同，二叉链表既可由独立分配的节点链接而成，也可由数组中的元素节·知沈口二.s±击«‘t口Jxd.J:3r_rmdfr.rmaw『二r廷些v" ID="3">
          <fptr EndPN="00000176" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="点链接而成。" ID="4">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="structBTreeNocle{" ID="5">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;" ID="6">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="BTreeNode*1eft;" ID="7">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="BTreeNode*right;若采用元素节点，则节点类型可定义为：" ID="8">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="structABTreeNode{" ID="9">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;" ID="10">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="int1eft,right;｝；在元素节点中，left和right域分别存储左、右子节点所在单元的下标，所以被定义为整型。rypedefABTreeNodeABTList[BTreeMaxSize其中BTreeMaxSize为全局整型常量，其值由用户事先定义，由它决定建立二叉链表的最大节点数。假定用ABTList类型的一维数组存储图5.9Cb)所示的二叉链表。由于在链接存储" ID="11">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="节点之间的逻辑关系是通过指针实现的，所以各节点在数组中占用的下标位置可以任何一种次序安排，不妨按照层数从小到大、同一层从左到右的次序为各节点分配存储位置，则得到该二叉链表的存储映像，如图5.1p所示。注意：元素节点从下标为1第s章树和二叉树·163来，当需要时再从文件整体读入到数组进行处理。" ID="12">
          <fptr EndPN="00000177" StartPN="00000176"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000177" TITLE="5.3  二叉树遍历" TYPE="Chapter">
      <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
      <Paragraph CONTEXT="假定二叉树由具有BTreeltiiac类型的、通过动态分配产生的独立节点链接而成，并假定BT为指向树根节点的指针，从树很指针出发可以访问到树中的每一个节点，所以可二叉树的遍历是二叉树中最重要的运算。二叉树的遍历是指按照一定次序访问树中所有节点，并且每个节点的值仅被访问一次的过程.根据二叉树的递归定义，一棵非空二叉树由访问根节点、遍历左子树和遍历右子树。若分别用D,L和R表示上述三个子问题，则有DLR.LDR,LRD,DRL,RDL,R工D六种次序的遍历方案。其中前三种方案都是先遍历左R工D六种次序的遍历方案。.历方案。熟悉了前三种，后三" ID="1">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="子树，后遍历右子树，而后三种则相反，都是先遍历右子树，后遍历左子树，由于二者对" ID="2">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="益创了荃公介，口右计46箭二：劫加卜良的；自不月纷安愉盛了省台：：劫苍二：劫化白奋书山刁飞曰胃扮双罕" ID="3">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="称，故我们只讨论前三种次序的遍历方案。熟悉了前三种，后三种也就迎刃而解了。" ID="4">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="1七拐白目二州七吧左n，刀d，伟1习队J七1乍1创B成今占台6妇盛‘七‘2‘4自1下1七创七.二改七廿今钓介五了毛全」" ID="5">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="因为访问根节点的操作在遍历左、右子树之前，故称之为前序" ID="6">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="（P戈侧旧盯）遍历或先根遍历。类似地，在LDR方案中，访问根节点的操作在遍历左子树之后和遍历右子树之前，故称之为中序（玩优dcr）遍历或中根遍历。在LRD方案中：" ID="7">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="访问根节点的操作在遍历左、右子树之后，故称之为后序（Postorder）遍历或石根遍历。" ID="8">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="显然，遍历左、右子树的问题仍然是遍历二叉树的问题，当二叉树为空时递归结束，珍" ID="9">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="当二叉树为空时递归结束，所·164·数据结构{" ID="10">
        <fptr EndPN="00000178" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCBTI-NULL)[Inorde{BTleft11中序遍历左子树cou摊BT－》data司仁“；11访问根节点Ioordei(ST-aright11中序退历右子树1" ID="11">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="12">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="3.后序迫历算法" ID="13">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="voidPostotdet(eTreeNode*BT)" ID="14">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="15">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="itTNULL){Postordct{BTalcft11后序通历左子树Postorder(BT-aright11后序遍历右子树couta:BT-xiata峭K;11访问根节点1" ID="16">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="1在这三种遍历算法中，访问根节点的操作可视具体应用情况而定，这里暂以打印根节点的值代之。当然若节点的值为用户定义的记录类型，或者依次输出节点值对象中的每个域的值。图5.11二叉树遍历当从其他函数调用（此次称为第D次递归调用）中序遍历算法时，需要以指向树根第5章树和二叉树·165r域，假定进行第U次递归调用后的返回地址为ro，中序遍历左子树后白行taut语句的地址）为rl，中序遍历右子树后的返回地址（即算法结兑并假定指向每个节点的指针用该节点的值后缀小写字母P表示，如指向用Bp表示，则每次进行递归调用时的系统栈的变化状态如图5.12所示。回地址r域，假定进行第0次递归调用后的返回地址为ro，中序遍历左子树后的返回地址（即执行cout语句的地址）为rl，中序遍历右子树后的返回地址（即算法结束的地址）为几，并假定指向每个节点的指针用该节点的值后缀小写字母p表示，如指向B节点的指针就用Bp表示，里噩剔田鬓幽（a）（b）（劝（d）（e）.出c（幻.出a团豁出幽幽国她）伪）抽出0（1）抽出AO〕你）抽出E（1）幽鬓幽（m）（n）抽出G（a）.出F" ID="17">
        <fptr EndPN="00000179" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="图5.12对图5.11所示的二叉树执行中序遍历算法时系统栈的变化状态由上述分析中序遍历算法的执行过程可知，打印出的节点序列为：·166。数据结构节点的个数.另外在执行每个递归遍历算法时，系统都要使用一个栈，栈的最大深度等千二1姗的涣彦D1.而二叉树的漫度视其具体形态决定，若二叉树为理想平衡树或接近" ID="18">
        <fptr EndPN="00000180" StartPN="00000179"/>
      </Paragraph>
      <Paragraph CONTEXT="理相平街树.则二叉树的深度大致为10衡n，所以其空间复杂度为以】雌1刀），若二叉树1另外，还可以按照二叉树" ID="19">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="1，即按照从上到下、同一层从左到右的次序访问各节点.如对于图$Picture[00000180\00000180_new\0008.jpg]Picture$5.11所示的二叉树，" ID="20">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="A，日，城C，D，从G按层遍历算法需要使用一个队列，开始时把整个树的根节点入队，然后每从队列中" ID="21">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="删除一个节点并输出该节点的值时，都把它的非空的左、右子节点入队，这样当队列空时算法结束。" ID="22">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="4.按层遮历算法此算法为一个非递归算法，具体描述如下：voidUvelo魂比式B介.N以加.BT）jl按层遍历由BT指针所指向的二叉树【co叹Max比n幽＝30；11定义用于存储队列的致组长度BT侧沈N以址＊q附肛助n晌】；11定义队列所使用的数组空间，元素类型为指向节点的指针类型int台。nt动，rear二0；11定义队首指针和队尾指针，初始均皿0表示空队BT庄法Node＊p；" ID="23">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="1《B侧喇ULL）《刀将树根指针进队" ID="24">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="花习r，恤肛＋1）％MaX比n幽；" ID="25">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="ql茂ar］＝BT；" ID="26">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="lw抽le（6们址！～）｛11当队列非空时执行循环fro以斌hont＋1）％Ma幻边ngtb；11使队首指针指向队首元素沪q【加。t］；刀删除队首元素第S章树和二叉树·167" ID="27">
        <fptr EndPN="00000181" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="{ll若节点存在左孩子，则左子节点指针进队" ID="28">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="资" ID="29">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="if(prightNUt工）" ID="30">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="{11若节点存在右孩子，则右子节点指针进队" ID="31">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="32">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="}/lwhileend" ID="33">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="l在这个算法中，队列的最大长度不会超过二叉树中相邻两层的最大节点数，所以定义队列数组时，要使数组的长度大于队列的最大长度，这样在节点进队时肯定不会发生" ID="34">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="滋出，因此也就不需要判断是否队满了。此算法的时间复杂度为O{n)。表示二叉树中" ID="35">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="节点的个数。" ID="36">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000181" TITLE="5.4  二叉树其他运算" TYPE="Chapter">
      <fptr LogicalPageNum="181" PhysicalPageNum="181"/>
      <Paragraph CONTEXT="1.初始化二叉树voidInitBTree(BTroeNodeBT)" ID="1">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="11初始化二叉树，即把树根指针t空" ID="2">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="3">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="BT=NULL;）" ID="4">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="2.建立二叉树表表示的输入法，二叉树广义表表示的规定如下：" ID="5">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）每裸树的根节点作为由子树构成的表的名字而放在表的前面；·1b8·数据结构A（B（C）.D（E（F.G）.H（，1）））根据二叉树的广义表表示建立二叉树链接存储结构的基本思路是：从保存二叉树广义字符串a中输入每个字符，若遇到的是空格则不进行任何操作：若遇到的是字母（假定表的字符串a中输入每个字符，若遇到的是空格则不进行任何操作：若遇到的是字母（假定1！1兰艺得作七节占的洁、加1书阳具节占的佰＿宙七亡麓台一个挤节占＿耸纲于女节占（姿亡不以字母作为节点的值），则表明是节点的值，应为它建立一个新节点，" ID="6">
        <fptr EndPN="00000182" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="是整个树的根节点的话）作为左孩子（若卜1）或右孩子（若胎2）翻" ID="7">
        <fptr EndPN="00000182" StartPN="00000182"/>
      </Paragraph>
      <Paragraph CONTEXT="共涌到的早左括号.mll夫明子表开始.应首失把指向它前面字母所在内：个树的根节点的话）作为左孩子（若卜1）或右孩子（若胎2）链接到其双亲节点上：湮口的是左括号，则表明子表开始，应首先把指向它前面字母所在节点的指针（即根节点·）进栈，以便括号内的子节点向双亲节点链接之用，然后把k置为1，因为左括号后面的字母（若有的话）必为根节点的左孩子：若遇到的是右括号，则表明子表结束，应退若遇到的是逗号.则表明以左孩子为根的子树处理完毕，应接着处理以右孩子为根的子所以要把k置为2。如此处理每一个字符，直到读入结束符’＠’为止.建立二叉树的算法描述为：指针）进栈，紧跟的字母树，v说dC代泊记BT六男（BTr忱N以址.＆BT，char.a）刀根据字符串a所给出的用广义表表示的二叉树建立对应的存储结构《" ID="8">
        <fptr EndPN="00000182" StartPN="00000182"/>
      </Paragraph>
      <Paragraph CONTEXT="c面鱿Maxsi，10；11栈数组长度要大于等于二叉树的深度减1" ID="9">
        <fptr EndPN="00000182" StartPN="00000182"/>
      </Paragraph>
      <Paragraph CONTEXT="iu。吻＝一l；lltop作为：栈的栈顶指针.初值为一1.表示空栈一一一一一一止壑主2.1b9tops[如pl=p;k=1;" ID="10">
        <fptr EndPN="00000183" StartPN="00000182"/>
      </Paragraph>
      <Paragraph CONTEXT="break;" ID="11">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="cast:if(top=＝一Uoout“二叉树广义表字符串错犷&quot;ocendl;exit(I" ID="12">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="13">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="top一；break;" ID="14">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="case吮" ID="15">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="ltr2;b德政；default:phewBTreeNode;pdata二(ipleftprightNULL;iflfBT二=NULL}BTU;" ID="16">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="17">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCk=1)s[tap】一＞lcftr-p;elsestop】一&gt;right=p;" ID="18">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="｝}11swithendi11为扫描下一个字符修改1值" ID="19">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="子}在这个算法中，s栈的最大深度等于二叉树的深度减1，而二叉树的深度则等于广义表表示中圆括号嵌套的最大层数加1。所以当定义5栈的数组空间时，其长度（即下标上限值）要大于等于二叉树的深度减1.该算法的时间复杂度为O(n。表示二叉树广义表" ID="20">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="中字符的个数，由于平均每2-3个字符具有一个元素字符，所以n也可以看做是二叉树中元素节点的个数。" ID="21">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="3.橄王二叉树是否为空boolBTreeEmpry(HTreeNade+BT)" ID="22">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="11判断一裸二叉树是否为空.若是则返回tru亡，否则返回false" ID="23">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="考·170·数据结构" ID="24">
        <fptr EndPN="00000184" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="4.求二叉树深度若一棵二叉树为空，则它的深度为0，否则它的深度等于左子树和右子树中的最大深" ID="25">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="1。设depl为左子树的深度，dcp2为右子树的深度，则二叉树的深度为：" ID="26">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="度加1。max（dePI，血pZ）＋1其中欢旧x函数表示取参数中的大者.求二叉树深度的递归算法如下：intBT欢姆氏呻（BT似N以koBT）11求由BT指针指向的一裸二叉树的深度" ID="27">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="r" ID="28">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="jl（ST～NULL）咖mo：ll对于空树.返回0并结束递归" ID="29">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="elsel" ID="30">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="11计算左子树的深度1以dePI＝BT暇D印山（ST－＞le田；" ID="31">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="刀计算右子树的深度int血p卜BT溉DePth（BT.》行动幻；" ID="32">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="刀返回树的深度" ID="33">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="比加mdePI＋1：" ID="34">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="花n甘”dePZ＋l；" ID="35">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="1｝若利用此算法求图5.11所示二叉树的深度，则得到的返回结果为40" ID="36">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="5.从二叉树中查找值为x的节点，该算法类似于前序遍历，若树为空则返回faise，则把节点值赋给x后返回仃”e结束递归，否贝结束递归，否则再向右子树查找，若找到则返回七ue$Picture[00000184\00000184_new\0032.jpg]Picture$第s章树和二叉树·l71王if(BT=NI几工）returnfalse;11树为空返回假else" ID="37">
        <fptr EndPN="00000185" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="it[BT-datax){11树根节点的值等于x则由x带回" ID="38">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="；" ID="39">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="。卜祀诬" ID="40">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="11向左子树查找若成功则继续返回真" ID="41">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="11向右子树查找若成功则继续返回宾" ID="42">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="左、右子树查找均失败则返回假" ID="43">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="returnfalse;" ID="44">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="卜" ID="45">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="46">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="47">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="B.翰出二叉树们采用广义表的形式打印。我们知道用广义表表示一棵二叉树的规则是：根节点被放在" ID="48">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="根节点被放在" ID="49">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="5.11所示的二由左、叉树，其对应的广义表表示为：＾（日（c，D），E（，峨0）））" ID="50">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="因此，用广义表的形式输出一裸二叉树时，应首先输出根节点，然后再依次输出它的左子树和右子树，不过在输出左子树之前要打印出左括号，在输出右子树之后要打印出右括号：另外，依次输出的左、右子树要至少有一个不为空.若均为空就没有输出的。172。数据结构if(BT！二NULL}曰树为空时结束递归.否则执行如下操作tout«BTdata;输出根节点的值ifl(BTleftl=NULLIIBTrightNULL)【taut«'(11出左括号PrintBTree(BTleft11出左子树if{BT一＞&gt;righl！二NULL)" ID="51">
        <fptr EndPN="00000186" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="couta1/若右子树不为空则输出逗号分隔符PttintBTree{BTright11$W出右子树" ID="52">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="tout«';输出右括号｝" ID="53">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="54">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="55">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="7，清除二叉树，使之变为一裸空树再清除右子树，最后删除〔即回收）根节点并把指向根节点的指针置空。由此可知它是一个递归过程.类似于后序递归遍历。" ID="56">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="voidC1earBTree(BTteeNode一＆BT)" ID="57">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="{if(BTNULL}C1rarBTree(BTleft/11H1除左子树C1earBTnee(BTright11删除右子树deleteBT;11释放根节点BT=NULL;11根指针为空" ID="58">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="】" ID="59">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="60">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000186" TITLE="5.5  树的存储结构和运算" TYPE="Chapter">
      <fptr LogicalPageNum="186" PhysicalPageNum="186"/>
        <div ORDERLABEL="00000186" TITLE="5.5.1  树的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="186" PhysicalPageNum="186"/>
        <Paragraph CONTEXT="第5章树和二叉树·l73树的抽象数据类型的数据部分为一棵普通的k叉树GT，它可以采用顺序，链接等任，存储结构，假定存储类型用GTREE标识符表示，操作部分包括初始化树，建立树、" ID="1">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="r树、查找树、愉出树、清除树、判空树等一些常用运算。下面给出普通树的抽象数" ID="2">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="一种存储结构，" ID="3">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="遍历树、查找树、有据类型的具体定义.DATGenetalTreeis" ID="4">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="Data:" ID="5">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="一棵普通树GT，存储类型用标识符0们妊扭表示。operations" ID="6">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="voidIaitGTnx(GTREE&amp;GT刀初始化树，即把它置为一棵空树" ID="7">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="voidCresteTree(GTREEGT,char+a万根据广义表表示的树建立对应的存储结构" ID="8">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="voidTravciacdTnee(GTREEGT" ID="9">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="存按照一定次序遥历树.使得每个节点的值均被访问一次boolFindGTree(GTRSEGT,IalemType&amp;item" ID="10">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="11从树中查找值为item的节点，若存在该节点则由item带回11它的完整值并返回。v已，否则返回faire表示查找失败" ID="11">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="void1'rintGTree(GTIZEEGT11按照树的一种表示方法输出一棵树" ID="12">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="boolEmptyGTnee(GTREEGT11判断树是否为空，若是则返回true。否则返回f1t" ID="13">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="voidCteatGTree{GTREEGT" ID="14">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="川育除树中的所有节点，使之变为一棵空树endGeneralTree" ID="15">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000187" TITLE="5.5.2  树的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="187" PhysicalPageNum="187"/>
        <Paragraph CONTEXT="，，树的顺序存储结构树的顺序存储结构同样豁要使用一个一维数组，存储方法是：首先对树中每个节点编号，然后以各节点的编号为下标，把节点值对应存储到相应元素中。·174数据结构树，若双亲节点的编号为i.则3个子节点的编号依次为3xi-1,3xi,3xi十1。又如对于4叉树.若双亲节点的编号为j，则4个子节点的编号依次为4xj-2,4xj-1,4xj,4xj+1e若k叉树中一个节点的编号为J，则它的父亲节点的编号为(j-2)Ik+l，即等于］以k得到的整数商再加上1.如当胎3时，父节点的编号为价2）13＋l，若户10，则父节点" ID="1">
          <fptr EndPN="00000188" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="1.如当胎3时，的编号为3。" ID="2">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="树的顺序存储适合满树的情况.否则将非常浪费存储空间。故在实际应用中很少使用.这里也不做深入讨论。" ID="3">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="2.树的链接存储结构树的链接存储结构通常采用如下三种方式." ID="4">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）标准方式在这种方式中，树中的每个节点除了包含有存储数据元素的值域外，还包含有k个" ID="5">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="指针域.用来分别指向k个子节点，或者说，用来分别链接k裸子树，其中k为树的度.节点的类型可定义为：stZuctGTrecN0de（ElemTy讲山妞；刀节点值域" ID="6">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="GT代忿Nedeot［k］；刀节点指针域t［0］～t［k-1］，k为事先定义的常量）；" ID="7">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）广义标准方式" ID="8">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="广义标准方式是在标准方式的每个节点中增加一个指向其双亲节点的指针域。节点的类型可定义为：曰cmTy伴data；刀节点值域刃丫1，r～卞J八d.止.汗1。矛厂片占到身全小寺刀节点指针域峨0］～tlk-11，k为事先定义的常量PGT二eN叼e＊p眼ntll双亲指针" ID="9">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="l；图5.13〔a）是一棵三叉树，其存储结构的标准方式如图5.玛（b）所示，广义标准方式如图5.13〔c）所示。第s章树和二叉树·ls$Picture[00000189\00000189_new\0002.jpg]Picture$$Picture[00000189\00000189_new\0003.jpg]Picture$（.）$Picture[00000189\00000189_new\0005.jpg]Picture$图5.13树的标准方式和广义标准方式的存储结构将树转换为二叉树的规则是：将树中每个节点的第一个子节点转换为二叉树中对应节点的左孩子，将第二个子节点转换为左孩子的右孩子，将第三个子节点转换为右孩子的右孩子。椒就县说.转揍后得到的二叉树中的每个节点及右孩子.存转换前的树中互也就是说，转换后得到的二叉树中的每个节点及右孩子，在转换前的树中互为兄弟。例如，对于图5.13(a）所示的树，对应的二叉树方式如图5.l4(a)所示，它的二叉链表如图5.14(b)所示。(a}(by图S.14树的二叉树方式的存储结构·176·数据结构但二叉树方式不能表示任一节点中缺少前面孩子.又存在后面孩子的那样有序树。" ID="10">
          <fptr EndPN="00000190" StartPN="00000188"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000190" TITLE="5.5.3  树的运算" TYPE="Chapter">
        <fptr LogicalPageNum="190" PhysicalPageNum="190"/>
        <Paragraph CONTEXT="树的运算包括建立树的存储结构、进行树的遍历、从树中查找节点值、求树的深输出树等。假定我们要讨论的树是k叉树。k被事先定义为整型符号常童。树的存储度、输出树等。假定我们要讨论的树是k叉树。k被事先定义为整型符号常童。树的存储杜撰，亚田去奋M李以士起七目、建立树的存储结构就是在内存中生成一棵树的标准方式的存储映像，即k叉链表。我们仍采用广义表的形式输入，对于图5.13所示的三叉树，得到的广义表表示为：A（B（D，E（H，1），F），C（G））这里假定每个节点的非空子树都是靠前面、按序排列的子树，把所有空子树都留在后面。在实际情况中可能会出现缺少前面子树而存在后面子树的情况，此时用广义表表示时空子树后面的逗号不能省略。在树的生成算法中，需要设置两个栈，一个用来存储指向根节点的指针，以便子节点向双亲节点链接之用，另一个用来存储待链接的子节点的序号，以便能正确地链接到双亲节点的指针城。假定这两个栈分别用：和d表示，5和d栈的深度不会大于整个树的深度。树的生成算法与二叉树的生成算法类似，假定节点值仍为字符类型char，整个k叉树用一个广义表形式的字符串a来表示.则具体算法描述为：voidC祀ale0T欣（OT几沈Node.aGT，cbar＊a）【constM卜10：11定义符号常盘指定栈空间的大小GT“笼Node，slMsl：lls数组作为存储树中节点指针的找使用intd［Ms］；lld数组作为存储子节点链接到双亲节点第5章树和二叉树·177whileta[i{11每循环一次处理一个字符.直到字符串结束符为止switch(e[i" ID="1">
          <fptr EndPN="00000191" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="{呼”：b佑比；存对空格不做任何处理c路.’（’：tops[topp;d[加Pl司;" ID="2">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="lip指针进s找，0进d栈，表明特扫描的子节点" ID="3">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="护涛链接到s栈顶元素所指节点的第一个指针城break;" ID="4">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="侧拐.’）‘：top一；lls和d退栈break;" ID="5">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="‘.seJ，性d[top11待读入的子节点将链接到。栈顶元素break;defaalt:11此处处理的必然是字符元紊11根据a[i]字符生成新节点patewGTreoNode;卜洲加匕e[i]甚fox(intice;i＜k;ip-t{iNULL;11使p节点成为树根节点或链接到双亲节点对应的指针域it(GT-=NULL)GT=p;olses[topt[d[top]l却.]i11准备处理下一个字符）" ID="6">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="]" ID="7">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="z.树的遍历" ID="8">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="树的遍历包括先根遍历（或称深度优先遍历）、后根遍历和按层遍历（或称广度优先遍历）三种。·»s·数据结构程是一个递归过程。如先根遍历图5.13所示的树，得到的节点序列为：ABDEHIFCG后根遍历定义为：从左到右依次后根遍历根节点的每棵子树，然后再访问根节点，得到的节点序列为：DHIEFBGCA按层遍历定义为：先访问第一层节点（即树根节点），再从左到右访问第二层节点，依次按层访问，直到全树中的所有节点都被访问为止，或者说直到访问完最深一层节点" ID="9">
          <fptr EndPN="00000192" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="为止。ABCDEFGHI同二叉树的先序遍历算法类似，下面给出树的先根遍历算法：voidPreRoat(GTreeNod#GT)" ID="10">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="11先根退历一裸k叉树" ID="11">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="赶ifl(GTl=NULL){couta:GTdataa;访问根节点" ID="12">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="fortinti；面《]c;iPreRaot(GT-＞t[i递归遍历每一个子树" ID="13">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="}树的后根遍历算法如下：voidPostRoot{GTreeNade+GT)" ID="15">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="11后根遍历一裸k叉树" ID="16">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="考ifCGTl=NULL)" ID="17">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="f4rSintice;i盛；iPostRovt(GT-＞t[i11递归遍历每一个子树ooutv:CTdataar;11访间根节点" ID="18">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="]I第s章树和二叉树.179点指针类型GTreeNode*，算法开始时将4初始化为空，接着若树根指针不为空则入队：然后每从队列中删除一个元素（即为指向节点的指针）时，都输出它的值并且依次使非空的孩子指针入队，这样反复进行下去，宜到队列为空时止。法，具体描述为：" ID="19">
          <fptr EndPN="00000193" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="voidLayerOrder(GTreeNode*GT)刀按层遮历由GT指针所指向的k叉树{QueueSqq;11定义一个队列q，其元素类型应为GTreeNode*InitQueue{q,511初始化队列qGTreeNode*p;II定义一个根节点指针孟P(GTNULL)1EnQueue(q,GT11卜空的树根指针进队whileF.mptyQueue(q{1/当队列非空时执行循环p=OutQrteue(q}11从队列中删除一个节点指针cout《pdaraa;11输出节点的值for(intice;irk;i＋十）ll空的子节点指针依次进队if(p-》t{iNULL)" ID="20">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="F_nQueue(q,卜at[i" ID="21">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="22">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="23">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="3.从树中查找节点值此算法要求：从树中查找值为item的节点时.若存在该节点则由item带回它的完整值并返回true，否则返回false表示查找失败。此算法类似树的先根遍历，它首引幼zX幼令去r生宫rarr‘给rn城r,.sr」上;日nw刁5nd七七,，二禽到聋』江月月、两阵七廿目.nrc谧-奄x;索从,.若相等则带回节点值并返回真，否则依次查找每个子树。boolFindGTrre(GTreeNode*GT,ElemTypeBcitem)诬ifi(GT-NULL)returnfalse;11空返回假.else{ifl(GT-洲加抽二司tern){11带回节点值并返回真ite皿GT-7d8ta;t+GtUflfitrUC;｝for(intice;ilc;i11向每裸子树继续杳找·18(1·数据结构returnfalse;11查找不成功返回假}" ID="24">
          <fptr EndPN="00000194" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="25">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="4.树的翰出假定要求输出为树的广义表形式。此算法同样类似于树的先根遍历，它首先输出树根节点的值，然后若存在非空子树则接着输出表的左括号及输出第一棵子树，再依次输" ID="26">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="最后输出表的右括号。该算法描述为：voidPrintGTree(GTreeNode*GT)11以广义表形式输出按标准方式存储的k叉树（ifCGT！-NULL){11若树不为空则进行如下处理cou峨OT.洲如加刀轴出根节点的值inti;for(i二0;iaic;i/1判GT节点是否有子树it[GTt[i]！二NULLbreak;if(ick)11有子树时向下递归tout«';11输出表的左括号1?rintGTreo(GTt[0111输出第一棵子树肠式i＝l；i＜k；1＋＋）1川渝出其余各个子树" ID="27">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="touts,'," ID="28">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="PrintGTree(GT-t(i" ID="29">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="}touts')/1物出表最后的右括号｝" ID="30">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="31">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="32">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="5，求树的深度若树为空则深度为0，否则它等于所有子树的最大深度加1。为此-ru要设置一个整型变量，用来保存己求过的子树中的最大深度.当所有子树都求过后，即可。具体算法描述为：" ID="33">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="intGTreeDeptli(GTreeNode*GT)" ID="34">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="刀求一裸k叉树的深度第s章树和二叉树.isi{" ID="35">
          <fptr EndPN="00000195" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="五f(GT.NULL)return0;/空树的深度为0" ID="36">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="else{intrQaxO;11用来保存子树中的最大深度，初值为afor[intice;ick;i{11计算出一裸子树的深度并赋给变量dintd州'freeDepth(GT-t[ilifCdmauc)maxim;11把当前深度.大者的值斌给max乡returnmaa+1;11返回树的深度，它等于子树的最大深度加1乡" ID="37">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="乡" ID="38">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="voidC1earC.tree(GTreeNode&amp;GT)" ID="39">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="40">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="袱GT！叫呱JL工）1" ID="41">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="fat(inti0;irk;iClearGTree(Gf-t[五:" ID="42">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="血】州比G】.；" ID="43">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Picture URL="00000195\00000195_new\0020.jpg">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Picture>
        <Paragraph CONTEXT="G不矛几fL.L;" ID="44">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="45">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="》上面讨论的树的一些运算都需要访问树中的所有节点，并且侮个节点的值仅被访问最差情况为以元）。省本章，1、结" ID="46">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="1.树是一种层次数据结构，第一层只有一个节.点，称为树根节点，其后每一层都是·1sz。数据结构个节点有并且只能有一个前驭节点.树中节点的前驱节点称为该节点的父亲或双亲，后继节点称为该节点的孩子。2－二叉树是度为2的有序树，每个节点至多有两个孩于，其中一个称为左孩于，另一个称为右孩子。若一个节.获没有左孩子或右孩子，也可以说该孩子为空." ID="47">
          <fptr EndPN="00000196" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="3.一裸深度为h的二又树，最少含有h个节点，最多含有梦一1个节点：一裸具有n卜点的二叉树，其最小深度为「lof2(n+1)或UoRzn+l." ID="48">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="个节点的二叉树，" ID="49">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="4.对于普通二叉树通常采用链接存储结构.二叉树健接存储的节点类型用BTrecNodc表示，它包含有值城data，指向左于节.点的指针城left和指向右于节点的指针城right," ID="50">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="5.遥历是二又树的主要运算，它包括先序、中序、后序和层次四种不同的遥历次前三种通过递归算法或使用钱的非递归茸法宾现.后一种通过使用队列的非递归葺序，前三种通过递归葬法或使用找的非递归算法实现，后一种通过使用队列的非递归算" ID="51">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="6.遇历也是对普通树的主要运算，它包括先根、后根和按层遥历三种次序.先根和丢扭名踢要田;sUfa'#七且;店食」.脸田一木队翻】田妻才转左口＿4云闷价占品左左卜才云" ID="52">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="用来保存已访问节点的存储位孟，以便当侧除它时能够访问到它的子节点.暑习。。5.1单选且" ID="53">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="i.树中所有节点的度等于所有节点数加（）。" ID="54">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="A.0B.1C-1D.2" ID="55">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="2.在一裸树中，每个节点最多郁》个前驱节点。" ID="56">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="A.0B.1C.2D.任意多个" ID="57">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="3.在一裸一叉树的二叉链表中.空指针城数等于非空摺针域数加（）。" ID="58">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="A.2B.1C.UD.一1" ID="59">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="4.在一裸具有n个节点的二叉树中.所有节点的空子树个数等(" ID="60">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="A.nB.n1C.n+lD.2xn" ID="61">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="5.在一裸具有月个节点的二叉树的第1层上.最多具有（）个节点。" ID="62">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="A.7B.2C2D.7'" ID="63">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="6.在一裸深度为h的完全二叉树中.所含节点个数不小于（)a第5章树和二叉树.183" ID="64">
          <fptr EndPN="00000197" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="8.在一裸具有35个节点的完全二叉树中，该树的深度为（）." ID="65">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.6B.7C.SD.S" ID="66">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="9，在一裸具有n个节点的完全二叉树中。树枝节点的.大编号为《）。" ID="67">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.L（n＋l）瓜」B.L伽一1}nJc.rn/ID.LnnJto.在一棵完全二叉树中。若编号为‘的节点存在左孩子，则左子节点的编号为（）。" ID="68">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.2i2i-1c.2t+1D.2t+211在一裸完全二叉树中，若编号为i的节点存在右孩子，则右子节点的编号为（）。" ID="69">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.2iB.2i-1C.2i+1D.2i+2" ID="70">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="12.在一裸完全二叉树中，‘对于编号为i(b1)的节点，其双亲节点的编号为（）。" ID="71">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.LG+Ui2JB.LG-1)nJc.firzlD.Lind13一裸二叉树的广义表表示为确（c）.d（以，9（h”，动，则该二叉树的高度为（）." ID="72">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.3B.4C.5D.6" ID="73">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="14.一棵二叉树的广义表表示为吕以‘），以以，渗h）），助.则该二叉树所含的单支节点数为（）." ID="74">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.2B.3C.4D.5is.一棵树的广义表表示为a(b(cdfCg(is,ij}，该树的深度为（）。" ID="75">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.3B.4C.SD.6l6.已知一棵树的广义表表示为a(b{cd{e,f(g(h,ijg节点的祖先节点为（）." ID="76">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="A.a,b,fB.a,d,aC.a,d,fD.a,c,f招城空月" ID="77">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="1.对于一棵具有。个节点的树，该树中所有节点的度数之和为＿.2假定一棵三叉树a节点个数为50," ID="78">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="3.在一棵高度为h的四叉树中，最多含有―节点。" ID="79">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="4.在一裸三叉树中，度为3的节点数有2个，度为2的节点数有1个，度为3的节点数为2个，那么度为0的节点数有＿个。" ID="80">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="5.一棵深度为5的满二叉树中的节点数为＿个，一棵深度为3的满四叉树中的节点数为个。" ID="81">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="6.假定一裸树的广义表表示为A（B（C，以氏F，G），H（LJ））），则节点H的双亲节点为＿.子节点为？.在一棵二叉树中，假定双分支节点数为5个，单分支节点数为6个。则叶子节点数为＿个。" ID="82">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="8.在一棵二叉树中.第5层上的节点数最多为＿." ID="83">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="4，一裸二叉树的广义表表示为a(6(c,de(fg，它含有双分支节点一一个，单分支节点―·184·数据结构l4.对于一裸含有44个节点的理想平衡树。它的高度为＿。" ID="84">
          <fptr EndPN="00000198" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="11.假定一棵二叉树顺序存储在一维数组a中，则a[门元素的左孩子元素为＿.右孩子元索为＿.双亲元素（i&gt;1）为＿·" ID="85">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="12.假定一裸二叉树链接存储在一维数组a中，则a[门节点的值为＿，左子节点的下标位t为＿。右子节点的下标位里为＿。" ID="86">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="13.若对一棵二叉树从0开始进行节点编号，并按此编号把它顺序存储到一维数组a中，即编号为0的节点存储到a[01中.其余类推，则a[r7元素的左孩子元紊为＿，右孩子元素为＿，双亲元素（j》0）为" ID="87">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="对应二叉链表中指针总数为个.其中个用于指向子节点，＿个指针空闲着。" ID="88">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="15.在一裸高度为5的理想平衡树中，最少含有.个节点，最多含有个节点。53算月1假定一裸二叉树广义表表示为a(b(cd(e,t7)，分别写出对它进行先序、中序、后序、按层遍历" ID="89">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="的结果。" ID="90">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="先序；" ID="91">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="中序：" ID="92">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="后序：按层：" ID="93">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="2.假定一棵普通树的广义表表示为a(b(ec(f(h,i,jgd)，分别写出先根、后根、按层7I历的结" ID="94">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="果。" ID="95">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="先根：" ID="96">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="后根：按层：" ID="97">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="3.已知一棵二叉树的先根和中根序列，求该二叉树的后根序列。先根序列：A,B,C,D,E,F,G,H,I,1中根序列：C,B,A,L,P,D,1,H,1,G后根序列：" ID="98">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="4.已知一棵二又树的中根和后根序列，求该二叉树的高度和双支、单支及叶子节点数。" ID="99">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="中根序列：c,b,d,e,a,g,i,h,1,f后根序列：c,e,d,b,i,j,h,g,f,a第5章树和二叉树·183" ID="100">
          <fptr EndPN="00000199" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="5.已知一裸二叉树在数组中的链接存储如下，写出该二叉树对应的广义表表示。012343678910I112dataI二Ia二bc」d一，｝一斗一f.gbi巨丰习一习left二2月0」二」二刁G滩0」8－40」0丰生4一－仁川rightII｝s13｝.0.1“一1····?I.°1.9二l0.｝.nIo1Ix1ad气月算法分析盆" ID="101">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="1.己知二叉树中的节点类型BinTc+ccNodc定义为：structBin'IYetNode{ElemTypedata;$inTreeNode+left,*right其中Fn.为节点值城，left和‘ght分别为指向左、右孩子节点的指针域.下面函数的功能是返回二叉树sT中值为x的节点所在的层号，请在划有横线的地方填写合适内容.intNodei.evel(BinTteeNtde*BT,ElcmTypeX)【" ID="102">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="i&gt;aT=NLTLlreturn0;11空树的层号为0clscif(BT-data～X)return1;11根节点的层号为1向子树中查找X节点else{intcl=NpdeLevel(BT-left,xif{clxl}{1)," ID="103">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="intc卜（2）…＿＿；" ID="104">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="if(3),11若树中不存在x节点则返回0elsereturo0;)}" ID="105">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="2.己知二叉树中的节点类型BiaTroeNad侣定义为：·186·数据结构叹" ID="106">
          <fptr EndPN="00000200" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="ifl(BT=M]LL)returnNULL;" ID="107">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="108">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="BinTreeNade+pt-newBinTneeNode;" ID="109">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="ptdata=BTdata;" ID="110">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="pt-xight=BTreeSwopX(BTleft" ID="111">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="ptleft二BTreeSwopX(BTright" ID="112">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="returnpt;" ID="113">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="114">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="115">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="3.已知二又树中的节点类型STreeNode定义为：sttuctSTroeNode(datatypedata;STreeNodEchild,*rchildparent其中data为节点值域，]child和rcitild分别为指向左、右孩子节点的指针域.!为指向父亲节点的指针域。根据下面函数的定义指出函数的功能。算法中参数ST指向一裸二叉树，X保存一个节点的值.STreeNode+PN(STreeNode*ST,datatype&amp;X}【" ID="116">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="if(ST-Nt,JL.L)returnNLFLL;" ID="117">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="118">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="StreeNode*mt;" ID="119">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="if(STdata=X)returnSTparent;elseif(mt二PN(STlchild,Xreturnntt;elseif{a吐二PN(STrchild,Xreturnmt;returnNULL;" ID="120">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="121">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="122">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="4.已知二叉树中的节点类型BinTreeNode定义为：structBinTreeNade{ElemTypedata;BinTreeNode*left,*right其中data为节点值域，left和right分别为指向左、右孩子节点的指针域.根据下面函数的定义指出函数的功能。算法中参数BT指向一棵二叉树。" ID="123">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="VoidBTC(BinTreeNode+BT)第，章树和二又树.187－一一一一一一" ID="124">
          <fptr EndPN="00000201" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="【if(BT！二NULL}{" ID="125">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="if(BTieftl=NULLBTrightl=NULL)" ID="126">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="BTrigkit=t;" ID="127">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="128">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="BTC(BTleft" ID="129">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="BTC(BTrigttTJ;" ID="130">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝" ID="131">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="S。已知二叉树中的节点类型BinTteeNode定义为：structBinTrecNode{chardata;BinTmeNode+ltftrigbt其中da.为节点值域，left和‘ght分别为指向左、右孩子节点的指针域。假定指针bt指向一棵二叉树，该二叉树的广义表表示为a(b(a,d(fc(ea(lcb，每次调用时整数变fC的值均为0，若：执行BTCl(btaC)调用后，C的值为―Q〕执行BTCl(btbC)调用后，C的值为一一一一；执行BTC1(btcC)调用后，C的值为一立止一一；执行BTCi(bt.’g’,C)调用后，C的值为一业止一一.；void$TCl(BinTnecNadew$T,charxintbtk}" ID="132">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="硬if(BTl=NULL){if(BTdata=x)k（BTeft.x，k）；BTC1(BTright,x.k" ID="133">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="}}·188·数据结构stiuctSinTreeNade(ElemTypedata;BinTreeNode*left,*right其中data为节点值域，left和right分别为指向左、右孩子节点的指针域。下面函数的功能是从二叉树BT中查找值为X的节点.若查找成功则返回节点地址，否则返回空.请在划有横线的地方填写合适内容。BinTreeNode*BTF(BinTreeNode*$T,ElemTypex)｛if(BT-NULL)(1),else{ifCBT-data=x).(else{" ID="134">
          <fptr EndPN="00000202" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="BinTreeNode*t;" ID="135">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="if(t二BTF(ST-cleft,z(3)," ID="136">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)," ID="137">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturnNULL;" ID="138">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="139">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="140">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="141">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="7.己知二叉树中的节点类型SinTteeNode定义为：structBinTreeNode{ElemTypedata;BinTreeNade*left,*right其中data为节点值域，1y和[fight分别为指向左、右孩子节点的指针域。根据下面函数的定义指出函数的功能。算法中参数BT指向一裸二又树。voidpreserve(BinTt+eeNode*BT,ElemTypeap,intn){" ID="142">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="staticinti巴0;" ID="143">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="if(BT！一NULL){preserve(ST一＞left,a,tJ;a[i」二BT一＞xlata;preserve(BT-Might,an｝" ID="144">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="第5章树和二叉树.i895‘算法设计月1已知二叉树中的节点类型BinTroeNade定义为：structBinTreeNode{chardata;BinTreeNode*left,*right其中data为节点值域，left和right分别为指向左、右孩子节点的指针域。根据下面函数声明编写出求一裸二叉树深度的算法，该深度由函数返回，参数BT初始指向这棵二叉树的根节点。intBTreeIieigbt(BinTreeNode*BT" ID="145">
          <fptr EndPN="00000203" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="2.己知二叉树中的节点类型Bin'heeNod.定义为：structBinTretNode{chardata;BinTreeNode*left二right;其中山扭为节点值域，left和对沙t分别为指向左、右孩子节点的指针域，根据下面函数声明编写出求一裸二叉树中节点总数的算法，该总数值由函数返回。假定参数BT初始指向这裸二又树的根节点.intBTreeCaunt(HinTreeNadC*HT" ID="146">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="3.已知二叉树中的节点类型inYeeN,r;定义为：structBinTreeNade{chardata;BinTreeNode-left,*right;其中山切为节点值域，left和right分别为指向左、右孩子节点的指针域.根据下面函数声明编写出求一裸二叉树中叶子节点总数的算法，该总数值由函数返回。假定参数BT初始指向这裸二叉树的根节点。" ID="147">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="intBTreeLeaPCountBioTneeNode*BT" ID="148">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="4.已知二叉树中的节点类型BinTreeNode定义为：sttuctBinTreeNade{chardata;BinTreeNode*left,*right;其中da.为节点值域，left和right分别为指向左、右孩子节点的指针域，根据下面函数声明编写出判断两棵二叉树是否相等的算法，若相等则返回l否则返回a。算法中参数T1和T2为分别指向这两棵二叉树根节点的指针。当两裸树的结构完全相同并且对应节点的值也相同时才被认为相等。intHTreelrqual{BinTreeNode*T1,BinTreeNade，T2" ID="149">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="5.已知二叉树中的节点类型用SinTrteNade表示，被定义为：struCtBinTreeNode{chardata;BinTrCeNgdC*ieftright;其中山.为节点值域，球和right分别为指向左、右孩子节点的指针域，根据下面函数声明编写出二90·数据结构交换一棵二义树中所有节点的左、右指针域值的算法，算法中参数BT初始指向这棵二叉树的根节点。voidBTreeSwop(BinTreeNode.BT)" ID="150">
          <fptr EndPN="00000204" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="6.已知花叉树中的节点类型用BinTreeNode表示，被定义为：structBinTreeNode{chardata;BinTreeN[x3e-left二right;其中data为节点值域，left和right分别为指向左、右孩子节点的指针域.根据下面函数声明编写出复制一棵二叉树的算法，并返回复制得到的二叉树的根节点指针。算法中参数BT初始指向待复制二叉树的根节点.BinTreeNodeBTreeCopy{BinTreeNade*BT" ID="151">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="7.己知二叉树中的节点类型BinTreeNode定义为：structBinTreeNade{chardata;BinTreeNpde*leftright其中data为节点值域，left和right分别为指向左、右孩子节点的指针域，根据下面函数声明编写出从一棵二叉树中求出节点值大于X的节点个数的算法，并返回所求结果.算法中参数BT初始指向一棵二叉树的根节点。intBTreeCount(BinTreeNode＊BT,ElemTypex" ID="152">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="8.根据下面函数声明写出对二叉树进行中序遥历的非递归算法.在算法中定义一个数组和栈顶指针作为栈使用。" ID="153">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="voidInorderN(BTreeNode+BT" ID="154">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="4.根据下面函数声明编写一算法，求出一裸二又树中所有节点数和叶子节点数.假定分别用变参Cl和C2统计所有节点数和叶子节点数，它们的初值均为0.voidCount(BTreeNode＊BT,int&amp;C1,int&amp;C2兰熙器叉树在计算机致据处理领域有着广泛的应用.如利用二叉搜索树、堆和从优吧叉树来分别实现快速信息搜索、优先级队列和硬优信息编码等。本章对这方面内齐进行讨i仑。" ID="155">
          <fptr EndPN="00000205" StartPN="00000204"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000195" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
      <div ORDERLABEL="00000196" TITLE="习题5" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000205" TITLE="第6章  二叉树的应用" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000205" TITLE="6.1  二叉搜索树" TYPE="Chapter">
      <fptr LogicalPageNum="205" PhysicalPageNum="205"/>
        <div ORDERLABEL="00000205" TITLE="6.1.1  二又搜索树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="205" PhysicalPageNum="205"/>
        <Paragraph CONTEXT="二叉搜索材（13inanySearchingTree）又称二叉排序树（(BinarySortingTree)，它或者裸空树.或者是一裸具有如下特性的非空二叉树。则左子树上所有节点的关键字均小于根节点的关键字：" ID="1">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）若它的右子树非空，则右子树上所有节点的关键字均大于（若允许具有相同的关键字的节点存在，则大于等于》根节点的关键字；" ID="2">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)左、右子树本身又各是一棵二叉搜索树.在二叉搜索树中，当每个节点的元素类型为简单类型时，则节点的关键字就是该节点的值，当每个节点的元素类型为记录类型时，则节点的关键字为该节点的某一个域的·192·数据结构$Picture[00000206\00000206_new\0003.jpg]Picture$树中所有节点的关键字.对此树进行中序遍历得到的节" ID="3">
          <fptr EndPN="00000206" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="12，15，19，23，26，叨，52，幻，74图6.1二叉搜索树可见此序列是一个有序序列。" ID="4">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000206" TITLE="6.1.2  二叉搜索树的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="206" PhysicalPageNum="206"/>
        <Paragraph CONTEXT="’一样的任何存储结构，操作部分除了已经讨论过的对一般二叉树的操作外，还具有.叉搜索树的一些常用操作，即搜索（查找）、更新、插入和删除元素的操作。假定二叉树一样的任何存储结构，对二叉搜索树的一些常用操作，叉搜索树中的节点类型为BTre二叉搜索树BST的查找，更新、BTreeN0de，指向二叉搜索树的树根节点的指针为BST，则对更新、插入和删除元素的操作声明如下：boo.Find（BTn姆N侧址＊ssT，ElcmTyPe＆1忆m〕；11从二叉搜索树中查找等于给定值1忱m的元素，若查找成功则返回tlue.11并由1记m返回该元素的值.否则返回fal铭。boolU帅州BT二N川e＊BST，co眼Elem巧讲＆It日m）；11从二叉搜索树中查找等于给定值1加m的元素，若查找成功.lJ用1以的值" ID="1">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="11更新该元紊并返回。uc.否则返回faisc。" ID="2">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="voidInsert（BTr忱N目‘＊＆B名T，co们肠tEIcmTy详浅1仍几）；11向二叉搜索树插入一个元紊item.使得插入后仍是一棵二叉搜索树." ID="3">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000206" TITLE="6.1.3  二叉搜索树的运算" TYPE="Chapter">
        <fptr LogicalPageNum="206" PhysicalPageNum="206"/>
        <Paragraph CONTEXT="第6章二又树的应用.193回真，若item小于根节点的值.则继续在根的左子树中查找，若item大于根节点的值，其递归算法描述如下：boolFind(BTreeNade+SST,ElemTypedcitem)11从二叉搜索树中查找等于给定值ium的元素" ID="1">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="f" ID="2">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="ifBST=NULL)" ID="3">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="returnfalse;11查找失败返回假" ID="4">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="else{试百妞m＝旧盯～火细曰" ID="5">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="{/1查找成功将元索的值斌给引用参数带回并返回真" ID="6">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="ium=SST-xlata;" ID="7">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="花奴lrttLr11t;》" ID="8">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="elseitYitemcBST-data)向左子树继续查找returnFind(BST-】已B,item" ID="9">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="else11向右子树继续查找teturnFsndST-aright,item" ID="10">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="｝l由于此递归算法中的递归调用属于末尾递归的调用，即递归调用语句是函数体中最后一条可执行语句，每次递归调用返回后不执行任何语句又返回到上一层，因此原先保存在数据堆找中的信息都是没有用处的。所以为了避免无效花费在进出数据栈操作上的" ID="11">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="时间和使用数据栈的空间，可编写出相应的非递归算法如下：" ID="12">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="toolPind(BTreelYode+BST,F.lemType&amp;item)" ID="13">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="刀进行二叉搜索树查找的非递归算法" ID="14">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="《while(BSTNUL)《if(item=BST-adata){·I94。数据结构｝" ID="15">
          <fptr EndPN="00000208" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="rctumfalse;" ID="16">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例如，从图6.1所示的二叉搜索树查找关键字为23的元素时，首先用23同根节点30进行比较，因23c30，所以向30的左子树继续查找：再用23同当前根节点15进行比较，因23＞15.所以向15的右子树继续查找；再用23同当前根节点23进行比较，因相等，所以由item带回该节点的值并返回真，整个查找过程就此结束。若从图5.1中查找关键字为48的元素时，其查找过程为：首先用48同根节点30进行比较，因48＞30，所I】口l1八bfft‘不iFS11+争刁匕i习日目」w4I言I1Gn:r日润沃脚‘，J」王舀二.山LlBFIiaJenC.GI+IiirnriF以向30的右子树继续查找：再用48同当前根节点52进行比较，因48＜52，所以向52的左子树继续查找，此时左子树为空，所以返回假，表明查找失败，整个查找过程就此结束.在二叉搜索树上进行查找的过程中，给定值item同树中节点比较的次数最少为一" ID="17">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="（即树根节点就是待查的节点），最多为树的深度，所以平均查找次数要小于等于树的" ID="18">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="变.若二叉搜索树是一棵理想平衡树或接近理想平衡树，则进行查找的时间复杂度为09班），若退化为一裸单支树〔最极端和最差的情况），则其时间复杂度为。（习，对于次深度.以109班），" ID="19">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="一般情况，其时间复杂度可大致看做为0009润。由此可知，在二叉搜索树上查找比在集合或线性表上进行顺序查找的时间复杂度o（曰要好得多，这正是构造二叉搜索树的优势所在。二叉搜索树查找的递归算法的空间复杂度平均情况为以”），非递归算法的空间复杂度为0（D。" ID="20">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="2.更新" ID="21">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="二叉搜索树的更新算法与查找算法基本相同，区别仅有两点：一是在更新算法第6章二叉树的应用·】仍·对应的递归算法描述为：voidInaert(6TrceNodeBST.CoostE1emTypedcitem)11向二叉搜索树中插入一个元素itcm，变参BST初始11指向一裸树的根节点.并且HST必须为变参套" ID="22">
          <fptr EndPN="00000209" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="ifYBST-NULL){ll把按照item元素生成的新节点链接到已找到的插入位tBTieeNnde+p-newBTreeNode;" ID="23">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="卜洲如加月比叫" ID="24">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="卜＞lef争xight=lViII.L;" ID="25">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="BST=p;" ID="26">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="》elseifl(item＜BSTdat1/向左子树中插入元素Insert(BST-deft,亘tomelse向右子树中擂入元素Insert(BST-aright,item" ID="27">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="}！二叉搜索树的递归查找算法一样，此算法也属于末尾递归的调用，所以为了消俘1归，减少算法运行的时间和空间，也可编写出对应的非递归算法（注意：消除月f不需要使用堆栈）。对于插入过程的非递归算法，需要首先查找插入位置，然后尹i入。查找插入位置从树根节点开始，若树根指针为空，则新节点就是树根节点；节点，则沿着根的右指针在右子树上继续查找插入位置，当查找到一个节点（假员" ID="28">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="末尾递归，减少算法运行的时间和空间，也可编写出对应的非递归算法（注意：消除末尾递归不需要使用堆栈）。对于插入过程的非递归算法，需要首先查找插入位置，然后再进行插入。查找插入位置从树根节点开始，若树根指针为空，则新节点就是树根节点；若1贻m大于等于根节点，则沿着根的右指针在右子树上继续查找插入位置，当查找到一个节点（假定由二全偿鑫IJ碳味耸向、配，生：j耸外石廿健匕俗抖毛力时油1待木方的均朴待粤朴早多奋去节占的左指针或右指针为空时，若原树为空，则将新节点指针赋给BsT，该新节点就成为树根节$Picture[00000209\00000209_new\0034.jpg]Picture$·196。数据结构BTretNode.tBSTQtu+entrNUi,L;whiie(tl=NULL){" ID="29">
          <fptr EndPN="00000210" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="侧叮.目；" ID="30">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="if(itemat-xiata)t二t-aloft;" ID="31">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT=".卜粗。成-aright;" ID="32">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="｝护健立值为item.左、右指针域为空的新节点BTroeNvde*p=newBTceeNode;卜加如etaitem;" ID="33">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="p-lef争xight=NULL;将新节点插入到以引用参数BST为树根指针的II二叉搜索树中的确定位置上if(parenl～NULL)BST=p;elseif(item‘parentdata)parent-deftp;elseparent-yrightp;" ID="34">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="杏二叉搜索树的插入算法与查找和更新算法一样，都具有相同的时间复杂度和空间复杂度.利用二叉搜索树的插入算法。可以很容易地写出生成一棵具有。个节点的二叉搜索树的算法，设生成二叉搜索树的n个元素由数组提供，则算法描述为：voidCt+eateBSTtee(STreeNode＊全BST,ElemTypea口.intn)" ID="35">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="11利用数组中的n个元素建立二叉搜索树的算法屯" ID="36">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="SST=NULL;" ID="37">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="for(inti二O;itn;i+t)" ID="38">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="Insen(BST,a[i" ID="39">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="）在一般情况下，该算法的时间复杂度为。(n*logzn)o假定待建立二叉搜索树的一组元素的关键字为：(38,26,fit,94,33,S0,2&amp;55)按照上述算法，每插入一个节点后得到的二叉搜索树如图6.2(a)一图b.2(1所示.第6章二叉树的应用·197圈6.2二叉搜索树的生成过程" ID="40">
          <fptr EndPN="00000211" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="a.川除$Picture[00000211\00000211_new\0007.jpg]Picture$$Picture[00000211\00000211_new\0008.jpg]Picture$$Picture[00000211\00000211_new\0009.jpg]Picture$二叉搜索树的删除比插入要复杂一些，上，因而不会破坏树的原有结构，也京节点上，系。从二叉搜索树上删除节点（元素）指针，使得删除后仍为一棵二叉搜索树。下而姑超乡阅成1了.、断福哥的一下抽礴所示的二叉搜索树，分三种情况说明删除节点的操作。" ID="41">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Picture URL="00000211\00000211_new\0018.jpg">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Picture>
        <Paragraph CONTEXT="i）侧除叶子节点" ID="42">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="此种删除操作很简单，只要将其双亲节点链接到它的指针去掉（即置为空）即可。如删除图6.3(a)树中叶子节点A时，把S节点的右指针域置空即可。2〕侧除单支节，获这种删除操作也比较简单，因为该节点只有左子树或右子树一支，也就是说，其后继一个：左孩子或右孩子。删除该节点时，只要将后继指针链接到它所在的链接位置即如删除图6.3(a）树中单支节点G时，将G的左指针（即指向F节点的指针）赋给D只有一个：左孩子或右孩子。删除该节点时，·I98·数据结构指针为空（左指针可能为空，也可能不为空）的节点，如图b.3(a）树中双支节点D的的链接位置。如在图6.3(a)树中删除双支节点D时，贝！点的右指针域，然后把n的左子树链接到L的左指针域，igtFfrrt困3‘16r福矛;3'rh，氏'ihh峪忿iillfinihtthSELF（c）所示。这种方法往往容易增加树的深度，用下面介绍的第二种方法。$Picture[00000212\00000212_new\0009.jpg]Picture$然后再删除它的中序前驱节点，因它的中序前驱节点的右指针为空，所以只要把中序前" ID="43">
          <fptr EndPN="00000212" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="如删除图6.3(a)树中双支节点D时，则首先把它的中序前驱节点A的生些创.了，冲依于告方、尝#f3Erln#Xih七均抖书公指针点）链接到D节点的右指针域，删除L节点后得到的二叉搜索树如图6.3(d)所示。(c)(d)图6.3二叉搜索树的删除从二叉搜索树中删除节点的算法可以是递归的，也可以是非递归的，下面只给出递归算法，读者可以自行编写出非递归算法.baoiDeleteA(BSTNode*8tBST,constElemType＆item)11从BST指针所指向的二叉搜索树中删除值为item的节点，树根指针必须为引用第6章二叉树的应用·199刀待侧除元素小于树根节点值，继续在左子树中州除it(itetrKBSTdata)returnDeleteA(BST-deft,item11待l除元素大干树根节点值，继续在右子树中删除ifitetnaBST-data}return17eleteA(BST-7right,itemB5TNode，temp=BST;11待删除元素等于树根节点值且左子树为空，将右子树作为整个树并返回真ifl(BST-yleft-NULL){HST=BSTright;deletetemp;returntrue;}待删除元素等于树根节点值且右子树为空，将左子树作为整个树并返回真elseifl(BST-right-NULL){BST=BST-deft;deletetemp;returntrue;｝刀待删除元素等于树根节点值且左、右子树均不为空时的处理情况else{11中序前驱节点就是左子节点时，把左子节点值斌给树根节点，刀然后从左子树中删除根节点" ID="44">
          <fptr EndPN="00000213" StartPN="00000212"/>
        </Paragraph>
        <Paragraph CONTEXT="if(BST-＞lcaright=NULL){" ID="45">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="BST-data二HSTleft-＞data;" ID="46">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="return17eleteA(BST-left,B5T-data}查找出中序前驱节点，即树的右下角节点，把该节点值斌给树根节点，刀然后从以中序前驱节点为根的树上侧除根节点else{" ID="47">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="BSTNodo.pI=BST,*p卜BST-left;" ID="48">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="while(p2right！二NULL){pl=p2;p2=p2一＞aright;}" ID="49">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="BST-datA=p2rdata;" ID="50">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="rexiunDeleteA{pl一》rigt,t,p么data}" ID="51">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="52">
          <fptr EndPN="00000213" StartPN="00000213"/>
        </Paragraph>
        <Paragraph CONTEXT="}二叉搜索树的查找、插入、删除元素的运算都具有相同的时间复杂度，都与具体二叉搜索树的深度成正比，时间复杂度的平均情况为O(logzn)，最差情况为(n}；它们的·200·数据结构空间复杂度，对于递归算法来说，平均情况为OUogxn最差情况为p(n)，对于非递归" ID="53">
          <fptr EndPN="00000214" StartPN="00000213"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000214" TITLE="6.2  堆" TYPE="Chapter">
      <fptr LogicalPageNum="214" PhysicalPageNum="214"/>
        <div ORDERLABEL="00000214" TITLE="6.2.1  堆的定义" TYPE="Chapter">
        <fptr LogicalPageNum="214" PhysicalPageNum="214"/>
        <Paragraph CONTEXT="堆（Heap）分为小根堆和大根堆两种，对于一个小根堆，它是具有如下特性的一棵完全二叉树。" ID="1">
          <fptr EndPN="00000214" StartPN="00000214"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)若树根节点存在左孩子，则根节点的值（或某个域的值）小于等于左子节点的值（或某个域的值）：" ID="2">
          <fptr EndPN="00000214" StartPN="00000214"/>
        </Paragraph>
        <Paragraph CONTEXT="则根节点的值（或某个域的值）小于等于右子节点的值（或某个域的值）；" ID="3">
          <fptr EndPN="00000214" StartPN="00000214"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）以左、右孩子为根的子树又各是一个堆。" ID="4">
          <fptr EndPN="00000214" StartPN="00000214"/>
        </Paragraph>
        <Paragraph CONTEXT="d，翻拿配卜尝，妙.而丫左rt净七-翻组经纽月卜一可右廿土致翻能丽.名方台廿d匕.习交注片、试禽占月，则该树中以每个节点为根的子树也都是一个堆.图6.4顶节点，即整个完全二叉树的根节点，对于小根堆来说具有最小值，对于大根堆来说具" ID="5">
          <fptr EndPN="00000214" StartPN="00000214"/>
        </Paragraph>
        <Paragraph CONTEXT="一个大根堆，堆中的最大值为堆顶节点的值科。若用堆来表示优先级队列，则堆顶节点则堆顶节点" ID="6">
          <fptr EndPN="00000214" StartPN="00000214"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000214" TITLE="6.2.2  堆的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="214" PhysicalPageNum="214"/>
        <Paragraph CONTEXT="第6章二叉树的应用·20卜IBT表示，其存储类型用标识符HeaPn'表示：堆的抽象数据类型中的操作部分通常JJ.记；，翻全日卜毛握，、＿滋凡二二曰匕r.习全阵.国W口赵、J盛卜，下百（二.国比Y.nIJa1L＿沈、aR2P6＿沈I.JLfY月.LiC为：向堆中插入一个元素，从堆中删除堆顶元素，初始化一个堆.清除一个堆，判断一个堆是否为空等.下面给出堆的抽象数据类型的具体定义：" ID="1">
          <fptr EndPN="00000215" StartPN="00000215"/>
        </Paragraph>
        <Paragraph CONTEXT="ADTHEAPis" ID="2">
          <fptr EndPN="00000215" StartPN="00000215"/>
        </Paragraph>
        <Paragraph CONTEXT="D日0七" ID="3">
          <fptr EndPN="00000215" StartPN="00000215"/>
        </Paragraph>
        <Paragraph CONTEXT="具有H.PTYP类型的一个堆HBT" ID="4">
          <fptr EndPN="00000215" StartPN="00000215"/>
        </Paragraph>
        <Paragraph CONTEXT="q脚咐此：voidInitHeap(HeapType&amp;HBT刀初始化一个堆，即把它t为一个空堆voidC1earHeap(HeapTypcBcHI3T刀清除一个堆，使之变为一个空堆IiJ断HBT是否为空，若是则返若是则返回妞”.，否则返回佃甘voidInsertHe娜-IeepType&amp;HST,oonstElemTypeitems;ElemTypeDeletcHcapieapTypeBtHHT" ID="5">
          <fptr EndPN="00000215" StartPN="00000215"/>
        </Paragraph>
        <Paragraph CONTEXT="刀从堆中侧除堆顶元素并将它返回，口删除后仍要成为一个堆" ID="6">
          <fptr EndPN="00000215" StartPN="00000215"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000215" TITLE="6.2.3  堆的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="215" PhysicalPageNum="215"/>
        <Paragraph CONTEXT="然后再以编号为下标存让堆中节点的编号从0而不是同一层从左到右进行，若堆中含有n个节【rt/2」至n-1的节点为叶子节点：当n为奇数时则每个分支节点既有左孩子又有右孩子，.2倪.数据结构0123456789！18｝,,I’35I73｝二｝i”i..T一”1101234Sb789｝74I53’'42I75｝36I35120I18I22I”,读者可以根据此存储结构验证上述给出的双亲和左、右子节点之间的下标关系。当一个堆采用顺序存储结构时，需要定义一个元素类型为ElemType、长度为MaxSiz。的一个数组来存储堆中的所有元素，还需要定义一个整型变量，用以存储堆的长度，即堆中当前包含的节点数。假定存储堆元素的数组名用heap表示，存储堆长度的变量名用]en表示，并且把它们连同存储空间大小MaxSize一起定义在一个结构类型中，结" ID="1">
          <fptr EndPN="00000216" StartPN="00000215"/>
        </Paragraph>
        <Paragraph CONTEXT="构类型名用Heap5q表示，则该类型定义为：structHeapSq{11定义堆的顺序存储类型日emTyl沁.he即；" ID="2">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="intkn：II定义保存堆长度的变量" ID="3">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="intMaxS泳：刀用于保存初始化时所给的动态数组空间的大小" ID="4">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；" ID="5">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000216" TITLE="6.2.4  堆的运算" TYPE="Chapter">
        <fptr LogicalPageNum="216" PhysicalPageNum="216"/>
        <Paragraph CONTEXT="下面给出在堆的抽象数据类型中列出的每一种操作的具体算法描述，对于插入和删" ID="1">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="除算法将以小根堆为例给出，当为大根堆时只是相应条件中的比较操作符不同，其余都" ID="2">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="当为大根堆时只是相应条件中的比较操作符不同，其余都" ID="3">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="，.初始化堆" ID="4">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="void玩1旧朋杯Hea恻匆＆HBT，intMS）第6章二叉树的应用·203HBT.heap=newElemType[MS1代IH旧T.heaP）1coutae“用于动态分配的内存空间用完.退出运行acendi;exit(1" ID="5">
          <fptr EndPN="00000217" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="）设里MazSize城和len的值HSTMaxSize=MS;" ID="6">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="HST.ien＝＝0;" ID="7">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="8">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="2.清除堆voidC1earHtap(HoapSgBcHBT)刀清除升习了，使之成为一个空堆{" ID="9">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="if(HBT.heap｝二N[JY.I{" ID="10">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="deleteHBT.heap;" ID="11">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="HBT.heap=MJLL;" ID="12">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="HBT,ien;" ID="13">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="HBT.Max5iz，习;" ID="14">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="15">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="16">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="3.检查一个堆是否为空boolEmptyNP杯r-teaci&amp;H$T)11判断HBT是否为空，若是则返回true.否则返回false《" ID="17">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="returnHST.lcn习:" ID="18">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="19">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="4.向堆中插入一个元亲向堆中插入一个元素时，首先将该元素写入到堆尾，即堆中最后一个元素的后面，亦即下标为len的位置上，然后经调整为一个新堆。由于在原有堆上插入一个新元素后.·zoa。数据结构整使之仍为一个堆。调整的方法很简单.若新元素小于双亲节点的值，就让它们互换位置：新元素换到双亲位置后.使得以该位置为根的子树成为堆，但新元素可能还小于此" ID="20">
          <fptr EndPN="00000218" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="位置的双亲节点的值，从而使以上一层的双亲节点为根的子树不为堆，还需要按上述方法继续调整，这样持续传递上去，直到以新位置的双亲节点为根的子树仍为一个堆或者法继续调整，这本例如.对于图6.4(a)所示的堆，若向它插入一个新元素i时，由于它不小于双亲节点的值35，所以以35为根的子树仍为一个堆，从而使整个二叉树仍然是一个堆.此次" ID="21">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="公〔a:国巳砚6HirI工Ir;F宜女七表a翻斗币二盛荟enF喇里巫rfbh#1rrrFl孟tr。tgar图6.5堆的插入" ID="22">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="对于图5.4(a)所示的堆，若向它插入一个新元素3，由于它小于双亲节点的值" ID="23">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Picture URL="00000218\00000218_new\0015.jpg">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Picture>
        <Picture URL="00000218\00000218_new\0016.jpg">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Picture>
        <Paragraph CONTEXT="35：所以需要将3a与35对调位置，" ID="24">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="去士下肠.季且劝『6产.自女2凡一1口位奋牛＿洲人翻全结束，对于图6.4(a}所示的堆，若向它插入的一个新元素为l5，由于它小于双亲元素所以需要将15与35对调位置，对调后因新元素15小于其双亲元素18，所以又f要c1;tQ7:iyF81t月邵iii口i-挥-irFrki目±klL$IiTiTtt拾与笋rlli周ll壮'_53NffFhf,入I" ID="25">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="35," ID="26">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="将15与18对调位置，" ID="27">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="结果如图6.5（c）所示。" ID="28">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="11向HBT小根堆中插入一个元素，使得插入后仍是一个堆" ID="29">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="｛第6章二叉树的应用.205" ID="30">
          <fptr EndPN="00000219" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="p[iHl3T.heap[i11把原内容复制到新的存储空间中deleteHl3T.heap二11别除原空间HBT.hea-p;1/堆指针指向新空间HBT.MaxSit二2+rH$T.MaxSiat+l;11修改堆空间大小｝" ID="31">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="11向堆尾添加新元素HBT.hcAp[HBT.Ienitem;HBT.Iea阴协新元素暂存x中。待放入到最终的位1取游ypex=item;刀用i指向待调整元素的位里.初始指向新元紊所在的堆尾位皿iati=HBT.Iea-i;11寻找新元素的最终位t.每次使双亲元素下移一层wlWe(i！习)intjm(i-l)l2;u指向下标为i的元素的双亲元素ifl(x＝＝H13T.heap[jbreak;比较调整结束退出循环NBT.heap[i]二HBT.heap[j11双亲元索下移ij;1/改变调整元素的位里为其双亲位里》刀把新元素调整到最终位置】田T力创甲【11＝x幕" ID="32">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="｝此算法的运行时间主要取决于whi]e循环的执行次数（假定不考虑重分配存储空间所沟时间），它等于新元素向双亲位置逐层上移的次数。此次数最多等于整个树的深度减" ID="33">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="rL'I竺件IfhBfCel官奋i&quot;Et[lllnonl.巾。hf#tt'I花的时间），" ID="34">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="5，从堆中剧除元案从堆中删除元素就是删除堆顶元素并使之返回。堆顶元素被删除后，留下的洲由堆尾元素来填补，这样既保持了顺序存储结构又不需要移动其他任何元素.·saa据结构子位置后，可能使以该位置为根的子树又不为堆，因而又需要使新元素向孩子一层调效六n.冲亏国效下串吉tlrl;周放居thr粤,坦tr舀声it吩,一木撬甜;止生益r-占蛋" ID="35">
          <fptr EndPN="00000220" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="整.如此调整下去.$Picture[00000220\00000220_new\0010.jpg]Picture$互换60和26的位置，60被移到新位置后，又大于两个" ID="36">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="孩子中的最小值48，所以接着同48互换位置，此时60图6.6堆的删除己被调整到叶子节点，所以调整完成，得到的完全二叉树又成为一个堆，如图6.6所示。所示堆的堆尾元素不是印而是45，则进行删除操作时把45写入到均" ID="37">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="大于两个孩子中的最小值26，所以需把它对调到左孩子26的位置，止中的最小值48，表明以45所在的新位置为根的子树已经成为一个堆，因45大于两个孩子中的最小值26，所以需把它对调到左孩子26的位置，此时它小于两个孩子中的最小值48，至此调整结束。" ID="38">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="从堆中删除元素的算法描述为。" ID="39">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypeDel比价叩（价aPS吵HBT）" ID="40">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="方从HBT小根堆中删除堆顶元素并将它返回，删除后仍要成为一个堆｛" ID="41">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="11若为空堆，则显示出错误信息并退出运行" ID="42">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="1氏HBT.len今0）【" ID="43">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="ce解“堆己空，退出运行！”姗耐七exl代1）；】刀将堆顶元素暂存妞mP中以便返回E】emTy声temP二HBT.heaP［0］；HBT.len一；第b章二叉树的应用.207intj=2«i+l;11寻找待调整元素的最终位置，每次使孩子元素上移一层while‘二HBT.Ien-1)(11调整到孩子为空时止刀若右孩子存在并且较小，应使j指向右孩子ifCj＜HBT.len-1&amp;8cHBTheap(jHBT.heap(j+11)j若条件成立则调整结束，退出循环刀若条件成立则调整结束，if(x二HBT.heap[jbreak;刀孩子元素上移到双亲位里" ID="44">
          <fptr EndPN="00000221" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="HBT.hcap[iHST.hcap[j/1使i和j分别指向下一层节点ice;j=2*i+1;" ID="45">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="46">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="刀把待调整元素放到最终位且HBT.hcaP【1］双；" ID="47">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="刀返回原堆顶元素returntemp;此算法的运行时间主要取决于while循环的执行次数，它等于堆顶新元素向孩子位置逐层下移的次数，此次数最多等于格个树的深度减1.所以堆酬险览块的时间有杂磨同播此次数最多等于整个树的深度减1，在解决实际问题时，若每次只需要取出（即删除）具有最小值就具有最小值的元素，则适合采用堆这种数据结构，因为其插入和删除元素的时间复杂度均为。（1092的。若采用线性表来实" ID="48">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="现这种功能，其插入和删除元素的时间复杂度将均为O（动。如在计算机操作系统中，管理一个共享资源就需要使用一个堆，把等待使用该资源的所有用户按照优先级号组织起来，优先级最高的用户一定处于堆首位置：系统每次从·208数据结构BkmType*heap:intlen;" ID="49">
          <fptr EndPN="00000222" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="intMaxSiu;" ID="50">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="liinclude&quot;heap.cpp&quot;ll定在程序文件heaP.cPP中保存着对堆的每一种操作的具体实现voidmaid}" ID="51">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="【inta[8123,56,40,62,38.55,10,16HeapSqb;11定义一个堆b1nitHeap(b,511初始化堆binti,x;fodi;i8;iIasertHeap(b,a(i" ID="52">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="11向堆b中依次插入数组a中的每一个元素whild!EmptyHeap(b" ID="53">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="直到堆空为止" ID="54">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="x=IlrleteHeap(b" ID="55">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="coutsat;ifCESmptyHap(boout,“;" ID="56">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="57">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="cout《endl;" ID="58">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="C1earHsap(b｝该程序的运行结果为：10,16,23,38,40,55,56,62" ID="59">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000222" TITLE="6.3  哈夫曼树" TYPE="Chapter">
      <fptr LogicalPageNum="222" PhysicalPageNum="222"/>
        <div ORDERLABEL="00000222" TITLE="6.3.1  基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="222" PhysicalPageNum="222"/>
        <Paragraph CONTEXT="t)路径和路径长度若在一棵树中存在着一个节点序列fit,kz.k,，使得吸是)4+，的双亲（1Sicj)，则第6章二叉树的应用.2的·个节点之间的惟一路径。从k，到与所经过的分支数称为这两点之间的路径长度，它等于路径长度为3.2）节点的权和带权路径长度在许多应用中，常常将树中的节点赋上一个有着某种意义的实数.我们称此实数为一占的匆＿节占的举匆阵释裕育翎常杰从姗用书占孔1月女节占少向的滩扔裕磨盆宁玄节占" ID="1">
          <fptr EndPN="00000223" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="该节点的权." ID="2">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="上权的乘积。" ID="3">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="3）树的带权路径长度w刊二艺以其中n表示叶子节点的数目，wi和几分别表示叶子节点粉的权值和树根节点到玩之" ID="4">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="间的路径长度。" ID="5">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="4）哈夫受树哈夫里（Huff恤an）树又称做最优二叉树。它是n个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树.因为构造这种树的算法最早是由哈夫曼于1952年提出的，所以被称之为哈夫曼树。栩1加＿右四个叶子节占。卜t.d＿（a）图6.7由四个叶子节点构成的三棵不同的带权二叉树每一棵二叉树的带权路径长度认中L分别为：（a）认甲L二9X2＋4XZ＋5火2＋2X去鸽0（b）认甲L二4XI＋2X2今5X3＋9X3幼0·aio·数据结构" ID="6">
          <fptr EndPN="00000224" StartPN="00000223"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000224" TITLE="6.3.2  构造哈夫曼树" TYPE="Chapter">
        <fptr LogicalPageNum="224" PhysicalPageNum="224"/>
        <Paragraph CONTEXT="构造最优二叉树的算法是由哈夫曼提出的，所以称之为哈夫曼算法，具体叙述如下：(t)根据与n个权值‘wt.wz,，wa}对应的n个节点构成具有n棵二叉树的森林FTl,TZ，一，T}，其中每棵二叉树T;(lCi&lt;rt)都只有一个权值为w;的根节点，其左、" ID="1">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）在森林F中选出两棵根节点的权值最小的树作为一棵新树的左、右子树，且置节点的权值为其左、右子树上根节点的权值之和；从F中删除构成新树的那两棵树，同时把新树加入F中；" ID="2">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)按照上述算法，则构6在构造哈夫曼树的过程中，每次由两棵权值最小的树生成一棵新树时" ID="3">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="树和右子树可以任意安排，这样将会得到具有不同结构的多个哈夫曼树，第6章二又树的应用·211{" ID="4">
          <fptr EndPN="00000225" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="BTreeNodebq;11动态分配一个由b指向的指针数组b=newBTnoeNoden" ID="5">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j;始化b指针数组，使每个指针元索指向a数组中对应元素的节点fot{i动;inn;i{" ID="6">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="b[i]二”ewBTneNode;b[idata[ib[iIT二b[ixightNULL;}" ID="7">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="11进行n-1次循环建立哈夫曼树" ID="8">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="角以1＝＝1；1哎n；1杆）f用kl表示森林中具有最小权值的树根节点的下标，用k2表示森林中具有次最小权值的树根节点的下标intkl二一1,k2;11让kl初始指向森林中第一裸树，k2初始指向森林中第二裸树fodj闭;jar,j{" ID="9">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="itCb[jYN[ILI,kl二一1){klj;continneifCb(j]1二NULi{k2=j;break;1）刀从当前森林中求出最小权值树和次最小权值树" ID="10">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="肠均比2；j＜n；j＋＋）f" ID="11">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="目肠(bGl-ode心民b沙夕】.洲加动匕句二" ID="12">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="}}/由最小权值树和次最小权值树建立一棵新树，q指向树根节点9二newBTroeNade;q-d8ta二b[kldata+b(kZdate;11将指向新树的指针斌给b指针数组中kl位" ID="13">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="1Cl位置1为空。212。数据结构刀删除动态建立的数组b" ID="14">
          <fptr EndPN="00000226" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="deleteb;" ID="15">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="刀返回整个哈夫曼树的树根指针" ID="16">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="returnq;" ID="17">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="】在这个算法中有多处动态分配存储空间.按正常情况需要判断分配是否成功，这里为简便起见而省略了。不过，由于计算机操作系统的功能越来越强，即使内存无动态分配的空间可用，系统也会自动到外存寻找空间并进行有效分配，所以通常没有必要判断动态分配是否有效.万一分配失败，也不会造成机器故障，系统会自动退出程序运行.下面给出根据哈夫曼树求出带权路径长度的算法。ElemTypeWeightPa山Lengdt(BTreeNode+FBT,intien)" ID="18">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="11根据FBT指针所指向的哈夫曼树求出带权路径长度，len初值为0" ID="19">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="lif(FBT=NULL)re加rn0;11空树则返回0else{II访问到叶子节点时返回该节点的带权路径长度，其中值参len" ID="20">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="刀保存当前被访问节点的路径长度" ID="21">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="if(FBT-＞1cCt=NULI.FBT-》t&quot;归今NULL){returnFBT-＞dttta+len;｝访问到非叶子节点时进行递归调用.返回左、右子树的带权" ID="22">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="刀路径长度之和.向下深入一层时蜘值增1returnWeightPaWL.ength(FBTdeft,1ea+1" ID="23">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="WeightPadtI.ength(FBT-xight,1cn+1" ID="24">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="25">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="｝}" ID="26">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000226" TITLE="6.3.3  哈夫曼编码" TYPE="Chapter">
        <fptr LogicalPageNum="226" PhysicalPageNum="226"/>
        <Paragraph CONTEXT="第G章二叉树的应用·213序列转换成二进制的0,1序列（即编码），在接收端又需要把接收的4,1序列转换成对应的字符序列（即译码）。最简单的二进制编码方式是等长编码。例如，假定媲褪亡介，式各易1雪亚＝J台一徽幽1立炸石丫fr4扁hTL'E,可依次编码为叹100,001,010,Oll,1.00,101。若用这六个字符作为六个叶子节点.生成一棵二叉树，让该二叉树中每个分支节$Picture[00000227\00000227_new\0010.jpg]Picture$叶子节点的路径上所经分支的0,1编码序列应等于该叶子节点的二进制编码，则对应的编码二叉树如图6.9图6.9编码二叉树" ID="1">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="所示。这六个字符的出现频率依次为：4.2,6,8,3,2.则电文被编码后的总长度L可由下式中，L＝nL=c;I;其中n表示电文中使用的字符种数，。和寿分别表示对应字符匆在电文中的出现频率石旦裕磨廷吞生珍们的伽与莽石1.份!frh.和编码长度.6r=i可知，采用等长编码时，传送电文的总长度为7Se·214·数据结构$Picture[00000228\00000228_new\0003.jpg]Picture$由编码哈夫曼树得到的字符编码称做哈夫里幼码。在图6.10中，A,B,C,D,E,F这六个字符的哈夫图6.1。编码哈夫里树曼编码依次为：00,1010,O1,il,100,1oll.电文的最短传送长度为：6r=i" ID="2">
          <fptr EndPN="00000228" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="=4x2+2x4+6x2+8x2+3x3+2x4=61显然，这比等长编码所得到的传送电文总长度75要小得多。对已经介绍过的求哈夫曼树带权路径长度的算法略加修改，法.具体给出如下：就可以得到哈夫曼编码的算法.voidHuffManCoding(BTreeNode*FBT,int1on)11根据FBT指针所指向的哈夫曼树输出每个叶子的编码，len初值为Q" ID="3">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="【" ID="4">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="staticinta{101;11数组的长度要至少等于哈夫曼树的深度减1试FBT！＝NULL）｛11访问到叶子节点时翰出其保存在数组a中的a和1序列编码if(FBT-1cft＝NULL&amp;8tFBT-7tight～NLTt&quot;i.l{oout«“节点权值为“礴:FST-dataa”的编码fot(inti=0;ialea;ioout«a[i]coutacendl;" ID="5">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="争" ID="6">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="刀访间到非叶子节点时分别向左、右子树递归调用，并分别把分支上第6章二叉树的应用，ais爵本章，J、结" ID="7">
          <fptr EndPN="00000229" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="i.二叉搜索树是左于节点的值小于根节点的值，右于节点的值大于根节点的值，并且其左、右子树也满足上述条件的二叉树." ID="8">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="a.对二叉搜索树进行中序遥历得到的节.饭序列是一个按值或关健字从小到大排列的有序序列。" ID="9">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="3.时二叉树进行各种运算的基本运葬是查找，查找是一个递归过程，它首先访问根节点，若其值等于给定值则查找成功，否则当给定值小于根节点值时继续向左子树中查找，大于根节点值时继续向右子树中查找，直到查找成功或当前树为空时止." ID="10">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="4.堆是一种满足一定条件的完全二又树，对于小根堆，它的每个分支节点的值都小于等于子节点的值：对于大根堆：它的每个分支节点的值都大于等于于节点的值.堆的侧除操作是侧除堆顶（即树根）元素并把堆尾元素移至堆顶，擂入和侧除一个元素后都要进行堆的调整，使之成为一个新堆，该堆比原堆相应增加或减少了一个元素，调整过程不涉及到所有节.盆，只涉及到从某个叶于到树根或从树根到某个叶子的一条路径上的节点.堆的播入和例除算法的时间树.为了尽童得到推一结构的哈夫处树，个带权叶子节点构成的所有二又树中，带权路径长度最短的二叉" ID="11">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="通常规定每个分支节点的左孩予的权小于等于右孩子的权，对应的C/C描述算法就是连循这个规定的.霭习。661单选翅" ID="12">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="1.从二叉搜索树中查找一个元紊时.其时间复杂度大致为（)o" ID="13">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="A.O(n)B.O(l)C.O(logyi)D.O(n2}" ID="14">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="2.向二叉搜索树中擂入一个元素时：其时间复杂度大致为（）。" ID="15">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="A.O(1)B.Dflag声}C.O(n}D.O(nlog2n)·216·数据结构" ID="16">
          <fptr EndPN="00000230" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="A.Q(l)B.a{n)C.O{lagZn)D.O{nlogn)5一向堆中插入一个元素的时间复杂度为（）." ID="17">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="A.O(logZn)B.O{n)C.O(1)D.O(nlog2n)山切信朴骊『蛋1只凡，呢幼衅早劝占扮劝一姐映丰县妙＿亡配" ID="18">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="s.由权值分别为3,8,6.2.5的叶子节点生成一棵哈夫曼树，它的带权路径长度为（》。" ID="19">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="A.24B.48C.72D.53" ID="20">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="7.利用n个值作为叶节点的权生成的哈夫虽树中#包含有（）个节点." ID="21">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="A.nB.n+1C.2xnD.2xn-1" ID="22">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="8.利用3,6.8,12这四个值作为叶子节点的权.生成一裸哈夫曼树，该树中所有叶子的最长带权路径长度为（）。" ID="23">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="A.18B.1GC.12D,30，.在一棵深度为h的具有R个元素的二叉搜索树中，搜索一个元素的最大搜索长度（即经比较的节点数）为《》." ID="24">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="A.nB.1ogreC.!t/2D.h'rd」r，cvl，孟A413t9B.ErA4i最轰谈dbh弓牛J十f卜titBFr里一d" ID="25">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="10.在由硬25，30.16.48）按照依次插入节点的方法生成的一棵二叉搜索树中，在等概率情况下成功搜索一个元素的平均搜索长度为（）。" ID="26">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="A.ZB.2.SC.3D.4‘J城空月" ID="27">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="1.在一棵非空的二又搜索树中，以每个分支节点为根的子树都是一棵" ID="28">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="2.对一棵二叉搜索树进行中序遍历时.得到的节点序列是一个" ID="29">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="3.从一棵二叉搜索树中查找一个元素时，若元素的值等于根节点的值，则表明，若元素的值小于根节点的值.则继续向查找，若元素的大于根节点的值，则继续向查找。" ID="30">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="4.在一个堆的顺序存储中.若一个元素的下标为1，则它的左孩子元素的下标为，右孩子元素的下标为" ID="31">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="5.在一个小根堆中，堆顶节点的值是所有节点中的＿，在一个大根堆中，堆顶节点的值是所有节点中的＿。" ID="32">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="6.当向一个小根堆插入一个具有最小值的元素时，该元素需要逐层―调整，直到被调整到＿位置为止.把它逐层―调整。" ID="33">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="8.若有两个树TI和程均为小根堆，当以它们作为一裸树T的左、右子树，并用一个比这两裸子第b章二叉树的应用·217的根节点，则树t闷一－（一成夕不一定》是二叉搜索树。]0.在哈夫曼编码中，若编码长度只允许小于等于4，则除了已对两个字符编码为0和to外，还可以最多对一一个字符编码。" ID="34">
          <fptr EndPN="00000231" StartPN="00000230"/>
        </Paragraph>
        <Paragraph CONTEXT="‘J运算月" ID="35">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="1.已知一组元素为‘46,23,7g,b2,12,37,70,29)出按元素排列顺序输入生成的一棵二叉搜索树.再以广义表形式给出该二叉搜索树。" ID="36">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="2.已知一裸二叉搜素树如图b所示。若从中依次删除72,12,49,2g节点，试分别画出每除一个节点后得到的二叉搜索树." ID="37">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="3.从空堆开始依次向小根堆中擂入集合{38,64,52,15,73,40,48,55,2b,12资中的每个元素，请以顺序表的形式给出每插入一个元素后堆的状态。" ID="38">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="4.已知一个堆为（l2,15,40,38,26,52,48,64)。若需要从堆中依次删除四个元索，请给出每删除一个元素后堆的状态·图6.11题6.3的2题图示" ID="39">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="5.有七个带权节点，其权值分别为3,7,g,2,6,10,14，试以它们为叶子节点构造一棵哈夫曼树（可以以广义表形式给出），并计算出带权路径长度WPL$Picture[00000231\00000231_new\0018.jpg]Picture$即a.b，c，d，e，它们的出现频率依次为4，7，5，2，9，求出每个字符的哈夫曼编码，并求出传送电文的总长度.M炸法设计瓜】.设在一裸二叉搜索树的每个节点的山加值域中，含有用于排序p二域和统计相同关键字节点个数的‘。因以域.当向该树擂入一个元索时，若树中已存在与该元素的排序码相同的节点，则就使该节点的以洲呱域增1，否则就由该元素生成一个新节点而插入到树中，并使其伪如t域置为1，试按照这种插入要求编写一个算法." ID="40">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="2.编写一个非递归算法求出二叉搜索树中的关键字最大的元素。" ID="41">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="3.假定一棵二叉搜索树被存储在具有ABTList教组类型（己在上一章中定义）的一个对象BST" ID="42">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="中，试编写出以下算法：" ID="43">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）初始化对象BST；" ID="44">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）向二叉搜索树中插入一个元素；" ID="45">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）根据数组a中的。个元素建立一裸二叉搜索树；" ID="46">
          <fptr EndPN="00000231" StartPN="00000231"/>
        </Paragraph>
        <Picture URL="00000233\00000233_new\0001.jpg">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Picture>
        <Picture URL="00000233\00000233_new\0002.jpg">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Picture>
        <Paragraph CONTEXT="之以毖月r" ID="47">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="月传，.与醉." ID="48">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="." ID="49">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000229" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
      <div ORDERLABEL="00000229" TITLE="习题6" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000233" TITLE="第7章  图" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000233" TITLE="7.1  图的概念" TYPE="Chapter">
      <fptr LogicalPageNum="233" PhysicalPageNum="233"/>
        <div ORDERLABEL="00000233" TITLE="7.1.1  图的定义" TYPE="Chapter">
        <fptr LogicalPageNum="233" PhysicalPageNum="233"/>
        <Paragraph CONTEXT="G城V,E)其中V是顶点集合，即V=Iv;l0蕊i，一1,Qv,EvertexTypevertexType为顶点·22d·数据结构" ID="1">
          <fptr EndPN="00000234" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="号i代替顶点叭的值）分别如下：$Picture[00000234\00000234_new\0004.jpg]Picture$$Picture[00000234\00000234_new\0005.jpg]Picture$圈7.1无向图和有向图YOGId,1,2,3,4,3,}E(Gl(d,1(d,2(0,3(d,4(1,4(2,4(2,5(3,5(4,5叭CZ）＝《0.1.2.3.41E(G2(d,1(0,2(1,2(1,4(2,1(2,3(4,3)}若用G2顶点的值表示其顶点集和边集，则如下所示。VCGZ卜{A,B,C,D,E}E(G2A{(A,B),(A,C),(B,C),(B,E),(C,B),(C,D),(E,D)}在日常生活中，图的应用到处可见。如各种交通图、线路图、结构图、流程图等，" ID="2">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="不胜枚举。" ID="3">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000234" TITLE="7.1.2  图的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="234" PhysicalPageNum="234"/>
        <Paragraph CONTEXT="1.端点和邻接点若存在一条边（vvJ)，则称vv;为此边的两个端点.并称它们互为邻接点（adjacent），即vi是vj的一个邻接点，vj也是v‘的一个邻接点。如在以顶点vo为端点的四条边是（0，D，（0，2），（0，3）和（0，4），vo的四个邻接点分别为v4；以顶点v3为端点的两条边是（3.0）和（3，5〕，v3的两个邻接点分别为v。和v，.在一个有向图中，若存在一条边＜vi，幼，则称此边是顶点片的一条出边（vo的四个邻接点分别为v：，介，v3和" ID="1">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="边＜vi，幼，则称此边声第，章图.22卜就是该顶点的边的数目，记为D(v)。如图G1中o顶点的度为4,.顶点的度为2.有向图中顶点v的度有入1和出度之分，入度（indegree）是该顶点的入边的数目，记为TT11、山角二，w”.aaPrue`3Yfil下蕊r'I4.f山Y11的Aff！曰扣毛nr杯.，、.丁ri,tetrf!C'IF鲍二pvI1滚毖盆州山翻你‘呀为，nn竹，＿＿、」六了＿、.了、了、，＿＿、石n因1了，气日，丫石.写人产山1泊二习，nIJJ泊：耳，，1合习，A的入度为0，出度为2，度为页点C的入度为2，出度为2，度为40」七＿洲、店乙日，1怡.一洲凡，布占泊1，质乙考击爪11月则该图所有顶点的度同边数e满足下面关系：1翻。，‘矛州】这很容易理解，因为每条边连接着两个顶点，使这两个顶点的的度数分别增1，总和增2，所以全部顶点的度数为所有边数的2倍，或者说。" ID="2">
          <fptr EndPN="00000235" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="3.完全图、稠密图、稀疏图若无向图中的每两个顶点之间都存在着一条边，’向相反的两条边，则称此图为完全圈。显然，有向图中的每两个顶点之间都存在若完全图是无向的，则图中包含有着方向相反的两条边，生。（n-1）条边，若完全12若完全图是有向的，则图中包含有n伍一1）条边。当一个图接近完全图时，·222数据结构" ID="3">
          <fptr EndPN="00000236" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="5.路径和回路" ID="4">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="从顶点V到顶点v’的一条路径(pa山）是一个顶点序列vri,viz,vim," ID="5">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="若此图是无向图，则（v一，，v)EE{G(2j簇m)；若此图是有向图，！同外，所有顶点均不同，则称此路径为简单路径.若一条路径上的，巾llu…”二、二石丫八、（，弓二言弓〔.、则（v少；，vij）EE（o），（2匀除了前后端点可以相同外，4；路径a，b，e，a为一条简单回路，其路径长度为3；路径a，b，e，式b不是一条简单路径，" ID="6">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="6.连通和连通分量在无向图G中，若从顶点灼到顶点vj有路径，则称v‘和vj是连通的。若图G中任意$Picture[00000236\00000236_new\0021.jpg]Picture$$Picture[00000236\00000236_new\0022.jpg]Picture$第7章图·2231扭）(b)(c}(d)图7,4有向图和强连通分量f" ID="7">
          <fptr EndPN="00000237" StartPN="00000236"/>
        </Paragraph>
        <Picture URL="00000237\00000237_new\0005.jpg">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Picture>
        <Paragraph CONTEXT="的数量；对于一个反映工程进度的图，边上的权可表示从前一子工程到后一子工程所需要的天数。边上带有权的图称做带权圈，也常称做网（{network)。图7.5中的GS和G6就分别是一个无向带权图和有向带权图。" ID="8">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="冷{a)GS" ID="9">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000237" TITLE="7.2  图的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="237" PhysicalPageNum="237"/>
        <div ORDERLABEL="00000237" TITLE="7.2.1  邻接矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="237" PhysicalPageNum="237"/>
        <Paragraph CONTEXT="·224·数据结构" ID="1">
          <fptr EndPN="00000238" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="-llD00010｝110010$Picture[00000238\00000238_new\0014.jpg]Picture$00D01｝300000例如，对于图7.5中的带权图GS和G6，0123401234一057－一0-0238-050123810000012001A3＝71206202A4＝；6000612003601513000000043＿00820150：4＿“”.，0＿45700000023801238100000121206202A4＝；600063601513’0000000第7章圈.225图的邻接矩阵表示，除了需要用一个二维数组存储顶点之间相邻关系的邻接矩阵猫骨书长里训摘田一木目右”木干安的一雄肠如左徐俑占信自甘由门盯妊告声的；于司毕2芝外，通常还需要使用一个具有n个元素的一维数组存储顶点信息，其中下标为i的元素存储顶点矶的信息。这两种数组的类型可定义为：constiatMaxVertexNu｛图的最大顶点数，它要大于等于具体圈的顶点数atonalintMaxFdgeN姗二{图的最大边数，它要大于等于具体图的边数CtypedefVertexTypevexliat[MaxVerbexNum11定义vexlisrt为存储顶点信息的数组类型typedefintadjmat&lt;ix[MaaVertexNumMaxVertexNum1/定义adjmatrix为存储邻接矩阵的数组类型对于图的邻接矩阵表示，很容易在内存中生成，下面给出生成一个无向带权图的算法描述：voidCteatel(vexlistV,AdjmaprixGA,iutn,inte)刀通过从键盘上输入的n个顶点信息和e条无向边的信息" ID="2">
          <fptr EndPN="00000239" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="11建立顶点数组GV和邻接矩阵GA（inti,j,k,w;" ID="3">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="1/建立顶点数组" ID="4">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="cout«“物入“礴泊《“个顶点“礴戈耐七" ID="5">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="fors-1闭：1＜n；1＋＋）cin＞》GV［1］：" ID="6">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="左初始化邻接数组" ID="7">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="far(i司;icn;i1叹1刊）GA［11盯1司；" ID="8">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="elseGA[ijMaxVatue;11MaxValue为一个全局整型" ID="9">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="其值要人于邻接矩阵中所有有效值之和" ID="10">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="｝刀建立邻接数组coutac&quot;输入即嘴笼条边“《ettdl;folk=1;k＜减;k" ID="11">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="city&gt;i»j»w;II1入一条边的两端点序号i和j及边上的权w·226·数据结构" ID="12">
          <fptr EndPN="00000240" StartPN="00000239"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000240" TITLE="7.2.2  邻接表" TYPE="Chapter">
        <fptr LogicalPageNum="240" PhysicalPageNum="240"/>
        <Paragraph CONTEXT="邻接表（adjacency1ist）是对图中的每个顶点建立一个邻接关系的单链表，并把它们V‘建立的邻接关系的单链表称做vi邻接表。v，邻接表中的每个节点用来存储以该顶点为端点或起点的一条边的信息，因而被称为边节点。v，邻接表中的节点数，对于无向图来说，等于v，的边数，或邻接点数或度数；对于有向图来说，等于、，的出边数、或出边邻接点数或出度数。边节点通常包含三" ID="1">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="2、去」全＿＿曰乃口屯七J沙玉翻，＿」二＿＿＿＿＿、口J.“叹匕户盆价吝」巳＿人人，卜六”4心竺丫翅绍1，丙‘.嗯」。一口J妞，」日.数；对于有向图来说，等于v，的出边数、个域：一是邻接点域（a匀ve、），用以存储顶点v‘的一个邻接顶点vj的序号" ID="2">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="（weight），用以存储边（片，vj）或＜v、vj）上的权；二是链该（nexo，用以链接v‘邻接" ID="3">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="表中的下一个节点。在这三个域中.邻接点域和链域是必不可少的，权域可根据情况取" ID="4">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="若表示的是无权图，则可省去此域。对于每个顶点v，的邻接表.需要设置一个表头·，若图G中有n个顶点，则就有n个表头指针。为了便于随机访问任一顶点的邻接舍，指针，表，邻接表的表头指针。图7.1中的Gl和图7.5中的G6对应的邻接表分别如图7.6（a）和（b）所示。图7.6GI和06的邻接表第，章图·227imadjvex;11邻接点域intweight;11权值域，对无权图可省去edgeaode*next;11指向下一个边节点的链域typedefedgenode.adjlist[MaxVettexNutn" ID="5">
          <fptr EndPN="00000241" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="11定义xdjliat为存储n个表头指针的数组类型voidG'rzateZ(vexlistGV,adjlistGL,intn,inte)刀通过从链盘上输入的。个顶点信息和e条有向边的信息1/建立顶点数组GV和邻接表GLi" ID="6">
          <fptr EndPN="00000241" StartPN="00000241"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k;刀建立顶点数组cout“输入”嘴尔《”个顶点“嘴;endl;fot{i功;iai;icituGV[i勿始化邻接表，即将表头向量中的每个城盖空刀初始化邻接表，fat(i动;inn;iGL[i]＝＝NUI.L;刀建立邻接表" ID="7">
          <fptr EndPN="00000241" StartPN="00000241"/>
        </Paragraph>
        <Paragraph CONTEXT="C优加忆“输入“劝戈《”条边“《即山：" ID="8">
          <fptr EndPN="00000241" StartPN="00000241"/>
        </Paragraph>
        <Paragraph CONTEXT="fo(k.l;k&lt;礴；如阵）《洲白入一条边心，j&gt;曲公＞卜习；11由系统分配一个新节点edgenade+卜ttewedgenade;刀将j的值赋给新节点的邻接点域" ID="9">
          <fptr EndPN="00000241" StartPN="00000241"/>
        </Paragraph>
        <Paragraph CONTEXT="卜＞咧枪龙勺；" ID="10">
          <fptr EndPN="00000241" StartPN="00000241"/>
        </Paragraph>
        <Paragraph CONTEXT="11将新节点插入到vi邻接表的表头" ID="11">
          <fptr EndPN="00000241" StartPN="00000241"/>
        </Paragraph>
        <Paragraph CONTEXT="介&gt;nexfdiL[iGL(ip;.zza.数据结构点单链表的平均长度为eln（对于有向图）或2eln（对于无向图），所以此查找运算的时间复杂度为Q(eln)。但要从有向图的邻接表中查找一个顶点的入边或入边邻接点，那就不adjacency1ist)，该表中每个顶点的单链表不是图7.7G6的逆邻接表边、入边上的权、入边邻接点和入度。在有向图的邻接表中，求顶点的出边信息较方便，在逆邻接表中，求顶点的入边信息较方便，若把它们合起来构成一个十宇·接表（orthogonaladjacency1ist)，则求顶点的一鼠馨歌森$Picture[00000242\00000242_new\0016.jpg]Picture$a'n图7.8G6的十字邻接表在十字邻接表中，每个边节点对应图中的一条有向边，它包含五个域：边的起点域$Picture[00000242\00000242_new\0020.jpg]Picture$第7章图·229$Picture[00000243\00000243_new\0002.jpg]Picture$表对应邻接矩阵中的第i行.整个邻接表可看做是邻接矩阵的带整个逆邻接表可看做是邻接矩阵的带列指针向量的链接存储：" ID="12">
          <fptr EndPN="00000243" StartPN="00000241"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000243" TITLE="7.2.3  边集数组" TYPE="Chapter">
        <fptr LogicalPageNum="243" PhysicalPageNum="243"/>
        <Paragraph CONTEXT="边集致组（edgesetarray）是利用一维数组存储图中所有边的一种图的表示方法。该每个元素用来存储一条边的起点、终点要存储顶点信息，同样需要一个具有n个元素的一维数组.图7.1中的G2和图7.5中的$Picture[00000243\00000243_new\0006.jpg]Picture$GS所对应的边集数组分别如图7.9(a}和〔b）所示." ID="1">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="01234S6" ID="2">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="“点巨玛斗斗退润阵点11121214｛t｛3｝3(a)G2的边泉橄组" ID="3">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="图7,9G2和GS的边集数组" ID="4">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="边集数组中的元素类型和边集数组类型定义如下：atuctedge{11定义边集数组的元素类型血h+omvex;1/边的起点域intendvex;11边的终点域intweight;11边的权值域，对于无权圈可省去此域卜·230·数据结构inti,k,j,w;" ID="5">
          <fptr EndPN="00000244" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="coutdC“输入“aa“个顶点“《ettdl;" ID="6">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="fo(i司;in;icin»GV[i" ID="7">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="oout愉入条边“endl;" ID="8">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="for(k＝0;k《e;k什）{" ID="9">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="C1IGOlj7DW;/入一条边的起点、终点和权值" ID="10">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="GE[kI.fromvex=i;" ID="11">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="GE[kI.eodvexj;" ID="12">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="GE[kI.weightw;" ID="13">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="14">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="}在边集数组中查找一条边或一个顶点的度都需要扫描整个数组，所以其时间复杂度}。边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任一条" ID="15">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="具体应用时，要根据图的稠密和" ID="16">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="图的存储结构又称图的存储表示或图的表示。它有多种表示方法，这里主要介绍邻接矩阵、" ID="1">
        <fptr EndPN="00000237" StartPN="00000237"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000244" TITLE="7.3  图的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="244" PhysicalPageNum="244"/>
        <div ORDERLABEL="00000244" TITLE="7.3.1  深度优先搜索遍历" TYPE="Chapter">
        <fptr LogicalPageNum="244" PhysicalPageNum="244"/>
        <Paragraph CONTEXT="第7章图。231-$Picture[00000245\00000245_new\0004.jpg]Picture$vo作为初" ID="1">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Picture URL="00000245\00000245_new\0007.jpg">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Picture>
        <Paragraph CONTEXT="v。，并将visited［0】置为真，表明vo已”＿的一刁从妻辣精门特的故垃占t，＿被访问过，接着从vo的一个未被访问过的邻接点vl（vo的三个邻接点vl，vZ和v3都未被访问过，假定取vl访问）图7.1。无向图G7" ID="2">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="v，，并将visiled［l〕置为真，表明v：已被访问过，接着从v：的一个未被（v.的四个邻接点中只有vo被访问过，其余三个邻接点v4.朽.v6均未" ID="3">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="，月右愉、山借排斤担磨挣牛泊由偏乐." ID="4">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="访问过的邻接点v4（v.的匹被访问过，假定取、访问）" ID="5">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）访问顶点钱，并袋并将visited【4］置为真，表明v4已被访问过，接着从v4的一个未被访问过的邻接点vs〔v4的两个邻接点为v，和vs." ID="6">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）访问顶点、，并将" ID="7">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="所以按厦路退回到上一个顶点h，又因h的两个邻接点v：和v’点v：和v4都被访问过，都已被访问过，所以再按原路退回到上一个顶点v：，vl的四个邻接点中有三个已被访问此时只能从未被访问过的邻接点、出发进行深度优先搜索遍历：" ID="8">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）访问顶点v6，并将visited【6］置为真，表明、已被访问过，接过的邻接点v：（只此一个）出发进行深度优先搜索遍历：" ID="9">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="（6）访问顶点为，并将visitedIZ〕置为真，表明vZ已被访问过，接即vo和v。）都被访问过，所以按原路退回到上一个顶点、，同理·232。数据结构构，给出相应的深度优先搜索遮历的算法描述.voiddfsl(adjmatrixGA,inti,intn}11从初始点v;出发深度优先搜索由邻接矩阵GA表示的图{cout月i《;11假定访问顶点v;以输出该顶点的序号代之visited[i]＝。uo;标记v;已被访问过fo:tintjam;jat;j依次搜索V1的每个邻接点" ID="10">
          <fptr EndPN="00000246" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="itiGA[ij闭8t&amp;GA[ijMaxValue&amp;1visited[j＃访问过，则从vi出发进行递归调用奋voiddfs2(adjlistGL,inti,intn}11从初始点v。出发深度优先搜索由邻接表GL表示的图《cout《i《;11假定访问顶点v;以输出该顶点的序号代之visited[i]二。ue;11标记v;己被访问过edgenode*p=GL(i11取v‘邻接表的表头指针" ID="11">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="while(p1VLTLL){11依次搜索Vi的每个邻接点" ID="12">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="intj=p-＞adjvea;!Ij为v;的一个邻接点序号" ID="13">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="则从v出发进行递归调用F=P一＞neat;11使P指向v单链表的下一个边节点" ID="14">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="}}图7.10的无向图G7所对应的邻接矩阵和邻接表分别如图7.11{a}和（b)所示，" ID="15">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT=".i‘月Jsr,i气crxu.口ciie自.u二rxF-,i.sea.IcaJsdwe.望.e.毛.e.J目臼t±.与rreTx.rri.rr.i" ID="16">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="请结合它们分析上面的两个算法，" ID="17">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="是否分别为以下序列。序列l:1,0,2,b,3,4,5第7章圈·233$Picture[00000247\00000247_new\0002.jpg]Picture$O1?3456" ID="18">
          <fptr EndPN="00000247" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="「01110001o" ID="19">
          <fptr EndPN="00000247" StartPN="00000247"/>
        </Paragraph>
        <Paragraph CONTEXT="1IOOOI11111100000031otao1au1sLOI1000OJ6（.）邻搜住阵(b)翻位表图7.i1G7所对应的邻接矩阵和邻接表的，它与边的输入次序和链接次序有关，所以对于同一个图的不同邻接表，从某一顶点另外，对于同一个邻接矩阵或邻接表，如果指定的出发点不同，则将得到不同的遍历序列。从以上两个算法可以看出，对邻接矩阵表示的图进行深度优先搜索遍历时，需要扫名sryry6s.drt.-副,ceri+r，二，.r史业～1z、二tic1vaLtr.绝e目i-t.s.rsavii-,e.d.u描邻接矩阵中的每一个元素，所以其时间复杂度为0伽勺；对邻接表表示的图进行深度优" ID="20">
          <fptr EndPN="00000247" StartPN="00000247"/>
        </Paragraph>
        <Paragraph CONTEXT="先搜索追历时，需要扫描邻接表中的每个边节点，所以其时间复杂度为以‘）；两者的空" ID="21">
          <fptr EndPN="00000247" StartPN="00000247"/>
        </Paragraph>
        <Paragraph CONTEXT="需要扫描邻接表中的每个边节点，所以其时间复杂度为以‘）；两者的空" ID="22">
          <fptr EndPN="00000247" StartPN="00000247"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000247" TITLE="7.3.2  广度优先搜索遍历" TYPE="Chapter">
        <fptr LogicalPageNum="247" PhysicalPageNum="247"/>
        <Paragraph CONTEXT="广度优先搜索（b化adth.fimt，earch）遍历类似于对树的按层遍历，其过程为：首先访问初始点灼，并将其标记为已访问过，接着访问v‘的所有未被访问过的邻接点，其访问：可以任意，假定依次为vll…，v，，并均标记为已访问过，然后再按月〕次序，访问每一个顶点的所有未被访问过的邻接点（次序任意），并均标依次类推，直到图中所有和初始点竹有路径相通的顶点都被访问过为止。·234·数据结构(S)访问顶点V3的所有未被访问过的邻接点V7（只此一个邻接点且没有被访问过）.并将其标记为己访问过：" ID="1">
          <fptr EndPN="00000248" StartPN="00000247"/>
        </Paragraph>
        <Paragraph CONTEXT="（6）访问顶点Vq的所有未被访问过的邻接点，因Vq的邻接点V7（只此一个）已被访问过，所以此步不访问任何顶点；（7〕访问顶点Ys的所有未被访问的邻接点Vg，并将其标记为已访问过；（$访问顶点V6的所有未被访问的邻接点，因、的仅一个邻接点Vg己被访问过，所.、二｝知通老路万「拐月卜心翻户仁振百不而J匕" ID="2">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="(9)依次访问v和V：的所有未被访问的邻接点，因它们均没有邻接点，所以整个遍历过程到此结束.从以上对有向图G8进行广度优先搜索遍历的过程分析可知，从初始点v。出发，得到的访问各顶点的次序为：V0,Vt,V2,V3,Vq,VS,V6,V7,V8容广磨什牛栩尝偏不巾＿牛油情翩的丽占＿宜教上在广度优先搜索遍历中，先被访问的顶点，其邻接点亦先被访问，所以在算法的实现中需要使用一个队列，用来依次记住被访问过的顶点.算法开始时，将初始点V‘访问后插入队列中，以后每从队列中删除一个元素，就依次访问它的每一个未被访问过的邻接点，并令其入队，这样：当队列为空时，表明所有与初始点有路径相通的顶点都己访问完毕，算法到此结束。" ID="3">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="度优先搜索遍历的算法，同样在算法中使用的标记数组visited[MaxVtrtexNum]为全程量。voidbfsl(adjaiatrixGA,inti,inta)从初始点v‘出发广度优先搜索由邻接矩阵QA表示的图【" ID="4">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="QueueSqQ;11定义一个队列Q.其元素类型应为整型InitQueue(Q刀里队列为空cout礴ia;11访问初始点v;visited[itrue;标记初始点v。已访问过EnQueue(Q,i11将已访问过的初始点序号i入队witile(fEmpryQneue(Q{当队列非空时进行循环处理intict-0utQueue(QIIJ除队首元素，第一次执行时k的值为i" ID="5">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="fo以intjam:j切;j第7章图‘233" ID="6">
          <fptr EndPN="00000249" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="乡" ID="7">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT=")Ilfor" ID="8">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="lwhilc" ID="9">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="】刀“记voidbfs2(adjlistGL,inti,intn)从初始点vi出发广度优先搜索由邻接表GL表示的图《" ID="10">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="QueueSqQ;" ID="11">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="IaitQueue(Q" ID="12">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="‘。以喇" ID="13">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="visited[itrot;" ID="14">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="FnQucue(Q,iw皿.（必鲜叮伽即以Q））1intk城utQueue(Q11除队首元素“9.以址，少幻L阁；沪乃仅V‘邻接表的表头指针while(p！二MJLL){/1依次搜索、的每一个邻接点" ID="15">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="intj=p-＞adjvex;11v为v‘的一个邻接点" ID="16">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="iflvisited[j{Il若v没有被访问过则进行处理" ID="17">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="p＝p-next;使P指向v、邻接表的下一个边节点}内s'" ID="19">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="}ll外while" ID="20">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="}/lend请结合图7.11(a）和〔b)分析上面的两个算法，看从顶点v】出发得到的广度优先搜索遍历的顶点序列是否分别为以下序列.序列1:1,0,4,5,6,2,3" ID="21">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="序列2:1,6,5,4,0,2,3·236·数据结构与图的深度优先搜索遍历一样，对于图的广度优先搜索遍历，若采用邻接矩阵表其时(7套杂f为O(nZ若采用邻接表表示，其时间复杂度为O(e)，两者的空间复杂示.其时间复杂度为o（矛），若采用邻接表表示，其时间复杂度为以e），度均为0（n）。由图的某个顶点出发进行广度优先搜索遍历时，访问各顶点的次序，对于邻接矩阵来说是惟一的，对于邻接表来说，可能因邻接表的不同而不同，这一点也与图的深度优串土由司淤碍扁爪时的我多袱一怪" ID="22">
          <fptr EndPN="00000250" StartPN="00000249"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000250" TITLE="7.3.3  非连通图的遍历" TYPE="Chapter">
        <fptr LogicalPageNum="250" PhysicalPageNum="250"/>
        <Paragraph CONTEXT="上面讨论的图的深度优先搜索遍历算法和图的广度优先搜索遍历算法.对于无向图j色司口自图旦掀弓苗图加1的德之绪食门获1图山的甜右丫币占共干尚阅且非牛众4苗回加1口来说，若无向图是连通图，则能够访问到图中的所有顶点，若无向图是非连通图，则只熊相史右食闪列1为】拍占解太书全斗苗夺岳山的所右佰占‘宜釉书全；西夺甚山的丽占具不石1.能去六闪豹1能够访问到初始点所在连通分量中的所有顶点，由的1孙芬灵与.了币占.认爹习阵右自圆垂仍替LI加柏占豹1圆由的扭木顶占翻t右波扬而1的被精愉" ID="1">
          <fptr EndPN="00000250" StartPN="00000250"/>
        </Paragraph>
        <Paragraph CONTEXT="中的所有顶点；对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问点作为初始点，进行搜索遍历，直到图中的所有顶点都被访问过为止。为了能够访问到任何图中的所有顶点，方法很简单，只要以图中未被访衣良简单，只要以图中未被访问到的每一个顶" ID="2">
          <fptr EndPN="00000250" StartPN="00000250"/>
        </Paragraph>
        <Paragraph CONTEXT="即在某个函数中执行下面的for语句。点作为初始点，去调用上面的任何一个算法即可。if（lvisi喇［1」）" ID="3">
          <fptr EndPN="00000250" StartPN="00000250"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="图的遍历就是从指定的某个顶点（称此为初始点）出发，按照一定的搜索方法对图中" ID="1">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Picture URL="00000244\00000244_new\0002.jpg">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Picture>
      <Paragraph CONTEXT="的所有顶点各做一次访问的过程。图的遍历比树的遍历要复杂，因为从树根到达树中的每个节点只有一条路径，而从图的初始点到达图中的每个顶点可能存在着多条路径。当顺着图中的一条路径访问过某一顶点后，可能还会顺着另一条路径回到该顶点。为了避免重复" ID="2">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000250" TITLE="7.4  图的生成树和最小生成树" TYPE="Chapter">
      <fptr LogicalPageNum="250" PhysicalPageNum="250"/>
        <div ORDERLABEL="00000252" TITLE="7.4.1  普里姆算法" TYPE="Chapter">
        <fptr LogicalPageNum="252" PhysicalPageNum="252"/>
        <Paragraph CONTEXT="假设CrV,E)是一个具有n个顶点的连通网，TdU,TE）是G的最小生成树.其中U是T的项点集，TE是T的边集，U和TE的初值均为空集。算法开始时.首先从V中任取一个顶点〔假定取vo)，将它并入U中，此时U=fo卜然后只要U是V的真子集（即（即权值最小）边.假定为（(i,j}，其中劝任U，vj任（V－－U），并把该边（(i,j}和顶点j分别并入T的边集TE和顶点集U，如此进行下去，每次往生成树里并入一个顶点和一条边，直到n-1次后就把所有n个顶点都并入到生成树T的顶点集中.此时U=V,TE中含有n-1条边，T就是最后得到的最小生成树。酋田俪曾律的兰摊3bf.扭rf每次如何从生成树T中到T外的所有边中，找出一条最短边。例如，在第k次（(1蕊k簇n-1）前，生成树T中己有k个顶点和k-l条边，此时T中是很费时的。是否有一种好的方法能够降低查找最短边的时间复杂度呢？回答是肯定的.它能够使查找最短边的时间复杂度降低到O(n-k)。方法是：假定在进行第k次前已经保留着从T中到T外每一顶点（共，一k个顶点）的各一条最短边，进行第k次时，首第7章图·239一条边后，顶点集U、边集'I'E（每条边的后面为该边的权）以及从T中到T外每个顶点的各一条最短边所构成的集合" ID="1">
          <fptr EndPN="00000253" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="1m120的62m12" ID="2">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="153口U.715｝3｝°°106乡09.｝41mmZ了，0°O｝5" ID="3">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="‘Wmm1，二0J6图7.15图7.14Ca)的邻接矩阵第0次U0}TE}LW0,1)S,(d,2)00,(0.3)5,(0,4)co,(0,5}Oa,(0,6)，}第1次U0,3}TE二｛(0,3}5}LW3,1}3,{0,2)Oa,(d,4)co,{3,5)7,(3,6)15}第2次UD,3,1}Tlr0,3}5,(3,1)3}LW1,2)l2,(l,4)10,(3,5)7,(3,6)15}第3次U0,3,1,5}Tir0,3)5,{3,1)3,(3,5)7}LW二{(5,2)2,(5,4?9,(3,6)15}第4次U0,3,1,5,2}TED,3)5,(3,1)3,(3,5)7,(5,2)2}LW2,4}6,(3,6)15)'Fir{(0,3)5,(3,1)3,(3,S)7,(5,2)2,(2,4)6}U胃＝＝｛（3，6）151·240·数据结构·办$Picture[00000254\00000254_new\0004.jpg]Picture$lal(b){e)(d)(c}(" ID="4">
          <fptr EndPN="00000254" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="〔9&gt;(h)图7.16利用普里姆算法求图的最小生成树的示意图图7.16(h）就是最后得到的最小生成树，它同7.14(d)是完全一样的，所以图$Picture[00000254\00000254_new\0012.jpg]Picture$$Picture[00000254\00000254_new\0013.jpg]Picture$$Picture[00000254\00000254_new\0014.jpg]Picture$7.14(d）是图7.14(a）的最小生成树.通过以上分析可知，在构造最小生成树的过程中，在进行第k次“6k簇n-1)前，边集TE中的边数为k-1条，从T中到T外每一顶点的最短边集LW中的边数为n-k$Picture[00000254\00000254_new\0018.jpg]Picture$$Picture[00000254\00000254_new\0019.jpg]Picture$条，TE和LW中的边数总和为n-1条。为了保存这n-1条边，的边集数组类型（即edgeset类型）的对象CT来存储，其中CT的前k-1个元素（即CT[01-CT[k-21）保存·1'l;中的边，后n-k个元素（即CT[k-11一n-21）保存LW中的边。在进行第k次时，首先从下标为k-1到n-2的元索（即LW中的边）中查找出权假定为CT[rn]；接着把边CT[k-1】与CT[m］对调，确保在第k次后CT的前k个元素保存着TE中的边，后n-k-1个元素保存着LW中的边；然后再修改LW中的有关边，使得从T中到T外每一顶点的各一条最短边被保存下来。这样经过。一1次运算后，CT中就按序保存着最小生成树中的全部n-1条边.根据分析，编写出利用普里姆算法产生图的最小生成树的具体算法如下：voidPrim(adjmatrixGA,ed$esetCintn)11利用普里姆算法从顶点o出发求出用邻接矩阵GA表示的图的第7章图·241/1最小生成树.最小生成树的边集存于数组CT中【" ID="5">
          <fptr EndPN="00000255" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k,min,f,m,w;11给CI，赋初值，对应第0次的LW值for(i=0；应＜”一1;i+十）" ID="6">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="CT[iI.fromvex刃;CT[iI.endvex=i+1;CT[iI.weight＝＝iA[Di+11;｝11进行n-1循环，侮次求出最小生成树中的第k条边fot(k二1;1c＜n;k＋十）" ID="7">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="！11从CT[k-11CT[n-21（即LW）中查找最短边CT[m]min=MaxValue;" ID="8">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="m=k一！；for(j=k-1;jar-1;j" ID="9">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="if(CT[jI.weight《min}{" ID="10">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="}川已最短边对调到第k-1下标位里edgetemp〔T[k-t1;CT[k-11沈T[m" ID="11">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="CT[mtemp;1/把新并入最小生成树T中的顶点序号赋给jj丈T[k-1I.endvex;/1修改LW中的有关边.使T中到T外的每一个顶点各保持一条到目前为止最短的边faro=k;i[n-1;i{" ID="12">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="件CT［1】.endvex；" ID="13">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="w目iA[jt" ID="14">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="if{w[CIiI.weigtrt)·Zz数据结构" ID="15">
          <fptr EndPN="00000256" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="Fu内for" ID="16">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="}ug卜for" ID="17">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="｝若利用图7.15所示的邻接矩阵调用此算法，则得到的边集数组CT中的内容为：《1" ID="18">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Picture URL="00000256\00000256_new\0008.jpg">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Picture>
        <Paragraph CONTEXT="fromvex" ID="19">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="已耐V已又" ID="20">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="weigfi它" ID="21">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000256" TITLE="7.4.2  克鲁斯卡尔算法" TYPE="Chapter">
        <fptr LogicalPageNum="256" PhysicalPageNum="256"/>
        <Paragraph CONTEXT="假设CrV,E)是一个具有n个顶点的连通网.TU,TE）是G的最小生成树，U的初值等于V，即包含有G中的全部顶点.TE的初值为空。此算法的基本思想是；将图G中的边按权值从小到大的顺序依次选取，若选取的边使生成树T不形成回路.则把它并入TE中，保留作为T的一条边，" ID="1">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="下去，直到TE中包含有n-1条边为止，州" ID="2">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="现以图7.i7(a）为例来说明此算法。" ID="3">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="现以图用排序算法，使之成为有序。】算法要求按权值从小到大次序选取各边，就转换成按边集数组中下标次序选取各边。当选取前三条边时，均不产生回路，应保留作为生成树T的边，如图7.17(h）所示：选第四条边（(2,3}时.将与已保留的边形成回路，应舍去；接着保留（(i,5)边.舍去（(3,5)边：取到（0,1)边并保留后，保留的边数已够5条（即$Picture[00000256\00000256_new\0016.jpg]Picture$已保留的边形成回路.这可将各顶点划分为不同集合的方法来解决，" ID="4">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="表示一个无回路的连通分量。算法开始时，由于生成树的顶点集等于一集为空.所以in个顶点分属于”个集合，每个集合中只有一个顶点，第7章图·243$Picture[00000257\00000257_new\0002.jpg]Picture$$Picture[00000257\00000257_new\0005.jpg]Picture$仍不会产生回路，会产生回路，此边应保留作为生成树的一条边.同时把端点所在的两个集合合并成$Picture[00000257\00000257_new\0010.jpg]Picture$，，即成为一个连通分量；当选取的一条边的两个端点同属于一个集合时，此边应放" ID="5">
          <fptr EndPN="00000257" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="因同一个集合中的顶点是连通无回路的，若再加入一条边则必产生回路。在上述例" ID="6">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="，当选取（(0,4(1,2(1,3)这三条边后，顶点的集合则变成如下三个：" ID="7">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="一个，弃，子中，（0，4卜｛1，2.31，【5｝下一条边（(2,3)的两端点同属于一个集合。故舍去，再下一条边（(1,5)的两端点属于不同的集合，应保留，同时把两个集合{1,2,3}和《5}合并成一个《1,2,3,5}，依次类推.直到所有顶点同属于一个集合，即进行了。一l次集合的合并，保留了。一1条生成树的边为止.为了用C语言编写出利用克鲁斯卡尔算法求图的最小生成树的具体实现，设GE" ID="8">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="是具有" ID="9">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="具有edgeset类型的边集数组，并假定每条边是按照权值从小到大的顺序存放的；再设：另外，在算法内部还要定义一个具有adjmatri：类型的一个二维数组.假定用s表" ID="10">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="，用它的每一行来存储每个连通子图所在的项点集合，若该行中的元素s[ij1，则表C" ID="11">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="边：尔，。244。数据结构lls[i41-s[iJ[n-11用来表示一个集合，若：[ilG］二1/1则表示vi顶点属于：G]集合，否则不属于：[i]集合for(i幻;inn;i[11初始化s集合，使每一个项点分属于不同的集合fos{j司;j＜n;j" ID="12">
          <fptr EndPN="00000258" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="ifii二，1)s[ilfjl'1;" ID="13">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="elses[ijl习;}11循环执行结束后，使得v‘顶点属于s[i】集合中intk=1;11k表示待获取的最小生！树中的边数，初值为1intdam;d表示GE中待扫描边元素的下标位置，初值为0intml,m2;1/ml和m2用来分别记录一条边的两个顶点所在集合的序号while(kn){11进行n-1次循环，得到最小生成树中的n-1条边fot{i动;icn;i{11求边GE[d]的两个顶点所在集合的序号ml和m2if(s[i][GE[dI.framvex1)m1=i;if(s[i][GE[dI.enclvex】二1)m2=i;）" ID="14">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="if{ml！二兀口}{11若两集合序号不等，则表明GE[d]是生成树中的一条边。刀应将它加入到数组C中C[k-1】二GE[d" ID="15">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="k十＋；11合并两个集合，并将另一个置为空集加为司；J＜n；j＋＋）！" ID="16">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="s[mll(js[mllLllI!s[m21[i3;" ID="17">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="5【n立IUI司；" ID="18">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="19">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="资d/Id后移一个位t，以便扫描GE中的下一条边1" ID="20">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例如，若利用图7.17&lt;d)所示的边集数组调用此算法.则最后得到的C数组为：第7章图·gasc" ID="21">
          <fptr EndPN="00000259" StartPN="00000258"/>
        </Paragraph>
        <Picture URL="00000259\00000259_new\0003.jpg">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Picture>
        <Paragraph CONTEXT="fromvex" ID="22">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="eadvex" ID="23">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="weight克鲁斯卡尔算法和普里姆算法都含有双重循环，其时间复杂度均为以月b，克鲁斯卡因为在内部使用了一个表示集合的二维数组，普里姆算法的空间复杂度为0（1，因为在内部只使用了一些简单变量。" ID="24">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="第7章圈·237只有一个顶点，假定具有一个顶点的图是连通的，以后每向G‘中加入一个顶点，鸽同一个图可以有不同的生成树。例如对于图7.13(a)，图7.13{b{c)和（d)" ID="1">
        <fptr EndPN="00000251" StartPN="00000251"/>
      </Paragraph>
      <Paragraph CONTEXT="都要加" ID="2">
        <fptr EndPN="00000251" StartPN="00000251"/>
      </Paragraph>
      <Picture URL="00000251\00000251_new\0013.jpg">
        <fptr EndPN="00000251" StartPN="00000251"/>
      </Picture>
      <Paragraph CONTEXT="这样" ID="3">
        <fptr EndPN="00000251" StartPN="00000251"/>
      </Paragraph>
      <Paragraph CONTEXT="这是因为此边的$Picture[00000251\00000251_new\0017.jpg]Picture$因此就形成了一条回路，就使得G‘变为非连必定使这两个端点（d）都是" ID="4">
        <fptr EndPN="00000251" StartPN="00000251"/>
      </Paragraph>
      <Paragraph CONTEXT="甫到盈荃11的址毛分今毛之绍磨才宁月卜庄吩姗." ID="5">
        <fptr EndPN="00000251" StartPN="00000251"/>
      </Paragraph>
      <Paragraph CONTEXT="被称之为广度优先生成树：·238二数据结构求图的最小生成树很有实际意义。例如，若一个连通网表示城市之间的通信系统，一顶点代表城市.网的边代表城市之间架设通信线路的造价，各城市之间的距离不网的顶点代表城市.同，地理条件不同，其造价也不同，即边上的权不同，" ID="6">
        <fptr EndPN="00000252" StartPN="00000251"/>
      </Paragraph>
      <Paragraph CONTEXT="求图的最小生成树的算法主要有两个：尔〔I{ruslcal）算法.下面分别进行讨论.一是普里姆（Prim）算法。另一是克鲁斯卡" ID="7">
        <fptr EndPN="00000252" StartPN="00000252"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000259" TITLE="7.5  拓扑排序" TYPE="Chapter">
      <fptr LogicalPageNum="259" PhysicalPageNum="259"/>
      <Paragraph CONTEXT="一个较大的工程往往被I分成许多子工程，我们把这些子工程称做活动（3CtiVlt])o子工程的结束为先决条件的，但有些子工程没" ID="1">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="为了形象地反映出整个工程中各个子工程（活表示，图中的顶点代表活动（子工程），图中的有先决条件，可以安排在任何时间开始。为了）动）之间的先后关系，有向边代表活动的先后关系，即有向边的起点活动是终点活动的前序活动，只有当起点活动完成之后，其终点活动才能进行。通常，我们把这种顶点表示活动、边表示活动间(ActivityOnVertexnetwork)，简称AOV网。裸粗代号课程名称先住裸程c离势傲学无cz序设计鉴抽无C3离，吸学ci,cz" ID="2">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="C，算法语育C2" ID="3">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="C6.译技术C4,C3" ID="4">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="C7熟作系统C4,C9" ID="5">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="CS势通物理C1" ID="6">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="Cg计算机.理朋·za6·数据结构$Picture[00000260\00000260_new\0002.jpg]Picture$程.没有先修课程。若用Aov图中的每个顶点代表一门课程.课程。从图中可以清楚地看出各。从图中可以清楚地看出各课程之间的先修和后续的关系.后续课程为c4和C6:C6的先修课程为C4和CS，它无后一个AOV网应该是一个有向无环图，即不应该带有回路，c2,上的所有活动都无法进行.如图7.2U是一个具有三个顶点的回路，由（A,B》边可得B必然在A活动之后，但由（C,A》边可得C活动必须在A活动之前，从而出现矛盾，使每一项活动都无法进行.这种情况若在程序中出现，则称为死锁或死循环，是应该必须避免的。图7.19ADV网图.2o三个顶点的回路在AoV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面.c们把此序列叫做拓扑序列（Topologicalorder)，由AOV网构造拓扑序列的过程叫做拓扑排序（Topologicalsori)oAOV网的拓扑序列不是惟一的，满足上述定义的任一线性序列都称做它的拓扑序列。例如，下面的三个序列都是Aov网构造拓扑序列的过程叫做拓扑排序（肠因10颐caisort〕。一的，满足上述定义的任一线性序列都称做它的拓扑序列。仑图7，19的拓扑序列，当然还可以写出许多。" ID="7">
        <fptr EndPN="00000260" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）CI，CS，Cg、CZ，C3，CS，C4，C7，C6" ID="8">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）CZ，CI，C3，CS，C4，C6，CS，Cg，C7" ID="9">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）CI，（卫，C3，CS，Cg，CS，C4，C6，C7第7章图·247下面以图7.21(a)为例，来说明拓扑排序算法的执行过程。" ID="10">
        <fptr EndPN="00000261" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="哎.）" ID="11">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="（‘》$Picture[00000261\00000261_new\0006.jpg]Picture$$Picture[00000261\00000261_new\0007.jpg]Picture$$Picture[00000261\00000261_new\0009.jpg]Picture$（”在图7.21(a）中vfl和v；的入度都为0，不妨选择vo并输出之，接着删去顶点vo及出边＜0,2)，得到的结果如图7.21{b)所示." ID="12">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）在图7.21(b〕中只有一个入度为0的顶点v，输出vi，接着删去v，和它的三条出边（(1,2(1,3)和（(l,4)，得到的结果如图7.21(c）所示。" ID="13">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)在图7.21(c)中vz和、的入度都为0，不妨选择vz并输出之，接着删去vz及两条出边（2,3）和（2,5得到的结果如图7.21(d)所示。" ID="14">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）在图7.21(d）上依次输出顶点V3+Vq和、，并应的邻接表如图7.22所示.在拓扑排序算法中，需要设置一个包含n个元素的图7.22图7.2iCa，对应的邻接表一维整型数组，假定用d表示，用它来保存AOV主三木7iTt占6h人商力占fan：弟洛门阵f?1，，tr、9i1@Ir如." ID="15">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="如对于图7.21〔a），得到数组d的初始值为：012345｝。10.…｝.…毛习二＿.1一＿＿匕一｛用，保存下一个入度为0的顶点的序号，这样就可以把所有入度为·248·数据结构点所对应的数组d中的元素，该元素的值则指向第二个入度为0的顶点所对应的数组d中的元'.4#x椎.最后一个入i为OT所对应1CSCAd中的元素4存着一1.表示" ID="16">
        <fptr EndPN="00000262" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="依次类推，为栈底。例如，根据图7.22所示的邻接表，建立的入度为0的初始栈的过程为：)开始置链栈为空，即给链栈指针top赋初值为一istop＝一七" ID="17">
        <fptr EndPN="00000262" StartPN="00000262"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)将入度为0的元素d[01进栈，即：d[01=top;top刃;此时top指向d[U]元素，表示顶点vo的入度为。，而d[01的值为一1，表明为栈底。rzl虫互a磨芍nYtr-m寻感ArllktQn.d[I］二top;top=此时tap指向d[11元素.表示顶点v；的入度为0，而d[11的值为0，表明下一个入度为0的元素为d[01，即对应下一个入度为0的顶点为va,d[U]的值为一1，所以此栈当前有即对应的v：到v，的入度均不为0，所以它们均不得到的数组d为：" ID="18">
        <fptr EndPN="00000262" StartPN="00000262"/>
      </Paragraph>
      <Paragraph CONTEXT="012343" ID="19">
        <fptr EndPN="00000262" StartPN="00000262"/>
      </Paragraph>
      <Paragraph CONTEXT="｝二」七寺业坦止日" ID="20">
        <fptr EndPN="00000262" StartPN="00000262"/>
      </Paragraph>
      <Paragraph CONTEXT="将入度为0的顶点利用上述链栈链接起来后，拓扑算法中循环执行的第（13步“选洲卜a月参2I,n配e7X'3谧rU-”石1奋翻,rui仑7Fi,ts,鑫-SGA比tiH了币占叮立龙共.习zim_择一个入度为0的顶点并输出之边”，可通过首先作退栈处理，该循环的终止条件“直到不存在入度为0的顶点为止”，可通过判断栈空来实现。第，章图·249ofz3asofz3as呼驴兰上」户团止今豁二一巡创fsl日脸顶点Vi及所有出边‘h1一睦7flssVAfl'r右Hil0{2345412345匕止气尸川口一生呼业止德(c）侧除顶点V及所有出边（(d）侧除顶点V,及所有ff！边图7.23数组d变化示意图当删除顶点v，及所有出边后。top的值为一]，表示栈空，至此算法执行结束.得到的拓扑序列为：1,4,4,2,3,5根据以上分析，给出拓扑排序算法的具体描述为：voidToposart(adjlistGL,intn)I1对用邻接表GL表示的有向图进行拓扑排序硬inti,j,ktop,m;习;m用来统计拓扑序列中的顶点数edgenoderp;11定义存储图中每个顶点入度的一维整型数组dint*d=newint{n" ID="21">
        <fptr EndPN="00000263" StartPN="00000262"/>
      </Paragraph>
      <Paragraph CONTEXT="初始化数组d中的每个元素值为0" ID="22">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i动;irn;id[i]m;" ID="23">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="刀利用数组d中的对应元素统计出每个顶点的入度" ID="24">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="肠代1司；1＜n；杆＋）仁" ID="25">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="p石L[i" ID="26">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="喃jle（p卜Nl几工）（" ID="27">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="j留padjvex;d[jp=pnext;" ID="28">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="29">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="）11初始化用于链接入度为。的元素的栈的栈顶指针top为一1。250·数据结构11每循环一次I除一个顶点及所有出边while(top=一l)" ID="30">
        <fptr EndPN="00000264" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="4i=ce;Ir的值为一个入度为0的顶点序号t叩习压甲』；调口除栈项元素coutoj《'11输出一个顶点m11输出的顶点个数加1pGL[jl:11p指向vi邻接点表的第一个节点while(pNiJLL}" ID="31">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="{k=padjvex;Ilvk是v的一个邻接点d[k]一；IW‘的入度减lif(d[k]二二0)(11把入度为0的元紊进栈" ID="32">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="d[ktop;topk;" ID="33">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="}p二P-xt;!Ip指向vg邻接点表的下一个节点乡" ID="34">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="35">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="couto:endl;f(mrn)11当输出的顶点数小于图中的顶点数时，输出有回路信息cout&quot;Thenetwork1iesacycle!°®:endl;deletedt删除动态分配的数组d｝拓扑排序实际上是对邻接表表示的图G进行遍历的过程，每次访问一个入度为0的。若图G中没有回路，此算法需要两次扫描邻接表中的所有边节点.两次扫描数组顶点。若图G中没有回路，此算法需要两次扫描邻接表中的所有边节点.两次扫描数组" ID="36">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="d中的所有元素." ID="37">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="巴；" ID="38">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000264" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="264" PhysicalPageNum="264"/>
      <Paragraph CONTEXT="1.图结构中的每个节.点可以有任意多个前驱和任意多个后继.对于无向图，每个顶点的郁接点既是它的前驱节点，又是它的后继节点二对于有向图，每个顶.点的入边邻接第，章图·251均等于它的都接点数；有向图中每个顶.点的度、入度和出度分别等于它的郁接点数、入边数和出边数." ID="1">
        <fptr EndPN="00000265" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="2.图的存储包括存储图的顶点信息和边的信息〔即顶点之间的关系）两个方面，为了运算方面，通常把它们分开存储.对于图的顶点信息适合采用能够直接存取的数组存储，对于图的边信.息：主要有都接拒阵、郁接表和边集数组三种存储表示，通常就把它们称为图的存储结构。" ID="2">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对于一个具有n个顶点和e条边的图，它的部接矩阵是一个nx月阶方阵，无向图中的每条边对应矩阵中的两个对称元素，有向图中的每条边对应拒阵中的一个元素。困的邻接拒阵中主对角线上的元素为d.无向图的郁接矩阵是对称矩阵." ID="3">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="4.图的郁接表是对图中每个顶点建立边节点单链表并把它们的表头指针用一维数组存储起来的一种存储结构.图的边集数组是把图中的每条边作为元素存储到一维数组中的一种存储结构。" ID="4">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="5.对田的遮历包括深度优先搜索和广度优先搜索这两种不同的访问顶.点次序.对于用邻接矩阵表示的图，从某一顶点出发按某种搜索方法得到的顶点序列是堆一的，对于用郁接表表示的图，从某一顶点出发按某种搜索方法得到的顶点序列随建立的邵接表的不同而可能不同。" ID="5">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="6.一个连通图的生成树含有该图的全部”个顶点和其中的n-1条边，其中权值最小1T,3T,L里t.zsTL.LJ心W,1L:匕＿1_.v」‘曰刁卜asa.，户.，uar,1s‘健n的生成树成为最小生成树.求图的最小生成树具有两种不同的算法《方法〕，姆算法，另一种是克香斯卡尔算法.所采用的算法不同，得到的最小生成树中边的次序也可能不同，" ID="6">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="7.AOV网是一个有向无环图，若把图中所有顶.点排成一个线性序列，使得每个顶点的前驱都被排在它的前面，或者说每个顶点的后继都被排在它的后面.则称此序列为图的一种拓扑序列.在求图的拓扑序列的算法中，雷要使用一个数组保存所有顶点的入度，它同时兼做保存顶点入度为0找的使用." ID="7">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="暑习题" ID="8">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="77.1单选姐" ID="9">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="1.设无向图的顶点个数为二，则该图最多有〔）条边。" ID="10">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="A.月一1n{n-lZC.月伽＋1）I2D.凡伽一1）" ID="11">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="2.n个顶点的连通图至少有（）条边。" ID="12">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="A.n-1B.nC.n+ld.0·252·数据结构" ID="13">
        <fptr EndPN="00000266" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="A.38.2C.1D.1/2" ID="14">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="4.若采用邻接矩阵存储具有s个顶点的一个无向图，则该邻接矩阵是一个（）。" ID="15">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.上三角矩阵B.稀疏矩阵C.对角矩阵D.对称矩阵" ID="16">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="5.设有向圈有，个顶点和e条边，采用邻接表作为其存储结构，在进行拓扑排序时，其时间复杂度为（）." ID="17">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(nlogZe)B.O(ne)C.IXnD.O(n)" ID="18">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="6.有向图的一个顶点的度为该顶点的（）." ID="19">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.入度B.出度" ID="20">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="C.入度与出度之和D.（入度＋出度}" ID="21">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="7.一个连通图的生成树是包含图中所有顶点的一个（）子图。" ID="22">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.极小B.连通C.极小连通D.无环" ID="23">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="S.n(n&gt;1)个顶点的强连通图中至少含有（）条有向边." ID="24">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.n-1B.nC.n(n-12D.nIn-1}" ID="25">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="9.在一个带权连通图G中.权值最小的边一定包含在G的〔）生成树中。" ID="26">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.最小B.任何C.广度优先D.深度优先" ID="27">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="10.对于具有e条边的无向图.它的邻接表中有（）个边节点。" ID="28">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.e-1B.aC.2(e-1}D.2e" ID="29">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="11.具有n个顶点的有向无环图最多可包含〔）条有向边。" ID="30">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.n-1B.nC.n(n-1)12Da(n-1)" ID="31">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="12.一个有二个顶点和n条边的无向图一定是（）." ID="32">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.连通的B.不连通的c.无环的D.有环的" ID="33">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="13.在n个顶点的有向无环图的邻接矩阵中至少有（）个零元素。" ID="34">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.nB.nin-1)nc.月（ntl)12D.n(n-U" ID="35">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="14，为了实现图的广度优先遍历.其广度优先搜索算法使用的一个辅助数据结构为（）." ID="36">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.栈B.队列c.二叉树D.树巧.为了实现图的深度优先遍历，其非递归的深度优先搜索算法使用的一个辅助数据结构为（）。" ID="37">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="A.栈B.队列C.二叉树D.树，J坟空月" ID="38">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="1.在一个图中，所有项点的度数之和等于所有边数的＿倍。" ID="39">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="2.在一个具有n个顶点的无向完全图中.包含有条边，在一个具有：个顶点的有向完全图中，包含有＿条边.，勺舟J二＿碑入目1乡洲、了币.句65）」第7章图·253" ID="40">
        <fptr EndPN="00000267" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="4.对于一个具有n个顶点和e条边的有向图和无向图，在其对应的邻接表中，所含边节点分别为和条。" ID="41">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在有向图的邻接表和逆邻接表表示中，每个顶点邻接表分别链接着该顶点的所有＿和节点。石.对于一个具有。个项点和。条边的有向图和无向图.若采用边集数组表示.则存于数组中的边数分别为―和―条。" ID="42">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="7.对于一个具有。个顶点和e条边的无向图，当分别采用邻接矩阵、邻接表和边集数组表示时.求任一顶点度数的时间复杂度依次为二、.1＿.和只翻中一木因目＿右.木场占翻.组抽耐垂田故翻趁级杯防故玉仁j" ID="43">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="8.假定一个图具有n个顶点和。条边，则采用邻接矩阵、邻接表和边集数组表示时.其相应的空间复杂度分别为、和43t田教址拓阵书录的冈徘杆挥一仙彼东时" ID="44">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="9.对用邻接矩阵表示的图进行任一种遍历时.其时间复杂度为＿，对用邻接表表示的图进行任一种遍历时，其时间复杂度为＿." ID="45">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="10.对于一个具有n个顶点和e条边的连通图，其生成树中的顶点数和边数分别为＿和一口" ID="46">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="11·对于图，‘5（a）所示的无向带权图，其最小生成树的权为＿." ID="47">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="12.假定用一维数组dl川存储一个人Ov网中用于拓扑排序的顶点入度，则值为。的元素被链接成" ID="48">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="为一个―。”运算月" ID="49">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="1.对于图7.24（a）和（b），求出：" ID="50">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）侮一个图的二元组表示，对于带权图，可将边的权写在该边的后面：" ID="51">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）在〔a）中每个顶点的度，以及每个顶点的所有邻接点和所有边：" ID="52">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）在〔b）中每个顶点的入度、出度和度，以及每个顶点的所有入边的出边：" ID="53">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）在（a）中从v。到v’的所有简单路径及相应路径长度；" ID="54">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）在（b）中从v。到v’的所有简单路径及相应带权路径长度。" ID="55">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）每个图的邻接矩阵：区" ID="56">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）侮个图的邻接表；" ID="57">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）图7.24（b）图的逆邻接表和十字邻接表：" ID="58">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）每个图的边集数组。" ID="59">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对于图，.25（a）和（b），按下列条件试分别写（a）“（b、" ID="60">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="竺竺埋资介兰塑竺匹毛罗些腮刽的贴序列和图7.247.3题中，题的图示。254。数据结构C2）假定它们均采用邻接表表示。并且假定每个顶点邻接表中的节点是按顶点序号从大到小的次序链接的。" ID="61">
        <fptr EndPN="00000268" StartPN="00000267"/>
      </Paragraph>
      <Picture URL="00000268\00000268_new\0005.jpg">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Picture>
      <Picture URL="00000268\00000268_new\0006.jpg">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Picture>
      <Paragraph CONTEXT="4.对于图7.26:" ID="62">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)画出最小生成树并求出它的权：" ID="63">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)从顶点0出发，按照普里姆算法求出最小生成树时所得到的各边的次序写出各条边：(37按照克鲁斯卡尔算法求出最小生成树时所得到的各边的次序写出各条边." ID="64">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="5.对于图7.27.试给出一种拓扑序列，若在它的邻接表存储结构中.每个顶点邻接表中的边节点都是按照终点序号从大到小链接的，则按此给出惟一一种拓扑序列。图7.267.3中4的图示图7.277.3题中5题的图示7A算法设计且：根据有向图的邻接矩阵GA求出序号为numb的顶点的度数，" ID="65">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="2.根据无向图的邻接表GL求出序号为numb的项点的度数。" ID="66">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="3.求出一个用邻接矩阵GA表示的图中所有顶点的最大出度值" ID="67">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="4.对7.3节中的dfsl算法做适当的修改.得到输出图的深度优先生成树中各条边的算法." ID="68">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="5.假定图采用邻接矩阵表示.编写出进行深度优先遍历的非递归算法。$Picture[00000269\00000269_new\0001.jpg]Picture$$Picture[00000269\00000269_new\0002.jpg]Picture$第LJ章" ID="69">
        <fptr EndPN="00000269" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="―一一一―――一一一一一一一一刁" ID="70">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000265" TITLE="习题7" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000269" TITLE="第8章  查找" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000269" TITLE="8.1  查找的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="269" PhysicalPageNum="269"/>
      <Paragraph CONTEXT="查找（(Search)义称检索.它问人们的日常T作和生iii有#密切的联系如从字典Pr资览';。从1'i中i't找L.从f11ii'石马it'1'r1找电话.从I11S7P1'杏找渊13。从地图上'r找;iy.Hi也J止'nj以iS.人们E人司；x小）rr；找t'rJkTlt分为人I匆1i147机两种，对于少t信息.人工查找是可行的，但对于大量信息来说，人工查找是困难的.有时甚至是无法办到的，在现代社会只有依靠计算机才能不受时间和地域的限制，实现快速、及时和准确地查找。·25石·数据结构数据处理过程的一个环节，它的下一个环节是如何对查找结果进行处理，这可根据实际当查找失败时，应输用于在表上查找记录的条件，情况比较复杂，它由具体应用而定，但其中最具有代表性的条件是：在关键字段（项）上查找关键字等于给定值K所在的记录。由于表中每个识录的关锹字都不同（在特狭应用中也可能出现相同的哭撼字），所以过种妾梓只可能个记录的关键字都不同（法，当然读者也不难根据实际需要给出使用其他条件的查找算法。" ID="1">
        <fptr EndPN="00000270" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="月七七态始节汁色的习岛的鑫全的】屯翩钊.本士仑，六护讼么一撅拓又反阁相找过程都是用给定值x同关键项上的关键字按照一定的次序进行比较的过程，比较次数同关键项上的关键字按照一定的次序进行比较的过程，比较次数才间复杂度，它是衡量一个查找算法优劣的重要指标。内时间复杂度.既可以采用数量级的形式表示，也可以采用平均对于一个查找算法的时间复杂度.查找长度（Asp一彻.ges。犷cb" ID="2">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="As肠艺几q" ID="3">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="式中，n为查找表的长度，即表中所含元素的个数.几为查找第1个元素的概率，若不特别指明，均认为查找每个元素的概率相同.即PI＝Ppo…＝Pn＝土，cl是查找第1个元素式可简化为：" ID="4">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000270" TITLE="8.2  顺序表查找" TYPE="Chapter">
      <fptr LogicalPageNum="270" PhysicalPageNum="270"/>
        <div ORDERLABEL="00000271" TITLE="8.2.1  顺序查找" TYPE="Chapter">
        <fptr LogicalPageNum="271" PhysicalPageNum="271"/>
        <Paragraph CONTEXT="顺序查找（SequentialSearch）是一种最简单和最基本的查找方法。它从顺序表的一端开始，依次将每个元素的关键字同给定值K进行比较，若某个元素的关键字等于给定到关键字为K的元素，则表明查找失败，返回特定的值（常用一1表示）。返回特定的值（常用一1表示）。ints沟韶h（ElemT月姆A［」.int氏KeyTyl军K）！" ID="1">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="11从表头元素A［01开始顺序向后查找，查找成功则退出循环。自式1掀1闭：kn；1＋＋）试A【t］.key～K）break；" ID="2">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="11查找成功则返回该元素的下标1，否则返回一1。" ID="3">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="讯1＜n）优奴往ni；else比加rll-1；1：组A中第n个位置的关键字域，这样每循环一次只需要进行元素比较，不需要比较‘曰不幼田出汤址劝1竺一持衫叶击不Ar.1‘.”一犷比吉＿出匕白坡祖由奋活公；＿两排" ID="4">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="给数组A中第" ID="5">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="下标是否越界，" ID="6">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="后的算法如下：" ID="7">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="位里时，由于A［司，key＝K成立，将自然退出循环.改进" ID="8">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="int义q盼1旧en门）伴A［1.intn，Ke扣勺声幻" ID="9">
          <fptr EndPN="00000271" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="（·ass·数据结构由于改进后的算法省略了对下标越界的检查.所以必定能够提高算法的执行速度。顺序查找的缺点是速度较慢，查找成功最多需比较n次，平均查找长度为（n+1)12" ID="10">
          <fptr EndPN="00000272" StartPN="00000271"/>
        </Paragraph>
        <Paragraph CONTEXT="约为表长度的一半，查找失败也需比较：+1次，所以顺序查找的时间复杂度为次.oc炸）。顺序查找的优点是既适用于顺序表，也适用于单链表，同时对表中元素的排列次序" ID="11">
          <fptr EndPN="00000272" StartPN="00000272"/>
        </Paragraph>
        <Paragraph CONTEXT="求，这将给插入新元素带来方便，因为不需要为新元素寻找插入位置和移动原有元无要求，" ID="12">
          <fptr EndPN="00000272" StartPN="00000272"/>
        </Paragraph>
        <Paragraph CONTEXT="素，只要把它加入到表尾（对于顺序表）或表头（对于单链表）即可。" ID="13">
          <fptr EndPN="00000272" StartPN="00000272"/>
        </Paragraph>
        <Paragraph CONTEXT="为了尺量根高腼序杳找的谏庶.一种可考虑的方法是，存已知各" ID="14">
          <fptr EndPN="00000272" StartPN="00000272"/>
        </Paragraph>
        <Paragraph CONTEXT="提高顺序查找的速度，一种可考虑的方法是，在己知各元素查找概率不等将各元素按查找概率从大到小排列，从而降低查找的平均比较次数（即平另一种可考虑的方法是，在事先未知各元素查找概率的情况下，在每次查时，将它与前驱元素对调位置，这样，查找频度高（即概率大）的元素就最后形成元素的前后位置按查找概率从大到小排列，从而达到减小平均查均查找长度）：另－找长度的目的。" ID="15">
          <fptr EndPN="00000272" StartPN="00000272"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000272" TITLE="8.2.2  二分查找" TYPE="Chapter">
        <fptr LogicalPageNum="272" PhysicalPageNum="272"/>
        <Paragraph CONTEXT="二分查找（BinarySearch)又称折半查找。作为二分查找对象的表必须是顺序存储的第8章查找.259" ID="1">
          <fptr EndPN="00000273" StartPN="00000272"/>
        </Paragraph>
        <Paragraph CONTEXT="夕在右子表上继续查找" ID="2">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="咨" ID="3">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn-i;I/查找失败返回一1" ID="4">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="}二分查找的递归算法也属于末尾递归的调用，很容易把它改成非递归算法.其算法描述为：int13insch(ELemTypeAintn,Key'IrpeK}llA[Oj一［[n-11区间内二分查找关键字为K的元素‘int1ow二fl,high=n-1;11给表示待查区间上界和下界的变量斌初值while{low《=high}" ID="5">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="星" ID="6">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="intmid1ow+high}12;" ID="7">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="刀求出待查区间内中点元素的下标if(K=＝人[midl.key)returnmid;" ID="8">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="11查找成功返回元素的下标e{seiP(K＜人[midI.lcey)high=mid-1;" ID="9">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="刀修改区间上界.使下一次循环在左子表上继续查找else1ow二mid+1;" ID="10">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="刀修改区间下界，使下一次循环在右子表上继续查找l" ID="11">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="return-1;11查找失败返回一1" ID="12">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="，例如，假定有序表A中la个元素（即n=1Q)的关键字序列为：12,23,2b,37,54,60,58.75,82,96当给定值K分别为23,96和58时，进行二分查找的过程分别如图8.l(a(b)和健茜二二吸】山用由出鉴工墓习陈；昌火合台刘嵘玉仑陌佗飞田舌录山当台台.二闷抬粤田t知所示。图中用中括号表示当前查找区间，用“1”标出当前mid位置，因low和" ID="13">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="分别为“［”之后和之前的第一个位置，故没有用箭头标出它们。" ID="14">
          <fptr EndPN="00000273" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="二分查找过程可用一棵二叉树来描述，树中的每个根节点对应当前查找区间的中点·260·数据结构对应元素的关键字，节点上面的数字为对应元素的下标，附加的带箭头虚线表示查找一个元素的路径，其中给出了图S.1(a(b)和（(c）中查找关键字为23,9d和58元素的路径。从此图可以清楚地看出，在有序表上二分查找一个关键字等于K的元素时，对应着判定树中从树根节点到待查节点的一条路径，同关键字进行比较的次数就等于该路径上的节点数，或者说等于待查节点的层数。01234S6789fl32326371346068758296几.；d(12232637546068758296}今midI'23263754fb06875829611323263754606875[6296112?326375460687582f961[12?32b375460687582q61I°_?3263754[606B758296112232b3754f60681758296进行二分查找的荆定树不仅是一棵二叉第a章查找.261率的情况下平均比较次数略低于h.约为h-1〔证明从略）.所以二分查找算法的时间复例如，（因对应的判定树高度找，则最多需要比较1440次，平均也得比较soo次.二分查找的平均查找长度“1n，其中客找所有元素所需的比较“数之和。因为在一棵具有n个节点的二分查找判定树中，高度为h牙logZ(n+11，前h-1层都是满的，所以在前h-1层中查找所有元素的比较次数之和为艺(2‘一‘xi在第h层（即最后一层）中查找所有元素的比较次数之和为（(n一艺2xhn+i-z&quot;一‘)xh,因此，可得进行二分查找的平均查找长度为：＾5、l：ni‘二，一，‘一”，" ID="15">
          <fptr EndPN="00000275" StartPN="00000273"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，若一个有序表的长度n=24，则可计算出判定树的高度h二S，由此可得平均查" ID="16">
          <fptr EndPN="00000275" StartPN="00000275"/>
        </Paragraph>
        <Paragraph CONTEXT="找长度为：" ID="17">
          <fptr EndPN="00000275" StartPN="00000275"/>
        </Paragraph>
        <Paragraph CONTEXT="24[客(2_‘一’xi5(20+’一=2Q[1+2x2+4x3+8x4+SxS]=3.7在二分查找中，查找失败也对应着判定树中的一条路径，它是从树根节点到相应节1(c）的查找过程，]因为待查的关键字为此时左子树为空（对" ID="18">
          <fptr EndPN="00000275" StartPN="00000275"/>
        </Paragraph>
        <Paragraph CONTEXT="此时左子树为空（对应待查区间为空），所以耀" ID="19">
          <fptr EndPN="00000275" StartPN="00000275"/>
        </Paragraph>
        <Paragraph CONTEXT="同关键字进行比较的次数也不会超过树的高度，·2b2·数据结构" ID="20">
          <fptr EndPN="00000276" StartPN="00000275"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="第8查找.257一内················元素的存储位置依次为p.1,2n-h在顺序表上进行查找有多种方法，这里只介绍最主要的两种方法―顺序查找和二" ID="1">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="分查找." ID="2">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000276" TITLE="8.3  索引查找" TYPE="Chapter">
      <fptr LogicalPageNum="276" PhysicalPageNum="276"/>
        <div ORDERLABEL="00000276" TITLE="8.3.1  索引的概念" TYPE="Chapter">
        <fptr LogicalPageNum="276" PhysicalPageNum="276"/>
        <Paragraph CONTEXT="索弓f查找（IndexSearch)又称分级查找。它在日常生活中有着广泛的应用.例如，在《现代汉语词典》中查找汉字时，若知道读音，则先在音节表中查找到对应正文中的然后再在正文同音字中查找出待查的汉字；若知道字形，则先在部首检字表中根据字的部首在部首目录中查找到对应检字表中的页码，再在检字表中根据毛目录查找检字表，所以称检字表为一级索引，即对主表的索引，称部首眨一这里，整个词典就是索部首目录、检字表和音检字表是以主表作为查即通过部首称部首目录为二级索引，即对一级索引的索引.若用计算机进行索引查找，则同上面人工查找过程相同，只不过对应的表（包括主表和各级索引表）" ID="1">
          <fptr EndPN="00000276" StartPN="00000276"/>
        </Paragraph>
        <Paragraph CONTEXT="在计算机中为索引查找而建立的主表和各级索引表，其主表只有一个，索引表的级" ID="2">
          <fptr EndPN="00000276" StartPN="00000276"/>
        </Paragraph>
        <Paragraph CONTEXT="数和数量不受限制，可根话具体需要确定。但在下面的讨论中，为了使读者便于理解，第8章查找·253imsta比；刀子表中第一个元素所在的下标位里int1ength:1/子表的长度域" ID="3">
          <fptr EndPN="00000277" StartPN="00000276"/>
        </Paragraph>
        <Paragraph CONTEXT="" ID="4">
          <fptr EndPN="00000277" StartPN="00000277"/>
        </Paragraph>
        <Paragraph CONTEXT="typcdcf1adexltemindexlist[ILMSiuIL.l4[Siu为率先定义的整型常f，它要大于等于索引项数m若所有子表（合称为主表）被顺序存储或静态链接存储在同一个数组中，则该数组的类型可定义为：typedefEletnTyperttainlist[MaxSizcI/MaxSize为事先定义的刀整型常盆.它要大于等于主表中元素的个fitl例如，一个学校的教师登记表如表S-1所示.此表可看做为按记录前后位置顺序排列1性表.若以每个'11录的双工号作为关撼字，则此维性裹（假宁用LA表示）可简icy.的线性表，若以每个记录的职工号作为关键字，则此线性表为：LAdJSU01,JSOOZ,JSOa3,JS004,DZ001,D7.002,DZOp3,JJ001,JJ002,H0001,HG002,H0003)衰&amp;1教师登记斑峡黔附洲气豁丹嘿科嘿黔一嘿州" ID="5">
          <fptr EndPN="00000277" StartPN="00000277"/>
        </Paragraph>
        <Paragraph CONTEXT="J.SO(1:Iti进｝it4fHLIi”一”｝lcso.a｝73ro72s15nn3I1f怀学1i帅｝l&gt;bn.cx)｝mn:osJsaN1.11i｝it171＿！～～YI#a'E-xKn,rrojsxro竺竺生习一－竺匕习一二竺二月一一三兰一二2兰塑一斗＝xmsrzaD7(MIXq'F'1，fI1$帅I1htMl(M(I64/Q,SI{Q77wliISCL｝电‘Iill1I21(MX(ISl112a｝‘晓、‘！，‘城.碑帅｝｛,Jooz｝赵,“｝b«i｝i帅｝IhaO.IX，I7a/f)axH0001I1:dIS。工｛!Y&quot;‘273Q0I53A16ro3嚣‘州一一井tl«！随a化‘·’侧教授1！HGQ03I!h’SCE！1Utk1taac&gt;nI7:1(IGU若按照单位数据项的值（或关键字中的前两位字符）对线性表LA进行划分，使得具" ID="6">
          <fptr EndPN="00000277" StartPN="00000277"/>
        </Paragraph>
        <Paragraph CONTEXT="贝j得到的四个子表分别为：·264·数据结构JJJJOa1,JJ002)" ID="7">
          <fptr EndPN="00000278" StartPN="00000277"/>
        </Paragraph>
        <Paragraph CONTEXT="HGHGOI,HGO2,NG003)" ID="8">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Picture URL="00000278\00000278_new\0005.jpg">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Picture>
        <Paragraph CONTEXT="类型的一维数组bl来顺序存储这种划分所得到的" ID="9">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="索引表，则bl中的内容如表S-2所示。" ID="10">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="对于上面的线性表LA.若按照职称数据项的" ID="11">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="行划分，使得具有相同职称的记录在同一个子" ID="12">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="值进行划分，表中，则得到的四个子表分别为：ZHUQZU01,HGOU3)" ID="13">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="若在上一次划分使用的主表a的基础上来链接存储这一次划分所得到的子表，" ID="14">
          <fptr EndPN="00000278" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="先需要在主表a的元素类型ElemType中增加一个整数类型的指针域（nett)，然无这个指针域把这一次每个子表中的元素分别链接起来。链接后得到的每个链接于图3所示，其中每个指针上的数值为该指针的具体值，即所指向节点（元素）然后利用链接后得到的每个链接子表如：，即所指向节点（元素）的下第S章查找·265均为1，所以完全可以省略子表的长度域。按照此种方法划分得到的索引表如表8所示.0" ID="15">
          <fptr EndPN="00000279" StartPN="00000278"/>
        </Paragraph>
        <Paragraph CONTEXT="i" ID="16">
          <fptr EndPN="00000279" StartPN="00000279"/>
        </Paragraph>
        <Picture URL="00000279\00000279_new\0005.jpg">
          <fptr EndPN="00000279" StartPN="00000279"/>
        </Picture>
        <Picture URL="00000279\00000279_new\0006.jpg">
          <fptr EndPN="00000279" StartPN="00000279"/>
        </Picture>
        <Paragraph CONTEXT="z" ID="17">
          <fptr EndPN="00000279" StartPN="00000279"/>
        </Paragraph>
        <Paragraph CONTEXT="3在索引存储中，若索引表中的每个索引项对应多条记录，则称为稀疏索引；若每个索引项惟一对应一条记录，则称为稠密索引。在一个文件索引系统中，若存储原始数据记录的主文件是无序的，即记录不是按照关键字有序排列的，则一级索引（即对主文件的索引）必须使用稠密索引，并且通常使索引表按关键字有序：若主文件是有序的，则一级索引应y:F;一相J习福落的着己十兰lat空fltrh或.l.一木F#rS1i6,T:F一如招寻的县，l、釜艘宝＿对应一组记录的最大关键字，同时要小于显然这种稀琉索引也是按索引值有序的.若在文件索引系统中使用二级或二级以上索用顺序或二分查找方法快速地查找出给定关键字对应记录的存储位置，然后再从主文件rhffrrLL1i友.sa" ID="18">
          <fptr EndPN="00000279" StartPN="00000279"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000279" TITLE="8.3.2  索引查找算法" TYPE="Chapter">
        <fptr LogicalPageNum="279" PhysicalPageNum="279"/>
        <Paragraph CONTEXT="二兰匕一一一…旧.…＿…些鱼兰少鱿一一一一一一和主表中关键字域的类型，并假定每个子表采用顺序存储，则索引查找算法的描述为：intindach(mainlistA,indexlistB,intm,IndexKe}rI'ypeK1,KeyTypeK2)关键字为K2/1的记录，返回该记录在主表中的下标位里，若查找失败则返回一i" ID="1">
          <fptr EndPN="00000280" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="｛inti,j;11在索引表中顺序查找索引值为K1的索引项for{i习;ism;i" ID="2">
          <fptr EndPN="00000280" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="ifLKi=B[iI.index}11若IndexKeyType被定义为字符" ID="3">
          <fptr EndPN="00000280" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="JJ串类型。则条件应改为：trcmp(K砚，B[iI.indexl-break;11若i等于m.则表明查找失败，返回一1if(i=二m)return-1;11在已经查找到的第i个子表中顺序查找关键字为K2的记录j二B[iI.start;if(K2-A[jI.key)brrsic;11若KeYT1”被定义为字符u串类型，则条件应改为.ircmp(I.2,A[jI.key）二＝Oclscj11若查找成功则返回元素的下标位t，否则返回一i" ID="4">
          <fptr EndPN="00000280" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="i1tj＜B[iI.start十B！iI.length)returnj;elsereturn-t;｝若每个子表在主表A中采用的是链接存储，则只要把上面算法中的while循环和其后的if语句进行如下修改即可." ID="5">
          <fptr EndPN="00000280" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="while！二一”一1作为空指针标记" ID="6">
          <fptr EndPN="00000280" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="if{K2=A[jI.key)break;elsej二AI.next;第S章查找·267当查找成功时返回H[iI.start的值，失败时返回一1即可。请读者自己编写出这个算法。之和。假定索引表的长度为。，相应子表的长度为s，则索引查找的平均查找长度为：ASI毕+一’+2等于主表的长度n，所以若假定每个子表具有相同的长度，因为所有子表的长度之和等于主表的长度n，即，等于咖，则平均查找长度为1＋鱼士李2皿.由数学知识可知.当推耐玩（即。石，乙此时子表长度，也等于而）时，平均查找长度最小，即为卜石.可见，索引查找的速度快于顺序查找，但低于二分查找。在主表被等分为而个子表的条件下，其时间复杂度例如，当。10《XK）时，若采用顺序查找则平均查找长度约为51次，若采用二分查找约为13次，若采用索引查找，则约为100次。虽然二分查找最快，但进行二分查找的表必须是顺序存储的有序表，为建立有序表需要花费时间，而对于顺序查找和可见索引查找一个子表中的所有元素与二分查找一个子表中的所有元素相" ID="7">
          <fptr EndPN="00000281" StartPN="00000280"/>
        </Paragraph>
        <Paragraph CONTEXT="比，前者比后者加快了logZn倍。若在主表中的每个子表后都预留有空闲位置，则索引存储也便于进行插入和删除运算，" ID="8">
          <fptr EndPN="00000281" StartPN="00000281"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000281" TITLE="8.3.3  分块查找" TYPE="Chapter">
        <fptr LogicalPageNum="281" PhysicalPageNum="281"/>
        <Paragraph CONTEXT="·26$数据结构分块查找要求主表中每个子表（子表又称为块）之间是递增（或递减）有序的，即前块中的最大关键字必须小于后块中的最小关键字，或者说后块中的最小关键字必须大于前块中的最大关键字，但每个块中元素的排列次序可以是任意的；它还要求索引表中每个去己】捅的由ai估+田水左住升扁恤由的备十兰蛾空山夺他杏始封士丰知由己！书的西带索引项的索引值域用来存储对应块中的最大关键字。的关键字域和索引表中的索引值域具有相同的数据类型，即为关键字所属的类型.困」0月匕片福声自努月.＿洲卜适各七五李军士公配.；菩名R｛」二习昌为山书11之卜叹，：二.圣.击xftHC.k'山&lt;.r主表被划分为三块，每块都占有5个记录位置，第一块中含有4个记录，第二块中含有S个记录，第三块中含有3个记录。第一块它小于第三块中的最小关键字Sb，所以，主表中块与块之间是递增有序的。从图中的索己1衷石1.J业菩申.拭水杳砚矛丽山的由日！拾描但左姜认十志伍山的县」州」巴徽中表己1名早饮胳引表可以看出：每个索引项中的索引值域保存着对应块中的最大关键字，索引表是按照责已！糟撇描右良的当进行分块查找时，应根据所给的关键字首先查找索引表.从中查找出给定值K刚好等于索引值的的那个索引项，从而找到待查块，然后再查找这个块，从中找到待查的小于等于索引值的的那个索引项，" ID="1">
          <fptr EndPN="00000282" StartPN="00000282"/>
        </Paragraph>
        <Paragraph CONTEXT="查找索引表结束，转而顺序查找主表中从下标5开始的块，第B章查找·269刀在索引表中顺序查找关键字为K所对应的索引项forties;i[m;i" ID="2">
          <fptr EndPN="00000283" StartPN="00000282"/>
        </Paragraph>
        <Paragraph CONTEXT="if1;KB[iI.indebreak;/1若i等于m，则表明查找失败，返回一1ifCivreturn-1;l1在已经查找到的第i个子表中顺序查找关键字为K的记录J二B[iI.start;while(j[B[iI.srart十13[iI.length)" ID="3">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="iftK=A[jI.key)break;" ID="4">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="elsej若查找成功则返回元素的下标位里，否则返回一1iftjcl3[iI.start十13[iI.length}returnj;elsereturn-1;" ID="5">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="}若在索引表上不是顺序查找，而是二分查找相应的索引项，则需要把算法中的for循int1ower,high=m-1;" ID="6">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="while(low=high){intmidflaw+high2;if(K=B[mid］甲index){i=mid;break;}elseiftKrB[midI.index}high=mid-1;else1ow二mid+1;" ID="7">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="8">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="if(lowhigh)i=low;在这里当二分查找失败时。应把[oW的值赋给1，此时b{iI.index是刚大于K的索引s4J2甚ifitr.fi'E,Ild妻r.官不4tr客E牛Ibfr" ID="9">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
        <Paragraph CONTEXT="值。" ID="10">
          <fptr EndPN="00000283" StartPN="00000283"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000283" TITLE="8.4  散列查找" TYPE="Chapter">
      <fptr LogicalPageNum="283" PhysicalPageNum="283"/>
        <div ORDERLABEL="00000283" TITLE="8.4.1  散列的概念" TYPE="Chapter">
        <fptr LogicalPageNum="283" PhysicalPageNum="283"/>
        <Paragraph CONTEXT="·274·数据结构$Picture[00000284\00000284_new\0002.jpg]Picture$$Picture[00000284\00000284_new\0003.jpg]Picture$：，它实现关键字到存储地址的映射（或称转换），使用的数组空间是数据进行散列存储的地址空间，址；或HashTable)或哈希表。在散列表上进行查找时，首先根据给定的关键字K，用与散列存储时使用的同一散列函数h(K)计算出散列地址，然后按此地址从散列表中取出对应的" ID="1">
          <fptr EndPN="00000284" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="元素。Si8,75,60,43,54,9b,46}其中每个整数可以是元素本身，也可以仅是元素的关键字，用以代表整个元素.为h（劝=K9om即用元素的关键字K整除以散列表的长度。，取余数（即为0(m-1)范围内的一·、才布：搜1解主4决；右；井寻毕仪1刽沙石＂扫由石卜共念田J四弓汁F关11～1资，月，认口宜度洲诊二IfcFI～立宣日卜a二&quot;个数）作为存储该元素的散列地址，这里假定K和爪均为正整数，" ID="2">
          <fptr EndPN="00000284" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="散列存储的集合的长度n。在此例中，：＝7.所以假定取m＝13，则得到的每个元素的散列" ID="3">
          <fptr EndPN="00000284" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="地址为：" ID="4">
          <fptr EndPN="00000284" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="h（18）＝18％13＝5h（75）曰5％13＝10" ID="5">
          <fptr EndPN="00000284" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="h（60）目队】％13＝sh（43）＝43％13＝4h（54）＝54％13砚h（90）二如％13＝12h（46）倒拓％13＝7若根据散列地址把元素存储到散列表H［m］中，则存储映像为；0123456789101112H从散列表中查找元素同插入元素一样简单，如从H中查找关键字为60的元素时，只" ID="6">
          <fptr EndPN="00000284" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="要利用上面的函数h（价计算出犬城铂时的散列她址8.则从下标为8的单元中取出该元素第8章查找·271素无法直接存入到此单元中，我们把这种现象叫做冲突（collision在散列存储中，冲突是很难避免的，除非关键字的变化区间小于等于散列地址的变化区间，而这种情况当" ID="7">
          <fptr EndPN="00000285" StartPN="00000284"/>
        </Paragraph>
        <Paragraph CONTEXT="列地址的取值区间为412，远比关键字的取值区间小。这样，当不同的关键字通过同一散列函数计算散列地址时，就可能出现具有相同散列地址的情况，若该地址中已经存入散列函数计算散列地址时，就可能出现具有相同散列地址的情况这种具有不同关键字而具有相同散列地址的元素称做，’同义词”，d由同义词引起的冲突称做的散列表H中插入一个关键字为70的新元素时，该元素的散列桩空场业e的异安兮士劝空劲才由乌台御未宁毛，n苗荡弓节.妻月口仕左入地址为5，就同已存入的关键字为18的元素发生冲突，葵11.1芬舌荟叹1《配飞苗弓芬d」1召.冲有n才石rl妥月冬笼难花石加七弓鼠泊1加五盛白到下标为5的单元中。因此，如何尽量避免冲突和冲突发生后如何解决冲突（即为发些的待插入元素找到一个空闲单元、使之存储起来）就成了散列存储的两个关键问题." ID="8">
          <fptr EndPN="00000285" StartPN="00000285"/>
        </Paragraph>
        <Paragraph CONTEXT="在散列存储中，虽然冲突很难避免，但发生冲突的可能性却有大有小，这主男" ID="9">
          <fptr EndPN="00000285" StartPN="00000285"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000285" TITLE="8.4.2  散列函数" TYPE="Chapter">
        <fptr LogicalPageNum="285" PhysicalPageNum="285"/>
        <Paragraph CONTEXT="·zn·数据结构可能简单，以节省计算时间。根据关键字的结构和分布不同，可构造出与之适应的各不相同的散列函数.这里只介绍较常用的几种，其中又以介绍除留余数法为主。在下面的这里只介绍较常用的几种，" ID="1">
          <fptr EndPN="00000286" StartPN="00000286"/>
        </Paragraph>
        <Paragraph CONTEXT="讨论中，假定关键字均为整型数，对应的散列函数h(1为：K本身或关键字加上某个数值常量C作为散列地址的方法。h(1卜K+C若C为a，则散列地址就是关键字本身。" ID="2">
          <fptr EndPN="00000286" StartPN="00000286"/>
        </Paragraph>
        <Paragraph CONTEXT="希寺灿门七贷上J牛曹若备信苗」全日剑压〕台.油立公庄空间的浪费。" ID="3">
          <fptr EndPN="00000286" StartPN="00000286"/>
        </Paragraph>
        <Paragraph CONTEXT="2.除留余数法除留余数法是用关键字散列函数h(K)为：K除以散列表长度优所得余数作为散列地址的方法.对应的身之外，不能被任何数整除的数）。当然，要确保m的值大于等于待散列的线性表的长度" ID="4">
          <fptr EndPN="00000286" StartPN="00000286"/>
        </Paragraph>
        <Paragraph CONTEXT="n，根据装填因子a最好为在0.60.9之间，所以m应取l.ln1.7n之间的一个素数。例第8章查找·273intHash{CharrK,int11把字符申K转换为0m-1之间的一个值作为对应记录的散列地址lint1en翁trlea(K11求出字符串K的长度unsignedintham;11给琪加变fh赋初值0for(intiU;iden;i曰采用一种方法计算K所对应的整数" ID="5">
          <fptr EndPN="00000287" StartPN="00000286"/>
        </Paragraph>
        <Paragraph CONTEXT="ha=3;11h的值左移3位" ID="6">
          <fptr EndPN="00000287" StartPN="00000287"/>
        </Paragraph>
        <Paragraph CONTEXT="h＋＝K［i］；洲月巴Kli］宇符的整数值累加到h上｝returnh96m;返回这个整数整除以几的余数｝例如，假定一个记录的关键字K为‘abl&quot;，则调用上述函数时最后计算得到的h值为：若m为127.则返回的散列地址为560" ID="7">
          <fptr EndPN="00000287" StartPN="00000287"/>
        </Paragraph>
        <Paragraph CONTEXT="3.数字分析法数字分析法是取关键字中某些取值较分散的数字位作为散列地址的方法。它适合于关键字已知，并对关键字中每一位的取值分布情况做出了分析。例如，有一组关键所有关键字已知，字为（92317602,92326875,42739628.92,343634,92706815,92774638,92381262,923942za.通过分析可知，每个关键字从左到右的第I,2,3位和第6位取值较集中，不宜作散列地址，剩余的第4,5,7和8位取值较分散，可根据实P为[列地址。若取最后两位作为s列地址，则散列地址的集合为（2,75,28,34,16,38,62," ID="8">
          <fptr EndPN="00000287" StartPN="00000287"/>
        </Paragraph>
        <Paragraph CONTEXT="20}0" ID="9">
          <fptr EndPN="00000287" StartPN="00000287"/>
        </Paragraph>
        <Paragraph CONTEXT="4.平方取中法平方取中法是取关键字平方的中间几位作为散列地址的方法，具体取多少位视实际。274。数据结构折亚法折叠法是首先将关键字分割成位数相同的几段（最后一段的位数若不足应补0)，段（舍去最高位进位，则将此关键字从左到右每三位一段进行划分，得到的三段为682,423和240,加和为" ID="10">
          <fptr EndPN="00000288" StartPN="00000287"/>
        </Paragraph>
        <Paragraph CONTEXT="68242324元素的散列地址.折叠法适应于关" ID="11">
          <fptr EndPN="00000288" StartPN="00000288"/>
        </Paragraph>
        <Paragraph CONTEXT="四坊小周时荤址空由扭一炭，的砌拮寸赫俊" ID="12">
          <fptr EndPN="00000288" StartPN="00000288"/>
        </Paragraph>
        <Paragraph CONTEXT="键字的位数较多，中的情况。" ID="13">
          <fptr EndPN="00000288" StartPN="00000288"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000288" TITLE="8.4.3  处理冲突的方法" TYPE="Chapter">
        <fptr LogicalPageNum="288" PhysicalPageNum="288"/>
        <Paragraph CONTEXT="处理冲突的方法可分为开放定址法和链接法两类." ID="1">
          <fptr EndPN="00000288" StartPN="00000288"/>
        </Paragraph>
        <Paragraph CONTEXT="1.开放定址法一个空闲的存储单元，把发生冲突的待插入元素存入到该单元中的一类处理冲突的方法。在开放定址法中，散列表中的空闲单元就看谁先占用它。在进行查找一个元素的过程是：首先根据给定的关键字K，利用与插入时使用的同（假定为下标d然后，用K同d单元的关键字进行比较，若相等则查找成功，否则按照插入时处理冲突的相同次序，依次用K同所查单元的J产，d自烤，刹住弓旱.J户七内1乌.劝1到匕奄卜d冬，‘石竹剑匕主拒蕊翻1＿洲人护二白占二二，兰目AKI创匕‘协PFi/r\I.L直到查找成功或查找到一个空单元（表明查找失败）为止。第8章查挽.275探查完所有单元为止。这种方法的探查序列为d,d+l,d+2,，或表示为（d+i)°6rn(dpi簇。一1)。若使用递推公式表示，则为：rd=1r(K)1dp(di1)96m(1感7c。一1,d这里的‘在最坏的情况下才能取值到m-1，一般只需取前几个值就可能找到一。找到一个空闲单元后，把发生冲突的待插入元素存入该单元即可。当然，北个空闲单元。例8.2向例8.1中构造的H散列表中再插入关键字分别为31和58的两个元素，若发生冲突则使用线性探查法处理.先看插入关键字为31的元素的情况。关键字为31的散列地址为h(3131X13=5,因H{51单元已被占用.接着探查下一个即下标为b的单元，因该单元空闲，所以关键字为31的元素被存储到下标为6的单元中，此时对应的散列表H为：｝｝154｝43I1SI31上肿,｝。IIslf叹.lK再看插入关键字为58的元素的情况。关键字为58的散列地址为h(5858°613rr‘i上田土色姜翻店客刁9一洲卜日n盯妊毛，ix4苗-TFPrJrn才T4XI,zs节阮1#姜it因H【6］己被占用，接着探查下一个即下标为7的单元，因H［刀仍不为空，再接着探查下9的单元时，字为58的元素存入该单元中，此时对应的散列表H为：012345石7吕9101112" ID="2">
          <fptr EndPN="00000289" StartPN="00000288"/>
        </Paragraph>
        <Paragraph CONTEXT="｝”’｝二哭匕止.43.！18”｛.－了T’’.｝照.L＿竺到二二＿1.…｝901.，1H利用线性探查法处理冲突容易造成元素的“堆积”或称“菜集”。这是因为当连续n·276·数据结构簇i簇m-1,do=d)是不能探杳到散列表上的所有单元，但罕少能掇杳到一半单元（证明从略）。例如，当例如，当do=5,rn=17时，则只能探查到下标依次为S,6,9,14,4,13,7,3,1的单元，而不能探查到剩余的单元。不过在实际应用中，能探查到一半单元也就可以了，若探查到一半单元仍e-n试萦fii苗-m（妻HarFlbrSil妻rter1C;雷荡翰r" ID="3">
          <fptr EndPN="00000290" StartPN="00000289"/>
        </Paragraph>
        <Paragraph CONTEXT="3)双散列函数探查法这种方法使用两个散列函数hl和h2，其中hl和前面的h（一样，以关键字为自变（即步长）。双散列函数的探查序列为：41(dr-1+h2(10}9bm(1.i.。一1,r1由以上可知，对于线性探查法，探查序列的步长值是固定值1，对于平方探查法，探" ID="4">
          <fptr EndPN="00000290" StartPN="00000290"/>
        </Paragraph>
        <Paragraph CONTEXT="浏匕r匕slel,ik.lG-A'J习浏tri4[r者atn花,l江、出,a+门口vv#rT，i汽下1Ilfri2S浏cit.泪-itS浏crl石rrrr.k.JC.I占对于双散列函数探查法，其探查序列的步长值桩接法就是把发生冲突的同义词元素（节点）用单链表链接起来的方法。在这种方，，散列表中的每个单元（即下标位置）不是存储相应的元素，而是存储相应单链表" ID="5">
          <fptr EndPN="00000290" StartPN="00000290"/>
        </Paragraph>
        <Paragraph CONTEXT="井江华抖＿苗撼害由的辑水常占rbYh太脚声士_ffRtda月p#1r于责ixk左E7e,iii法中，单链表中，在单链表中可以任意地插入和删除节点，所以填充因子a既可以小于等于1.第8章查找·277当发生冲突时，假定采用链接法处理，则得到的散列表如图8.5所示。" ID="6">
          <fptr EndPN="00000291" StartPN="00000290"/>
        </Paragraph>
        <Paragraph CONTEXT="图8.，采用链接法处理冲突的散列表用链接法处理冲突，虽然比开放定址法多占用一些存储空间用来存储链接指针，但$Picture[00000291\00000291_new\0005.jpg]Picture$它可以减少在插入和查找过程中同关键字平均比较的次数（即平均查找长度）。这是因毛介棋炸抹由性冲材乖的常占撅且曰心端氰成今占月有尤斗不访申林之上由性冲吉朽的闷禽占1之六7为，在链接法中待比较的节点都是同义词节点，而在开放定址法中，句今右目妙福哥节占＿寻而日句今右业阁口韧常占＿仕仕」仁目卿翻节古而且包含有非同义词节点，往往非同义词节点比同义词节点还要对于一个具体的散列表来说，要求出在插入或查找过程中的平均查找长度很容易，在随机插入或在查找每个元素概率相等的情况下，它等于每个元素的查找长度（即比较ydr316Ir1-Rff4L'1riN'rbhlti(rfnG6114健t5ft(r万dada客i3吩rhFk+J反r奋3.1-F&gt;'h.人SI州8x1+3x2+1x3)112=17!12若将例8.3中的线性表B采用线性探查法处理冲突进行散列存储，则各元素的散列地址为：h{601喇d%13-8h{43r-439613二4h(54k549613=2h(90）二909613=12h{461`469613=7h(31）二31'R'v13二5冲突hl(311斌h(3i1)％及3=6h(585896I3=5冲突h，（58）试几（58卜1）％13二7冲突hz(5818冲突hs(5819h(73卜739613=8冲突hl{73h(73+1)9613二9冲突&amp;Z(731C10冲突h3{73）二11，278·数据结构得到的散列表为：" ID="7">
          <fptr EndPN="00000292" StartPN="00000291"/>
        </Paragraph>
        <Paragraph CONTEXT="oiz34s67s91a1112｝341I,，卜s｛43JISI,.311,46二｝叩.1sa1二匕73.二ASL-7X1+2X2+2X4+1x6)112=25112可见开放定址法处理冲突的平均查找长度要高于链接法处理冲突的平均查找长度。" ID="8">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="但它们都比以前所有查找方法的平均查找长度要短.这里虽然是对具体的散列表进行的" ID="9">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="分析，但其分析结果具有普遍意义。" ID="10">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000292" TITLE="8.4.4  散列表的运算" TYPE="Chapter">
        <fptr LogicalPageNum="292" PhysicalPageNum="292"/>
        <Paragraph CONTEXT="在线性表的散列存储中." ID="1">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="｛的散列存储中.处理冲突的方法不同，其散列表的类型定义也不同，假定zSize常量表示待定义的散列表类型的长度，它要大于等于实际使用的散列下面分别给出与采用开放定址法和链接法对应的散列表的类型定义。开放定址法，其散列表的类型用hashlist1表示，该类型定义为：使用HashMaxsize表的长度m，" ID="2">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="假定采用开放定址法，" ID="3">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="ty声川亡fE让mTy讲h翻hlistl［H舫hMaxsi那］：" ID="4">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="若采用链接法，其散列表的类型用bashlistZ表示，则类型定义为：" ID="5">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="ty伴切时sNodc＊bash】15已［Hasll］随axs吮］；其中sNode＊为指向sNo由节点类型的指针类型，sNode节点类型在第2章中已经定义过，如下所示：5如ctsNode【己emTy声da斌" ID="6">
          <fptr EndPN="00000292" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="sN以七＊next；第S章查找·2T911把散列表HT中每一单元的关键字lcey域都t为空标志{" ID="7">
          <fptr EndPN="00000293" StartPN="00000292"/>
        </Paragraph>
        <Paragraph CONTEXT="far(inti二U;icHashMaxSiu;iHT[iI.key=NullTag;Nu11Tsg常t表示空标志.当关健字刀类型为字符申时它为空申“铂”，当为数值型时它为一个ll卜关键字的特定数值：另外，对干字符串类型应采用刀字符申函数进行比较或赋值，下同。}" ID="8">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="2）清空一个散列表" ID="9">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="voidC1earHashl.ist(hashlistlHT)" ID="10">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="11.°散列表HT中每一单元的关键字址y域都1为空标志硬" ID="11">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="for(intice;iHashMazSize;i" ID="12">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="HT[iI.lcey=NullTag;" ID="13">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="》" ID="14">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="3)向散列表抽入一个元素bowlInsert(bashlistlHT,intm,F1emTypcitem)11向长度为m的散列表HT中插入一个元素item（" ID="15">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="intd=H(ttem.key,ttt" ID="16">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="刀可选用任一种合适的构造散列函数的方法，计算散列地址inttemp;I！用temp变量暂存散列地址dwhile(HT[dI.key！二NuilTag)" ID="17">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="｛万用线性探查法处理冲突" ID="18">
          <fptr EndPN="00000293" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="did+1)96m;if(dtemp)returnfalse;返回佃犯表示插入失败｝H'I'Ldl二item;1新元素插入到下标为d的位盖returntrue二/返回true表示插入成功三竺二一一一一一一鱼堕迪" ID="19">
          <fptr EndPN="00000294" StartPN="00000293"/>
        </Paragraph>
        <Paragraph CONTEXT="4）从散列表中查找一个元素intSearch(hashlistlHT,intm,ElemTypeitem)11从长度为m的散列表HT中查找关键字为ittmkey的一个元素【" ID="20">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="intd二H（item.key.m）；" ID="21">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="inttemp;while(HT[dI.keyl=NullTag)易11当散列地址中的关键字域不为空则循环" ID="22">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="itCHT[dI.key=item.key)netumd;11查找成功返回下标d" ID="23">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="else卜（d＋盆）％m；if(dtemp)rctasrn-1;p查找失败返回一】｝return-I;11查找失败返回一" ID="24">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="25">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="5)从散列表中删除一个元素int17elete(hashlistlHT,intm,ElemTypeitem)11从长度为m的散列表HT中删除关键字为item.key的一个元素" ID="26">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="27">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="intd=H(item.key,minttetrtp=d;while(HT[dI.key！二NuI1Tag}{" ID="28">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="if(HT[dI.keyitem.key){" ID="29">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="u则就割断了元素的查找路径，显然是不行的，该位置u可为以后插入元素之用" ID="30">
          <fptr EndPN="00000294" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="return1;11删除成功返回1第S章查找·281" ID="31">
          <fptr EndPN="00000295" StartPN="00000294"/>
        </Paragraph>
        <Paragraph CONTEXT="dd+1}96m;11继续向后探查if(d二=temp}rttum0;!1一周仍未找到S返回。表示删除失败｝tturn0;/l}9除失败返回0｝" ID="32">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="2.在类型为hashlist2的散列裹上进行的运算1}初始化散列表voidIaitHashList{hashlist2HT)刀把散列表】们，中每一元素均t为空指针{for(intice;i＜HashMaxSizo;i+十）NT[il=NU-L;" ID="33">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="34">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="2)清空一个散列表voidC1earHashListihasltlist2H'I清除I-IT散列表，即回收每个单链表中的节点{" ID="35">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="sNode*p;fot{ieti二ii＜HashMaxSize;i砚" ID="36">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="pH'I7;" ID="37">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="while(pt二NULL){" ID="38">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="HT【11州卜》next；" ID="39">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="deletep;" ID="40">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="P＝HT【1］；" ID="41">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="42">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="43">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="44">
          <fptr EndPN="00000295" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="33向散列表插入一个元素intInsert(hashlist2HT,intm,ElemTypeiuut)，282.数据结构{刀得到新元素的散列地址intd=H{ittm.key,m11为新元素分配存储节点sNode+p=newsNode;内存空间用完.返回0表示插入失败if(pNULL)return0;护肥新节点插入到d单链表的表头pdata二item;" ID="45">
          <fptr EndPN="00000296" StartPN="00000295"/>
        </Paragraph>
        <Paragraph CONTEXT="p-next＝＝HT[d" ID="46">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="IT[d]二P:刀返回1表示插入成功return1;" ID="47">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="48">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="4)从散列表中查找一个元素ElemType+Sesrch(hashlist2HT,intm,ElemTypeitem)" ID="49">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="从长度为m的带链接的散列表HT中查找元素｛11得到待查元素的散列地址intd二H（item滋cy.m）；刀得到对应单链表的表头指针sNode＊p=NT[d从该单链表中顺序查找匹配的元素.若查找成功返回该元素的地址while(pNULL){" ID="50">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p-data.key＝二item.key)" ID="51">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="52">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="】11查拢失败返回空指针retumNULL;" ID="53">
          <fptr EndPN="00000296" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="I第8章查找，283" ID="54">
          <fptr EndPN="00000297" StartPN="00000296"/>
        </Paragraph>
        <Paragraph CONTEXT="5)从散列表中侧除一个元素int17elete{hsslilist2HT,intm,ElemTypeitem)刀从长度为m的带链接的散列表甘】，中翻除元素｛刀求出待删除元素的散列地址intd=H(item.ltey,m仰指向对应单链表的表头指针sNode+p=H'f{d*q;刀若单链表为空，返回0表示删除失败if（声-M]LL)returno;刀若表头节点为被删除的节点.则删除它并返回1表示成功" ID="55">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p-data.key二二；tem.ttey){" ID="56">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="HT[d]别-＞next;" ID="57">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="detetep;" ID="58">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="rewtn1;}I！从第二个节点起查找被侧除的元素，若查找成功则删除它并返回1" ID="59">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="q＝P-》next;" ID="60">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="while{q！二NULL)" ID="61">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="忆" ID="62">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="teturn1;" ID="63">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="64">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="P=q二q阅-》next;" ID="65">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="66">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="67">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="11返回0表示删除失败" ID="68">
          <fptr EndPN="00000297" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="return0;｝·284·数据结构列函数、a的值和处理冲突的方法有关。若假定所选取的散列函数能够使任一关键字等概率地映射到散列空间的任一地址上.则理论上已经证明.当采用线性探查法处理冲突时，平均查找长度为1(1；当用链接法处理冲突时，平均查找长度为1+a;用L1-0‘开放定址法中的平方探查法、双散列函数探查法处理冲突时，平均查找长度为一土uR-a)o" ID="69">
          <fptr EndPN="00000298" StartPN="00000297"/>
        </Paragraph>
        <Paragraph CONTEXT="实际应用中通常比理论值要大些。-f―二面再二二二月一石福一.二一丁－二一「―一MM2.les～Ct}f一一丁一下一蔽丁一众LIH,｝1115＿＿＿＿＿仁‘一、’工！由表8-5可知，在散列存储中：插入和查找的速度是相当快的.它优于前面介绍过的" ID="70">
          <fptr EndPN="00000298" StartPN="00000298"/>
        </Paragraph>
        <Paragraph CONTEXT="任一种方法，特别是当数据量很大时更是如此。散列存储的缺点是；①根据关键字计算散列地址需要花费一定的计算时间，若关键字不是整数，则首先要把它转换为整数.为此也要花费一定的转换时间；②占用的存储空间较多，因为采用开放定址法解决冲突的" ID="71">
          <fptr EndPN="00000298" StartPN="00000298"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000298" TITLE="8.5  B树查找" TYPE="Chapter">
      <fptr LogicalPageNum="298" PhysicalPageNum="298"/>
        <div ORDERLABEL="00000298" TITLE="8.5.1  B_树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="298" PhysicalPageNum="298"/>
        <Paragraph CONTEXT="第S章查找.285是一种在文件系统中常用的动态索引技术。B＿树或者是一棵空树，或者是一棵具有如下节点结构的树.｝,I，,II1Ip1xr公1.：.：｝K.】、卜｛x.IPwlB一树中每个节点的大小都相同，其中。称为&gt;3一树的阶.其值要大于等于3:par为指向父亲节点的指针域，由它可以找到父亲节点；Ki,Kz,，KR为。个按从小到大顺序HL'C.1.41」hi，目acIl..ii.y1工a卜la+F.r-rta.，tr_，I.d全rItrr.i.Lif'rl.排列的关键字，n是变化的，对于非根节点，对于树根节点，n值的变化范围规定为1簇n落m-1:Po,P,Pz，二，PR为n+1个指针，用于分别指向该节点的。+1棵子树，其中Pa所指向子树中的所有关键字均小于J1,P所指向子树中的所有关键字均大于Kn,P;(1蕊i蕊n-1）所指向子树中的所有关键字均大于K,且小于Kr+，由n的取值范围可知，对于树根节点，它最少有两棵子树，最多有rn棵树，对于非树根节点，它最少桥成1棵子树，最多有m棵子树，当然树叶节点中的子树均为空树；在B＿树的节点结构中，每个关键字域的后面还应包含一个指针域，用以存储该关键字所属记录（元素）在主文件中的存储位置，在此省略未画。B＿树中除了节点结构与一般树不同外，还有一个特点就是所有叶子节点均在同一层图8.6是一棵由13个关键字组成的四阶B一树的示意图，当然同二叉搜索树一样，关键字的插入次序不同，将可能生成不同结构的B一树.该树共有三层，所有叶子节点均在第三层上。为了简化起见，每个节点的后面尚未利用的关键字域和指针域未画出，同·286·数据结构的域。又如，在一棵七阶的S一树中，树根节点的关键字个数最少为1，最多为。一1＝6,畏；为m-i，子树个数最少为「”口21dra，最多为m二？." ID="1">
          <fptr EndPN="00000300" StartPN="00000299"/>
        </Paragraph>
        <Paragraph CONTEXT="B一树中的节点类型定义如下：" ID="2">
          <fptr EndPN="00000300" StartPN="00000300"/>
        </Paragraph>
        <Paragraph CONTEXT="子" ID="3">
          <fptr EndPN="00000300" StartPN="00000300"/>
        </Paragraph>
        <Paragraph CONTEXT="树个数最少为" ID="4">
          <fptr EndPN="00000300" StartPN="00000300"/>
        </Paragraph>
        <Paragraph CONTEXT="最多为m-1＝6，constint华IB＿树的阶数1；structMBN叼七《intkeynum；11关键字个数域MBN侧如＊paJ呛nt；11指向父节点的指针域KeyTypekeylm＋ll；ll保存n个关键字的域.下标0位置未用MBNode。网m＋l］；ll保存n＋l个指向子树的指针域intrecPtrlm＋l］；II保存每个关键字对应记录的存储位置域，" ID="5">
          <fptr EndPN="00000300" StartPN="00000300"/>
        </Paragraph>
        <Paragraph CONTEXT="刀假定所有记录被存储在外存上一个文件中，这里的介犯ptr［i111保存key【1］对应记录在文件中的位置序号，所以被定义为整型." ID="6">
          <fptr EndPN="00000300" StartPN="00000300"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000300" TITLE="8.5.2  B_树查找" TYPE="Chapter">
        <fptr LogicalPageNum="300" PhysicalPageNum="300"/>
        <Paragraph CONTEXT="根据B一树的定义，在B一树上进行查找的过程与在二叉搜索树上类似.都是经过一不过对路径中每个节点的比较过程比通常需要经过同多个关键字比较后才能处理完一个耸。在B＿树中查找一个关键字等于给定值K的具体乏出树根节点，使给定值K依次同该节点中的每一个关键字进行比较，直到K蕊Ki（l续1（n＋1，假定用凡＋，作为终止标志。保存比所有关键字都大的一个特定值，该值不妨用MaxKcy常量表示）时为止，此时若人卜蜀，则表明查找成功，返回具有该关键字KI的记录的存储位置，否则其值为K的关键字只可能落在该节点的由Pi＿。所指向的子树上，接着只要在该子树上继续进行查找即可；这样，每取出一个节点比较后就下移一层，直到查找成功或被查找的子树为空（即查找失败）时止。第a章查找·zap又如若在图8.6的B一树上查找值为56的关键字时，首先取出树根节点a，因55CKt（即62)，所以再取出由指针Pa所指向的节点b，因56大于b节点的所有关键字，但必我小于终止标志x3（即MaxKey)，所以再取出由b节点的指针2所指向的节点f，因56然小于终止标志凡（即MaxKey），大于该节点的KI，小于终止标志几，所以接着向P.子树查找，因P.指针为空，所以查" ID="1">
          <fptr EndPN="00000301" StartPN="00000300"/>
        </Paragraph>
        <Paragraph CONTEXT="找失败，返回特定值（假定用一1表示）.待查的关键字用K表示，则在B一树上进行查找的算法描述为：" ID="2">
          <fptr EndPN="00000301" StartPN="00000301"/>
        </Paragraph>
        <Paragraph CONTEXT="斌seaJ陷h侃BNode＊M阿，KeyTyl竿幻" ID="3">
          <fptr EndPN="00000301" StartPN="00000301"/>
        </Paragraph>
        <Paragraph CONTEXT="刀从树根指针为MT的B＿树上查找关键字为K的对应记录的存储位置" ID="4">
          <fptr EndPN="00000301" StartPN="00000301"/>
        </Paragraph>
        <Paragraph CONTEXT="｛inli.”；MBNode.护MT；喃ile（P！二NULL）！11从树根节点起依次向下一层查找口月少＞k七ynum；ll把节点中的关健字个数斌给n1＝卜刀用1表示待比较的关键字序号，初值为1卜》keyln＋l】二MaxKey；刀把MaxK盯常t赋给序号为叶1的关键字域while（心卜》吐y［i］）1＋＋；万用K顺序同节点中的每一关键字进行比较，直到小11子等于某个关键字为止，此步也可采用二分杳找。斌K＝甲一》key【11）代tumP－＞成兄Ptrli］；ll查找成功返回记录的存储位t" ID="5">
          <fptr EndPN="00000301" StartPN="00000301"/>
        </Paragraph>
        <Paragraph CONTEXT="el阴" ID="6">
          <fptr EndPN="00000301" StartPN="00000301"/>
        </Paragraph>
        <Paragraph CONTEXT="p别卜＞Ptr卜11；刀继续向子树查找｝比n“n-1；11查找失败返回一1成和关键字总数N有关，下面就来讨论它们之间的关系。·Zsa·数据结构一方面，s＿树中的空指针数C1应等于总指针数C2减去非空指针数C3，而总指针数又等于关键字的总数N加上所有节点数C4，这是因为每个节点中的指针数等于其关键字数加1，所以，所有节点的指针数就等于所有节点的关键字数加上节点数。除树根节点外，C1=C2-C3N+C4）一C3试N+C3+1）一C3=N+1" ID="7">
          <fptr EndPN="00000302" StartPN="00000301"/>
        </Paragraph>
        <Paragraph CONTEXT="即B一树中的空指针数等于关键字总数加】，这与二叉树中的的关系相同.综上所述，可列出如下不等式N+1多2Xrm/21'一”" ID="8">
          <fptr EndPN="00000302" StartPN="00000302"/>
        </Paragraph>
        <Paragraph CONTEXT="＿＿一‘" ID="9">
          <fptr EndPN="00000302" StartPN="00000302"/>
        </Paragraph>
        <Paragraph CONTEXT="个，即：求解后得：1e）lognN+1)m阶B＿树的高度h为：由以上分析可知，]ogN+1)hc1+log(NZ1)例如，当N10000,m二10时，B一树的高度不超过6，若由N=10001）个记录构成一裸幼刁者当廿r十IldiatEftr7kF不.I、E,Qnr,GfiEr田本目国匡么ran宣有由1wn了Iff六A二叉搜索树时，则树的高度至少为树上查找所需比较的节点数比在二叉搜索树上查找所需比较的节点数要少得多。这意味着若B＿树和二叉搜索树都被保存在外存上，若每读取一个节点需访问一次外存，则使用B一树可以大大地减少访问外存的次数，从而大大地提高处理数据的速度。" ID="10">
          <fptr EndPN="00000302" StartPN="00000302"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000302" TITLE="8.5.3  B_树的插入" TYPE="Chapter">
        <fptr LogicalPageNum="302" PhysicalPageNum="302"/>
        <Paragraph CONTEXT="在B＿树上插入一个元素的关键字x也同在二叉搜索树上类似，都首先要经过一个从第S章查找·289" ID="1">
          <fptr EndPN="00000303" StartPN="00000302"/>
        </Paragraph>
        <Paragraph CONTEXT="m.PaGi,Pa(Ks,Ps，(JCPte}除xfnl外分为前后两个部分.分别存于a和a‘节点中.a节点中的信息为：「ml2-1,Pa(K,Pi，(xf+nl小PCzl二）" ID="2">
          <fptr EndPN="00000303" StartPN="00000303"/>
        </Paragraph>
        <Paragraph CONTEXT="a’节点中的信息为：" ID="3">
          <fptr EndPN="00000303" StartPN="00000303"/>
        </Paragraph>
        <Paragraph CONTEXT="m一「拼佗1，竹砒（玲初袖，计枕、：），一，(K,P则插入到K，和P.的位置上）。当a节点的前驱节点被插入一个索引项后，其关键字个数又有可能超过脚一1，若超讨又得伸该节点分裂为两个节点，其分裂过捍同上。在最坏的情祝下.这种从叶子节点$Picture[00000303\00000303_new\0016.jpg]Picture$点的中项关键字Kr翩，左子树是以原树根节点为根的子树，右子树是由原树根节点分裂出的一个新节点为根的子树。在B＿树中通过插入关键字可能最终导致的根节点的分裂从" ID="4">
          <fptr EndPN="00000303" StartPN="00000303"/>
        </Paragraph>
        <Paragraph CONTEXT="若在此树上依次插入关键字65，24，50和所示." ID="5">
          <fptr EndPN="00000303" StartPN="00000303"/>
        </Paragraph>
        <Paragraph CONTEXT="1，最多为2，当插入后关键字的个数为3时，就得分裂成两个节点，让原有节点只保留第1个关键字和它前后的两个指针，让新节点保存原有节点中的最后一个（即第3个）关键字和它前后的两个指针，让针，原有节点的第2" ID="6">
          <fptr EndPN="00000303" StartPN="00000303"/>
        </Paragraph>
        <Paragraph CONTEXT="驱节点中，若没有前驱节点，则就生成一个新的根节点，并将原树根节点和分裂出的节" ID="7">
          <fptr EndPN="00000303" StartPN="00000303"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000303" TITLE="8.5.4  B_树的删除" TYPE="Chapter">
        <fptr LogicalPageNum="303" PhysicalPageNum="303"/>
        <Paragraph CONTEXT="·24a·数据结构迹蜜飞介亘扩毓" ID="1">
          <fptr EndPN="00000304" StartPN="00000304"/>
        </Paragraph>
        <Paragraph CONTEXT="区募蕊" ID="2">
          <fptr EndPN="00000304" StartPN="00000304"/>
        </Paragraph>
        <Picture URL="00000304\00000304_new\0005.jpg">
          <fptr EndPN="00000304" StartPN="00000304"/>
        </Picture>
        <Paragraph CONTEXT="（n$Picture[00000304\00000304_new\0009.jpg]Picture$$Picture[00000304\00000304_new\0010.jpg]Picture$叶子节点中删除之.例如，若从图8.7(h}中删除关键字46时，首先要将它与中序前驱$Picture[00000304\00000304_new\0013.jpg]Picture$关键字38或中序后继关键字50对调：然后再从对调后的叶子节点中删除关键字46。从以下三种情况进行处理：(1}若删除后该节点的关键字个数除关键字18或32时就属于这种情况。n）「m/2-1，则删除完成.如从图8.7(a）中删的关键字个数n&gt;「m/21-i，则首先将双亲节点中的指向该节点指针的左边（或右边）一如从图8.7第8章查找·291节点中的最小关键字58上移至双亲节点中刚空出的位置上，然后把右兄弟节点中的原Pfl指针（即为空）赋给被删除关键字32节点的P1指针域." ID="3">
          <fptr EndPN="00000305" StartPN="00000304"/>
        </Paragraph>
        <Paragraph CONTEXT="rz14雪ilNl1f弘巨;i.劝k.tGtr3自旦之月、翻r-zrW乃l，r同时它的左兄弟和右兄弟（若有的下台击闷p奄七UJ亡，的七七0苗山4苗右兄弟中通此时就必须进行节点的“合并”，即将该节键字个数为0，低于规定的下限1，但它的左兄弟和右兄弟中的关键字个数都只有一个（即为最低限），所以只能将该节点中剩余的关键字（在此没有）和指针（在此为空）连同双亲节点中的关键字抖一起合并到左兄弟节点中，然后将包含被删除关键字46的茁亘二蕊）（心）图8.8B＿树的删除当从一棵B＿树的叶子节点中删除一个关键字后，可能出现上面所述的第（3）种情2蕊刁夺勺胃知玉，亡书夕、节产＿洲凡八‘翻全之争.刁言蔺六飞j上咙出.七七玉卫山.砂5＿洲人汽户自自赶梦，砚六，忆二J‘暇亡学r沪内月晓胃！丫石1艺合并而被下移）了一个关键字，而双亲节点被删除一个关键字（实际为所在的索引项及·z·数据结构关键字12后只剩下一个关键字20.同时它的右兄弟（没有左兄弟）节点中只含有两个关键字.所以又得继续合并，即把b节点中的一个关键字和两个指针同根节点a的一个关键字一起合并到c节点中。使c节点成为新的树根节点，导致整个B一树减少一层，最后(c1图a.9在五阶s＿树上删除关键字导致其高度减少一层的情况B＿树的插入和删除算法比较复杂.概括地说，在插入时，首先要为待插入的关键字$Picture[00000306\00000306_new\0012.jpg]Picture$序表的插入方法把索引项（K,NULL,recp)插入到a节点的第i个位置上（recp表示对应$Picture[00000306\00000306_new\0014.jpg]Picture$;户寻tih左任衍苦、被谷正徘斤括入石的括仄b卜翻吉311T里西斗l占七.卜。亦翻1睦$Picture[00000306\00000306_new\0016.jpg]Picture$第8章查找.293关键字K所在的索引项，然后再进行删除后的循环处理，直到不需要合并节点为止。关于B＿树的插入和删除的具体算法这里不给出，有兴趣者可参考书后参考书目中所列的第" ID="4">
          <fptr EndPN="00000307" StartPN="00000305"/>
        </Paragraph>
        <Paragraph CONTEXT="二本书籍。" ID="5">
          <fptr EndPN="00000307" StartPN="00000307"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000307" TITLE="8.5.5  Bˉ+树简介" TYPE="Chapter">
        <fptr LogicalPageNum="307" PhysicalPageNum="307"/>
        <Paragraph CONTEXT="B树分为B一树和B＋树两种，它们的树结构大致相同.一裸二阶的s＋树和一棵.阶的B＿树的差异是：" ID="1">
          <fptr EndPN="00000307" StartPN="00000307"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)在B＿树中，含有，个关键字和n棵子树，即每个关键字对应一棵子树.C2）在B＿树中，每个节点（除树根节点外）中的斗中的关键字个数n的取值范围是：r-1cnC。一1，而在B＋树中，每个节点（除树根节点外〕中的关键字个数。的取值范树根节点的取值范围是l簇n蕊mt3)B今树中的所有叶子节点包含了全部关键字及指向对应记录的指针，且所有叶子节点按关键字从小到大的顺序依次链接。例如，图8.10所示为一棵三阶的B中树，其中叶子节点的每个关键字下面的指针表示例如，图8.10所示为一棵三阶的B中树，其中叶子节点的每个岁·294·数据结构当插入后节点中的关键字个数大于。时应分裂为两个节点，它们所含关键字个数分别为，，.已亡..二目.‘几，.弓刀目垃洲汤二护J，杯，占闷礴口卜.名.声，J氏‘一诬，龟」卜，。分J、一卜卜卜人儿胜纽一二一山‘更，白‘巴，，含，(m+1)12」和f[m+0121，同时要使得它们的双亲节点中包含有这两个节点的最大关键字和" ID="2">
          <fptr EndPN="00000308" StartPN="00000307"/>
        </Paragraph>
        <Paragraph CONTEXT="指向它们的指针，若双亲节点的关键字数目因此而大于脚，应继续分裂，依次类推。s+树的删除也从叶子节点开始.若叶子节点中的最大关键字被删除，则在非叶子节点中的值可以作为一个“分界关键字”存在：若因删除而使叶子节点中的关键字个数少于fm/21，则从兄弟节点中调！关键字或同兄弟节点合并的过程也同&gt;3＿树类似。均二" ID="3">
          <fptr EndPN="00000308" StartPN="00000308"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000308" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="308" PhysicalPageNum="308"/>
      <Paragraph CONTEXT="l.顺序查找既适应于顺序表，也适应于单链表，并且对表中元素的排列次序无要求.顺序查找的时间复杂度为U(n)，平均查找长度为（[n+l2," ID="1">
        <fptr EndPN="00000308" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="2.二分查找只能适应于顺序存储的有序表，不适应于单链表.二分查找的时间复杂度为O[logZn二分查找利定树是一裸理想平衡树，查找任一元素的边程对应该树中从寸林J相勺一条路径.二分查找的平均查找长度等于利定树中所有顶.点的层数之和的平均值。索引查找包括查找索引表和查找子表两个阶段.若索引表的长度为。，每个于毕" ID="2">
        <fptr EndPN="00000308" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="3.索引查找包括查找索引表和查找子表两个阶段.若索引表的长度为。，每个于表的平均长度为s，并假定采用顺序方法查找索引表和相应子表，则平均查找长度为1rn+s)12," ID="3">
        <fptr EndPN="00000308" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="4.分块查找是索引查找中的一种特例，其索引表中的索引值与主表中每个元素的关健字具有相同的数据类型，并且索引表是按索引值升序排列的，而每个子表中的元素排列可以任意安排." ID="4">
        <fptr EndPN="00000308" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="5.索引表分为稠密索引和稀疏索引两种，在稠密索引中每个索引项对应下一级表中的一条索引项或记录，在稀疏索引中每个索引项对应下一级表中的多条索引项或记录.在实际应用中，当主表《即原始翻以居记录〕很大时，可以建立多级索引." ID="5">
        <fptr EndPN="00000308" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="b.散列存储是根据元素的关健字计算存储地址的一种存储方法，此地址称为散列地址，用于计算地址的函数称为散列函数，用于存储元素的数组空间称为散列表." ID="6">
        <fptr EndPN="00000308" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="7.待散列存储的元素个数n与散列表长度。的比值称为散列表的装填因子，用a表示，它等于nlm.在利用开放定址法处理冲突的散列存储中，a必须小于等于i，在利用一一一一一一一鱼翌.灼5.30.在一裸。阶B一树中，所有叶子节点都处在同一层上.在所有节点中，树根节.t至少具有一个关健字和两裸于树，至多具有。一l个关健字和。裸子树；非树根节点至少树上侧除节.饭可以引起节点合并，它们是最终引起树的高度增1或减1的帷一途径." ID="7">
        <fptr EndPN="00000309" StartPN="00000308"/>
      </Paragraph>
      <Paragraph CONTEXT="叠习。。" ID="8">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="S.l单选月" ID="9">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="1.对长度为l0的顺序表进行查找，若查找前面S个元素的概率相同，均为1/8，查找后面5个元素的概率相同，均为3州旧.则查找任一元素的平均查找长度为‘）." ID="10">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.S.SB.5C.3918D.1914" ID="11">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="2.对长度为3的顺序表进行查找，若查找第一个元素的概率为112，查找第二个元素的概率为" ID="12">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="113，查找第三个元素的概率为116.则查找任一元素的平均查找长度为（）." ID="13">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.513B.2C.7/3D.413" ID="14">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="3，对长度为月的单链有序表，若查找每个元素的概率相等，则查找任一元素的平均查找长度为()o" ID="15">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.月CLB.(n+1112C{n一三)12D.n14" ID="16">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="4.对于长度为月的顺序存储的有序表。若采用二分查找，晰对所有元素的最长查找长度为《）的值的向上取整。" ID="17">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.1og2(n+US.1vgnC.n!2D.(r+l)f2" ID="18">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对于长度为。的顺序存储的有序表，若采用二分查找，则对所有元素的最长查找长度为《）的值的向下取整加le" ID="19">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.1ogz(n+l)B.1ogx+eGn12D.(a+l112" ID="20">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="6.对于长度为9的顺序存储的有序表.若采用二分合找，在等概率情况下的平均查找长度为《》的值除以9e" ID="21">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.2aB.万8C.25D.22" ID="22">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="7.对于长度为18的顺序存储的有序表，若采用二分查找。则查找第15个元素的查找长度为（）。" ID="23">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="A.3B.4C.5D.6" ID="24">
        <fptr EndPN="00000309" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="8.对于顺序存储的有序表（5.12,20,2b,37,42,45,S0,641，若采用二分查找，则查找元素26的查找长度为《)e，296·数据结构" ID="25">
        <fptr EndPN="00000310" StartPN="00000309"/>
      </Paragraph>
      <Paragraph CONTEXT="9.对具有。个元素的有序表采用二分查找.则算法的时间复杂度为《）。" ID="26">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O{s)B.O{nZ}C.O{1)D.O(logZn}]0.在索引查找中.若用于保存数据元素的主表的长度为n.它被均分为k个子表.每个子表的长度均为。Ik，则索引查找的平均查找长度为‘）。" ID="27">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.n+kB.k十川无C.（虎＋川几破D，（走＋川几胶＋1I1.在索引查找中，若用于保存数据元素的主表的长度为二.它被均分为若干个子表，每个子表的长度均为s，则索引查找的平均查找长度为（）。" ID="28">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.{n+s2B.(nls+s2+1C.(n+s)12+ID.{n/s+s)12" ID="29">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="12.在索引查找中.若用于保存数据元素的主表的长度为144，它被均分为l2个子表，每个子表的长度均为!2，则索引查找的平均查找长度为（）." ID="30">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.13B.24C.12D.79" ID="31">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="13.在索引查找中，若用于保存数据元素的主表的长度为117，它被均分为4个子表，则索引查找的平均查找长度为《）." ID="32">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.11B.12C.13D.9" ID="33">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="14.若根据数据集合｛23,44,36,48,52,73,64,58}建立散列表，采用h(KK9613计算散列地址，并采用链接法处理冲突，则元素研的散列地址为（，." ID="34">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.4B.8C.12D.13" ID="35">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="15.若根据数据集合｛23.44,36.48,52,73.64.58}建立散列表，采用h{KK96，计算散列地址，则同义词元素的个数最多为（，个。" ID="36">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A,1B.2C.3D.4" ID="37">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="16.若根据数据长度为二的闭散列表，采用线性探测法处理冲突，假定对一个元紊第一次计算的散列地址为d.则下一次的散列地址为（）." ID="38">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.dB.d+巨C.（d＋1）加0.《d＋1）％祝" ID="39">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="17.在采用线性探测法处理冲突的散列表上，假定填充因子a的值为0.5，则查找任一元素的平均查找长度为（）。" ID="40">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.1B.1.5C.2.D.2.5" ID="41">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="18.在采用链接法处理冲突的开散列表上.假定填充因子a的值为4.则查找任一元素的平均查找长度为（）。" ID="42">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.3B.3.5C.4D.2.5" ID="43">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="19.在散列查找中.平均查找长度主要与（）有关。" ID="44">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.散列表长度B.散列元素的个数C.填充因子D.处理冲突方法" ID="45">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="20.在5阶B＿树中，每个节点最多允许有（〕个关键码." ID="46">
        <fptr EndPN="00000310" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="A.2B.3C.4D.5第S章查找.297-" ID="47">
        <fptr EndPN="00000311" StartPN="00000310"/>
      </Paragraph>
      <Paragraph CONTEXT="21.在一裸含有二个关键字的S＿树中，所有节点中的空指针数为（）个。" ID="48">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="A.陀B.n+1C.n-1D.2n" ID="49">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="22.在一棵高度为h的B＿树中.当插入一个新关键字时，为查找插入位t需访问（）个节点." ID="50">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="A.hB.1什IC.h-1D.2h82i" ID="51">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="1.以顺序查找方法从长度为”的顺序表中查找一个元索时.平均查找长度为＿，时间复杂度为" ID="52">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="2。以二分查找方法从长度为。的有序表中查找一个元素时，平均查找长度小于等于＿，时间复杂度为＿." ID="53">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="3.以二分查找方法从长度为12的有序表中查找一个元素时，平均查找长度为＿。" ID="54">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="4.对于二分查找所对应的判定树，它既是一棵―，又是一裸―." ID="55">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="3.假定对长度n=30的有序表进行二分查找，则对应的判定树高度为＿，判定树中前5层的节点数为＿，最后一层的节点数为＿。" ID="56">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="6.在索引表中.每个索引项至少包含有―域和―域这两项。" ID="57">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="7.假定一个线性表为（12,23,74,Si,63,40.82,36)，若按Key963条件进行划分，使得同一余数的元索成为一个子表，则得到的三个子表分别为、…和二" ID="58">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="8.在索引表中.若一个索引项对应主表中的一条记录，则称此索引为＿索引，若对应主表中的若干条记录，则称此索引为＿索引。" ID="59">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="9.在稀硫索引表上进行二分查找时，若当前查找区间为空，则不是返回一1表示查找失败，而是返回该区间的＿。" ID="60">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="并假定每个子表的长度均为石，则进行索引查找的平均查找长度为＿，时闻复杂度为＿。" ID="61">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="11.若对长度。laas〕的数据表进行二级索引存储，每级索引表中的索引项是下一级as个记录的索引，则一级索引表的长度为＿，二级索引表的长度为＿.lz，在数据的―存储中，对每一个元素只能采用顺序存取。" ID="62">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="13.假定对数据集合《38,25,74,32,48}进行散列存储，采用ht'1=K07作为散列函数，若分别采用线性探查法和链接法处理冲突.则对各自散列表进行查找的平均查找长度分别为＿和一." ID="63">
        <fptr EndPN="00000311" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="14.假定要对长度。100的数据集合进行散列存储，并采用链接法处理冲突，则对于长度»曰20的散列表，每个散列地址的单链表的长度平均为＿.巧，在线性表的散列存储中.装填因子a又称为装填系数，若用二表示散列表的长度，摊表示待散·248·数据结构" ID="64">
        <fptr EndPN="00000312" StartPN="00000311"/>
      </Paragraph>
      <Paragraph CONTEXT="16.在线性表的散列存储中.处理冲突有和两种方法。" ID="65">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="17.对于一棵含有N个关键字的。阶B＿树，其最小高度为，最大高度为＿" ID="66">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="17.对于一棵含有N个关键字的。阶B＿树，其最小高度为，最大高度为＿＿二" ID="67">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT=".0口加，－妇田，一少口人.七呼d，刁卜协才‘n‘月、内汽考.叫扮m＂二方七踌配，舌己，.、力二.白二习，月压4.卫里口奋从，" ID="68">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="18.一.19在一棵九阶的B＿树中.每个非树根节点的关键字数目最少为…个.最多为个." ID="69">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="20.在对。阶B＿树插入元素的过程中，每向一个节点插入一个索引项（叶子节点中的索引项为关键字和空指针）后.若该节点的索引项数等于个，则必须把它分裂为…个节点。" ID="70">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="21.在从，阶的B＿树删除元素的过程中，当一个节点被删除掉一个紊引项后，所含索引项数等于" ID="71">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="个，并且它的左、右兄弟节点中的索引项数均等于个，则必须进行节点合并。，，自一坦n甘坛入开去的冲娜山＿甚昌挂已！翻姗拐节占的斗烈＿翻！新树冲店树的寡时" ID="72">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="22.向一裸B＿树插入元素的过程中，" ID="73">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="一." ID="74">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="23.从一棵B＿树删除元素的过程中，若最终引起树根节点的合并，则新树比原树的高度.83运算月" ID="75">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="1.假定查找有序表人【乃1中每一元素的概率相等。试分别求出进行顺序、二分和分块（假定被分为，块，每块5个元素〕查找每一元素时的平均查找长度。" ID="76">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="2.假定一个待散列存储的数据集合为！32，75，29，63，48，94，25，46，18，7川，散列地址空间为HT［13］，若采用除留余数法构造散列函数和线性探查法处理冲突，试求出每一元素的散列地址，画出最后得到的散列表.求出平均查找长度。" ID="77">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="3.假定一个待散列存储的数据集合为《32.75，29，63，48，94，25，36，18.70｝.散列地址空间为卜仃［川，若采用除留余数法构造散列函数和链接法处理冲突，试求出每一元素的散列地址，画出最后得到的散列表，求出平均查找长度." ID="78">
        <fptr EndPN="00000312" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="4.已知一组关键字为（26，38，12.45。73，64，30，561.试依次插入关键字生成一棵三阶的B＿树，画第8章查找·299乐刁算法设计姐" ID="79">
        <fptr EndPN="00000313" StartPN="00000312"/>
      </Paragraph>
      <Paragraph CONTEXT="1.编写一个非递归算法，在稀疏有序索引表中二分查找出给定值K所对应的索引项，即索引值刚好大于等于x的索引项，返回该索引项的sta比域的值，若查找失败则返回一i" ID="80">
        <fptr EndPN="00000313" StartPN="00000313"/>
      </Paragraph>
      <Paragraph CONTEXT="2.假定有一个100x100的稀疏矩阵，其中1％的元素为非零元素，现要求对其非零元素进行散列存储，使之能够按照元素的行、列值存取矩阵元素（即元素的行、列值联合为元素的关键字）.试采用除留余数法构造散列函数和线性探查法处理冲突，分别写出建立散列表和查找散列表的算法。咋弓踢" ID="81">
        <fptr EndPN="00000315" StartPN="00000313"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000309" TITLE="习题8" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
    <div ORDERLABEL="00000315" TITLE="第9章  排序" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="00000315" TITLE="9.1  排序的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="315" PhysicalPageNum="315"/>
      <Paragraph CONTEXT="排序《Sorting)是数据处理领域一种址常用的运算.排序的kl的主要是为了方使六1戈.由上一章可知.对于一个顺序存储的数据表.若不经过排序而六找.则时间赵杂度为O(n在排）f的几r础卜进行二分杳找·k1时间复itc`可提高390(loc：，i效果iLT1当显著的‘排序就是把一组记录（元素）按照某个域的值的递增（即由小到大）或递减（即由大到小）的次序重新排列的过程。通常把用于排序的域称为排序城或排序项.把该域中的每一个值（它与一个记录相对应）称为排序码.为了以后讨论方便，假定排序域的域名用标识符9t11表示.如对于具有ElamType类型的一条记录x来说，x.st。为它的排序码。设待排序的一组，个记录为{Ra,Ri,…,一，｝，对应的排序码为硬SaSu5。一小若排序码的递增次序为《'，S'一i，即So'攫Sl'簇续5，则按递增排序后的记录玫序为套R欲R.，.一1L1.其中R(O蕊i延n-1)1排序码为S(O毛i毛n-ll：若排序码的次序为侄叮，RI，，一凡一l’l，递减次序为！50＂.51，’.…，氏一1，’），即Son）51即〕二）5。一则按递减排序后的记录次序为《鱿，R厂，·，凡一1，’l.其中旷的排序码为St’’（0蕊1毛。一1）.例如，在表9－1中，若以每个记录的职工号为关键字，以基本工资为排序码：则所有8条记录可简记为：《（1呱1348）.（101，1574）t（1此1224），（103，1205），（104，1729），（1仍，1548），.。数据结构面z―TYS/IJIR｛1SIRYf.W扭:1211若按排序码的递增次序对记录进行重排，则得到的排序结果为：1{16,1084(103,1205{102,1224(107.1324(100,1348{105,1548(101,1574(104,1729若以每个记录的出生日期为排序码（出生日期为8位字符串，其中前四位数字代表出生年份，中间两位数字代表月份，最后两位数字代表月内日号），并按出生日期从前到后的次序（即递增次序）对记录进行重新排列，则得到的排序结果为：I03,1951/03/2b(100,19611041'15(142,1963/06R8(105,1965/12/l8(107,19r,nvza(101,1971ro3112c1oa.197arosro3c106.1980ro3rzs)}一组记录按排序码的递增或递减次序排列得到的结果称之为有序表，序前的状态称为无序表；递增次序又称为升序，递减次序又称为降序.码升序排列的，则称为升序表：若按相反次序排列，则称为降序表。今J全日j上T毛性Sddi+3uF16SftFr1当·已岂Eti?ACb1G;ts叮宝己习匕+f,i匕xLr之，并且若不特别指明.所说的有序均指升序，也可以是任何非关键字，所以排序码相同的记录可能只有一个，也可能有多个。对于具有同一排序码的多个记录来说，若采用的排序方法使排序后记录的相对次序不变，则称此排序方法是稳定的，否则称为不稳定的。如假定一组记录trl排序码为（23,15,72,18,23,40)，其中排序码同为23的记录有两个，为了" ID="1">
        <fptr EndPN="00000316" StartPN="00000315"/>
      </Paragraph>
      <Paragraph CONTEXT="18,23,赴,40,72)，则称此方法是稳定的；若一种排序方法使排序后的结果可能为（15,第9章排序，303间的数据交换，则称为外排序。显然，外排序速度比内排序速度要慢得多。对于一些较大btrtri山门口rb7s贪很-bhfi61幽lx自协一冲且古aref7z;ft4千r*r口但理田bikI的数据文件.由于内存容量的限制，不能一次装入内存进行内排序，只得采用外排序来完成。内排序方法有许多种，按所用策略不同，可归纳为五类：插入排序、选择排序、交换排序、归并排序和分配排序。在本书第2章和第3章中已经讨论了插入排序方法，本章将讨论最常使用的选择排序、交换排序和归并排序方法。对于外排序只讨论归并排序方法。" ID="2">
        <fptr EndPN="00000317" StartPN="00000316"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000317" TITLE="9.2  选择排序" TYPE="Chapter">
      <fptr LogicalPageNum="317" PhysicalPageNum="317"/>
        <div ORDERLABEL="00000317" TITLE="9.2.1  直接选择排序" TYPE="Chapter">
        <fptr LogicalPageNum="317" PhysicalPageNum="317"/>
        <Paragraph CONTEXT="直接选择排序（StraightSelectSorting}也是一种简单的排序方法。它每次从待排序的区间中选择出具有最小排序码的元素，把该元素与该区间的第一个元素交换位置。第一认，i日na,t.、k3七.主两'i'I.i才r6‘二右'共息毕wrm.wr二1y3;f;tk王居tt决Zi/h暇兰wrm）l,目待排序区间包含所有元素A【0］一A［n-11，经过选择和交换后，A［0】为具有最小排序码的元素；第二次待排序区间为A［l1-A［n-1］，经过选择和交换后，A［l〕为整个排序过程结束。例如，假定n＝8.数组A中8个元素的护（0）13.62，铭乒“54320，吕］数组A中8个元素的排" ID="1">
          <fptr EndPN="00000317" StartPN="00000317"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）1212.，45366，43’职当5］孑码为：、2，1：元，甲3‘。543争5：1（36.25，48，12，65.43，20，58）（3）122。乃t36“434858］图9.1序码位置的变动情况，其中中括号内为待排序（，）”2。乃" ID="2">
          <fptr EndPN="00000317" StartPN="00000317"/>
        </Paragraph>
        <Paragraph CONTEXT="区间，它是一个无序表，中括号前面为已排好" ID="3">
          <fptr EndPN="00000317" StartPN="00000317"/>
        </Paragraph>
        <Paragraph CONTEXT="元素，它是一个有序表。（71”加”。3U4·数据结构for(i=1;ia-1;i＋十》" ID="4">
          <fptr EndPN="00000318" StartPN="00000317"/>
        </Paragraph>
        <Paragraph CONTEXT="{11i表示次数，共进行n-1次选择和交换k二卜1;11用k保存当前得到的最小排序码元素的下标，初值为1-Zfoj=i;jn-1；,j+f{11从当前排序区间中顺序查找出具有最小排序码的元素A[k]ifA[jI.smtA[kI.son)k=j;" ID="5">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
        <Paragraph CONTEXT="乡" ID="6">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
        <Paragraph CONTEXT="if{ki-l){11把人［[k］对调到该排序区间的第一个位置，即i-1位置x二A[i-11;A[i-11=A[kl；A[kx;" ID="7">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="8">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="9">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
        <Paragraph CONTEXT="}在直接选择排序中，共edILL要进行n-I次选择和交换，每次选择需要比较n-i次，其中l蕊i蕊n-1，每次交换最多需移动3次记录，故总比较次数商2，；-lM=3=3(。一：）可见，直接选择排序的时间复杂度为。（矛），但由于它移动记录的总次数为。(n)数量" ID="10">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
        <Paragraph CONTEXT="所以当记录占用的字节数较多时通常比第2章所介绍的直接插入排序的执行速度要级，所以当记录占用的字节数较多时通常比第2快一些。" ID="11">
          <fptr EndPN="00000318" StartPN="00000318"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000318" TITLE="9.2.2  堆排序" TYPE="Chapter">
        <fptr LogicalPageNum="318" PhysicalPageNum="318"/>
        <Paragraph CONTEXT="第9章排序·305点（即编号为0的节点）止，依次对每个分支节点进行“筛”运算，以便形成以每个分古节占去娜的堆.当易居对树用节占排行偏长竺居.鹅个姗鼓袖成了一个性＿支节点为根的堆，下面讨论如何对每个分支节点R(fl‘ic【碗-1）进行筛运算，以便构成以Ri为根的堆.因为，当对久进行筛运算时，比它编号大的分支节点都已进行过筛运算，即已形成堆.其中包括以民的左、右子节然若子节点为叶子节点，则认为叶子贡其左、右子树均为堆的基础上实现的。筛运算的过程可叙述为：成为堆，筛运算完毕。否则孔与R/互换位置，互换后可能破坏以R/（此时的R/的值为原来的凡的值）为根的堆，接着再把畴与它的两个孩子中排序码较大者进行比较，依次类推，直到父节点的排序码大于等于子节点中较大的排序码或者子节点为空时止。这" ID="1">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Picture URL="00000319\00000319_new\0018.jpg">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Picture>
        <Paragraph CONTEXT="则会被逐层下移.就像过筛子一样，小的被漏下去，大的被选上来，所以把构成堆的过程形象地称为筛运算。图9.2给出了对待排序元素的排序码序列（45,36,1S,53,72,34,48,93,15,3b）构成" ID="2">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="所以从编号为4的节点起至树根节点止，" ID="3">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="节点进行筛运算。图9.2(a）为按照原始排序码序列所构成的完全二叉树，图9.2(b)" ID="4">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="图9.2(f)为依次对每个分支节点进行筛运算后所得到的结果.其中图9.2(f)为最后构" ID="5">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="成的初始堆." ID="6">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="则对A[i进行筛运算的算法描述为：" ID="7">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="voidSit7t(ElemTypeAiotn,inti)" ID="8">
          <fptr EndPN="00000319" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="/1对A[n]数组中的A[i]元素进行筛运算，·306·数据结构u修改1和i的值，以便继续向下'd奋" ID="9">
          <fptr EndPN="00000320" StartPN="00000319"/>
        </Paragraph>
        <Paragraph CONTEXT="tinebreak;查找到x的最终位置.终止循环】" ID="10">
          <fptr EndPN="00000320" StartPN="00000320"/>
        </Paragraph>
        <Paragraph CONTEXT="A[i]二；11被筛节点的值放入通终位宜" ID="11">
          <fptr EndPN="00000320" StartPN="00000320"/>
        </Paragraph>
        <Paragraph CONTEXT="｝$Picture[00000320\00000320_new\0012.jpg]Picture$$Picture[00000320\00000320_new\0013.jpg]Picture$1iF1s$Picture[00000320\00000320_new\0016.jpg]Picture$$Picture[00000320\00000320_new\0017.jpg]Picture$下移一层(c)(d1i$Picture[00000320\00000320_new\0021.jpg]Picture$$Picture[00000320\00000320_new\0022.jpg]Picture$一－叫卜下移两层iel(fl第9章排序·307$Picture[00000321\00000321_new\0002.jpg]Picture$一鱼丛.$Picture[00000321\00000321_new\0007.jpg]Picture$$Picture[00000321\00000321_new\0008.jpg]Picture$下移两层（.）少）A61s$Picture[00000321\00000321_new\0012.jpg]Picture$$Picture[00000321\00000321_new\0013.jpg]Picture$卜下移两层(c)(d)$Picture[00000321\00000321_new\0017.jpg]Picture$$Picture[00000321\00000321_new\0018.jpg]Picture$93b卜" ID="12">
          <fptr EndPN="00000321" StartPN="00000320"/>
        </Paragraph>
        <Paragraph CONTEXT="下移一层。0＠。0。{c1(fl" ID="13">
          <fptr EndPN="00000321" StartPN="00000321"/>
        </Paragraph>
        <Paragraph CONTEXT="图9.3利用堆排序的图形示例" ID="14">
          <fptr EndPN="00000321" StartPN="00000321"/>
        </Paragraph>
        <Paragraph CONTEXT="堆排序的算法描迷为：·3p8·数据结构for(i=n/2-I;ia印;i一）" ID="15">
          <fptr EndPN="00000322" StartPN="00000321"/>
        </Paragraph>
        <Paragraph CONTEXT="Sift(A,n,i11建立初始堆" ID="16">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=1;in-l;i" ID="17">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="{11进行n-1次循环，完成堆排序" ID="18">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="x=A[01;A[QA[n-iA[n-it=x:刀将树根节点的值同当前区间内最后一个节点的值对换Sift(A,n-i,pIliA[p]节点.得到n-i个节点的堆}" ID="19">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="f假定n=8，数组A中8个元素的排序码为（36.25,48,12,65,43,20,58{9.4(a）和（b）分别给出了在构成初始堆和利用堆排序的过程中，每次筛运算后数组A中各元素排序码变动的情况。&quot;F标01?34567" ID="20">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(or" ID="21">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="：｝｛" ID="22">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)" ID="23">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(41" ID="24">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="1016558483625432D12" ID="25">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(11583b481225432065" ID="26">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(214$36431225205865" ID="27">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(31433612?S485865" ID="28">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(4?3633201243485865" ID="29">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)25i22p3643485865" ID="30">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(by?0t22536434858b5" ID="31">
          <fptr EndPN="00000322" StartPN="00000322"/>
        </Paragraph>
        <Paragraph CONTEXT="(7)12?425364348586i在整个堆排序中，共需要进行n+n/2-1次（约3n/2次）筛运算，每次筛运算进行父子或兄弟节点的排序码的比较次数和记录的移动次数都不会超过完全二叉树的高度，第9章排序·309$Picture[00000323\00000323_new\0002.jpg]Picture$中选择一个最小值，），所以整个直接选择；.每次从待排序区间狗，其时间复杂度为O(n)，所以整个直接选择同样需要进行n-1次选择.每次从待排序区间值，而选择最大值的方法是在各子树已是堆的（即当前筛运算的区间）中选择一个最大值，基础上对根节点进行筛运算（即树形比较）实现的，其时间复杂度为O(logZn)，所以整个外，直接选择排序和堆排序都是不稳定的，空间复杂度也都为o(1)a" ID="32">
          <fptr EndPN="00000323" StartPN="00000322"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="选择排序主要包括直接选择排序和堆排序两种." ID="1">
        <fptr EndPN="00000317" StartPN="00000317"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000323" TITLE="9.3  交换排序" TYPE="Chapter">
      <fptr LogicalPageNum="323" PhysicalPageNum="323"/>
        <div ORDERLABEL="00000323" TITLE="9.3.1  气泡排序" TYPE="Chapter">
        <fptr LogicalPageNum="323" PhysicalPageNum="323"/>
        </div>
        <div ORDERLABEL="00000325" TITLE="9.3.2  快速排序" TYPE="Chapter">
        <fptr LogicalPageNum="323" PhysicalPageNum="323"/>
        <Paragraph CONTEXT="想是通过相邻元素之间的比较和交换使排序码较小的元素逐渐从底部移向顶部.即从下" ID="1">
          <fptr EndPN="00000323" StartPN="00000323"/>
        </Paragraph>
        <Paragraph CONTEXT="+Y,s-目roc,as石共签分r,〕口去公‘.a.c,a；共合+才自叮主-za在rLei一云彗;工封嵘r,H1目1之1扁脚公t淆邀多3i序码较小的元素逐渐上移，排序码较大的元素也逐渐下移.气泡排序过程可具体叙述为，首5Fr.将Afn-11元素的排序码同Afn-21元素的排序码讲行比较。若Afn-li.stn&lt;为：首先将A［n-1］元素的排序码同A［n-21元素的排序码进行比较，若A［n-11.stn＜几r＿，1.一爪日刃愉七执决石；书.月乡r叱1矛为月弓，击t再全J，日n划七已艺丈双盆八.I、创，；共习毕、卜句场生后.习匕.，日n月L亡睡小的元素）上浮，重者（民排序码，同样使轻者上浮，并使轻者上浮重者下沉后，Aln-ZI.stn，则于重者-310·数据结构浮的位置。在此过程中，从第四趟排序起，没有出现排序码的交换，表明元素己经有良1月层父续告的娜良习井里今业夕千voidBubbleSort(ElemTypeAintn)11采用气泡排序的方法对数组A中的n个元素进行排序" ID="2">
          <fptr EndPN="00000324" StartPN="00000323"/>
        </Paragraph>
        <Paragraph CONTEXT="i" ID="3">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypex;" ID="4">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,flag;ford=l;i=n-l;i{11i表示+数.最多进行n-1趟" ID="5">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="flag;11flag表示每一趟是否有交换.在进行每一趟之前11置为0，表示无交换fvr(j=n-t:ji;j一）11进行第ij排序" ID="6">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="if(A[jI.stn[A[j-1I.Strl){" ID="7">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="x二AGI;A[11=AG-1］;All-11=x;" ID="8">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="flag=1;" ID="9">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="}if(flag=川)return;刀进行一趟后若无交换，表明已有序，则返回。" ID="10">
          <fptr EndPN="00000324" StartPN="00000324"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝从气泡排序算法可以看出，若待排序元素为有序，即最好情况，则只需进行一+排序，其记录（元素）的比较次数为n-1次，且不移动记录。反之，任，乙n-1次，移动次数为梦3（。一1）＝县（矿一。〕次，因为每次交换需移动3次记录：在平均情况份罗‘下，比较和移动记录的总次数大约为最坏情况下的一半。因此，气泡排序算法的时间复杂度为0（矛）。由于气泡排序通常比直接插入排序和直接选择排序需要移动较多第9章排序·311种种种种种种种种种种种种种" ID="11">
          <fptr EndPN="00000325" StartPN="00000324"/>
        </Paragraph>
        <Picture URL="00000325\00000325_new\0006.jpg">
          <fptr EndPN="00000325" StartPN="00000325"/>
        </Picture>
        <Paragraph CONTEXT="进行的，记录每次交换只能上移或下移一个相邻位置，因在快速排序中，记录的比较和交换是从两端向中间进行排序码较小的记录一次就能够交换到前面单元，记录每次移动的距离较远，因而总的比较和移动次数较少。A[n］元素的排序码域预先赋值为比所有排序码都要大的一个值，作为“岗哨”，以便能够终止同排序区间后无效位置的比较）中选取一个元素（为方便起见，一般选取该区间的第一个元素，若不是，则要把它同第一个元素交换其值）作为比较的基准元素，通过从的那个元素交换其值，当所有元素的排序码都比较过一遍后，把基准元素交换到前后两部分单元的交界处，这样，前面单元中所有元素的排序码均小于等于基准元素的排序" ID="12">
          <fptr EndPN="00000325" StartPN="00000325"/>
        </Paragraph>
        <Paragraph CONTEXT="码，后面单元中所有元素的排序码均大于等于墓准元素的排序码，基准元素的当前位置就是排序后的最终位置，然后再对基准元素的前后两个子区间分别进行快速排序，即重就结束该区间上的快速排序过程。·312·数据结构假定A(101元素中存放的排序码为200，它大于所有的排序码。下面给出按照A[01元素的排序码45进行一次划分的过程，如图9.5所示。0I134S6784[45331836723048931536】移动比较" ID="13">
          <fptr EndPN="00000326" StartPN="00000325"/>
        </Paragraph>
        <Paragraph CONTEXT="几.了，3今.36乎.36｝4536183672304尽93155」】交换位皿" ID="14">
          <fptr EndPN="00000326" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="气尸1－万45兰1吕367230礴8931笋SJI移动比较几石通1毛4，丝”’6护.’04“”甲.川始姐【4536133615304一＊1，" ID="15">
          <fptr EndPN="00000326" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="t3o丝1忍3615454.93，2531交换Als］与＾UI" ID="16">
          <fptr EndPN="00000326" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="‘兰‘.130丝1名361514，14.9372531完成一次到分图9石在快速排序中进行一次划分的过程示例" ID="17">
          <fptr EndPN="00000326" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="根据以上分析，编写出快速排序的递归算法如下：voidQuicksort（ElemTy讲All.ints.intt）11采用快速排序方法对数组A中Als］至Alt］区间进行排序.11开始进行非递归调用时5和t的初值应分别为0和n-1。｛11对当前排序区间进行一次划分" ID="18">
          <fptr EndPN="00000326" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="int云＝：，j二t＋1；11给1和j赋初值" ID="19">
          <fptr EndPN="00000326" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="EI翻Ty讲x二A〔5］；11把基准元素的值暂存：中第9章排序·313}while(i[j11条件成立时继续进行一次划分中的比较和交换A[s]二AGAG］二x;" ID="20">
          <fptr EndPN="00000327" StartPN="00000326"/>
        </Paragraph>
        <Paragraph CONTEXT="113换A[s]和A[j]的值，得到前后两个子区间刀在当前左区间内超过一个元素的情况下递归处理左区间if(s[j-l}QuickSort(A,s,j-1刀在当前右区间内超过一个元素的情况下递归处理右区间" ID="21">
          <fptr EndPN="00000327" StartPN="00000327"/>
        </Paragraph>
        <Paragraph CONTEXT="if(j+itt)QuickSort（人，j+1,t" ID="22">
          <fptr EndPN="00000327" StartPN="00000327"/>
        </Paragraph>
        <Paragraph CONTEXT="】仍以图9.6第一行元素的排序码为t4J+tl9.7'iti1用伏迷拜仔·活[4353183612304893153b的过程中，对每个区间划分后排序码303418361S145[4893。15k830[3b到4S[48937253嚣从排序结果可以看出：快速排序是.30丝36；54：1。3，：531曰仪1巴于n、些仓二二寸汗1浅了一可生由法冶扮d」丈丫幼扩城七六照，（a）所示。该树的高度为" ID="23">
          <fptr EndPN="00000327" StartPN="00000327"/>
        </Paragraph>
        <Paragraph CONTEXT="5，分支节点数为7，所以该排序算法过程需要进行4层划分，共包含有7个划分区间，·314·数据结构在快速排序中.记录的移动次数通常小于记录的比较次数，因为只有当记录出现逆（即A[iI.stru二A[sI.stn和A[jI.stn＜=A[sI.stn）时才需要把A[7同A[ja交换其值·灵。因此，讨论快速排序算法的时间复杂度只要按它的比较次数讨论即可。夕更：假定由快速排序算法过程得到的二叉搜索树是一棵理想平衡树。在理范节点数n同高度h的关系为logznlr‘1ogz刀十1，且前h-1层都是满的，最后－序（即Ali］.stn＞二Als］.stn和A川.sttl＜认15］.stn）时才需要把A［习同A切交换其值.即移动记录。因此，讨论快速排序算法的时间复杂度只要按它的比较次数讨论即可。为了讨论方便：假定由快速排序算法过程得到的二叉搜索树是一棵理想平衡树。在理想平衡树由节占梦先曰宣磨‘的兰玄去.。。＿一，‘＜1。，＿.、1日启嘴r‘＿1旦抓月.诀法的右蒸层＿巨毛峙中，节点数n同高度h的关系为ingZ，＜h‘1092刀＋1，且前h-1层刁子节点。由快速排序算法可知，进行每一层所有区间的划分时，为n＋1次，所以快速排序算法过程中比较记录的总次数C不大于（”＋l）x（h-1），因h-1石由以上分析可知，在快速排序算法过程得到的是一棵理想平衡树的情况下，其算法的时间复杂度为O（nlog2n）。当然这是最好的情况，在一般情况下，由快速排序得到的是证明，在平均情况下，快速排序的比较次数是最好情况下的ZlnZ倍，平均情况下快速排序算法的时间复杂度仍为0（n1092刀），并且系数比；：速排序的比较次数是最好情况下的ZlnZ倍，约1.39倍.所以在云的时间复杂度仍为0（nl092刀），并且系数比其他同数量级的排序少己经证明：当。较大时.它是目前为止在平均情况下速度最快在平均和最好情况下快速排序算法的空间复杂度为0‘10gZn），显的一种排序方法。另外，" ID="24">
          <fptr EndPN="00000328" StartPN="00000327"/>
        </Paragraph>
        <Paragraph CONTEXT="然它比前面讨论过的所有排序方法要多占用一些辅助存储空间。" ID="25">
          <fptr EndPN="00000328" StartPN="00000328"/>
        </Paragraph>
        <Paragraph CONTEXT="快速排序的最坏情况是得到的二叉搜索树为一棵单支树，如待排序区间上的记录已为升序或降序时就是如此，图9.8（b）给出了对为升序的5个元素fl，2，3，4，5｝时的情况。在这种情况下共需要进行n-1层，同时也是n-1次划分，每次划分得到一个子区间为空，另一个子区间包含有n-1个记录，1代表层数，取值范围为1簇1簇n-1，每层划分需要比辍。一1＋2）次，所以总的比较次数为望（，一‘＋2》·丢（。’＋3：一4），即时间复杂度份贯‘" ID="26">
          <fptr EndPN="00000328" StartPN="00000328"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000328" TITLE="9.4  归并排序" TYPE="Chapter">
      <fptr LogicalPageNum="328" PhysicalPageNum="328"/>
      <Paragraph CONTEXT="第9章排序·315理，有三路归并、四路归并等.二路归并最为简单和常用.既适用于内排序，也适用于外排序，所以我们只讨论二路归并.例如有两个有序表（7,12,15,20）和（4,8,10,17)，归并后得到的有序表为（4.7,8,10,12,15,17,20)。以后若不特别指明，所述的归并均指二路归并。二路归并算法很简单，假定待归并的两个有序表分别存于数组A中从下标s到下标m的单元和从下标m+1到下标r的单元（sum,rn+l.t)，结果有序表存于数组R中从下去荃.劝1门蔺台茫‘改1苗荞」上名卜言者卜离卜见llJ匕南今含月北龙军.充习俘配作宜―洲卜苗币二1匕生t名计邢弓从，目产创口标5到下标t的单元，并令1，j，k分别指向这些有序表的第一个单元。归并过程为：比较A［l1.sln和A田.sth的大小，若A旧.stn《A切.stn，则将第一个有序表中的元素A［习复制到元素A叨复制到Rtkl中.并令j和k分别加1：如此循环下去，" ID="1">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="幼知有幽｝点为介曰节巨吹只＿木右良丰由拍！奋的开妄有幽1荃llDr，直到其中的一个有序表比中从下标k到下标t的单R" ID="2">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="元。二路归并算法描述为：voidTw0MCrge（Elc.ITy讲A［］，曰朗订y件R［】.ints，int叭intt）刀把A数组中两个相邻的有序表Als］峨lm］和Alm＋l］峨［t］" ID="3">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="11归并为R数组中对应位置上的一个有序表RI习一R［t］" ID="4">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="5">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="inti，j，k；" ID="6">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="i－s；j二m＋1；k韶；11分别给指示每个有序表元素位置的指针赋初值" ID="7">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="11两个有序表中同时存在未归并元素时的处理过程" ID="8">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="while（1＜周m＆＆j倒）1找＾11］.stn＜二ADI.‘回fRlk】二A［1］；1＋＋；k＋＋；" ID="9">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="1" ID="10">
        <fptr EndPN="00000329" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="else｛义k】二人D］；j＋＋；k＋＋；1，31b教据结构｝归并排序（MergeSorting）就是利用归并操作把一个无序表排列成一个有序表的过若利用二路归并操作则称为二路归并排序.二路归并排序的过程是：首先把待排序｝（即无序表）中的每一个元素都看做为一个有序表，则。个元素构成月个有序表，区间接着两两归并，即第一个表同第二个表归并，第三个表同第四个表归并，……若最后只涌11门口＿洲人国甘翩1喇旨士众J业飞－盯＿幸幽.匕并名寺去星山怜喇宜瀚东，r－＿”，洲人」乙右‘内，j己‘＿关、目巨沪凶2‘右则直接进入下一趟归并，这样就得到了「耐21个长度为2〔最后一个表的长度的有序表，称此为一趟归并；然后再两两有序表归并，得到吓破1川个长度可能小于2）的有序表，称此为一趟归并；然后再两两有序表归并，（1！［45531119，6］1阅，2114，刃1【15（2！！183‘45531［知铭咒031［1，逃1" ID="11">
        <fptr EndPN="00000330" StartPN="00000329"/>
      </Paragraph>
      <Paragraph CONTEXT="13）118拍364548幻，293］1］5（4！115183036丝必铭53狡图9.9二路归并排序的过程示例" ID="12">
        <fptr EndPN="00000330" StartPN="00000330"/>
      </Paragraph>
      <Paragraph CONTEXT="要给出二路归并的排序算法，首先要给出一趟归并排序的算法。设数组A［n】中每个" ID="13">
        <fptr EndPN="00000330" StartPN="00000330"/>
      </Paragraph>
      <Paragraph CONTEXT="有序表的长度为址n（但最后一个表的长度可能小于len〕，进行两两归并后的结果存于数" ID="14">
        <fptr EndPN="00000330" StartPN="00000330"/>
      </Paragraph>
      <Paragraph CONTEXT="组R卜］中.进行一趟归并排序时，对于A中可能除最后一个（当A中有序表个数为奇数口汁、胃片杯石洲人，卫2人日，，阮.民声到匕泌、翅介J‘，田舀氏才口方吐‘二＿2人司艘内人F＿已云＿.＿，尸，＿n二、.健，目留，妇J小第9章排序·31711把数组A[n]中每个长度为kn的有序表两两归并到数组Rjn]中｛intper;/lp为每一对待合并表的第一个元素的下标，初值为Dwhile(p+2+len-14n-1){11两两归并长度均为kn的有序表TwoMerge(A,R,p,p+len-1,p+2*len-1P'二2＊len;" ID="15">
        <fptr EndPN="00000331" StartPN="00000330"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="16">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="if(p+len-lan-1?TwoMerge(A,R,p,p+ka-1,n-1" ID="17">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="11归井最后两个长度不等的有序表else" ID="18">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="for{inti=p;it-l;i什）" ID="19">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="R[iA[t11把剩下的最后一个有序表复制到R中｝二路归并排序的过程需要进fjlogxn，第一趟len等于1，以后每进行一趟将ten。假定待排序的n个记录保存在数组A[n】中，归并过程中使用的辅助数组为R[n加倍。假定待排序的n个记录保存在数组A［n】中，第一趟由A归并到R，第二趟由R归并到A：如此反复进行，序表为止。如果实际只需奇数趟〔即「fogZnl为奇数）完成，那么最后还要进行一趟，正好此时R月" ID="20">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="R中二路归并排序的算法描述为：voidMe卿Sort（ElemTy详All，intn）11采用归并排序的方法对数组A中的n个记录进行排序！E址mType‘R＝淤wElemT月冲【n］；刀定义长度为n的辅助数组R" ID="21">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="Intjc解1；11从有序表长度为1开始" ID="22">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="while（len＜n）【M哩e彻5认，R.n，len）；" ID="23">
        <fptr EndPN="00000331" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="刀从A归并到R中，得到每个有序表的长度为2＊len·318·数1·结构" ID="24">
        <fptr EndPN="00000332" StartPN="00000331"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="25">
        <fptr EndPN="00000332" StartPN="00000332"/>
      </Paragraph>
      <Paragraph CONTEXT="deleteR;11释放R数组所占用的动态存储空间｝二路归并排序的时间复杂度等于归并趟数与每一趟时间复杂度的乘积。归并趟数为（即由一个数组复扭一#d习五dicrhyAr1#r+k,竺：r4ryFr由;口李再6fi瑕下Qn右x1ra生上rc,a于rr省力，同牛,O(n)。因此二路归并排序的时间复杂度为O(nlogZn}二路归并排序时需要利用同待排序数组一样大小的一个辅助数组，所以其空间复杂二路归并排序是稳定的，因为在每两个有序表归并时.若分别在两个有序表中出现" ID="26">
        <fptr EndPN="00000332" StartPN="00000332"/>
      </Paragraph>
      <Paragraph CONTEXT="有相同排序码的元素，TwoMerge算法能够使前一有序表中同一排序码的元素先被复制，" ID="27">
        <fptr EndPN="00000332" StartPN="00000332"/>
      </Paragraph>
      <Paragraph CONTEXT="居一右南韦山阁一挑良祖的千去白游有krl11,而r但亡Idliph#:lrl7丈查ir习6" ID="28">
        <fptr EndPN="00000332" StartPN="00000332"/>
      </Paragraph>
      <Paragraph CONTEXT="从而确保它们的相对次序不会改变." ID="29">
        <fptr EndPN="00000332" StartPN="00000332"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000332" TITLE="9.5  各种内排序方法的比较" TYPE="Chapter">
      <fptr LogicalPageNum="332" PhysicalPageNum="332"/>
      <Paragraph CONTEXT="各种内排序方法之间的比较，、稳定性、算法简单性、待排杂度、不一坐＿健时问省态膺衡$Picture[00000332\00000332_new\0006.jpg]Picture$第9章排序·319快速排序比堆排序和归并排序速度快.由此可知，在最好情况下.直接插入排序和气泡" ID="1">
        <fptr EndPN="00000333" StartPN="00000332"/>
      </Paragraph>
      <Paragraph CONTEXT="：在平均情况下，快速排序最快；在最坏情况下，堆排序和归并排序最快.从空间复杂度看，所有排序方法可归为三类，归并排序单独属于一类.舅" ID="2">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)从空间复杂度看，所有排序方法可归为三类，归并排序单独属于一类.其空间复杂度为U(n)：快速排序也单独属于一类，其空间复杂度为O(log2n)：其他排序方法归" ID="3">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
      <Paragraph CONTEXT="七丝一二二创险1c`3r'艺4Fnltldl.W石1.dst'i：：Lk雀萝仓上bh:311毛汀力」FF石虱ftZ.'一31E4/r为第三类，其空间复杂度为0（1）。由此可知，之，第一类最差。" ID="4">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）从稳定性看，所有排序方法可分为两类，一类是稳定的，它包括直接插入排序、气泡排序和归并排序；另一类是不稳定的，它包括直接选择排序、" ID="5">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）从算法简单性看，一类是简单算法，它包括直接抽入排序、直接选择排序和气：序，这些算法都比较简单和直接，易于理解；另一类是改进后的算法，它包括堆排" ID="6">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
      <Paragraph CONTEXT="快速排序和归并排序（归并排序可看做为对直接插入排序的一种改进，’它把记录分对记录的插入和移动改为向另一个数组的复制），这些算法都较复杂一些.从待排序的记录数n的大小看，。越小，采用简单排序方法越合适，滩越大采用：均小于1（除气泡排序中最坏情况外），改进算法的时间复杂度的系数均大于等组排序，" ID="7">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）另外，输入和调试简单算法比输入和调试改进算法要L去，当n较小时，选用简单算法比选用改进算法要" ID="8">
        <fptr EndPN="00000333" StartPN="00000333"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000333" TITLE="9.6  外排序" TYPE="Chapter">
      <fptr LogicalPageNum="333" PhysicalPageNum="333"/>
      <Paragraph CONTEXT="·324·数据结构问题。" ID="1">
        <fptr EndPN="00000334" StartPN="00000334"/>
      </Paragraph>
      <Paragraph CONTEXT="每个磁盘文件的存储空间逻辑上是按字节从0开始顺序编址的。若一个文件中存放n木i备.水i,'.'右1个空#r.Glll小i,axdltl首空iiGflr(i_llsl甘Cf1ICiC有n个记录，每个记录占有b个字节.则每个记录的首字节地址为（1-1）＊b，其中1毛1成" ID="2">
        <fptr EndPN="00000334" StartPN="00000334"/>
      </Paragraph>
      <Paragraph CONTEXT="n。此文件按字节计算出的大小为n＊b，按记录计算出的大小为。，通常文件的长度是指文件中所含的记录数，所以该文件的大小为炸。用文件流类中的移动文件指针的成员函数可以使文件指针指向文件中的任何字节位置，" ID="3">
        <fptr EndPN="00000334" StartPN="00000334"/>
      </Paragraph>
      <Paragraph CONTEXT="的信息块后，其文件指针自动由原来位置向后移动b个字节的位置，以便用户存取下一个信息块。当然若在进行下一次文件存取前，用户把文件指针移向了其他位置，接着存文件存取前，用户把文件指针移向了其他位置，接着存" ID="4">
        <fptr EndPN="00000334" StartPN="00000334"/>
      </Paragraph>
      <Paragraph CONTEXT="当文件指针移动到最后一个字节位置之后时，若再从文取信息就会从这个新位置开始。当文件指针彩件中读出信息.则就读到了文件的结束标记（每个文件的最后都会存在有这个结束标方式存取文件信息的，每个信息块通常包含一个或若干个实际记录的内容。信息块在内存中对应着一个记录对象或具有记录类型的数组对象。内存中的一个信息块可以一次写入到磁盘文件中，磁盘文件中的一个信息块也可以一次读入到内存中具有同样大小的变第9章排序，321-内存归并排序在开始时是把数组中的每个元素均看做长度为1的有序表（又称归并段），也就是说，在进行归并排序过程中，归并段的长度从l开始。依次为2,4,8，，直归并段的长度通常不是从1开始，而是从一个确定的长度（如100）开始，这样能够有效监减小归莽裁扮和访问外存的玫教，提高外排序速度。这要求在对磁盘文件归并排序之地减少归并趟数和访问外存的次数，前首先要利用一种内排序方法，按用有序表，然后再调用对文件的归并排序算法完成排序.在对磁盘文件进行归并排序时，同样需要使用一个与原文件大小相同的辅助文件，" ID="5">
        <fptr EndPN="00000335" StartPN="00000334"/>
      </Paragraph>
      <Paragraph CONTEXT="其作用与内存归并排序时使用的辅助数组相同。假定原文件对应的文件流对象用A表" ID="6">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="示，辅助文件所对应的文件流对象用R表示，则把A中从记录位置s～m的有序表和记" ID="7">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="录位置为m+1t的有序表归并为R中记录位置为：t的有序表的二路归并算法描述为：voidFfwoIVlerge(fstre二＆A,(stream&amp;R,ints,intm,intt)II把文件A中两个相邻位盆，一m和m+lt的有序表归并为11文件R中对应位tst上的一个有序表" ID="8">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="《" ID="9">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j,k;ElemTypeal,a2;ice;j=m十1;k=s;11分别给指示每个有序表元素位，的指针赎初值" ID="10">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="ner1.,r1g^kkudfihbRkihiac31H下iC31itfihf7凡狱娜压.b）；加表示Ele.ITy伴记录类型的大小。即每个值所占有的字节数。" ID="11">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="刀两个有序表中同时存在未归并元素时的处理过程喃1加（1＜二及＆」倒）｛" ID="12">
        <fptr EndPN="00000335" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="11从文件人的记录下标为1开始的归并段中读出一个记录到al中。322。数据结构" ID="13">
        <fptr EndPN="00000336" StartPN="00000335"/>
      </Paragraph>
      <Paragraph CONTEXT="i" ID="14">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="15">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="else{" ID="16">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="Rwritechara2,b" ID="17">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="j" ID="18">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="19">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="｝刀对前一个归并段中存在的未归并元素进行处理" ID="20">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="A.概kg（1＊b）；" ID="21">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="while(i二ixJ{" ID="22">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="A.readUchar*kkal,b" ID="23">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="R.writecharral,bi" ID="24">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="}11对后一个有序表中存在的未归并元素进行处理" ID="25">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="A.seekg（j＊b）；" ID="26">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="while{j=t}{" ID="27">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="A.readchara2,blt.writechara2,bj＋＋:" ID="28">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="29">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="｝对文件A进行一趟二路归并的算法描述为voidFMergePass(fstream&amp;A,fstream&amp;R,intn,int1en)11把文件A中每个长度为len的有序表两两归井到文件R中｛" ID="30">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypeX;intper;11p用于指向每一对归并段的首记录位登.初值为0while(p+2+len-1=n-1){11两两归并长度‘即记录个数）均为len的有序表FTwoMerge{A,R,p,p+len-1,p+2+len-1P十二2+len;" ID="31">
        <fptr EndPN="00000336" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="1第，章排序·323if{p+1Cn-1。一11归并最后两个长度不等的有序表FIvoMerge(A,R,F,p+len-1,。一【刀把剩下的最后一个有序表复制JR中else" ID="32">
        <fptr EndPN="00000337" StartPN="00000336"/>
      </Paragraph>
      <Paragraph CONTEXT="A.seekg(p+b11移动文件人中的指针到规定的位t" ID="33">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="R.Seek吕勿＊b〕；刀移动文件R中的指针到对应位置" ID="34">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="for(inti=p;～一1;i{" ID="35">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="A.抬目仅char，）＆x.b）；" ID="36">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="R切行以（d这r+r}dux,b" ID="37">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="38">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="}）对磁盘文件进行二路归并排序的算法描述为：void1Mergtuort(fstnam&amp;A,intB1ockSize}刀采用归并排序的方法对文件A中的、每个有序子表长度为" ID="39">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="S1ocltSize的记录进行排序《fstreatnRe:llxxklltemp.datiosinIiosoutIiosbinary刀定义一个能够按块随机存取的辅助文件R,刀物理文件名中的双反斜线代表一个反斜线，因它是转义字符itC!R){CetLdC&quot;C:11XJCk11tCQlp.ddt&quot;《rr《nnOtOpen1&quot;咭endl;" ID="40">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="Cxit" ID="41">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="》int1en=l31ockSize;11从有序表长度（即记录个数）为给定值BlockSize开始归并" ID="42">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="A.seekg(0,iosend" ID="43">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="intn二A.tellgUlb;" ID="44">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="11用n表示文件长度，" ID="45">
        <fptr EndPN="00000337" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="while(lenca){·324·数据结构" ID="46">
        <fptr EndPN="00000338" StartPN="00000337"/>
      </Paragraph>
      <Paragraph CONTEXT="FMergePass(R,A,a,1en" ID="47">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="得到每个有序表的长度为2.len" ID="48">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="/1修改lcn的值为＾中的每个有序表的长度" ID="49">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="50">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="R.cIoseO;1/关闭辅助文件R" ID="51">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="removee:llxxklltemp.dat&quot;/从磁盘上别除R所对应的物理文件}曰老落x、目i.«/ei口后-flfll甘3-去E主«R1e7.ir”玉扛或雪i国B3n‘蔺.Iftr浪币居艺irGn山;" ID="52">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="“filel.dat”：接着调用Pril，t函数顺序打印出该" ID="53">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="L幸件巨尧茗丢芭币.者.生它t卜‘二闷蕊月听冶，扇月亩白‘山引卜匕艺" ID="54">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="后的结果。" ID="55">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="俐ncludc‘i0Bt民派m，b）" ID="56">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="衍nclu山＜ion习””P上｝" ID="57">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="徽nclude（5目10.h》消公lu血（5回ib五）消nc】u血（‘七访9励们nc】u山（台赶已.n.b）5姗t既mTy声111文件中的记录类型" ID="58">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="imnum；intstlt；刀排序码域曲叮b试12］；｝；" ID="59">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="iot‘韶汹的式曰emTy沐）：11用全局变tb保存记录长度" ID="60">
        <fptr EndPN="00000338" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="帕idQ应ks叭《Elem巧碑AI］，ints，intt）I11函数体省略第，章排序·32311函数体省略" ID="61">
        <fptr EndPN="00000339" StartPN="00000338"/>
      </Paragraph>
      <Paragraph CONTEXT="}voidFMergePass(fstreamdtA,fstream&amp;R,iata,iat1ea)【" ID="62">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="函数体省略" ID="63">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="乡voidFMergeSon(fstresm$A,iatBloclsSize)I" ID="64">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="/1函数体省略" ID="65">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="66">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="void1'riat(fatream8cff7刀顺序打印出仔文件中每个记录.实际上只打印其排序码{" ID="67">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="ElcmTypcx;ffseelcg(0,ios:：已nd11将文件指针移至文件末intn=fftellgb;用n表示文件所含的记录数ff.seelcg(011将文件指针移至文件首匆式inti闭；i＜n泣什）【fftsadchar&amp;x,b/1从文件中读一记录到x中if{i9613＝刃)coutauttdl;1/°每行显示13个数据后换行。。以asetw(4}a:x.stn;11每个数据占4个字符显示位t}" ID="68">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="coot闷rendl;" ID="69">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="资" ID="70">
        <fptr EndPN="00000339" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="void1oarlFile(chsr*frame,intn)1/向物理文件名为frame指针所指字符串的文件中输入n个记录【fstreamf(fnarne,iosoutIiasbsnary刀用所给的物理文件名定义一个输出文件流对象f,刀它是与物理文件相对应的逻辑文件试！幻《CetY'«f113n1e宋''《”nOtOpens“4Cetldl;exit(1·3?b。数据结构}" ID="71">
        <fptr EndPN="00000340" StartPN="00000339"/>
      </Paragraph>
      <Paragraph CONTEXT="fot{intice;itn;i（刀假定只向每个记录的排序码域翰入数据，并由随机产生" ID="72">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypcx;" ID="73">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="x.stn=randU°a6500;11每个排序码为0至499之间的整数" ID="74">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="fwritechar。)dc,sizoof(ElemType}fclose关闭逻辑文件f｝" ID="75">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="voidmainU" ID="76">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="77">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="intn;cout月K&quot;输入存于文件的记录数citt卜n;" ID="78">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="ooutaendl;intBlockSize=10;规定初始归并段的大小1_oadFilee:llxxkllfilel.da定择，n" ID="79">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="刀利用所给的文件名进行调用建立含有n个记录的文件fstreamft&quot;o:llxxkllfkl.datiosiniiasout" ID="80">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="刀定义所给的文件为能够进行随机存取的逻辑文件厅ifff){" ID="81">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="Cerra&quot;Filenatopen;" ID="82">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(l" ID="83">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="84">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="c。以《”排序前文件中的数据Frint(ff顺序打印出ff中的每个记录couta:endl;" ID="85">
        <fptr EndPN="00000340" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="ff.seekg(0,iosendn二ff.tellgb;11求出文件ff中的记录个数并赎给nff.撰k吕（0）；刀将文件指针移至文件的开始位置if(n＜二B1ockSize)第9章排序·327{11当文件长度小于等于初始归并段的长度时，无需进行外排序，只要将文件内容一次读入内存数组.11进行内排序后再写入外存文件即可81cmType＊人=new1?lemType[nIl定义与文件大小相同的内存数组Aif(A=NULL){cerr《&quot;memoryallocationfailure礴endl;exit(1" ID="86">
        <fptr EndPN="00000341" StartPN="00000340"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="87">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="ff.readcharA.n*b刀将文件内容整块读入数组A中QuiclSort(A,d,n-111任选一种内排序方法对刀数组A进行内排序，此处采用快速排序方法tl:seekg(a" ID="88">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="刀使文件指针指向开始位里" ID="89">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="ffwritechar)A,n*b11把已排序过的数组内容重新写回文件中deleteQA;" ID="90">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="刀侧除临时数组A" ID="91">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="}else在当文件长度大于初始归并段的长度时，须进行外排序.刀首先要对文件建立好每个初始归并段，然后再调用归刀并排序算法进行外排序，ElemType*A二newElemType[131ockSize刀动态分配具有初始归并段长度的数组AiP(A=NULL){oerr«&quot;memoryallocationfailure司长endi;" ID="92">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1" ID="93">
        <fptr EndPN="00000341" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="）intk=n/131ockSiu;11求出文件中的初始归并段的整段个数并赋给kintu二n46131ockSize;，328数据结构for(inti0;idc;i{11依次建立好k个整归并段ff.scekg(i*BIockSize*bff.rradcharA,BlockSixe*bQuickSort(A,0,B1ockSize-1ff:scckg(i*B1ockSizc*bff.writecharA,131ockSizcrb｝if(ttt0}11建立好最后一个不足长度的归并段ff.readcharA,m*bQuickSort(A,0,m-lff,seekg(k*BIockSize*bff.writechars)A,m*h｝" ID="94">
        <fptr EndPN="00000342" StartPN="00000341"/>
      </Paragraph>
      <Paragraph CONTEXT="deleteA;" ID="95">
        <fptr EndPN="00000342" StartPN="00000342"/>
      </Paragraph>
      <Paragraph CONTEXT="刀删除动态数组AFMergeSort(ff,B1ockSize11对文件ff进行外归并排序}couta”排序后文件中的数据1'rint{ff111序打印出以排序好的文件ff中的每个记录cout州拭cndl;" ID="96">
        <fptr EndPN="00000342" StartPN="00000342"/>
      </Paragraph>
      <Paragraph CONTEXT="ff.claseQ;" ID="97">
        <fptr EndPN="00000342" StartPN="00000342"/>
      </Paragraph>
      <Paragraph CONTEXT="｝假定要求对1,个记录进行外排序.则该程序的运行结果为：输入存于文件的记录数：100" ID="98">
        <fptr EndPN="00000342" StartPN="00000342"/>
      </Paragraph>
      <Paragraph CONTEXT="排序前文件中的数据：41467334016922447835846246420514528132746149149544232743639110440215329238242121fi218395447226271383fi94121fi72993539420331132233317316414121125336847144i6225737359223241292783163519034228810640442264148446305390229370第9章排序·329354614139348129123B445425634446637643130844443912632337381188242941排序后文件中的数据：06293533373738384041414748828410110410611812312612914114414514815316216416716917319024324521121621822322422622924125325625726427127828128829229930330831131632232332732733333434034235D35835936836937037638239039139334439544241242142943143643944244244444石447454461462464466467478491495必本章，1、结" ID="99">
        <fptr EndPN="00000343" StartPN="00000342"/>
      </Paragraph>
      <Paragraph CONTEXT="i.直接擂入排序、直接选择排序和窗泡排序是三种简单的排序方法，它们的时间复" ID="100">
        <fptr EndPN="00000343" StartPN="00000343"/>
      </Paragraph>
      <Paragraph CONTEXT="空间复杂度均为al" ID="101">
        <fptr EndPN="00000343" StartPN="00000343"/>
      </Paragraph>
      <Paragraph CONTEXT="z.堆排序、快速排序和归并排序是三种较快的排序方法，它们的时间复杂度均为o(nlogan)。空间复杂度分别为以1），O（l昭协）和o(nj.在通常情况下，快速排序比堆书阵" ID="102">
        <fptr EndPN="00000343" StartPN="00000343"/>
      </Paragraph>
      <Paragraph CONTEXT="3.对n个元素进行堆排序的过程包括建立初始堆和利用堆排序两个阶段。建立初始堆就是按编号从大到小依次对每个分支节点进行纬运算，每次堆的大小为n-1GiGn-1}，在每次筛运算前都凌.交换堆顶与堆尾元素." ID="103">
        <fptr EndPN="00000343" StartPN="00000343"/>
      </Paragraph>
      <Paragraph CONTEXT="4.对n个元素进行快速翻J是一个递归过程，每执行一次这个过程就把当前区间上的所有元素按基准元素划分为前后两个于区间，当一个子区间的元素个数等于或大于2时继续向下递归。" ID="104">
        <fptr EndPN="00000343" StartPN="00000343"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在快速排序中进行一次划分时，通常以该区间上的第一个元素作为基准元素，从AS」L是，i扁卜.l.J.dilii.le」.1.1」a卜二告J卜由色」‘甘碌卜J备日‘氏工。‘若，.」吐目台＿产瓜二备目自‘第二个元素起依次向后扫描，当被扫描元素大于等于基准元素时止，起依次向前扫描，当被扫描元素小于等于基准元素时止，接着时调这两个位1上的元素，然后再继续从两边向中间扫描并交换，直到扫描过程相遇为止，把基准元素对调到相遇位1枕完成了一次划分。·330·数据结构能小于2;第二趟归并时，有序表的长度为2，得到长度为4的有序表，依次类推，直到得到的有序表长度大于等于持喇铸元素个数n为止.归并湘铸方法同样适应于夕踌文件拆序.叠。。" ID="105">
        <fptr EndPN="00000344" StartPN="00000343"/>
      </Paragraph>
      <Paragraph CONTEXT="9" ID="106">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="9.l单选魔" ID="107">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="1.若对。个元素进行直接插入排序，在进行第i苗{l簇i延a-I〕排序时，为寻找插入位t最多需要进行（）次元素的比较。" ID="108">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.i+lB.i-1GiD.1" ID="109">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="2.若对n个元素进行直接插入排序.在进行任一趟排序的过程中，为寻找插入位里而需要的时间复杂度为（)" ID="110">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O(1}B.O{n]C.O{nZ)D.O(log2n)" ID="111">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="3.在对陀个元素进行快速排序的过程中.第一次划分最多需要交换（）对元素." ID="112">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.n121B.n-IC.nD.n+l" ID="113">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="4.在对n个元素进行快速排序的过程中，最好情况下需要进行（）层划分." ID="114">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.nB.n2C.bgaD.2n" ID="115">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="5.在对，个元素进行快速排序的过程中，最坏情况下需要进行（）层划分。AnB.n1C.n/2D.1ogZn" ID="116">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="6，在对二个元素进行快速排序的过捏中。最坏情况下的时间复杂度为（〕." ID="117">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.O{1)B.O{bg2n)C.O{n2)D.O(nlog)在对n个元素讲行快谏排序的过程中.平均情况下的空间复杂庵为（" ID="118">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="7.在对n个元素进行快速排序的过程中.平均情况下的空间复杂度为（〕。＾，O（l）日.0（拓兮洲）c.O（启0.。心.105户）在对儿个元素进行直接选择排序的过程中，需要进行（〕摘冼择和令揍。" ID="119">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="8.在对。个元素进行直接选择排序的过程中，需要进行（" ID="120">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.nB。月十IC。n-10.月瓜" ID="121">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="9.若对，个元素进行直接选择排序，则进行任一的排序的过程中，为寻找最小值元素所而要的时间复杂度为（）.＾.O（l）B，以碗户）c.以为勺0.饰）" ID="122">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="10，若对：个元素进行堆排序.则在构成初始堆的过程中需要进行（）次筛运算。" ID="123">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.IB。耐ZC。抢0。月一1" ID="124">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="11.若对n个元素进行堆排序，则在由初始堆进行的每趟排序的过程中，共需要进行（）次筛运算。" ID="125">
        <fptr EndPN="00000344" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A，月斗IB.刀口C.忍D.nl第9章排序·331l3.若对n个元素进行归并排序，则进行归并的越数为（）。" ID="126">
        <fptr EndPN="00000345" StartPN="00000344"/>
      </Paragraph>
      <Paragraph CONTEXT="A.nB.n-1C.n/2b.tagzn" ID="127">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="14.若一个元素序列基本有序，则选用《）方法较快。" ID="128">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="A.直接插入排序B，直接选择排序" ID="129">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="c.堆排序D.快速排序" ID="130">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="15.若要对1000个元紊排序，要求既快又稳定，则最好ilk用〔）方法。" ID="131">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="A.直接插入排序B.归并排序" ID="132">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="C.堆排序D，快速排序16‘若要对1000个元素排序，要求既快又节省存储空间.贝叮最好采用（）方法.A直接插入排序B‘归并排序" ID="133">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="C。堆排序D.快速排序" ID="134">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="17.在下列排序方法中.空间复杂度为O(lag2n)的方法为（）." ID="135">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="A。直接选择排序B.归并排序" ID="136">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="C.堆排序D.快速排序，J坡空月" ID="137">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="l.每次从无序表中取出一个元素，把它插入到有序表中的适当位置，此种排序方法叫做排序；每次从无序表中挑选出一个最小或最大元素，把它交换到有序表的一端，此种排序方法叫做排序。" ID="138">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="2.每次直接或通过基准元素间接比较两个元素.若出现逆序排列时就交换它们的位置.此种排序方法叫做―排序；每次使两个相邻的有序表合并成一个有序表的排序方法叫做―排序。" ID="139">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="3.在直接选择排序中.记录比较次数的时间复杂度为＿。记录移动次数的时间复杂度为一." ID="140">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="4.在堆排序的过程中，对碑个记录建立初始堆需要进行＿次筛运算，由初始堆到堆排序结束，需要对树根节点进行＿次筛运算。整个堆排序过程的" ID="141">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="6.假定一组记录的排序码为（肠，" ID="142">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="7.快速排序在平均情况下的时间复杂度为＿，在最坏情况下的时间复杂度为＿。" ID="143">
        <fptr EndPN="00000345" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="8.快速排序在平均情况下的空间复杂度为＿。在最坏情况下的空间复杂度为＿。]0.假定一组记录的排序码为（4b,79,56,38,40,80·332·数据结构l1.在归并排序中，进行每趟归并的时间复杂度为，整个排序过程的时间复杂度为＿.笙IJ星:yIiEJ" ID="144">
        <fptr EndPN="00000346" StartPN="00000345"/>
      </Paragraph>
      <Paragraph CONTEXT="12.t26个ir？录k'irU31时." ID="145">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="12.对20个记录进行归并排序时，共需要进行趟归并，在第三趟归并时是把长度为＿的有序表两两归并为长度为＿的有序表。" ID="146">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="，J运算月" ID="147">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="己知一组元素的排序码为：（46，74，16，53，14，26，40，38，86f65，27，34）" ID="148">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="1.利用直接插入排序的方法写出每次向前面有序表插入一个元素后的排列结果。" ID="149">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="2.利用直接选择排序方法写出每次选择和交换后的排列结果。" ID="150">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="3.利用堆排序的方法写出在构成初始堆和利用堆排序的过程中，每次筛运算后的排列结果，并画出初始堆所对应的完全二叉树。" ID="151">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="4.利用快速排序的方法写出每一层划分后的排列结果，并画出由此快速排序得到的二叉搜索树。" ID="152">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="5.利用归并排序的方法写出每一趟二路归并排序后的结果。，.4算法设计月" ID="153">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="1.己知奇偶转换排序方法如下所述：第一趟对所有奇数‘，将al习和ali＋ll进行比较，第二越对所有偶数1，将球］和a［汗1］进行比较，每次比较时若afll＞a【1＋1］，则将两者交换，重复以上过程，直到整" ID="154">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="个数组有序。" ID="155">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）试问：排序结束的条件是什么？" ID="156">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）编写一个实现上述排序过程的算法，函数原型为：voidoeso献inta［］，intn）；" ID="157">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="2.一个集合中的元素为正整数或负整数，设计一个算法，将正整数和负整数分开，使集合的前部为负整数，后部为正整数，不要求对它们排序，但要求尽量减少交换次数。函数原型为：voidsep暇征（ints［］，intn）；" ID="158">
        <fptr EndPN="00000346" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="3，编写·个对整型数组A［n】中的A［0j-A［n-1］元素进行选择排序的算法，使得首先从待排序区间中选择出一个最小值并同第一个元素交换，再从待排序区间中选择出一个最大值并同最后一个元素交换，反复进行直到待排序区间中元素的个数不超过1为止.算法原型为：v币dselec山rtl（intAintn）；一嘿月a;It" ID="159">
        <fptr EndPN="00000347" StartPN="00000346"/>
      </Paragraph>
      <Paragraph CONTEXT="3.心vddInhSct(inlm1inlaintn1！" ID="160">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;fot(il;i&lt;沼E'I'SIZE;im[i]d;加丙吐卜习j切j什〕" ID="161">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="叹鱿妞1;" ID="162">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="乡" ID="163">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="第3章" ID="164">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="3.办从顺序存储的线性表上删除所有其值重复的多余元素，使所有元索的值均不同.voidAelete2(ListSq&amp;L)!1L可以为值参" ID="165">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="{intice;奋每循环一次将删除加币」后面与此值相同的所有元素" ID="166">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="whtleitIlen){" ID="167">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="妞扮i+l;" ID="168">
        <fptr EndPN="00000347" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="while{j[LJen}：334’数据结包一一一一一―}" ID="169">
        <fptr EndPN="00000348" StartPN="00000347"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="170">
        <fptr EndPN="00000348" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="7.voidJosephus(intn,intm,ints)刀使用带表头附加节点的循环单链表解决约瑟夫问题。｛刀生成表头附加节点，此时循环单链表为空.sNode*HL二newsNode;HL一＞next=HL;" ID="171">
        <fptr EndPN="00000348" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;卜成含有n个n点的、节点值依次为1,2,…,n的带表头附加节点1I的循环单链表。" ID="172">
        <fptr EndPN="00000348" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i＝n;iI;i一）｛" ID="173">
        <fptr EndPN="00000348" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="生成新节点。sNode*newptrnewsNode;newptrdata=i;ll把新节点插入到表头。newptrnext=HL一＞next;HLnext=newptr;" ID="174">
        <fptr EndPN="00000348" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="圣ll从表头开始顺序查找出第s个节点，对应第一个开始报数的人sNode+ap=HL.*cp=HLnext;fo找1＝1；1＜5；1＋＋j《llap和cp指针后移一个位置。aP尤p" ID="175">
        <fptr EndPN="00000348" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="cp二cp一＞next:ll若ep指向了表头附加节点，则仍需后移ap和cp指针，使之指向表头节点，ifcp=HL){ap=HL;cp=HL一＞next;)附录A部分算法设计题参考解答·335}" ID="176">
        <fptr EndPN="00000349" StartPN="00000348"/>
      </Paragraph>
      <Paragraph CONTEXT="11依次使n-1个人出列。" ID="177">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="化di＝＝IJ＜”；1＋＋）11/顺序查找出待出列的人.即为循环结束后cP所指向的节点far(intj=1;jam;j{" ID="178">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="cpxpnext;" ID="179">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="lIl输出cp节点的值，即出列的人couta:cpdeita&quot;&quot;11从单链表中删除P节点ap-next=cp-nezt;" ID="180">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="deletecp;11使cp指针指向被删除节点的后继节点cp＝apnext;11若cP指向了表头附加节点.则后移;Wr和cP指针ifl(Cp=HL}{ap=HL;CpGI'.r&gt;nGXt;}｝" ID="181">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="刀使最后一个人出列。cout《I-Inextdataaendl;刀删除表头节点和表头附加节点。deleteHG&gt;next;" ID="182">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="deleteHL;" ID="183">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="184">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="8.void0rderList(SLNode*Si" ID="185">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="ll定SLNode类型为按题目要求所定义的节点类型，SL为指向刀表头附加节点的指针{" ID="186">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="SLrangelNULJ" ID="187">
        <fptr EndPN="00000349" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="frn{SLNode*pSL-＞二xt;pI=NULL;p=p-7next)｛刀每循环一次把p所指向的节点按序插入到以彻参域刀链接的有序表中引，336＿一一一一止鱼色邑旦一一一SLNode*ap,*cp;叮为P节点寻找合适的插入位置。ap二SL;cpap一＞range;" ID="188">
        <fptr EndPN="00000350" StartPN="00000349"/>
      </Paragraph>
      <Paragraph CONTEXT="while(cpNULL)ifipdatacp-data)break;else{a(，二cp;cp刊p-xange;}y置在ap和cP之间，把P节点插入其中。" ID="189">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="11插入位置在aP和CP之间，" ID="190">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="卜＞ran罗邵p；" ID="191">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="叩.＞n川ge＝P；" ID="192">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="193">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="194">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="9.intFiod（01洲ode＊GL.charchj11从广义表GL中查找单元素字符等于ch的算法.若查找成功11则返回数值1，否则返回数值乐l" ID="195">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="while（GL！＝NULL）1il（GL一＞tag今。）福11处理单元素节点1代GL一习ata＝＝二‘h）rc加ml：ll查找成功返回1日沁GL目OL一》next；ll否则继续向后查找，" ID="196">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="。15。｛11处理子表节点。intx二日耐（o卜＞sublis认h）；11向子表中继续查找。1找x）II若在子表中查找成功则返回1，否则继续向后查找。" ID="197">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="理tuml；" ID="198">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="199">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="GL＝OL一＞next；" ID="200">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="201">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="｝retuo0；11当查找到表为空时返回0。｝" ID="202">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="第4章" ID="203">
        <fptr EndPN="00000350" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="7.任何递归算法都可以编写为非递归算法的形式，这通常需要在非递归算法中定义和附录A部分算法设计题参考解答·337使用栈。对于求解迷宫问题同样可以编写出递归算法，为此需要定义栈中的元素类型Finm'f4mnt描徐碟宣巾当前抬署的姑角坐刑.弓玄姑油毖刑去。sttuctitems11定义描述迷宫中当前位置的结构类型百lld表示移动到下一步的方向｝；求解迷宫的非递归算法如下：voidSeekPathtintm,intn)查找m*。迷宫中从入口（1,1）到出口（m,n)的一条通路3刀将入口点访问标记置为l，表示将访问它“舫叮kL11Lll=1;11定义栈并初始化.栈的元素类型为items" ID="204">
        <fptr EndPN="00000351" StartPN="00000350"/>
      </Paragraph>
      <Paragraph CONTEXT="StackSqS;InitStack(S,5定义temp为进出栈的变量itemstemp;刀将入口点位置及方向初值一1压入栈temp.x=1;temp.y=1;temp.d二一1;Push{S,temp11循环处理，直到栈空为止" ID="205">
        <fptr EndPN="00000351" StartPN="00000351"/>
      </Paragraph>
      <Paragraph CONTEXT="whileEmpty5tack{S)){刀退栈，即从查找的路径中退回一步temp二Pop(S万沿着原位里的下一个方向前进" ID="206">
        <fptr EndPN="00000351" StartPN="00000351"/>
      </Paragraph>
      <Paragraph CONTEXT="mtx二temp.x;inty二temp.y;intd=temp.d+1;" ID="207">
        <fptr EndPN="00000351" StartPN="00000351"/>
      </Paragraph>
      <Paragraph CONTEXT="while{da4}·338·数据结构cout'awn«'«n《'《;whileEmptyStack(S{" ID="208">
        <fptr EndPN="00000352" StartPN="00000351"/>
      </Paragraph>
      <Paragraph CONTEXT="temp=Pop(S1;" ID="209">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="cout'd:temp.x«'temp.yoc,),《,}" ID="210">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="coutaendl;" ID="211">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="return;" ID="212">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11按方向d前进，求出下一个位置的坐标intg=x+move[d01;inth=y+tnove[d11;11对未访问过的可通行的下一个位置，应将当前位t进栈，11并将下一个位置变为当前位t，否则沿下一个方向前进itY二［[s]Lh]＝刃&amp;8cmark[gh]＝刃)！" ID="213">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="mark[gh1=1;tetnp.x=x;tcmp.y=y;temp.d月;Push(S,temp" ID="214">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="x二g:Yom;dam;" ID="215">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="刀进入一个新位里后，重新从初始方向开始争" ID="216">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="elsed11沿下一个方向前进争" ID="217">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="218">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="刀不存在从入口到出口的通路cout”不存在从入口到出口的通路“《已ndl;】" ID="219">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="8.voidHanoi1(intn,inta,intb,intc)" ID="220">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="221">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="刀定义栈中的元素类型，它含有保存每个值参的域structitems{intn.a,b,c;" ID="222">
        <fptr EndPN="00000352" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="｝；一一一一一一bf#A5?iif'3‘33911定义数组s[101作为顺序栈使用" ID="223">
        <fptr EndPN="00000353" StartPN="00000352"/>
      </Paragraph>
      <Paragraph CONTEXT="itemss[lll11定义栈顶指针toP赋初值为一1，表示置槐空inttop1;11定义临时变里t.作为出入栈变量itemsttmp;左算法主体：进行汉诺塔运算，当栈非空或。大于等于1时循环whils(top!＝一1Any=1)" ID="224">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="！" ID="225">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="whiie(1}{II若n等于l则直接由a柱搬到c柱，同时置n二U并退出此层循环试n－1）〔咖t咤一“《cacendl;n二习;break;}刀将所有值参的值进栈temp.n二n;tcmp.a;tcmp.b=b;temp.c书;tops[toptemp;II按原递归调用Hanoi(n-l,a,c,b)的要求给每个值参重新斌值n=n-1;intdam;b=c;‘二d;11a值不变" ID="226">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="}斌吻！＝一1}{IC}L行原递归调用Hanoi{n-i,a,c,b)返回后退栈.方分别把栈顶元素的每个域的值赋给对应的值参tm拼韶[ttipl;top一；" ID="227">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="n.emp.n;atemp.a;b=temp.b;。＝ttmp.c;11执行原递归调用Hanoi(n-1,a,c,b）后的输出语句couta”一”Q:caccndi;11按原递归调用Hanoi(n-l,b,a,c)的要求给每个值参重新赋值" ID="228">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="～一1;intd二.；a=b;b司;Ilc值不变" ID="229">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="230">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="圣" ID="231">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="]第5章" ID="232">
        <fptr EndPN="00000353" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="4.intBTrxEqual(BinTrxNadesT1,BinTneeNadesT2)·洲习·数据结构11若两棵树均为空则返回1表示相等if(Tl二NULLT2=NULL)returni;刀若一裸为空一裸不为空则返回0表示不等elseif(Tl-NULLIIT2二.NULL)return0;1/若根节点值相等并且左，右子树对应相等则两棵树相等elseif(Tldata=TZ一》data8c&amp;STreeEqual(Tlleft,T2-eft)" ID="233">
        <fptr EndPN="00000354" StartPN="00000353"/>
      </Paragraph>
      <Paragraph CONTEXT="returnI;11若根节点值不等或左、右子树对应不等则两棵树不等elsereturn0;" ID="234">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="235">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="另一个参考答案：intBTreeEqual{BinTreeNode*Tl,BinTreeNode*T2)《11若两裸树均为空或实际上是同一棵树时，返回1表示相等if{T1=T2)return1;11若一棵为空一棵不为空则返回0表示不等if(T1=NULL11T2=NULL)return0;" ID="236">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="11若根节点值不等返回4表示不等" ID="237">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="if(T1一＞dataT2一＞data)return0;ll根节点值相等，则两棵树是否相等取决于它们的左、右子树是否对应相等returnBTreeEqual(T1一＞Ic几几户习cft）＆＆｝" ID="238">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="8.voidinorderN(BTreeNode*ST)" ID="239">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="11对二叉树进行中序遍历的非递归算法" ID="240">
        <fptr EndPN="00000354" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="{BTreeNode*s[i01;11定义用于存储节点指针的栈inttop;II定义栈顶指针并赋初值使，栈为空BTreeNode*pBT;11定义指针P并使树根指针为它的初值while(top！二一II!pI=NULL)附录A部分算法设计题参考解答·341{ll当栈非空或P指针非空时执行循环while(p！二NULL)" ID="241">
        <fptr EndPN="00000355" StartPN="00000354"/>
      </Paragraph>
      <Paragraph CONTEXT="top+卜；" ID="242">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="s[topp;" ID="243">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="p=plcft;｝" ID="244">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="if(top!＝一1){" ID="245">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="p=s[top" ID="246">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="P一；" ID="247">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="coutap-dataac;" ID="248">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="P二1}＞right;｝" ID="249">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="250">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="251">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="第6章" ID="252">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="3." ID="253">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)voidInitBTree(ABTI.istGST){" ID="254">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="刀将树里空" ID="255">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="BST[0I.left二0;" ID="256">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="厅建立空闲链接表" ID="257">
        <fptr EndPN="00000355" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="BST[0I.righti;for(inti二1;icBTreeMaxSiu-1;iBST［1］.rigb同＋1；BST[BTtrxMaxSiu-1I.tight=U;资(2}voidInsert(ABTListSST,intot,coastElemType&amp;item}11向数组中的二叉搜索树插入一个元素item的递归算法，刀变参t初始指向树根节点王if(t习1进行插入操作道11取出一个空闲节点·342数据结构intp=BST[0I.right;" ID="258">
        <fptr EndPN="00000356" StartPN="00000355"/>
      </Paragraph>
      <Paragraph CONTEXT="if{p=闭)" ID="259">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="cerrs长“数组空间用完！“a:endl;" ID="260">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="exit(1" ID="261">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="｝11修改空闲链表的表头指针，使之指向下一个空闲节点BST[01,right=BST[pI.right;11生成新节点" ID="262">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="BST[pI.data二item;BST[pI.left二BST[pI.tight0;方把新节点插入到确定的位里" ID="263">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="t=p;lelseifl(item.keyaBST[tI.datakey)" ID="264">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="Insert(BST,BST[tI.left,item11向左子树中插入元素else" ID="265">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="Insert{BST,BST[tI.right,iumit向右子树中插入元紊" ID="266">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="267">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="第7章" ID="268">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="3.intmax0utllegree(adjmatrixGA,intn}夏" ID="269">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="intij,max＝0;" ID="270">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="刀求出所有顶点的最大出度值" ID="271">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="几以1阅；1＜n；1＋＋）苦" ID="272">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="了璐顶点的出度里为d" ID="273">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="intk巴a;" ID="274">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="i统计出顶点i的出度" ID="275">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="for(j幻;jcn;j" ID="276">
        <fptr EndPN="00000356" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="ifiG人［ijII司GA[ijlbtaxValue)一一一一一一」#cA遗i9'it·34311若k的值大于max则用它修改max的值" ID="277">
        <fptr EndPN="00000357" StartPN="00000356"/>
      </Paragraph>
      <Paragraph CONTEXT="if{Icmax)max=k;｝11退回所有顶点的最大出度值比妞胜nmaz;" ID="278">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="}" ID="279">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="5。voiddfsa(adjmatrixGA,inti,intn)｛" ID="280">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="5tackSqS;" ID="281">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="[nitStack(S" ID="282">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="Push(S,iwhileEmptyStack(S{" ID="283">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="intk=Pop(s" ID="284">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="ifviaited[k{" ID="285">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="286">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="乡" ID="287">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="288">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="第8章" ID="289">
        <fptr EndPN="00000357" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="2.分析：由题意可知，整个稀疏矩阵中非零元素的个数为1.00。为了散列存储这100个非零元素，需要使用一个作为散列表的一维数组.该数组中元素的类型应为：atnrctElemType{introw;11存储非零元素的行下标intcol;11存储非a.元素的列下标floatval;存储非零元素值·344·数据结构假定用HT[m]表示这个散列表，其中m为散列表的长度，若取装填因子为0.8左右，则令m为127为宜（因127为质数）。所以每按除留余数法构造散列函数。并考虑尽量让得到的散列地址分布均匀，所以采用的散列函数为；H(x)d13*x.row十17+x.col)4bm根据以上分析，建立散列表的算法如下：intCreate(ElemTypeHTintm)" ID="290">
        <fptr EndPN="00000358" StartPN="00000357"/>
      </Paragraph>
      <Paragraph CONTEXT="1/根据稀疏矩阵中100个非零元素建立长度为m的散列表" ID="291">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="292">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,d,tertlp;ElemTypex;for(i司;ivn;i" ID="293">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="{散列表初始化，使关键字域被置为一1，元素值域被里为0" ID="294">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="HT[iI.row＝一1;" ID="295">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="HT[iI.col＝一1;" ID="296">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="HT[iI.val闭;｝for(i二］；i100;i{每循环一次从键盘上输入一个非零元素并插入到散列表中coutacic&quot;.cittsx.row》x.col枷x.val;11'1入非零元素d13*x.row+17*x.col)96m;计算初始散列地址" ID="297">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="temp=d;" ID="298">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="while(HT[dJ.val!＝O)[线性探查存储位置，此循环条件" ID="299">
        <fptr EndPN="00000358" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="也可用ITT【d］，恻1＝＝一1或HT[dI.col!＝一1来代替if(d=temp)11无插入位置返回breturn0;｝HT［d卜：：11非零元素存入下标d位置附录人部分算法设计题参考解答·345｝在散列表上进行查找的算法如下：intSearch(ElemTypeHTintm,introw,intcal)（刀采用与插入时使用的同一散列函数计算散列地址intdd13#row+17.col)'bm;11采用线性探查法查找行、列下标分别为田w和col的元素while(HT[dI.val0)悦11此循环条件也可用盯【d］‘解1＝＝一1或Hr［d】加11＝＝一1来代替" ID="300">
        <fptr EndPN="00000359" StartPN="00000358"/>
      </Paragraph>
      <Paragraph CONTEXT="if(HT[dI.rowowHT[dI.col=rot)" ID="301">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="302">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="if(d＝目emp)return-1;｝" ID="303">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="11查找失败返回一1" ID="304">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="return-1;" ID="305">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="】" ID="306">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="第9章" ID="307">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="4.void1ZuickSortl(ElemTypeA,intn)刀采用快速排序方法对数组A中n个元素进行排序的非递归算法i11定义栈的元素类型." ID="308">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="stuctst{inis,t;11s,t用来保存当前排序区间的下界和上界定义保存待排序区间的下界和上界的栈stSck[201;11'定栈空间大小为zo/定义栈顶指针并初始化inttom-1;" ID="309">
        <fptr EndPN="00000359" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="a将当前区间的下界和上界进栈top十十；Sck[topI.s＝0;Sck[topl.t=n-1;刀栈非空时执行以下循环.·数据结构while(top!＝一1}" ID="310">
        <fptr EndPN="00000360" StartPN="00000359"/>
      </Paragraph>
      <Paragraph CONTEXT="{" ID="311">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="定义局部变量" ID="312">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j,s用，和t分别保存当前区间的下界和上界5＝Sck［tOP］.5：t二Sck[topI.t;top一；把基准元素的值暂存x中" ID="313">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypex=A[s" ID="314">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="11对当前区间进行一次划分i=s+l;j=t;给i和j赋初值while(i&lt;j1刀从前向后顺序查找一个需向后一区间交换的元素" ID="315">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="while(A[iI.key&lt;x.key8c&amp;i&lt;j)i11从后向前顺序查找一个需向前一区间交换的元素" ID="316">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="whiie(A(jI.key&gt;x.keyc$j&gt;i)j一；11如果i&lt;j成立则交换A[i]与A[j]元素的值并各自前进到下一位置" ID="317">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="if{i&lt;j)" ID="318">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="319">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="}II交换人［[s]和A[j]的值.得到前后两个子区间：J-t和j+1tA[sA[jA[jx;刀在当前右区间内超过一个元素的情况下把其下界和上界进栈" ID="320">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="1均＋1＜t）｛tapSck[tnpI.sj+1;Sck[topI.t=t;l11在当前左区间内超过一个元素的情况下把其下界和上界进栈" ID="321">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="ifIs&lt;j-1}{topSck[topI.s=s;Sck[topI.t=j-1;" ID="322">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="323">
        <fptr EndPN="00000360" StartPN="00000360"/>
      </Paragraph>
      <Paragraph CONTEXT="}$Picture[00000361\00000361_new\0001.jpg]Picture$1徐孝凯.数据结构实用教程（C/C描述）.北京：清华大学出版社.1999AAdiG171177a11.3-1E田工口.vt+7dJL，己rSdL.W.」一之里i[Lp.今.1-1AM2徐孝凯.数据结构课程实验.北京：清华大学出版社，20（j23徐孝凯.数据结构实用教程习题参考解答.北京：清华大学出版社.19994殷人昆.数据结构.北京：清华大学出版社.2001SWnliamFord.从m五aln，扣PD月rAgrl双J（刀工IREsvnthC＋＋.北京：清华大学出版社.1997" ID="324">
        <fptr EndPN="00000361" StartPN="00000360"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000343" TITLE="本章小结" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
      <div ORDERLABEL="00000344" TITLE="习题9" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
    </div>
  
</METS>
