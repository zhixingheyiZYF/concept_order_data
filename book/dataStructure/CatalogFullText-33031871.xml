<?xml version="1.0" encoding="utf-8" standalone="no"?>
<METS xmlns:METS="http://www.loc.gov/METS/" xmlns:gdm="http://sunsite.berkeley.edu/GDM/" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" TITLE="Zhejiang University.jdl.China-America digital library project" TYPE="Section" xsi:schemalocation="http://www.loc.gov/METS/http://www.loc.gov/standards/METS/METS.xsd">
  
    <div ORDERLABEL="1" TITLE="第1章 绪论" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="1" TITLE="1.1 什么是数据结构" TYPE="Chapter">
      <fptr LogicalPageNum="12" PhysicalPageNum="12"/>
      <Paragraph CONTEXT="计算机突飞猛进的发展，不仅体现在计算机本身运算速度的提高，信息存储量的增大，而且更重要的是其应用范围的拓广。从最初的工程和科学计算逐步发展到信息处理、事务管理、工业控制、CAD/CAM/CIMS等人类活动的各个领域.计算机处理的对象也从纯数值性数据，如整数、实数、复数、双精度数，扩展到字符、图形、图像、声音等非数值性数据，因此，我们可以把计算机的处理对象统称为数据，同时给数据下一个定义：数据（data)：数据是客观事物的符号表示，在计算机领域中，是指h有能输入到计算机中并被计算机程序处理的符号总称。用计算机对应用领域的数据进行处理，必须由软件人员根据需要编制程序，一般经过这样几个阶段：①对具体问题进行分析，抽象出一个适当的数学模型；②设计针对该数学模型的算法；③根据算法编制程序；④对程序进行调试、测试，直至得到最终解答。4个步骤中，抽象出问题的可描述数学模型是求解实际问题关键的一步，而建立数学模型的实质是分析具体问题，从中提取操作对象―数据，并找出数据之间的关系，用数学语言描述。对于工程和科学计算问题，其数学模型往往可用微分方程、代数方程等数学方法描述，如预报人口增长率的数学模型是微分方程。而应用领域的很多非数值性数据处理问题无法找到相应的数学公式建立其数数据结构学模型，则需要选择合适的数据结构来描述和存储这些非数值性数据及其关系。下面的几个例子分别选用不同的数据结构加以描述。" ID="1">
        <fptr EndPN="00000013" StartPN="00000012"/>
      </Paragraph>
      <Paragraph CONTEXT="例1.1同学通讯录管理最简单的方法是建立一张如图1.1所示的表，表中的每一行存放一个同学的通讯信息，每个同学在表中占" ID="2">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="一行。I" ID="3">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="翠释分带州图i.i同学通讯录同学通讯录以表的形式存人计算机后，计算机的处理对象为同学的相关信息即数据。每个同学的信息，在计算机程序中作为一个整体进行考虑和处理，是数据的基本单位，称作数据元寮〔DataElement图1.1同学通讯录中的一行就是一个数据元素，这样的数据元素是由若干数据项组成的，构成一个同学通讯信息的数据项有学号、姓名、性别、出生日期、家庭住址、电话、Email等。数据项（DataItem）是使数据有意义的最小单位，不能再分割。若将数据项如姓名再分割就没有实际意义了。当然，数据元素也可能仅由一个数据项构成，如英文字母表中" ID="4">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="的数据元素就是A,B,G二各个字母，季节表中的数据元素为春、夏、秋、冬，整数表｛12,35,46,25,78｝中的数据元紊分别为12,35,46,25,78.总之，在数据处理领域中，每一个需要处理的对象都可以抽象成数据元素。存储在计算机中的同学通讯录，每个数据元素即每个同学的信息是一个接一个存放的，数据元素之间是一种简单的线性关系，逻辑上是一种线性结构，这类数学模型可称为线性数据结构，存储通讯录的表为线性表.对通讯录的管理就转化为对线性表的操作即线性表的运算.如转人新同学，即在线性表中增加一行新同学的通讯信息；转出一位同学，即在线性表中删除该同学的通讯信息；查询某同学的电话号码或电话号码改变时，即在线性表中查找该同学所对应的数据元素.也就是说，对通讯录的查询、修改、同学信息的增加、减少等动作表现为定义在全&amp;M七习匕tft7Jifr#d洲毕hM剑牟土仑1ctri扮a月dp卜9日'id'Q:F习p?v1.»宙宜互-E.iC4-F-u7k:F:”“.kzfr线性表中数据元素的查找、修改、播人、删除等运算。" ID="5">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="“插入侧除”等算法。可以发现，算法的设计完全依赖于线性表的数据元素在计算机内的存储方式。就“查找”运算而言，从直观上来说，“查询某同学的电话号码”的操作与通讯录的组织" ID="6">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="方式有关，通讯录有多种组织方式，可随意排列，也可按学号排列，或按姓名的字母顺序排列，" ID="7">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="对于不同的组织形式，该操作的执行效率是不同的。同样，“查找”运算的算法设计与线性表的存储方式密切相关。图书馆书目检索、仓库账目管理等常见的二维表管理如同通讯录管理一样，数据元素之间$Picture[00000014\00000014_new\0002.jpg]Picture$下面讨论关于询问某教师有关情况的处理问题。为了处理这个问题，首先必须解决如何把这些数据存储到计算机中，也就是要解决数据的物理存储问题。假如这个问题已解决，那么又如何实现对于某教师有关情况的查询？若查询给出了该教师的所在的系和专业，查询可方f翁Uh11么廿ii日越冬飞欲＿又东舌.士仑劝1书众鑫冶1潇配1才合自马称lc;tt砚乡i日7k7眨47t;旨yam'sG1I7iF月p拓T玄A67书经、Ib_filtl便地从树根沿某一分支找到该教师的信息。问题的解决就复杂得多，必须按系按专业逐一查找，这就是所谓的树的遍历问题。还会出现这样的问题：当增加一个系或专业时，需在树中增加结点，有新教师调人时需增加叶子结点，这就是树结构的插人问题。若某系或某专业被取消时，必定会影响树结构，怎样将该系或该专业的所有教师的数据从树中删除？这实际上是树的删除问题，而删除的过程势必引起有关的系和专业的变动，需要进行重新整理，就会涉及有关结点的删除和插人问题。因此，为了适应数据的查询、增加、减少，必须定义相应的查找、插人、删除的运算及其算法，并保证在插入、删除之后不破坏树结构。另一个树状结构的例子是近几年来较热的人机对弈问题。计算机能够和人进行对弈，是因为有人将对弈的策略存人计算机。而对弈是在一定规则下随机进行的，不仅要看棋盘当时的格局，还要能够预测将来将可能发生的趋势。这是一个相当复杂的问题，不仅需要数据结构的知识，还深人涉及到人工智能的领域。如图1.3&lt;a)所示为井字棋，计算机处理的对象是对拱排" ID="8">
        <fptr EndPN="00000014" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="／｝｝＼(a)(b)图1.3井字棋对弈树数据结构个系统来满足旅行家提出的一些问题：如要从A城到B城去旅行，他希望选择一条总路程最短或是途中中转次数最少的路径.这是一个以城市为顶点，以城市和城市之间相连的道路为连线构成的图状结构或网状结构，这类道路交通问题的数学模型就是一种称为“图”的数据结构。综上所述，描述这类非数值计算问题的数学模型不再是数学方程，而是诸如线性表、树、图之类的数据结构。从上述的例子中，大家应该知道数据结构是处理哪些领域的问题，同时，也$Picture[00000015\00000015_new\0009.jpg]Picture$可看出，作为计算机的操作对象是一组具有同样性质的数据元素的集合，可称为数据对象(DataObject)。而且数据元素不是孤立存在的，相互之间存在某种结构关系，因此，把相互之间存在一种或多种特定关系的数据元素的集合定义为数据结构（DataStructure),数据结构和数据对象不同，在描述一种数据结构时，不但要描述数据对象，还要描述数据元素之间的相互关系。" ID="9">
        <fptr EndPN="00000015" StartPN="00000014"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="4" TITLE="1.2 数据的逻辑结构和存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <div ORDERLABEL="4" TITLE="1.2.1 数据的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <Paragraph CONTEXT="在了解了数据结构的定义之后，再来看一看数据结构所研究的对象：数据元索。而要对数据元素进行抽象研究，就要对其进行分类。在本课程中，选择的分类标准就是数据元素之间的关系，根据数据元素之间关系的不同特性，通常有下列4类基本结构：集合：结构中的数据元素除了同属于一个集合的关系外，并无其他逻辑关系，即数据元素之间的关系是一种空关系，这是一种最松散的组织形式。线性结构：结构中的数据元素之间存在一个对一个的关系，是按线性关系或前后关系来组织的。树形结构：结构中的数据元素之间存在一个对多个的关系，具有分支及层次特性，其形态像一颗倒挂的树。圈状结构或网状结构：结构中的数据元素之间存在多个对多个的关系，任意两个数据元素都可邻接，是一种最复杂的关系。图1.5为上述4类基本结构的关系图，使我们直观感受了“数据结构”，严格地说，数据结构是一个二元组DataStructureD,R)，其中，D是数据元素的有限集，R是D上关系的有限集。这里，R集合中的关系指的是数据元素之间的逻辑关系，因而这种结构又称为数据的逻辑结构。" ID="1">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Paragraph CONTEXT="·4" ID="2">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
        <Picture URL="00000016\00000016_new\0002.jpg">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Picture>
        <Picture URL="00000016\00000016_new\0003.jpg">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Picture>
        <Paragraph CONTEXT="OO" ID="3">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="00" ID="4">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="r,v(a）集合（b）线性结构（c）树（d）图数据的逻辑结构是从解决问题的需要出发，为实现必要的功能所建立的数学模型即数据结构，属于用户视图，是面向问题的。其实，讨论数据结构的目的是为了在计算机中实现对它的操作，因此，重点还需研究如何在计算机中表示它." ID="5">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="5" TITLE="1.2.2 数据的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="16" PhysicalPageNum="16"/>
        <Paragraph CONTEXT="数据结构在计算机中的表示（又称映像）称为数据的物理结构，又称存储结构，是数据逻辑结构的物理存储方式，属于具体实现的视图，是面向计算机的。数据的存储结构包括数据元素的存储表示和数据元素之间逻辑关系的存储表示。例如，一个简单字母表（A,B,C,D,E)是一个线性表，其存储可以实现为一字符数组。h[0二maxn]，每个数据元素存储在一个存储单元（字节），数据元素之间的线性关系则隐式地表示为数组元素的顺序连续存放，如图1.6(a)所示。显然，从逻辑结构到存储结构的映像中，数据元素可以存储在字节、字或多个字构成的位" ID="1">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="串中，这个位串称为结点.结点可以看成数据元素在计算机中的映像，而存储结构关键取决于逻辑关系的存储表示，有两种方式：" ID="2">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)顺序存储方式如图1.6(a)所示，每个数据元素对应一个结点，所有存储结点的物理位置相继存放在一" ID="3">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="图1.6简单字母表的存储结构(a)顺序存储结构（b)链式存储结构（(c）链式储结构形象描述" ID="4">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)链式存储方式在这种方式下，每个数据元素对应的存储结点包括数据元素和指针两部分，借助指示元素" ID="5">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="6">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="6" TITLE="1.3 存储结构的表示与实现" TYPE="Chapter">
      <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <div ORDERLABEL="6" TITLE="1.3.1 数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <Paragraph CONTEXT="首先，以C语言为例，回顾一下程序设计语言中的数据类型。C语言有5种基本的数据类型：字符型（char)、整型（int)、浮点型（float)、双精度型（double）和无值（void)。这些数据类型如C语言中的整型，取值范围为一32767～32767的整数，相关的操作有十、一／等。事实上，数据类型（DataTyPe）是一组性质相同的值的集合以及定义在这个值集上的一组操作的总称，分为原子类型和结构类型两种。原子类型为值在逻辑上不可分解的数据类型，如上述C语言的基本数据类型。同时，在C语言或PASCAL语言这样的程序设计语言中，不但规定了一些基本的数据类型，还提供了一些组合类型（如数组型、构造型、文件型等）的规则。数据元素的值由若干成分按某种结构组成，称为结构类型。程序员可以利用结构类型的规则，自行定义为解决应用问题所必需的数据类型。数据类型封装了数据存储与操作的具体细节。程序员对“两整数求和”，只关心其“数学上求和”的抽象特性，而不需了解“整数”在计算机中如何表示，相加操作如何实现，这是信息隐藏" ID="1">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="或封装的概念。" ID="2">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="6" TITLE="1.3.2 抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <Paragraph CONTEXT="从数据类型到抽象数据类型，“抽象”的意义在于数据类型的数据抽象特性的反映。数据的抽象，以一个例子说明：数据在计算机中以二进制数存储和运算的，而汇编语言程序设计中可使用各种数据的自然表示，如十进制数“.3，100等，而不必考虑十进制到二进制的转换，这是二进制数的抽象；在高级语言程序设计中，出现字符型、整型、浮点型、双精度型等，这是更高一级的数据抽象；待到抽象数据类型出现，可以定义更高级的数据抽象，如线性表、栈、队列、树、图等。抽象数据类型可以使我们更容易描述现实世界。例：用线性表描述学生成绩表，用树或图描述遗传关系。抽象数据类型通常是指由用户定义，用以表示应用间题的数学模型以及定义在该模型上的一组操作。抽象数据类型由数据类型组成，并包括一组相关的操作。使用它的人可以只关心它的逻辑特征，不需要了解它的存储方式，定义它的人同样不必要关心它如何存储.如线性表这样的抽象数据类型，其数学模型是数据元素的集合，该集合内的元素有这样的关系：除第一个和最后一个外，每个元素有惟一的前趋和惟一的后继。可以有这样一些操作：插入一个元" ID="1">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="素、删除一个元素等。" ID="2">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="ADT抽象数据类型名｛数据对象：（数据对象的定义）数据关系：＜数据关系的定义）基本操作：＜基本操作的定义）}ADT抽象数据类型名例1.4抽象数据类型线性表的定义。ADTList{数据对象：D二｛a;｝a,EE(emSet,i=1,2,…,n,n0}/，任意数据元素的集合，／数据关系：R,二{(a,一：,ala,一，，a。eD，1＝2，…，n｝／，除第一个和最后一个元素基本操作：InitList(L)/，初始化线性表，／DestroyList(L)/，撤销线性表，／Insert&lt;L,i,item)/，在线性表L的第i个元素前插人数据元素item，/Delete(L,i)/，删除线性表L的第i个元素，用item返回其值，／" ID="3">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="}ADTList" ID="4">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="7" TITLE="1.3.3 抽象数据类型的表示与实现" TYPE="Chapter">
        <fptr LogicalPageNum="18" PhysicalPageNum="18"/>
        <Paragraph CONTEXT="本书所讨论的抽象数据类型是在高级程序设计语言数据类型的层次上抽象的，因此，可以通过高级程序设计语言固有的数据类型来表示与实现。本书讨论的抽象数据类型有线性表、栈、队列、串、多维数组、树、二叉树、图等，采用C语言语法进行描述.各种抽象数据类型也就是我们将讨论的数据（逻辑）结构，对应不同的存储结构，可分别用类型定义（typedef）描述。如上面定义的抽象数据类型线性表，其顺序存储结构描述为：typedefstruct1ist{ElemType1istarray/*ElemType为数据元素的类型，实现时由用户自行定义，／intnuminlist/，线性表中数据元数的个数关／" ID="1">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="}SegList也可直接用结构体类型表示，如：definemaxsize100structSegList{" ID="2">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemType1istarray[maxsize+lintnuminlist;｝；" ID="3">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="数据类型SegList就是抽象数据类型线性表在顺序存储结构下的一种表示，其使用方法与基本数据类型完全相同。抽象数据类型与基本数据类型的区别仅在程序实现时，基本数据类型是由系统预先定义好了，可直接用来进行变量定义，如intx，而抽象数据类型必须先自定义，然后再使用。如：用自定义的抽象数据类型SegList，实现线性表的基本操作，使用方法如7下：" ID="4">
          <fptr EndPN="00000019" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="Insert(SegListLinti,ElemTypeitem){" ID="5">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="在以后的讨论中，将主要关注各种抽象数据类型的逻辑特性、不同存储结构的表示（类型" ID="7">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="定义）以及基本操作的实现和一些典型应用。" ID="8">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="如何描述存储结构呢？虽然存储结构涉及数据元素及其关系在存储器中的物理位置，但不可能直接以内存单元地址来描述存储结构，可以借用高级程序语言中的“数据类型”来描述。如可以用“一维数组”类型描述顺序存储结构，以“指针”类型描述链式存储结构。" ID="1">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="8" TITLE="1.4 问题、算法和程序" TYPE="Chapter">
      <fptr LogicalPageNum="19" PhysicalPageNum="19"/>
      <Paragraph CONTEXT="问题、算法和程序，是程序设计人员必须面对的三个不同的概念。相应的输出。问题的定义中无法包含有关怎样解决问题的限制。只有在问题被准确定义并完全理解后才能研究问题的解决方法。从数学角度讲，问题可看做函数（Function)或是输人（即定义域domain)和输出（即值域range)的一种映射关系。算法《Algorithm：算法是解决问题的一种方法或者一个过程。如果将问题看作函数，那么算法就能把翰人转化为输出。一个问题可以有多种算法，一个给定的算法解决一个特定的问题。算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作.但不是任何指令序列都可以称作算法，要能够称为算法，必需具备以下5个重要特征：" ID="1">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="1)输入性一个算法有零个或多个输人；" ID="2">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="2)输出性一个算法有一个或多个输出；" ID="3">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="3)有穷性一个算法在合法输人的情况下，总是在执行有限步后结束，而且每一步都可在" ID="4">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="有穷时间内完成。大多数算法描述语言均提供一些实现重复行为的方法，如C语言中的while和for循环结构。循环结构具有简洁的描述，但实际执行次数由输人决定." ID="5">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="4)确定性算法中每一条指令必须有确切的含义，不会产生二义性。而且，在任何条件下，算法只有惟一的一条执行路径，即相同输入得到相同输出。任何算法描述语言都有选择语句（如C语言中的if和。ase语句），它允许对下一步执行的语句进行选择，但选择过程必须是确定的。" ID="6">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
      <Paragraph CONTEXT="5)可行性算法中描述的操作都是可以通过已经实现的运算执行有限次来实现的，这些输人取自特定的对象的集合。程序《Program)：一个计算机程序是对一个算法使用某种程序设计语言的具体实现。任何一种程序设计语言都可以实现任何一个算法。然而，算法的有穷性即可终止，意味着不是所有的计算机程序都是算法，程序允许存在死循环。操作系统是一个程序，而不是一个算法，但可以把操作系统的各种任务看成是一些单独的问题，每个问题由一部分操作系统程序通过特定的算法实现，得到输出结果后便终止。.g.马" ID="7">
        <fptr EndPN="00000019" StartPN="00000019"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="9" TITLE="1.5 算法的描述与分析" TYPE="Chapter">
      <fptr LogicalPageNum="20" PhysicalPageNum="20"/>
        <div ORDERLABEL="9" TITLE="1.5.1 算法的描述" TYPE="Chapter">
        <fptr LogicalPageNum="20" PhysicalPageNum="20"/>
        <Paragraph CONTEXT="用来描述算法的方式有几种，可用条列式的步骤来描述解决问题的方法，如法，还可直接用程序设计语言来描述。本书的算法采用C语言进行描述，基本操作的算法都用以下形式的函数描述：函数类型函数名（函数参数表）｛高。表达能力强，可移植性好，而且C语言的使用范围广。读者通过阅读算法的描述，不仅可以掌握数据结构的知识，也可提高程序设计的能力，为从事C语言应用软件的开发作好准备。为了便于算法地描述，在函数参数表中除了值调用方式外，增添了C＋语言中的引用调用的参数传递方式.在形参表中，以＆打头的参数即为引用参数，引用参数能被函数本身更新参数值，可以此作为翰出数据的管道。下面对C语言常用的数据类型和内存动态分配函数作一个简要概述。" ID="1">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)墓本数据类型C语言有5种由计算机系统直接支持实现的基本数据类型：整型int、浮点型float、双精度型double、字符型。har和无值型void," ID="2">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="1)char型存储空间为一个字节8位。" ID="3">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="2)float,double,longdouble三种形式的存储空间分别为4字节、8字节、16字节，对应约6位、12位、24位有效数字。" ID="4">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="3)int型的存储空间为2字节（16位），数值范围在一3276832767.可以在int前加short，1ong和unsigned三种限定词，以缩小或扩大int型整数的存储空间和数值表示范围，d口。PA1r1}妻录L7/iL口能雨不救断" ID="5">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="4)void型用于确定函数无值返回。" ID="6">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）指针类型指针是C语言最显著的特征，允许直接对存储变量的地址进行操作，指针即地址。存放地址的变量称为指针变量。例如int，p，定义了指针变量P，指示一个整型数的存储单元.指针类型有两个特殊的指针运算符：＆和，,p表示指针变量P所代表的内存地址，简称取地址，，p表示指针变盆P所指内存单元的值，简称取内容。数据结构指针变量为动态变量，在程序中需要此变量时，为此变量申请内存空间；在不需要时，将其所占空间释放，以便合理安排内存空间。这两个功能分别由标准函数malloc）和free()来实现。例如：一个指针在定义之后和赋值之前，其值是未知的。如果在对其赋值之前就引用，这不仅可能破坏程序，甚至可能破坏计算机的操作系统，这是非常严重的错误！按照惯例，未用指针应当赋以初值NULL，如p=null,如果函数采用指针作为形参，则参数传递采用地址传递的形式，即把实参的地址传给形参，这时如果函数类形参的值改变，则实参中的值也跟着变化。" ID="7">
          <fptr EndPN="00000021" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)数组类型数组是一个由若干同类型变量组成的集合。数组名标识了这一组数，数组元素的下标指示了数组元素在该数组中的顺序位置。在C语言中数组下标的最小值即下界总是。。数组下标的最大值称为上界，为数组定义值减1。如定义inta[1001，则下界为。，上界为99,指针和数组是紧密相连的.一个数组名可看成这组数的起始地址，也就是说，一个数组名就是一个指针变量，换句话说，一个数组也可用指针变量来表示，如：inta［100］，，p；" ID="8">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="p=a;这里，P被置成数组a的第1个元素的地址，要访问a的第5个元素，可表示为：a[41，也可为：*(P十4C语言提供了两种存取数组元素的方法：数组下标检索和指针运算，用指针表示数组也是很普遍的。" ID="9">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）字符串C语言中没有单独的字符串类型，而是把字符串定义成字符数组.每个字符串由表示其结束。一个字符串常量由一对双引号表示，当一个字符串常量被存人内存时，系统自动在其末尾添加’\O’o" ID="10">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;5）结构体类型结构体由一组称为结构体成员的数据项组成，每个结构体成员都有自己的标识符，可以用来对结构体成员的访问。定义一个结构体类型变量分为两步：定义结构体类型和定义结构体变量。例如：structstudent/，定义结构体类型，／｛" ID="11">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="longno;" ID="12">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="charname[401;" ID="13">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="charsex[21;" ID="14">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="mtage;" ID="15">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="floatscore;" ID="16">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；" ID="17">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="structstudentsl,s[201,*sp;/，定义结构体类型变量‘／或者在结构体类型定义后直接定义结构体变量，例如：structstudent咬／二定义结构体类型及变量，／10" ID="18">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="longno;" ID="19">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="charname[401;" ID="20">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="charsex[21;" ID="21">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="intage;" ID="22">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="floatscore;" ID="23">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="｝51，5［20sp；具有同样类型的结构体变量可以互相赋值，如s1=s[11。对结构体成员的访问可使用圆点运算符（.）描述。如sl.name,sl.score等。" ID="24">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)共同体类型共同体是把不同类型的成员项组织为一个整体，它们在内存中共用一段存储单元，但不同的成员项以不同的方式被解释。共同体类型的定义和操作方法与结构体类型变量相同.例如：unionstudent/，定义共同体类型，／｛" ID="25">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="longstu_no;" ID="26">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="charstu_name[201;·｝；unionstudentstu;/，定义共同体类型及变量，／····,········ae／Y.Gr`I」十1洲H-创比au百1.』目.，1" ID="27">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="或者：unionstudentStU；与结构体类型不同的是，在结构体中，每个成员有自己独立的存储位置，而对共同体而言，它的所有成员共享同一位置开始的存储区。由此可知，一个共同体变量在每个时刻只能保存它的某一个成员的值。共同体变量的使用方式与结构体变量一样。" ID="28">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="（7）枚举类型枚举类型变量的取值只能是指定的若干个值之一定义一个枚举类型变量分为两步：枚举类型定义和枚举类型变量定义。例如：enum。olor／二定义枚举类型，／｛red，green，blue，white，black，yellow；｝；enum。olor。1，cZ，／，定义枚举类型变量，／枚举变量d和cZ只能取枚举类型定义中的6个值之一。枚举类型主要用于提高程序的" ID="29">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="可读性。" ID="30">
          <fptr EndPN="00000022" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="（8）类型定义数据结构是高级程序设计语言的一种重要机制。在写程序（算法）时自己定义的数据类型被称为“用户定义类型”，与语言的内部基本数据类型在程序（算法）中同样使用。在C语言中，类型定义用关键字typedef引导，例如：" ID="31">
          <fptr EndPN="00000023" StartPN="00000022"/>
        </Paragraph>
        <Paragraph CONTEXT="TypedetintINTEGER;" ID="32">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="Typedefstructstudent/，定义结构体类型及变量‘／" ID="33">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="34">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="charname[401;这样，就可用INTEGER类型名来代替int类型名，用student代替structstudent结构体类型名.注意，这里的student是structstudent结构体类型的一个新类型名，与前面定义的结构体类型变量不同。还应当提醒读者，这样的类型定义从C语言的角度看都不是什么新类型；本身并不分配存储空间，而仅是为原有类型另外起了新名称。有时定义新类型名是为了提高程序的可读性，提高程序的清晰度。例如下面的定义：rypedefdoubleLENGTH;" ID="35">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefdoubleAREA;在一个算法中长度与面积可能都用双精度数表示，但把一个表示长度的变量与表示面积的变量相加大概不是个合理操作。定义这样的类型名可以帮助人们在阅读算法时看到这种内望七配1〕眨＿赛粉门且面" ID="36">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(9）动态内存分配函数所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的方法。动态内存分配相对于静态内存分配的特点：”不需要预先分配存储空间；" ID="37">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="2)分配的空间可以根据程序的需要扩大或缩小.根据程序的需要实现动态分配存储空间，常用到以下几个函数：①动态存储分配函数malloc()。其原型为：void*malloc(unsignedintsize)其作用是在内存的动态存储区中分配一个长度为size的连续空间.其参数是一个无符号整型数，说明存储空间的大小size，返回值是一个指向所分配的连续存储区起始地址的指针。必须注意的是，当函数未能成功分配存储空间（如内存不足）就会返回一个NULL指针，所以在调用该函数时应该检测返回值是否为NULL并执行相应的操作。②动态存储释放函数free由于内存区域总是有限的，不能不限制地分配下去.而且一个算法要尽量节省资源，所以当所分配的内存区域不用时，就要释放它，以便其他的变量或者程序使用，这时就要用到free（）函数。" ID="38">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="·12其函数原型为：voidfree(void*p)作用是释放指针P所指向的存储区。其参数P必须是先前调用malloc函数或。allo。函数（另一个带计数和清0的动态存储分配函数）时返回的指针。给free函数传递其他的值很可能造成死机或其他灾难性的后果." ID="39">
          <fptr EndPN="00000024" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="举例说明以上两个函数的使用。" ID="40">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="例：" ID="41">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="mtn;" ID="42">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="int关Ps" ID="43">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="scanf（“％d＂，＆n）pdoulle*)malloc&lt;n，sizeof&lt;int;/＊分配n个整型数存储空间‘／if(p=NULL){" ID="44">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="45">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="free(p);/，释放已经不用的存储空间，／在调用malloc函数，确定所分配的存储块大小时一般利用sizeof运算符进行计算，而不是直接写出一个整数，以免出现不必要的错误.另外强调两点，一是每次动态分配都必须调查成功与否，而不应该盲目地执行下去；二是为保证动态存储区的有效使用，在程序中，一旦知道某动态分配的存储块不再使用了，就应该将它释放，这应成为一个习惯。③分配调整函数realloc()realloc函数的原型为：void，realloc(void‘p,unsignedintsize)该函数用于更改前面已做过的存储分配，有两个参数，其一指针P指向过去分配的存储空间，其二size表示当前希望分配的存储空间大小。如果新的要求不能满足，函数reallo。返回一个空指针值，P所指存储空间原来的内容保持不变。如果新的分配要求能满足，函数realloc返回指向一个能存放大小为size的数据存储空间的指针值，并保证新存储空间的内容与原存储空间内容一致。例如，要把前面程序段中分配的n个整型存储空间变更到能存放m个整数的存储空间，可以用以下程序段处理：qint)realloc(p,m，sizeof(intif(qNULL){／，分配未成功，P仍然指向原存储空间，／｝else{" ID="46">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="P-q;" ID="47">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="／，分配成功，通过P使用新的存储空间，／｝一这里的q是另一个整数指针，不直接使用指针P是为了避免分配失败时原存储空间的内容丢失。13" ID="48">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="49">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="14" TITLE="1.5.2 算法分析" TYPE="Chapter">
        <fptr LogicalPageNum="25" PhysicalPageNum="25"/>
        <Paragraph CONTEXT="对于一个给定的问题有多种解法，可以设计出多个算法，哪个算法最好、最有效，需要对各种算法进行分析、比较。估量一个算法或一个计算机程序效率的办法，称为算法分析（Algo-rithmAnalysis)。它还可度量一个问题的内在复杂程度。衡量一个算法好坏的准则有很多。例如，算法是否正确即正确性（Correctness)；算法是否易于理解、易于编码、易于测试即可读性（Readability)；当输人数据非法时，算法能否适当的作出反应或进行处理，而不会产生莫名其妙的结果，即健壮性（Robustness)；以及算法是否节省时间和空间即高效率和低存储量需求。其中正确性的要求是其他所有要求的基础，离开了正确性，其他一切问题都谈不上。其次算法的效率是一切算法设计者所追寻的目标，效率的高低很可能就决定了这个算法是否有实用价值。下面主要讨论算法效率的度量。算法执行效率需依据该算法编制的程序运行时消耗的资源，包括计算机运行时间和所占用的内存空间来度量。与之相对应，算法的的效率就分为时间效率和空间效率两个方面。一个程序执行时间等于其所有语句执行时间的总和，而任一语句的执行时间为该语句执行一次所需时间与执行次数的乘积。要想精确计算各种语句执行一次所需时间是十分困难的，与执行程序的硬件环境、书写程序的语言、所用编译程序的质量及运行环境等因素有关，因此，在算法分析中只是粗略估计算法中语句执行的最大次数作为算法时间效率的度量，而不必" ID="1">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="精确计算具体执行时间。" ID="2">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，分析以下程序段：" ID="3">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="程序段语句执行次数" ID="4">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=l;in;i十十）n十1" ID="5">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="6">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="y=y+1;①n" ID="7">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=1yjnjn*(n-1-1)" ID="8">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="x©n*n" ID="9">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="｝f(n）二（n+1）十n十n*(n+l）十n二n=2nZ+3n+1(1.1)显然，执行次数f&lt;n)为n的函数，其中，n为问题的规模。算法分析，就是确定f(n)是n的什么函数，进而分析f&lt;n)随n变化的情况和确定f(n)的数量级。若用大“O”表示数量级的概念，则式（(1.1)可表示为：f(n0&lt;nZ)。说明当问题规模n增大时，该算法的执行时间与n，成正比，或者说，f(n)和nz数量级相同，称为算法的渐近时间复杂度（AsymptoficTimeComplex-ity)，简称时间复杂度《TimeComplexity),从上面程序段的分析可以看出，影响f(n)数量级的是基本运算②.因此，在算法分析中，通常的做法是从算法中选取一种对于所研究问题来说是基本运算的原操作，多数情况下它是最深层循环内的语句中的原操作，该语句重复执行的次数称为语句的频度（FrequencyCount)。如语句①的频度为n，语句②的频度为n二n=nZ。因此，一个算法中所有语句的频度之和构成该算法的执行时间，其最高的数量级为算法的数量级即算法的时间复杂度T(n" ID="10">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="如上述算法的时间复杂度T(nO(nz若基本操作的语句频度最高数量级分别为1,n,n`，则对应算法的时间复杂度分别为O&lt;1O&lt;nO&lt;nZ)，分别称为常量阶、线性阶、平方阶。算法还可能呈现的时间复杂度有：对数阶O&lt;logZ)，指数阶O(2）等。一般地，常用的时间复杂度有如下关系：" ID="11">
          <fptr EndPN="00000026" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="U(1O(logZO(nO(n1og2O(nZO(n（…&lt;O(n镇O(2实际上，一个算法的时间复杂度除与问题的规模n有关外，往往还与问题的输人数据集有关。例如冒泡排序算法，如算法1.1所示。" ID="12">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="算法1.1" ID="13">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="voidbubble_sort(intaintn" ID="14">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="／／将a中整数序列重新排列为从小到大有序的整数序列" ID="15">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="｝③｝}bubble_sort该冒泡排序算法中以语句③（“交换两个整数位置”）为基本操作，但是基本操作重复执行的次数还取决于问题的输人数据集。当输人数据集a中初始序列为从小到大有序，if语句条件不满足，基本操作次数为0；当a中初始序列为从大到小有序，基本操作次数为n(n-12对这类算法的分析，一种方法是考虑平均情况，在同等规模大小n、各种可能的输人等概率的情况下，取算法的平均时间复杂度.如假设输入数据集a口中初始数据出现的概率相等，冒泡排序算法的平均时间复杂度Tg(n0(n2)；另一种方法是考虑算法在最坏情况下的时到小有序，则冒泡排序算法在最坏情况下的时间复杂度为T&lt;n)=0(nZ)。本课程中所指的时算法的空间效率以空间复杂度（SpaceComplexity）来衡量。一个算法的空间复杂度，一般是指执行该算法所需的存储空间，包括算法程序所占的空间、输入数据所占的存储空间以及算法执行过程中所需要的辅助空间。如程序执行过程中的工作单元以及某种数据结构所需要" ID="16">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="15" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="26" PhysicalPageNum="26"/>
      <Paragraph CONTEXT="数据结构" ID="1">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="是使数据有意义的最小单位。数据对象是具有相同性质的数据元素的集合，是数据的子集。数据结构是一个数据元素的集合以及定义在该集合上数据元素之间关系的总称。根据数据元素之间的不同关系，通常有4类基本结构：集合、线性结构、树形结构、图状结构。数据结构在不考虑其在计算机内的具体存储方式，只关心数据元素之间的相互关系时称为逻辑结构，逻辑结构在计算机内的映像称为数据的存储结构.数据的存储结构包括数据元素的映像和数姆干杏令向兰玄的恤伪茜奴八甘由粉恨干害的吐属敬毛仕占姗垠二会令向垫互苗吐旗右据元素之间关系的映像两部分。顺序映像和非顺序映像两种方式，由此得到两种不同的存储结构：顺序存储结构和链式存储结构.数据类型是一组性质相同的值的集合以及定义在这个值集上的一组操作的总称。具体地说，是程序设计语言中所允许的变量的种类，是变量所能取的值和所能做的运算的集合。数据类型可以看成是程序设计语言中已实现的数据结构。抽象数据类型是在高级程序设计语言数据类型的层次上抽象的，本书讨论的线性表、栈、队列、串、多维数组、树、二叉树、图等数据结构可看成是一些抽象数据类型，可以通过C语言固有的数据类型来表示与实现。数据结构上的运算是为数据处理的需要而在数据结构的数据元素集合上所进行的操作。运算是数据结构的一个重要方面。运算是定义在数据的逻辑结构上的，但运算的实现是依赖数据的存储结构的。各种数据结构中常用的运算有查找、插人、删除等。算法是解决某一特定类型问题的有限指令序列，它的一个特点是在执行有限步之后终止，算法与程序既有区别又有联系。算法的效率分析包括时间复杂度和空间复杂度的分析。时间复杂度以算法中原操作的语句频度来近似度量，空间复杂度则以算法中辅助存储空间的使用来估算。构和数据类型、抽象数据类型的区别与联系。了解什么是算法，算法和程序的区别与联系，难" ID="2">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="点在于理解数据元素之间的4种结构关系以及算法时间复杂度与空间复杂度的分析计算。" ID="3">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="16" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="27" PhysicalPageNum="27"/>
      <Paragraph CONTEXT="1.1简述下列术语：数据、数据元素、数据项、数据对象、数据结构、存储结构、数据类型和" ID="1">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="抽象数据类型。1.2说明数据结构的概念和程序设计语言中数据类型概念的区别与联系。1＋十；" ID="2">
        <fptr EndPN="00000027" StartPN="00000027"/>
      </Paragraph>
      <Paragraph CONTEXT="®k＋今10，i;" ID="3">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="i}while(in-1Qi=l;k=0;while(in-1){i" ID="4">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="＠k＋二10，1；" ID="5">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="6">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="®k=o;for(i=l;in;i{for(j=i;jn;j＠k十＋；" ID="7">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝Qfor(i=l;in;i{for(j=l;ji;j{for(k=l;kj;k＠x1;" ID="8">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="9">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="10">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="©i=1;j=0;while(i+jn){＠if（1＞j）j＋＋；elsei" ID="11">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝Qx=n;y=0;n是不小于1地常数while(xy+1)*(y+1{＠Y＋十；" ID="12">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="13">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="®x=91;y=100;" ID="14">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="while(y&gt;0){＠if（x＞100）｛x一＝lo;y一一；）elsex十十；" ID="15">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="｝1.5物人三个整数，试写出寻找中数的一个算法，并回答下列问题：①在最坏情况下和平均情况下，你的算法分别要比较多少次？" ID="16">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="1.“试编写算法，求一元多项式P。(x)一艺a,、的值Pn(Xo)，设n,X。和a,(OGi&lt;n）均2" ID="17">
        <fptr EndPN="00000029" StartPN="00000028"/>
      </Paragraph>
      <Paragraph CONTEXT="第‘章" ID="18">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="线性表娜邸魏理娘夕吸娜叼筑珍粼脚橄娜澎筑妙翻脚戮娜澎碑理用圈欲娜澎翼沙涸洲啾多卿更溯归吸多绷腆妙脚沙汤脚敬娜到腆妙脚棘旅李咽蹄线性结构是一种应用十分广泛的数据结构.线性结构的基本特点是在数据元素的非空集合中，除第一个和最后一个数据元素外，每个数据元素只有一个前驱和一个后继。本章讨论的线性表是最简单和最常用的一种线性结构。本章内容安排如下：第2.1节首先介绍了线性表的逻辑特点；第2.2节和第2.3节详细介绍了线性表的两种存储结构表示―顺序表和链表，并给出了两种存储结构表示下线性表各种运算的实现；第2.4节介绍了链表的数组描述与实现。" ID="19">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="18" TITLE="第2章 线性表" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="18" TITLE="2.1 线性表的逻辑特点" TYPE="Chapter">
      <fptr LogicalPageNum="29" PhysicalPageNum="29"/>
      <Paragraph CONTEXT="线性衰是由有限个元素组成的有序序列。这个定义中的有序是指线性表中存在惟一的第一个和最后一个元素，除了第一个和最后一个元素外，其他元素前面均只有一个称为前驱的元素和后面均只有一个称为后继的元素.数据元素之间相对位置是线性的。我们把线性表的第一个元素称做表头，最后一个元素称做表尾.线性表中元素的个数称做线炸表的长度.线性表中不包含任何元素即长度为0时，称之为空表.在线性表中，每个元素也都有一种数据类型。在不同的场合下，元素的类型各不相同。它可以是简单的整型、字符型，或复杂的用户自定义类型。虽然概念上不反对具有不同数据类型元素的线性表，但是在这一章讨论的线性表中，表中的所有元素都具有相同的数据类型。在表示线性表的内容时，可以将线性表中的元素写在括号内，并用逗号分隔开。例如，线性表（eo,eie.，，e一：）包含n个元素，下标表示元素在线性表中的位置。对于所有的i&gt;0，下标为i的元素紧跟着下标为i-1的元素，在这种表示法中，空表记做（）.线性表的形式化定义为：" ID="1">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="Do为某个数据对象，n为线性表的长度。现实世界中存在大量可用线性表来描述或组织的数据。例如，常见的英文字母表（A,B," ID="2">
        <fptr EndPN="00000029" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="C,…,Z)是英文字母集按字母顺序关系组成的线性表；学生成绩登记表可把学生成绩情况按学号顺序组成线性表，日常工作中常用的各种二维表格都可看作线性表。18线性表是一个相当灵活的数据结构，对线性表的元素不仅可以进行访问，还可以在线性表的任何地方插人或者删除元素，也可由当前元素找到它的前驱和后继元素等。线性表的操作主要有如下几种：" ID="3">
        <fptr EndPN="00000030" StartPN="00000029"/>
      </Paragraph>
      <Paragraph CONTEXT="①线性表置成空表；" ID="4">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="②求线性表的长度；" ID="5">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="③读取线性表第i个元素的值；" ID="6">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="④修改线性表中第i个元素值；" ID="7">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="⑤在表尾插人新元素；⑥在表中第i个位置插入一个新元素，0&lt;i&lt;n，使原编号为i,i+1,…,n-1的元素变成编号为i+l,i+2,…,n。例如，如果线性表List是（12,32,15,30)，在元素32的位置插人一个元素16，那么就会把这个线性表转化成（12,16,32,15,30⑦删去位置i的元素，0&lt;i（n-1，使原编号为i-l,i-2,…,n-1的元素变成编号为i,i+1,…,n-2。例如，如果线性表List是（12,32,15,30)，删去元素32就会把这个线性表转化成（12,15,30" ID="8">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="⑧求元素的前驱元素；" ID="9">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="⑨求元素的后继元素；" ID="10">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="⑩在线性表中寻找具有特定值的元素；" ID="11">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="0判断线性表是否为空表。利用上述这些基本运算，人们就可以根据需要组织有关线性表的各种更复杂的运算操作，女口：①把两个或更多的线性表组合成一个线性表，常见的操作如两个有序表的并、交、差运算；②把一个线性表分成若干个线性表；" ID="12">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="③复制一个线性表等." ID="13">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="19" TITLE="2.2 线性表的顺序存储结构--顺序表" TYPE="Chapter">
      <fptr LogicalPageNum="30" PhysicalPageNum="30"/>
        <div ORDERLABEL="19" TITLE="2.2.1 顺序表的类型定义" TYPE="Chapter">
        <fptr LogicalPageNum="30" PhysicalPageNum="30"/>
        <Paragraph CONTEXT="大家知道，线性表是由数据元素的有限集和数据元素之间的线性关系两者组成。因此，要在计算机中存储一个线性表，就必须存储其数据元素的集合并表达元素之间的线性关系。线性表的顺序存储结构就是用数组来存储线性表中的元素.表中的元素存储在数组中相邻的位置，数组的位置与元素的位置相对应，数组下标的增序关系则表达了线性表的线性关系。换句话说，就是线性表中第补个元素存储在数组的第i个单元中。表头总是在第。个位置，线性表的这种顺序存储结构称为顺序表（SequentialList顺序表实质上是逻辑上有序的数据元素映射到一组连续的存储区域。如图2.1所示，其特点是每个数据元素占用相同数量的存储单元，且逻辑上相邻的数据元素物理次序也相邻。19数据结构$Picture[00000031\00000031_new\0003.jpg]Picture$$Picture[00000031\00000031_new\0005.jpg]Picture$在图2.1中，假设线性表中每个元素占用k个存储单元，表头元素的存储地址为a，则线性表中任意相邻的两个元素a，与a，的存储首址Loc(a,）与Loc(a）将满足下面的关系：这个公式表明，只要确定了存储线性表的起始地址，给出表中某一个位置，这个位置对应元素的值就可以直接获取。因此，线性表的顺序存储结构是一种随机存取的存储结构。由于采用数组存储线性表中的元素，因此当线性表生成时数组的长度必须是已知的。另外，由于线性表的元素个数随各插人删除操作的进行而变化，因此，线性表中当前的实际元素数目必须在线性表中记录.根据上面所述，用C语言定义顺序表的数据类型如下：$defineMaxsize100;示线性表当前实际长度.ElemType表示线性表的元素类型，可以使用应用程序中任何方便的数据类型来代替，比如简单的整型或实型，也可以是用户自定义的更复杂的类型." ID="1">
          <fptr EndPN="00000031" StartPN="00000030"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="20" TITLE="2.2.2 基本操作的实现" TYPE="Chapter">
        <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <Paragraph CONTEXT="由于线性表的顺序存储结构是一种随机存取存储结构，这就使得随机访问表中任意一个元素相当容易。给出表中某一个位置，这个位置对应元素的值就可以直接获取，因此访问线性表中任意元素的时间复杂性是O(ll在表尾插人和姗除元素也是很容易的，只需花费O&lt;1)时间‘。但是如果我们想按图2.2所示例那样在表头插人一个元素，那么当前表中所有元素必须向表尾移动一个位置以腾出空间。如果表中已经有了n个元素，那么这个过程就要移动n个元素。一般情况下，如果想要在有n个元素的表中第i个位置i人一个元素，那么n-i个元素都必须向表尾移动。个元素也是如此，数组中的所有元素都要向前移动一个位置以填满空间，要删去第i个元素，·20姜｝’：6’卜1，2卜卜卜.（a）在插人值为16的元素之前，表中包含5个元素（b）表中所有元素向后移动一个位置之后的表（。）在表中的第0个位置插人元素16n-1-1个元素都要向前移动。平均说来，在线性表中插入和删除要移动一半元素，也即需要0（n）时间。.在线性表的顺序表示法中，线性表的操作很容易实现。下面给出线性表的部分操作实现：" ID="1">
          <fptr EndPN="00000032" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）线性表里成空表" ID="2">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="将线性表置成空表只需简单地将线性表元素个数置成0即可，用C语言描述将线性表置" ID="3">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="成空表的算法如下：" ID="4">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="算法2.1" ID="5">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="voidclear－SList（SeqListL）" ID="6">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="7">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="L.numinlist＝0；｝" ID="8">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）求线性表的长度" ID="9">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="由于线性表的长度已经记录在变量numinlist中，因此求线性表的长度只要返回nu－" ID="10">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="minhst的值即可。用C语言描述该算法如下：" ID="11">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="算法2.2" ID="12">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="intLengt卜SList（SeqListL）" ID="13">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="｛returnL.numinlist；｝" ID="14">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）在表尾插入新元素函数append是在线性表的表尾插人一个元素。函数首先检查线性表中的元素是否已达到maxsize，如果线性表已满，函数返回0，否则将新元素插人到表尾。用C语言描述该算法如下：算法2.3数据结构" ID="15">
          <fptr EndPN="00000033" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="return1;" ID="16">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）插入在线性表中第i个位置插入一个新元素item时，首先要将i,i-1,…,n-1位置上的元素向后移，使这些位置上元素的编号变成为i十l,i十2,…,n，然后将item插人到第i个位置，且线性表的长度加1，如图2.3所示。若插人位置i&lt;0或i&gt;L,numinlist则无法插人。me*aize-1C语言描述顺序表的插人操作算法如下：$Picture[00000033\00000033_new\0011.jpg]Picture$$Picture[00000033\00000033_new\0012.jpg]Picture$算法2.4intinsert-SList(SegListLinti,ElemTypeitem)｛" ID="18">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="intJ;if&lt;i&lt;0｝｝i&gt;L.numinlist)return0;/＊插人位置不合法‘／if(L.numinlistmaxsize)return0;/，表已满，／for=L,numinlisti;j一一）／，移动表中元素‘／" ID="19">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="L,1istarray[j〕二L,1istarray[j-11;" ID="20">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="L,1istarray[i]=item;" ID="21">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="L,numinlist/，修改表长度，／return1;" ID="22">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="23">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）删除线性表的删除操作是要删去表中位置i上的元素，同样需要移动表中元素。原编号为i十l,i十2,…,n-1的元素变成编号为i,i-f-1,…,n-2，并将表的长度减1，如图2.4所示。若删除位置i&lt;0或i&gt;L.numinlist-1则无法删除。删除表中位置i的元素的C语言描述如下：" ID="24">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="22" ID="25">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Picture URL="00000034\00000034_new\0002.jpg">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Picture>
        <Picture URL="00000034\00000034_new\0003.jpg">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Picture>
        <Paragraph CONTEXT="算法2.5intdelete-SList&lt;SegListLinti)（" ID="26">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="tntJ;if(i&lt;01｝i＞L.numinlist-1)return0;/，删除位置不合法，／for(j=i;j&lt;L.numinlist-1；j＋＋）／‘移动表中元素‘／" ID="27">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="L,1istarray[j]=L.1istarray[j-f-11;" ID="28">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="L.numinlist一一，／，修改表长度，／｝" ID="29">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="(6）在线性表中查找具有特定值的元素在表中查找特定值元素的过程是从表头开始依次与表中元素逐个进行比较，直到表尾结束。若找到，返回该结点所在的位置，否则，查找失败，返回一1.该算法的C语言描述为：算法2.6intfind-SList(SegListL,ElemTypeitem)｛" ID="30">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="intj=0;while(jL.numinlistL,Listarray[j]！二item)jif(jam=L.numinlist)" ID="31">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="returnj;" ID="32">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn-1;" ID="33">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="34">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="23" TITLE="2.2.3 典型应用--多项式求值" TYPE="Chapter">
        <fptr LogicalPageNum="34" PhysicalPageNum="34"/>
        <Paragraph CONTEXT="符号多项式的操作，已成为表处理的典型用例。在数学上，一个一元多项式A(x)可写成数据结构其中a&quot;护0，它由n十1个系数惟一确定。因此，在计算机里，可用一个长度为n十2的一维数组a把A(x)表示为一个系数的线性表第一个元素是多项式的次数，其后是以递减指数为序的n十1个系数。在这种表示法中，多项式的求值、加法与减法运算很容易实现。但是这种表示法有一个最大的缺点，就是对那些多项式的次数很高且变化很大的多项式会浪费大量的存储空间。例如，对于多项式x'ooo-1，它需要一个长度为1002的线性表，而表中只存储3个非。元素，有999个元素的值都是0,假定取上述多项式A(x)，并且只保留其非0系数，那么多项式可写成其中，b：是指数e.的项的非0系数，指数e、是递减的，e。一，＞e。一：＞＞eoi0。若用一个长度为2m1的线性表便可惟一确定多项式A(x)。第一项是非。项的个数，然后，对每一个非。项，用两个元素分别来表示指数与系数。在这种表示方法中，xto00十1可表示为（2,1000,1,0,1如果多项式采用上述顺序存储结构，则多项式求值运算很容易实现。读者可自行写出相应算法，这里就不再赞述。" ID="1">
          <fptr EndPN="00000035" StartPN="00000034"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="序存储结构，第2.3节讨论线性表的链式存储结构。" ID="1">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="24" TITLE="2.3 线性表的链式存储结构--链表" TYPE="Chapter">
      <fptr LogicalPageNum="35" PhysicalPageNum="35"/>
        <div ORDERLABEL="24" TITLE="2.3.1 单链表的类型定义" TYPE="Chapter">
        <fptr LogicalPageNum="35" PhysicalPageNum="35"/>
        <Paragraph CONTEXT="在链表表示法中，线性表元素可放在内存中任何位置.因此，为了按正确次序存取线性表中的元素，对线性表中每个元素来说，除了存储元素本身的信息之外，还需要存储表中下一个元素的地址或位置，我们把链表中的元素称为结点。结点中存储元素本身信息的域称为数据域，存储表中下一个元素的地址域称为指针域，指针域中存储的信息称做指针或链。如图2.5所示。链表就是通过指针或链将结点连接起来的一种方法。因为在由这种结点建立的链表中，每个结点只有一个指向表中下一个结点的指针，所以也被称为单链表。在这种表示方法中，表中元素之间的逻辑关系是由结点中的指针指示的，因此逻辑上相邻的两个元素其存储地址不·24" ID="1">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="要求相邻。通常把单链表画成有序的结点序列，指针用箭头表示。图2.6是线性表（20,25,12,15)的链表表示.由于最后一个结点无后继结点，用符号“A”表示最后一个结点的指针值（在C语言中使用一个特殊记号“NULL'，表示）。每个链表都有一个指向第一个结点的指针（head)和一个指向尾结点的指针（tail),｝～曰玉福刁骊司head4cRt#tzo口～is一四惬tail121sn图2.5单链表的结点结构图2.6单链表示意图在C语言中，链表中结点类型说明如下：" ID="2">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="structLinkNode{" ID="3">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypeelement;" ID="4">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="structLinkNode，next;" ID="5">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；其中element表示数据域，存放该结点的数据信息，ElemType表示线性表的元素类型，Elem-Type可以使用应用程序中任何方便的数据类型来代替，比如简单的整型或实型，也可以是用户自定义的更复杂的类型来代替；next为指针域，指明该结点的惟一后继结点在内存中的存放地址。" ID="6">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="单链表的数据类型定义为：" ID="7">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructLinkNocle二LinkList;为了算法实现上的方便，通常在单链表的第一个结点之前附设一个结点，称为表头结点。表头结点的数据域可以不存储任何信息，也可存储如线性表长度等信息。表头结点的指针域存储的是指向表中第一个结点的指针。如果线性表为空表，则表头结点的指针域为空。图2.7表示线性表为空时，使用表头结点的单链表的情形。图2.8是线性表（20,25,12,15)带表头结点的单链表示例." ID="8">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="." ID="9">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="25" TITLE="2.3.2 基本运算的实现" TYPE="Chapter">
        <fptr LogicalPageNum="36" PhysicalPageNum="36"/>
        <Paragraph CONTEXT="在线性表的顺序存储结构中，由于逻辑上相邻的两个元素在物理位置上也相邻，则每个元素的存储地址都可从线性表的起始地址计算得到。而在单链表中，任何两个元素的存储地址之间没有固定的联系，表中每个元素的存储地址都包含在其前驱结点的指针域中，所以，单链.25数据结构表的运算与顺序表的运算一般有所不同。设L为一带表头结点的单链表，其头指针为head。下面给出求单链表L的长度、取单链表的第i个元素、单链表的追加、插人、删除和查找运算的实现。说明语句LinkListL：定义了单链表L，则L是指向该单链表的头指针，如图2.8中L=head。因此，可直接用head指针指示单链表I.。本节以下算法中直接用头指针head表示单链表L," ID="1">
          <fptr EndPN="00000037" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;1)求长度单链表长度是指单链表中所含结点的个数.为求单链表的结点个数，必须从单链表表头开始，沿着每个结点的链指针，依次向后访问并计数，直到最后一个结点。该过程的C语言实现如算法2.7所示。" ID="2">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="算法2.7int1ength(LinkListhead)｛structnode关P+intcnt二0;for(p=head&gt;next;p!=NULL;p=p&gt;next)" ID="3">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="cnt十十；returncnt;｝" ID="4">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）取元素由于单链表中任何两个元家的存储位置之间没有固定的联系，每个元素的存储位置只能其前驱结点得到。因此，在单链表中，取得第i个元素必须从单链表头指针出发寻找。函通过其前驱结点得到。数get从链表表头开始寻找第i个结点，若结点i不存在，函数返回空，否则返回指向该结点的" ID="5">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="指针。算法2.8structLinknode赞get(LinkList,inti)｛structnode*p;" ID="6">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="intJ;p=head;" ID="7">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=0;(p！二NULL)(j&lt;ijP=P一亡＞next;" ID="8">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="returnp;" ID="9">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｝&lt;3）追加函数append实现追加一个新结点到单链表的最后，新结点的元素值为item。若单链表设有尾指针tail，只要将尾指针tail指向新插人结点，新插人结点成为最后一个结点即可，如算法2.9所示。若单链表没有设尾指针tail，则必须从单链表头指针出发直到找到最后一个结点，插人新结点，如算法2.10所示。" ID="10">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="算法2.9voidappend(LinkListhead，structnode*tail,ElemTypeitem)｛tail=tail一＞next=malloc(sizeof(structnodetail一）&gt;element=item;tail一＞next=NULL;｝" ID="11">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="算法2.10Voidappend(LinkListHead,ElemTypeitem){structnode*p;" ID="12">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="antJ;" ID="13">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="p=head一）&gt;next;while(p){p一）next};p=malloc(sizeof(structnodep&gt;element=item" ID="14">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="P一＞next=NULL" ID="15">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="16">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）插入设P是指向单链表中一个结点的指针，在P指向的结点后面插人一个结点包括三个步骤：首先，要创建一个新的结点，并且赋给它一个新的值；其次，新结点的next指向指针P所指结点的后继结点；最后，指针P指向的结点的next要指向新插人的结点。假设s为指向新插人结点的指针，则上述指针修改的代码为：s一二＞next=p一＞next;p代＞next=s;在单链表中插人一个结点之前和之后的指针变化情况如图2.9所示。稚刃枢叶插人i2图2.9在单链表中插人一个结点的过程函数insert实现在单链表的第i个结点后面插入一个新结点。算法在实现时，首先查找新结点插人位置，然后根据上面所述修改相应指针.算法2.11intinsert(LinkListhead,inti,ElemTypeitem)｛structnode*p,关s;数据结构" ID="17">
          <fptr EndPN="00000039" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="intj;s=malloc&lt;sizeof(structnode;/，创建新结点，／s一＞element二item;/，给新结点赋值‘／p=head;for&lt;j二0p!=NULL)g.(jGij)/＊寻找插人位置‘／p=p一＞next;if!P川（jaireturn0;/‘插人位置不合理‘／s一＞next二P一）next;/‘修改相应指针，／p一＞next=s;" ID="18">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="return1;" ID="19">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="20">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="(5)删除从单链表删去一个结点只需将被删结点的前趋结点的next域指向被删结点的后继结点即可。但必须注意，被删结点占据的内存空间应该返回给存储器，因此可设一个临时指针指向要删去的结点，而后调用C语言提供的标准过程，free将被删去的结点占据的内存空间返回给存储器。图2.10给出了这一过程的图示。删除指针P所指结点的后继结点的代码为：temp=p＞next;P一亡＞next=p&gt;next－－－：＞next;free(temp)" ID="21">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="(a）川除值为12的结点前的单链表（b&gt;侧去结点后指针的变化情况根据上面的分析，在单链表中删除一个结点首先要找到被删结点的前驱结点，然后修改相应指针，最后归还被剐结点所占据的存储空间。删除单链表中第i个结点算法的C语言实现为：算法2.12intdelete(LinkListhead,inti)｛structnode*p,*temp;intj;p=head;/，寻找被删除结点，令P指向其前驱结点‘／for&lt;j二0p！二NULL)(j&lt;i-1j·28if！p川（jaireturn0;／二被删结点不存在‘／temp=p一＞next;／二修改相应指针，／P一）next=temp一）next;free(temp);/，释放被删结点占据的空间，／return1;" ID="22">
          <fptr EndPN="00000040" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="｝容易看出，在单链表的表尾插人结点，若有尾指针tail是很容易的，只需花费O(1)时间。若没有尾指针tail，则与求单链表结点个数和在链表中寻找第i个结点一样需要花费O(n)时间。在链表中插人和删除一个结点的时间复杂性也为O&lt;n)，这是因为，在第i个结点插人一个新结点或删除第i个结点，都必须首先找到第i个结点或第i个结点的前驱结点。" ID="23">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="29" TITLE="2.3.3 循环链表与双向链表" TYPE="Chapter">
        <fptr LogicalPageNum="40" PhysicalPageNum="40"/>
        <Paragraph CONTEXT="(1)循环链表如果将单链表最后一个结点next域指向单链表中第一个结点，便得到一个循环链表。如图2.11所示。循环链表是线性表的另一种形式的链式存储结构，其特点是整个链表构成一个由链指针相链接的环，可以从循环链表的任意一个结点开始，访问到链表的每一个结点。h耀钾褥异区引亚纯甲循环链表的操作和单链表的操作基本一样，读者可以参考单链表操作的算法写出循环链表相应算法。但是应该注意的是，由于循环链表中没有明显的最后一个结点，可能使得链表的操作进人死循环。一种解决这个问题的方法是使用head指针来标记表的处理是否遍历了整个表.在算法中，仅需将判断单链表表尾的条件：p=NULL改为P=head即可。作为例子，写一个可确定循环链表长度的函数length," ID="1">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="算法2.13" ID="2">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="int1ength(LinkListhead)" ID="3">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="4">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="5">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="next)" ID="6">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="｝循环链表可使某些运算简化。例如，在链表上实现将两个线性表（(a，，aZ，a）和（bbZbm）连接成一个线性表（&lt;a,a。,b,bm）的运算。若在单链表或头指针表示的单循环表上做这种链接操作，都需要遍历第一个链表，找到结点a，然后将结点b，链到a。的后面，其执行时间是O(n若在尾指针表示的单循环表上实现，则只需修改指针，无须遍历，其执行时间是U(1)。如图2.12表示了两个单循环链表的链接操作，其实现见算法2.14,算法2.14LinkListConnect(LinkListA,LinkListB)/／假设A,B为非空循环链表的尾指针｛LinkListp=A一）&gt;next;①保存A表的头结点位置$Picture[00000041\00000041_new\0016.jpg]Picture$A一＞next=B一＞next叫气＞next;©B表的开始结点链接到A表尾free(B一～＞next)③释放B表的头结点B一）next=p;®returnB;/／返回新循环链表的尾指针｝" ID="7">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）双向循环以上讨论的链式存储结构的结点中只有一个指针连接后继的指针域，因此只允许从表中一个结点访问它的后继结点，若要想访问结点的前驱结点，惟一的方法就是再从表的第一个结点开始。也就是说，在单链表中，求“后继”的执行时间为O(1)，而求“前驭”的执行时间为O&lt;n)。为克服单链表这种单向性的缺点，可利用双向链表（DoubleLinkedList),双向链表可以从链表中任一个结点出发，方便地在线性表中访问它的前驱结点和后继结点。双向链表的每个结点有两个指针，一个指向它的后继结点，另一个指向它的前驱结点。当然，双向链表也可以是循环的，图2.13说明了双向链表的结构。双向链表结点结构定义如下：" ID="8">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="structdlnode{" ID="9">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypeelement;structdlnode*prey;/‘指向结点前驱结点的指针‘／structdlnode*next;/，指向结点后继结点的指针二／｝；" ID="10">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="30" ID="11">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="head" ID="12">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)图2.13双向链表示例(a）一个双向链表（b)带表头结点的循环双向链表（。）带表头结点的空双向循环链表与单链表类似，双向链表也是由头指针head惟一确定。在双向链表中，若P为指向双向链表的一个结点指针，显然有：" ID="13">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="p一＞next一）&gt;prev=p一＞prev一＞next=p这个公式反映了这种结构的基本优点，即可以方便地向后和向前移动指针。在双向链表中，有些操作（如求长度，取元素，寻找特定元素等）仅涉及一个方向的指针，这些操作与单链表的操作完全相同，读者可参考单链表算法写出双向链表相应算法。但双向链表的插人和删除过程与单链表有很大的不同，在双向链表中插人和删除结点需要修改两个方向的指针。下面介绍双向链表的插人与删除算法。&lt;1）插入双向链表的插人算法很简单.图2.14给出了双向链表中，在指针P指向的结点后面插人一个新结点（由指针s指向）之前和之后的情况，指针变化情况由insert函数的四行代码完成：s一＞next=p代＞next;" ID="14">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="s&gt;prev=p;" ID="15">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="p一＞next一＞prev=s;" ID="16">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="pes－－：＞next=s;在带表头结点的双向链表中第i个结点后面插人一个值为item的结点的算法如下：算法2.15intinsert(DLinkListhead,inti,ElemTypeitem)｛" ID="17">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="structdlnode*p，关s;" ID="18">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="intj;s=malloc(sizeof(structdlnode;/，创建新结点，／数据结构" ID="19">
          <fptr EndPN="00000043" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="城丛壮丑还丘$Picture[00000043\00000043_new\0006.jpg]Picture$：‘＿＿／‘吞‘拿‘夺上六日多才占‘1s&gt;element=item;p=head;for(j=0p!=NULL)(j&lt;ij／二寻找插人位置二／p=p～－－：＞next;if!p川（jaireturn0;/，插人位置不合理，／s代＞next二pinext;/，修改相应指针，／ses－－：＞prev=p;P一），next一）prey=s;" ID="20">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="p～－－：＞next=s;" ID="21">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="return1;" ID="22">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="｝&lt;2)删除在带表头结点的双向链表中删除第1个结点的算法如下：算法2.16intdelete(DLinkListhead,inti)｛structdlnode*p;" ID="23">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="intJ;p=head;for(j=0;(p！二NULL)(j&lt;ijp=一＞nextsifp川（jaireturn0;／二被删结点不存在‘／p－～＞next一＞prey=p一仁＞prev;/‘修改指针，／P一它＞prey一＞next=p一）next;free(p);/‘释放被删结点占据的空间‘／" ID="24">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在双向链表中删除一个结点时指针变化情况如图2.15所示。在双向链表中删去P指针所指向的结点，指针变化情况由函数delete两行代码完成：Pnext一＞prev=p一亡＞prev;" ID="25">
          <fptr EndPN="00000044" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="P一＞prey一＞next=p一仁＞next;" ID="26">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="屯咐过丑娅丘" ID="27">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="花卫工片二二月工亚于｝-1_" ID="28">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="33" TITLE="2.3.4 典型应用--多项式相加" TYPE="Chapter">
        <fptr LogicalPageNum="44" PhysicalPageNum="44"/>
        <Paragraph CONTEXT="在2.2.3节已经介绍过一个一元多项式A(x)可写成并可以采用顺序表表示上述多项式。本节用链表表示一个一元多项式，并介绍在链表表示方式下，多项式加法运算的实现。用链表表示多项式时，链表中结点表示多项式的每一项，结点包含三个域：系数域。oef存放该项的系数，指数域exp用来存放该项的指数和指向下一项结点的指针next.如图2.16所示。例如，多项式A（x）＝3xl‘＋Zxs＋1可表示成：±Yrl渊扫3114I小I110’!n1多项式B(x)=8x1‘一3x10+10x6可表示成：4姗扫8114,I-31'10I）小卜｝A(x）加上x）可得到多项式C(x）二11x'‘一3x'0+2x8-1-10x6i-1。表示C(x）的链表形式为：G渊扫11I141扫-3110I-H2卜｝干105平｝I卜卜｝下面来讨论多项式相加的算法。多项式链表的结点结构C语言描述如下：structPolyNode{" ID="1">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="2">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="floatcoef;" ID="3">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="tntexp;structPolyNode关next;｝多项式链表的数据类型定义为：typedefstructPolyNode关PolyLinkList;多项式链表依然由头指针惟一确定。一元多项式相加的运算规则很简单：两个多项式中所有指数相同的项，对应系数相加，若和不为零，则构成“和多项式”中的一项；所有指数不相同的项均复抄到“和多项式”中。为了实现多项式的相加，设P和q分别指向多项式A和B中某一结点，当P！毕NULL且q!=NULL时，相加过程为比较结点中的指数项：若P一＞exp=q一它＞exp，则将系数相加，当和不为零时，建立一个新结点，将其插人到和多项式C中，P和q移至下一结点。若p代＞exp&lt;q一＞exp，则为B中的该项建立一个结点，将其插人到C中。然后q向前移到下一结点；若P一二＞exp＞q一）exp，则为A中的该项建立一个结点，将其插人到和多项式C中。然后P向前移到下一结点。每当一个新结点生成，就置好该结点的系数域和指数域，并把该结点插人到C的最后。为了避免每次插人一个新结点时要到C中查找最后结点，设一个指针r，指向C中最后一个结点。函数append建立一个新结点并将它插人到和多项式C的最后。图2.17给出了多项式相加的过程，多项式相加算法的C语言实现为：算法2.17voidappend(flotc,inte,structPolyNode‘r)／，生成多项式一项并将其插人到和多项式C中，该项指数为e，系数为。，／｛ptr=malloc(sizeof(structPolyNode" ID="4">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="ptr一＞exp=e;ptr一－－：＞coef=c;r一）next=ptr;r二ptr;｝算法2.18(PolyLinkListA,PolyLinkListB,PolyLinkListC)voidAddpoly(A,B,C)／，带表头的单链表多项式A和B相加，和多项式为C,A,B和C分别为多项式A,B和" ID="5">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="C的头指针，／王structpolyNode*p,*q;p=A;q=B;C=malloc(sizeof(structnoder=C;whilep!=NULL)&amp;&lt;q！二NULL{$Picture[00000046\00000046_new\0002.jpg]Picture$$Picture[00000046\00000046_new\0004.jpg]Picture$$Picture[00000046\00000046_new\0006.jpg]Picture$(a)p一＞exp=q^＞exp(b)p一＞expGq一＞exp(c)p一＞expoq一＞expif(p一）exp==qse它＞exp)}／二指数相等，／x=p一＞coef+q&gt;coef;if(xl=0)append(x,p一＞exp,rP=P一＞next;" ID="6">
          <fptr EndPN="00000046" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="q=q一）next;" ID="7">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="8">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="else{if(p一＞exp&lt;q一＞exp数据结构" ID="9">
          <fptr EndPN="00000047" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="append(q&gt;coef,q代＞exp,r" ID="10">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="q=q一＞next;｝" ID="11">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="else{append(p一｛&gt;coef,p一仁＞exp,rp=p.－：＞next;｝" ID="12">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="｝while(p!=NULL)/长复制多项式A的余项，／｛append(pcoef,p气＞exp,rprp一＞next;｝while(qt=NULL)/，复制多项式B的余项二／（append(y.－－：＞coef,q一）exp,r);q=q一＞next;｝" ID="13">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="从2.z节的讨论中可以看出，线性表的顺序存储结构的特点是逻辑上相邻的两个元素在物理位置上也相邻。、表中任意元素的存储地址可用一个简单、直观的公式来表示，这就使得对表中任意一个元素的随机访问相当容易；另外，存储分配也容易实现，只要求足够大的一块连续存储空间。但是线性表的顺序存储结构要求它的大小事先必须固定，这样一来，线性表不仅不能超过预定的长度，而且当线性表中只有几个元素时，浪费了相当多的空间。另外，为了保持表中元素的顺序，在做擂人和剐除操作时，需要移动大量元素。本节介绍第二种传统的实现线性表的方法：链式存储结构.由于链式存储结构不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构的弱点，但同时它也失去了顺序存储结构随机存取的优点。" ID="1">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="36" TITLE="2.4 链表的数组描述与实现" TYPE="Chapter">
      <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
      <Paragraph CONTEXT="如果高级程序设计语言中没有“指针”类型，可以使用数组描述单链表。此时链表中的一个结点是数组的一个元素。每个元素包含一个数据域element和一个指针域next,next指示后继结点在数组中的相应位置。数组的第。个元素看成是表头结点，其next指向链表的第一个结点。最后一个结点的next域值为零。为了和使用指针描述的链表相区别，称这种链表为静态链表。图2.18是线性表（20,25,12,15)的静态链表表示。静态单链表的结点结构定义如下：structSNode{ElemTypeelement;intnext;" ID="1">
        <fptr EndPN="00000047" StartPN="00000047"/>
      </Paragraph>
      <Paragraph CONTEXT="｝；structSNodeslist[maxsize];·36静态链表像顺序表那样需要预先分配一个较大的存储空间，但在作插人和删除操作时，不需要移动元素，只需要修改指针（下标），故具有链表的优点。例如，在图2.1S所示静态链表中元素25的后面插人一个新元素（值为9)，只要将新元素放到表尾（数组下标为5)，然后修改相应的指针即可，如图2.19所示。" ID="2">
        <fptr EndPN="00000048" StartPN="00000047"/>
      </Paragraph>
      <Paragraph CONTEXT="012345678neuIi！二‘1汽.1，＿IU.IJllll图2.19在图2.18所示的静态链表中插人元素（值为9)静态链表的操作与单链表的算法类似，所不同的是：mallo。和free两个函数需由用户自己实现。为了确定数组中的哪些单元未被使用，可以将未被使用的以及被删除的单元用下标链成一个空闲的链表，每当进行插人时便从空闲的链表中取得第一个结点做为待插人的结点；反之，在删除时将从链表中删除的结点链接到空闲链表上。因此，在静态链表中有两个链表：一个是已用的静态链表，另一个是空闲的静态链表。已用静态链表的头指针是第。个数组元素，空闲的静态链表的头指针需另外增加一个变量来表示。" ID="3">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="假设slist为静态链表名，space为空闲静态链表的头指针，下面给出在静态链表中进行插入与删除算法的实现。" ID="4">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)初始化初始化操作是把整个静态链表初始化成一个空闲的静态链表。其具体实现为：算法2.19" ID="5">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="voidinit(structSNodeslistint*space)" ID="6">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="｛for(i=O;i&lt;maxsize-l;i)slist[inext=i-1;" ID="7">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="slist[maxsize-11,next=0;" ID="8">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="关space=l;｝" ID="9">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）擂入" ID="10">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="在静态链表，list的第i个结点后面插人一个结点（元素的值为item）的方法是：首先从空闲静态链表上得到一个可用结点并将item赋给其element域，然后把它链人到静态链表的第i个结点之后.具体算法为：算法2.20intinsert(structSNodeslistinti,ElemTypeitem,int*space)" ID="11">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="12">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="if(!spacereturn0;/＊没有空闲结点，／" ID="13">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="k“关space;" ID="14">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构for(j二0p！二0）农乙（j＜1-1)；1-i-/！寻找插人位置＊／p=slist[pnext;if1P川（j＞lreturn0;/，插人位置不合理，／slist[knext=slist[pI.next;slist[pnext=k;" ID="15">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="return1;" ID="16">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="17">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)删除删除静态链表第i个结点的过程与单链表相同。首先修改被删结点的前驱结点的指针，然后将被删结点链入空闲静态链表中。具体实现为：算法2.21intdelete(structSNodeslist,inti,int二space)（" ID="18">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="P片slist[0I.next;for(j=0;(p！二0)(j&lt;i-1）；j＋＋）／＊寻找被删结点的前驱结点‘／" ID="19">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="p=slist[pI.next;ifiP川（jaireturn0;/，删除位置不合法，／k=slist[pnext;slist[pnext=slist[kI.next;slist[knext=*space;*space=k;return1;" ID="20">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="21">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="38" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="49" PhysicalPageNum="49"/>
      <Paragraph CONTEXT="线性表是最常用且最简单的一种线性数据结构。它是由有限个元素组成的有序序列。线个元素，直接后继是第1＋1个元素.线性表常用的存储结构有两种：顺序表和链表.顺序表的实现是用数组来存储表中的元素，这就意味着将要分配固定长度的数组。因此当线性表生成时数组的长度必须是已知的。线性表的顺序存储结构把表中的元素存储在数组中相邻的位置，数组的位置与元素的位1对应。表中第1个元素存储在数组的第1个单元中。表头总是在第0个位置。因此，在顺置相对应。表中第1个元素存储在数组的第1个单元中。表头总是在第0个位置。因此，在顺个结点的指针域指向表的第一个结点时，称为循环链表。双向链表也可以是循环的。在n个结点的链表中访问某个结点必须遍历整个链表，时间代价为O&lt;n)，花费时间较多。但在链表中插人一个结点和删除一个结点，只需要修改指针，而不需要移动元素，时间代价为O(1)，速度较快。但为了找到插人和删除的位置，需要遍历整个链表，在链表中插人和删除一个结点总的时间代价仍为O(n与表中其他元素一样，只是它的值被忽略，不被看做表中实际元素。因为增加了一个表头结点，因此，我们不需要再考虑空链表的插人与删除，删除结点后表成为空表等特殊情况。表头顺序表与链表相比，顺序表的缺点是它的大小事先固定，虽然便于给数组分配空间，但是它不仅不能超过预定的长度，而且当线性表中只有几个元素时，浪费了相当多的空间。顺序表的优点是随机存取表中元素相当容易，而且对于表中的每一个元素没有浪费空间。链表的优点是只对实际在表中的元素分配空间，只要有可用的内存空间分配，链表中的结" ID="1">
        <fptr EndPN="00000050" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="点个数就没有限制。但是，链表需要在每个结点上附加一个指针或两个指针，浪费了空间." ID="2">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="如果事先知道线性表的大致长度，使用顺序表可节省存储空间。而当线性表元素数目变" ID="3">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="如果事先知道线性表的大致长度，使用顺序表可节省存储空间。化较大或未知时，最好使用链表.一元多项式可用线性表来表示。如果对多项式只是进行求值操作，而不改变多项式的系断知华扮书云谊＿可孚田丽良妻卞才叼5加！＿俞老由垂田毅全妻卞才" ID="4">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="39" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="50" PhysicalPageNum="50"/>
      <Paragraph CONTEXT="2.2设计一个算法，使线性表的n个元素倒置。线性表采用顺序表表示." ID="1">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="2.2设计一个算法，使线性表的n个元素倒置。线性表采用顺序表表示.2.3对单链表的情况做习题2.1（设原链表为（al，a：，…，an一；，an）），则逆置后的序列为" ID="2">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="（a。，a。一：，…，a：，a：）。2.4设计一个算法，将单链表数据域等于已知值k的所有结点删除。" ID="3">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="2.5设计一个算法在循环链表中第1个结点后插人一个新结点.3" ID="4">
        <fptr EndPN="00000051" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="第J章" ID="5">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="栈和队列笋脚朋形洲娜峨冻阅脚键多卿胭妙魂劝限班圈场破娜邸项妙脚沙陌酮吸分戮断到或妙弹盼随李滩珍月栈和队列是两种特殊的线性表，它们的逻辑结构和线性表相同，其特殊只在于它们的运算规则较线性表有更多的限制，故又称运算受限的线性表。栈和队列广泛应用于各种程序设计中，从数据类型角度，可以把它们看成是与线性表不同的两类重要抽象数据类型。本章除了讨论栈和队列的逻辑特点、数据类型、表示方法和运算实现以外，还将给出一些应用的例子。" ID="6">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="40" TITLE="第3章 栈和队列" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="40" TITLE="3.1 栈的逻辑特点" TYPE="Chapter">
      <fptr LogicalPageNum="51" PhysicalPageNum="51"/>
      <Paragraph CONTEXT="栈（stack)是限定只能在表的一端进行插人和删除的线性表。在表中允许插人和删除的一端称为栈顶（top)，而表中不允许插人和删除的另一端则称为栈底（bottom)。不含元素的空表称为空栈。栈的逻辑结构特点可通过图3.1来表示。假设栈SSo,Si5一，），则称50为栈底元素，S一，为栈顶元素。栈中元素按So,SI,…,S。一：的次序进栈，退栈的第一个元素应为栈顶元素S一；，这就是说最后一个进栈的元素最先出栈。由于这个原因，栈也形象地被称作后进先出表，即LIFO(LastInFirstOut）表。日常生活中有很多栈的例子。比如，可以把栈比做桌子上的一叠书，约定不可从中间把书抽出，也不可把书插在中间。这样，后来放的书总是放在这一图3.1找的逻辑结构示意图在栈上进行的运算主要是插人和删除。插人一个新的栈顶元素称为进栈（PUSH删除栈顶元素称为出栈（POP)。对栈进行的其他运算还有设置一个空栈、判断某个栈是否为空栈、读取栈顶元素等。因为栈是线性表的特例，所以栈可以使用顺序存储结构和链式存储结构。栈的顺序存储结构称为顺序栈，栈的链式结构称为链栈，以下分别加以介绍." ID="1">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="41" TITLE="3.2 栈的顺序存储结构--顺序栈" TYPE="Chapter">
      <fptr LogicalPageNum="52" PhysicalPageNum="52"/>
        <div ORDERLABEL="41" TITLE="3.2.1 顺序栈的类型定义" TYPE="Chapter">
        <fptr LogicalPageNum="52" PhysicalPageNum="52"/>
        <Paragraph CONTEXT="类似于顺序表，用一维数组描述顺序栈中数据元素的存储区域，并预设一个数组的最大空间。通常的习惯做法是以top=0表示空栈，鉴于C语言中数组的下标约定是从。开始，则当以C作描述语言时，如此设定会带来很大不便；另一方面，由于栈在使用过程中所需最大空间的大小很难估计，因此，一般来说，在初始化设空栈时不应限定栈的最大容量。一个较合理的做法是：先为栈分配一个基本容量，然后在应用过程中，当栈的空间不够使用时再逐段扩大。为此，可设定两个常量：STACKCSL（存储空间初始分配量）和STACKZL（存储空间分配增量）。下面给出顺序栈的类型定义：" ID="1">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="include&quot;stdlib.h&quot;defineSTACKCSL64/，顺序栈存储空间初始分配量，／$defineSTACKZL8/，顺序栈存储空间分配增量二／(a）空栈（b）元素5,8,1进栈（c）元素1出栈（d）元素4,3进栈（e）元素3出栈（f）栈满数据结构typedefintElemType;/＊栈元素的数据类型定义，它可以是任意的，具体问题时只typedefstruct{ElemType*top;/＊栈顶指针‘／" ID="2">
          <fptr EndPN="00000053" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemType二bottom;/‘栈底指针，／" ID="3">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="intstacksize;/，当前已分配的存储空间，以栈元素为单位二／}segstack;／二顺序栈类型定义‘／segstack*segs;，segs是顺序栈类型指针‘／其中，stacksize指示栈的当前可使用的最大容量，初始化栈时，stacksize的值等于STACKCSL，以后根据需要按分配增量STACKZL增长。bottom是栈底指针，在顺序栈中，它始终指向栈底的位置，如果bottom的值等于NULL,就意味着栈结构不存在。top是栈顶指针，其初值指向栈底，也就是说top=bottom可作为栈空的标记。每当插人新的栈顶元素时，指针top增1;删除栈顶元素时，指针top减1.所以，非空栈中的栈顶指针始终在栈顶元素的下一个位置上。图3.2表示了栈顶指针top和顺序栈中数据元素之间的对应关系。" ID="4">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="42" TITLE="3.2.2 基本运算的实现" TYPE="Chapter">
        <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
        <Paragraph CONTEXT="上述顺序栈的类型定义以及本小节将介绍的基本运算操作均放在文件“segstack.c”中，使用时需要用命令：#include&quot;segstack,c”将其包含到具体的应用程序中去。在顺序栈上可以实现初始化栈、进栈、出栈、判栈空、取栈顶元素等几种基本运算，具体算法如下：&lt;1）初始化栈该算法用于建立一个容量为stackcsl的空顺序栈ss。建立时首先使用malloc函数进行内存储区的分配，并将所分配的存储区的起始地址赋给栈底指针bottom。如果bottom不为空，说明分配成功，否则说明分配失败。成功时进行置空栈的操作，失败则退出。具体算法如" ID="1">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="下：算法3.1Voidinitstack(Sagstack‘ss)/‘初始化一个顺序栈ss二／谧ss一二＞bottomElemTypemalloc(STACKCSL*sizeof(ElemType" ID="2">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="ifssbottom)exit(0" ID="3">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="ss&gt;top=ss&gt;bottom;" ID="4">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="ss一它＞stacksize=stackcsl;" ID="5">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(”置空栈成功！”）；" ID="6">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）进栈该算法用于向顺序栈ss的栈顶插入一个元素x。算法首先判断栈是否已满，如果栈不满，就直接进行插人操作，否则就使用reallo。函数为该顺序栈再多分配增量stackzl个元素的存储空间。如果分配成功，则修改栈顶指针top的位置和栈的容量stacksize，然后将元素x插人在栈顶位置。具体算法如下：" ID="8">
          <fptr EndPN="00000054" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.2Voidpushsegstack二ssElemTypex／，将元素x插人顺序栈ss的顶部，／｛if(ssestop-ss一＞bottamss一＞stacksize)/，判断顺序栈是否已满‘／{ss一＞bottomElemTyperealloc(ss一＞bottomss一＞stacksize-stackzl)if(!ss一二＞bottom){printf“栈容量扩充失败”）；refum;)ss-estop二ss一＞bottom+ss一＞stacksize;ss一＞stacksize=ss一）stacksize+STACKZL;｝" ID="9">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="*ss一＞top=x;" ID="10">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="ss一）top" ID="11">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｝注意：如果在顺序栈已满的情况下再执行进栈操作时，就会发生“上溢出”的错误，必须进行栈容量的扩充。" ID="12">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;3）判栈空该算法用于判断顺序栈ss是否为空栈。算法以栈顶指针top和栈底指针bottom是否指向同一位置为判断条件。这是因为对于栈来说，bottom永远指向栈底的位置，只有栈中没有元素时，top和bottom才可能指向同一个位置。具体算法如下：算法3.3" ID="13">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="intStackempty&lt;segstack关ss)" ID="14">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="／关判断顺序栈ss是否为空，／" ID="15">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｛if(ss气＞topss－－－：＞bottom)return1;else" ID="16">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="return0;" ID="17">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）出栈该算法用于从顺序栈ss的栈顶删除一个元素，并将该元素的值通过x返回.算法进行时，首先判断栈是否为空，如果为空则是错误操作，不空则将栈顶指针向下移动一个位置。具体算法如下：、算法3.4Voidpop(segstack关ss,ElemTypex)／关从顺序找ss中弹出栈顶元素置于x中，／（if(ss一＞topss一＞bottom)exit(0数据结构" ID="19">
          <fptr EndPN="00000055" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="ssestop一一；" ID="20">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="x=*ss一）top;" ID="21">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="｝需要注意的是：在该算法中，删去栈顶元素只要将栈顶指针减1即可，但该元素在下次进栈操作之前仍然是存在的，因此函数segpop中利用变量x返回被删元素。另外，当顺序栈为空时，进行出栈操作会发生“下溢出”错误，应尽量避免。" ID="22">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="(5)取找顶元亲将顺序栈ss的栈顶元素通过变量x返回.该算法与segpop操作有所类似，只是此算法中栈顶指针不发生变化。" ID="23">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.5" ID="24">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="Voidgettop(Segstack*ss,ElemTypex)" ID="25">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="／，取顺序栈ss的栈顶元素置于x中，／" ID="26">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="27">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="if&lt;ss～topss-ibottom)exit(0);" ID="28">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="x=爷(ss-top-1" ID="29">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在以上顺序栈的实现算法中，虽然设置了一个存储空间分配增量STACKZL，用于堆栈容量不够时进行扩容调整，但是还是要面对“滋出”问题.尤其堆栈的使用非常广泛，经常出现在一个程序中需要同时使用多个堆栈的情形。为了避免出现滋出，需要为每个堆栈分配一个足够大小的空间。然而，要做到这一点往往是很不容易的，原因之一是各个堆栈所需要的空间大小很难估计；原因之二是由于堆栈是个动态结构，各个堆栈的实际大小在使用过程中都会发生动态变化，有时其中一个堆栈发生了上滋出，而其他各堆栈还保留很多可用空间。这就要求设法来解决多栈共享空间的问题。" ID="30">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="44" TITLE="3.2.3 多栈共享空间" TYPE="Chapter">
        <fptr LogicalPageNum="55" PhysicalPageNum="55"/>
        <Paragraph CONTEXT="假设将多个堆栈顺序地映射到一个已知大小为m的存储空间上。如果只有两个堆栈来共享这m个存储空间，问题比较容易解决：只需要让第一个栈的栈底位于1处，让另一个栈的栈底位于m处。在使用堆栈时，两栈各自向中间伸展，仅当两个栈的栈顶指针相遇时才发生上滋出.这样，两个堆栈之间就做到了余缺互补，互相调节，从而大大减少了空间的浪费现象，如图3.3所示。如果有两个以上的堆栈共享空间m，问题的处理就要复杂一些。当然，如果事先知道每个堆栈可能存放的元素的最多个数，那也可以将这m个空间根据各个堆栈的大小合理分配。但是，更多的情况是人们事先并不知道各个堆栈的最大容量。一个解决的办法就是：先将m个·44存储空间平均分配给n个（(n&gt;2)栈，每个栈占[m/nJ（不大于m/n的最大整数）个存储空间，当其中任意一个堆栈发生上溢出而整个空间并未占满时，就要进行再调整。进行调整操作时，首先设top[1二司为n个堆栈的栈顶指针的集合，top[i〕为第i个堆栈的栈顶指针；设bot[卜二n+11为n+1个栈底指针的集合，bot[i」为第i个堆栈的栈底指针，位于第i个堆栈实际栈底元素的前一个位置（为了方便对应描述，数组元素top[0］和bot[0〕不使用）。其中设置第’n-1个栈底指针bot[n1］的目的是为了测试第n个堆栈栈满与否。" ID="1">
          <fptr EndPN="00000056" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="初始状态如图3.4所示：" ID="2">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="bot〔1〕今top仁1〕“（1-1），（tm／nJ）（1镇1（n）bot[n+11=m图3.4多栈共享空间初始状态示意图第1个栈第2个栈第1个栈第n个栈" ID="3">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="落阵匕率匕煎$Picture[00000056\00000056_new\0016.jpg]Picture$bol[l]top[11bot[21top[2jbot[i]top[iJbol[o]top[n]bot[n图3.5多栈共享空间一般状态示意图很显然，表示第i个堆栈为栈空的条件是：top[ibot[i]&lt;l镇i&lt;n)表示第i个堆栈为栈满的条件是：top[ibot[i+11(1&lt;i&lt;n)在上述情况中，很容易出现“假溢出”的情况，也就是当用户想在第i个堆栈中插人一个新元素，此时第i个堆栈已满，而其他堆栈实际上可能还很空，整个存储空间可能还有剩余。要想有效利用其他堆栈的剩余存储空间，调整第i个堆栈空间，使得该新元素能够插人到第i个堆栈中，可以进行以下调整：方法一：右移法。该方法在i&lt;j&lt;n中确定有可用空间的最小j，也就是找到第i个栈右边的第1个有可用空间的栈j（此时必然有toP［j］＜bot［j＋1〕），然后将第i+1、第i-2二第J个方法二：左移法。该方法相对于右移法而言，当第i个栈的右边不再有可用空间时，就在" ID="4">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="多个堆栈共享空间的优点之一就是节省空间，但这种处理方法的弊病仍旧是要移动大量的数据元素，这也正是顺序存储结构固有的缺点。" ID="5">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="46" TITLE="3.2.4 典型应用举例" TYPE="Chapter">
        <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <Paragraph CONTEXT="在计算机软件设计中，栈的应用非常广泛。子程序嵌套调用、递归的实现、中断的处理、表达式的计算等都是找的实际应用。只要问题求解具有后进先出的天然特性，则其求解过程中必然需要利用“栈”。下面举例说明栈的应用。例3.1数制转换十进制数N和其他d进制数的转换是计算机实现计算的基本问题，其转换算法基于下列原理：NNdivd)*d-f-N·modd（其中：div为整除运算，mod为求余数运算）例如：(2340=(11101010)2，其运算过程如下：NNdiv2Nmod2出与其等值的二进制数。由于上述计算过程是从低位到高位顺序产生二进制的各个数位，而打印输出，一般来说应从高位到低位进行，刚好和计算过程相反，这与栈的先进后出的特性相吻合。因此，若将计算过程中得到的二进制数的各位顺序进找，则按出栈序列打印输出的就是与输人对应的二进制数." ID="1">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="#include&quot;linkstack.c&quot;" ID="2">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="main()" ID="3">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="｛linkstack*1s=NULL;datatype*a=NULL,n;linkstacknull(lsscanf”请愉人＋进制非负整数：％d”，＆n）；while(n)" ID="4">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="｛ls=1inkpush(Is,n°02);·46" ID="5">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="n=n/2;" ID="6">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="｝printfn对应的二进制数为：”）；while(ls！二NULL)" ID="7">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="8">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="ls=linkpop&lt;ls,a" ID="9">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="printf%d*a);" ID="10">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="》" ID="11">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="该程序的执行结果为：" ID="13">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="请输人十进制非负整数：234对应的二进制数为：11101010十进制数N和其他d进制数的转换是计算机实现计算的基本问题，其转换算法基于下列原理：NNdivd)，d+Nmodd（其中：div为整除运算，mod为求余数运算）例如：(2340=(11101010)Z，其运算过程如下：现需设计一算法实现十进制到二进制的数制转换：对于愉人的任意一个非负十进制整数，打印输出与其等值的二进制数。由于上述计算过程是从低位到高位顺序产生二进制的各个数位，而打印输出，一般来说应从高位到低位进行，刚好和计算过程相反，这与栈的先进后出的特性相吻合.因此，若将计算过程中得到的二进制数的各位顺序进栈，则按出栈序列打印输出的" ID="14">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="就是与物人对应的二进制数。" ID="15">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="X法3.6站，，」即，，即#inciuaesegstacx.cVoidconversion(Segstack关ss)／，十进制到二进制的数制转换，／｛intstack(ss/，构造空栈，／" ID="16">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="scanf”请翰人＋进制非负整数：％d＆n）；" ID="17">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="push（55，n％2）；／‘余数人栈‘／" ID="18">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="printfn对应的二进制数为）；while(！stackempty&lt;ss))/，依次弹出栈中元素‘／｛" ID="19">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="pop(ss,a" ID="20">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="若将算法3.6改为主程序main()，则该程序的执行结果为：请输入十进制非负整数：234对应的二进制数为：11101010" ID="22">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="这是利用栈后进先出特性的最简单的例子。类似还可解决如“从键盘上输入一批整数，然后按照相反次序打印出来”一类的问题。例3.2括号匹配括号匹配问题在高级语言编译系统中是一个基本的检测操作，它的检测方法就是通过堆栈的应用实现的。在一个程序段中，若允许出现的括号有三种：“｛｝［］（）”，则它们必须成对出现，允许嵌套，但不能有交叉现象出现。例如：｛＜［（）」｝｝是正确的，" ID="23">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="｛〔（（｝｝〕和（｛｝［）〕都是错误的。" ID="24">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="利用堆栈实现检测方法的算法描述如下：算法3.7先建立左括号栈，然后从左至右扫描该程序段：" ID="25">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="1)若扫描到左括号，将该左括号进栈；" ID="26">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="2)若扫描到右括号，则对左括号栈的栈顶元素进行考察：①二者相匹配，栈顶括号元索出栈；②二者不匹配，则停止扫描该程序段，" ID="27">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="3)以上情况①，则继续扫描程序段，直至全部扫描完；" ID="28">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="4)最后考察左括号栈：①栈为空，且该程序段已扫描完，则该程序段中括号均相匹配；②否则，此程序段中有不匹配的括号。下面来看两个实例：" ID="29">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="1）｛｛［（）〕｝｝该实例中各个括号进、出栈的情况如图3.6所示：其扫描过程如下：a）依次扫描到“（（〔（”，则分别进栈；b)扫描到“）”，与栈顶的“（”相匹配，则“（”出栈；·48c）扫描到与栈顶的“［”相匹配，则“［”出栈；d)扫描到“）”，与栈顶的“｛”相匹配，则“｛”出栈；e）扫描到“｝”，与栈顶的“｛”相匹配，则“｛”出栈；f)扫描结束，左括号栈为空。" ID="30">
          <fptr EndPN="00000060" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="可以判断：该程序段的括号均匹配。2该实例中各个括号进、出栈的情况如图3.7所示：图3.7括号匹配检测2)" ID="31">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="其扫描过程如下：a)依次扫描到“（（”，则分别进栈；b)扫描到与栈顶的“（”相匹配，则“（”出栈；c）扫描到“［”，进栈；d)找描到“）”，与栈顶的不匹配，则停止扫描；" ID="32">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="e)扫描未结束，左括号栈不为空。" ID="33">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="可以判断：该程序段的括号不匹配。" ID="34">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="例3.3衰达式求值" ID="35">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Picture URL="00000060\00000060_new\0022.jpg">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Picture>
        <Paragraph CONTEXT="(1)表达式的计算表达式的计算与括号匹配一样是程序设计语言编译系统中的一个基本问题，它的实现是堆栈应用的一个典型实例。任何一个表达式都是由运算对象（也称操作数）和运算符（也称操作符）以及分界符组成的。这些运算对象、运算符以及分界符称为单词。根据运算符的类型，通常可以把表达式分为数据结构含二元运算符的算术表达式的求值问题，读者不难将它推广到一般表达式。先要说明的是，通常在数学中看到的或者出现在程序中的算术表达式都称为中缀表达式，中缀表达式中的运算符一般出现在两个运算对象之间（单目运算符除外）。例如，在计算机系统内多遍处理的编译程序中，在处理这样的表达式并将其生成一系列机器指令或者直接求值之前，往往先将它变换成另外一种形式，即后缀表达式.形式。顾名思义，后缀表达式就是表达式中的运算符出现在运算对象之后。在后缀表达式中，不存在括号，也不存在运算符优先级的差别，计算过程完全按运算符出现的先后次序进行；整个计算过程仅需一遍扫描便可完成，比中缀表达式的计算简单得多。例如，前面给出的中缀表达式写成后缀形式为：这样处理的好处是：编译程序处理表达式时，首先从左至右一次扫描后缀表达式的各个单词，如果读到的一个单词为运算符，就对该运算符前面的两个运算对象施以该运算符所代表的运算；然后将结果存入一个临时单元T：中（(ijl)，并作为一个新的运算对象重复进行上述过程，直到表达式处理完毕.例如：abcd二十e／一的运算过程如表3.1所示。巨月从上面的讨论知道，后缀表达式之所以容易被编译程序处理，是由于它具有以下特点：①后缀表达式中不出现括号；②后缀表达式与中缀表达式的运算对象的先后次序相同，只是所读到的运算符先后次序可能有所改变.正是由于后缀表达式具有以上特点，所以，处理时不必考虑运算符的优先关系。在具体的处理过程中，需要设置一个堆栈，用来保存已经读到的运算对象。也就是说，从左至右依次扫描后缀表达式，每读到一个运算对象就将其压人堆栈；每读到一个运算符，就从堆栈中取出相应的运算对象进行该运算符所代表的操作，并把运算结果作为一个新的运算对象压人堆栈.表达式最后的计算结果就是位于堆栈中栈顶的值。式；二是根据后缀表达式产生计算表达式的机器指令序列。相对而言，第二个步骤较为简单些，先讨论实现第二个步骤的算法。" ID="36">
          <fptr EndPN="00000061" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3,8" ID="37">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="include&quot;segstack.c&quot;" ID="38">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="Voidevalution" ID="39">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="{charc;" ID="40">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="intopl,op2,cl,result,x=O,val" ID="41">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT=".50segstack*opd;/，栈opd存放操作数及计算结果关，initstack(opd);/，初始化栈，／while(c二getchar（）！＝‘＼n，）／，后缀表达式未结束，／｛if(c一‘continue;/，空格则读人下一个字符，／if（（c＞‘0‘）＆＆（c＜＝‘9‘））／二若读人字符是数字，／{cl二c一’0'；/，将字符数字转化为数值数字，／push(opdata(opd,cl/，将该字数值数字作为操作数进栈，／" ID="42">
          <fptr EndPN="00000062" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="elseifc二＝’＋‘川（c‘一‘川（c一二川（。二＝‘／‘））／，若读人字符为运算符＊／opt=pop(opd,x);" ID="43">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="result=val(c,op2,op1/，两操作数出栈，进行运算，／" ID="44">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="push(opd,result/，运算结果进栈‘／" ID="45">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="｝少" ID="46">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="printf该后缀表达式的值为：％了，pop（。pd，x））；／，计算完后栈中只剩计算结果，／少算法3.9" ID="47">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="intval(chartag,intal,inta2)／‘函数val进行算术运算，／左switch（tag)" ID="48">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="气" ID="49">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="case'" ID="50">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="return(al-1-a2);break;I尸case一：return&lt;al-a2break;尸尸casereturn(al*a2break;" ID="51">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="caser/r.return(al/a2" ID="52">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="53">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="｝下面来讨论如何把中缀表达式变换为后缀表达式。旨先，已知中缀表达式与后缀表达式的运算对象的排列次序完全相同，只是运算符按某种现则可能改变了位置。根据这个特点，可以从左到右依次扫描中缀表达式，每读到一个运算对象就把它作为后缀表达式的一部分输出.关键在于处理运算符时要事先设置一个运算符栈，数据结构每读到一个运算符，就将其与栈顶位置的运算符的优先级进行比较，以决定所读到的运算符是该进栈还是该将栈顶位置的运算符作为后缀表达式的一部分输出。表3.2给出的是＋、一／四则运算以及圆括号的优先关系。其中，“＃”为中缀表达式的左、右分界符，符号optl代表栈顶运算符，opt2代表当前扫描到的运算符。该表格给出的优先关系不外乎三种：＞，＜，件，表中的空格处表示无优先关系。上根据这个优先关系表，每读到中缀表达式中的一个运算符叩t2，先将opt2与optl的优先级进行比较，如果。pt2&gt;optl，则将opt2进栈，然后读下一个单词；如果opt2&lt;optl,optl退栈作为后缀表达式中的一员输出。此后，继续比较。pt2与。ptl的优先级（注意，此时的optl已经不是先前的那个运算符了），直到opt2得到合适的处理。如果opt2=optl，并且opt2“＃”，则。ptl退栈且消去opt2，然后继续读下一个单词，重复以上步骤，直到optl#opt2二“＃”时，算法结束.算法3.10将中缀表达式转换成后缀表达式。" ID="54">
          <fptr EndPN="00000063" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="#include&quot;segstack" ID="55">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="zztohz()（／，设opt为运算符栈，op为运算符集合，super为运算符优先比较函数，／" ID="56">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="segstack补opt;" ID="57">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="charc,x;" ID="58">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="initstack(opt);" ID="59">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="Push（opt，‘＃‘），" ID="60">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="c=getcharO;" ID="61">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="while（。！＝‘＃’日seqtop（opt）！＝‘＃‘）" ID="62">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="63">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="c=getcharO;" ID="64">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="65">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="elseswitch(super(gettop(optc)（" ID="66">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="case‘&lt;Push（oPt，c）；／，栈顶元素优先权低，当前运算符进栈，／c=getcharU;" ID="67">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="break;case’二’：poP（oPt，x）；／，优先级相等则将栈中括号出栈＊／c=getchar;break;case'＞':putchar(pop(opt,x/＊栈顶元素优先权高，栈顶元素退栈并输break;" ID="68">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="69">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="70">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="｝利用上述算法，中缀表达式a一（(b-Fc，de转换成后缀表达式的过程如表3.3所示：数据结构" ID="71">
          <fptr EndPN="00000065" StartPN="00000064"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="栈的顺序存储结构简称顺序栈，它是运算受限的顺序表。顺序栈的存储结构是：利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。" ID="1">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="54" TITLE="3.3 栈的链式存储结构--链栈" TYPE="Chapter">
      <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <div ORDERLABEL="54" TITLE="3.3.1 链栈的类型定义" TYPE="Chapter">
        <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <Paragraph CONTEXT="如图3.8所示，链栈的结点结构和单链表的结点结构相同.值得注意的是，链栈中指针的方向是从栈顶指向栈底。" ID="1">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="链栈的数据类型可作如下定义：" ID="2">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="#include&quot;stdlib.h&quot;" ID="3">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineNULL0typedefintElemType;/，定义链栈数据元素类型‘／$Picture[00000065\00000065_new\0012.jpg]Picture$typedefstructnode" ID="4">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="5">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;" ID="6">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="structnode*next;}*Linkstack,Linknode/，定义链栈数据类型和链栈结点类型，／" ID="7">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="54" TITLE="3.3.2 基本运算的实现" TYPE="Chapter">
        <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <Paragraph CONTEXT="链栈中的结点是动态产生的，因而不必考虑上滋问题.上述链找的类型定义以及下面将给出的链栈基本运算都放在文件“linkstack,c”中，使用时需通过命令：#include&quot;linkstack.c”将其包含到应用程序文件中去。链栈的基本运算与线性链表相似，这里只介绍初始化链栈、进链栈、出链栈和输出链栈内" ID="1">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="容的算法。（”初始化链找初始化链栈即构造一个空的链栈，is是栈顶指针，它可惟一确定一个链栈。当Is=NULL" ID="2">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="时，该链栈是空栈。" ID="3">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.11" ID="4">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="Voidinitstack(linkstack1s)／，构造一个空的链栈，栈顶指针设为空即可二／｛" ID="5">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="Is=NULL;" ID="6">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)进链栈当一个数据元素进链栈时应先生成一个q结点，置数据域值为x，把is所指结点作为q结$Picture[00000066\00000066_new\0011.jpg]Picture$$Picture[00000066\00000066_new\0013.jpg]Picture$$Picture[00000066\00000066_new\0015.jpg]Picture$$Picture[00000066\00000066_new\0016.jpg]Picture$(a）原链栈（b)插人结点4后的链栈算法3.12Voidpush&lt;linkstackIs,ElemTypex)／，将元素x插人链栈is栈顶，／" ID="8">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="｛linkstackq;qlinknode，)malloc(sizeof(linknode/‘生成新结点‘q" ID="9">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="qdata=x;" ID="10">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="q一＞next=ls;" ID="11">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="is=q;" ID="12">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="13">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)出链栈应先取出栈顶结点中的数据，通过变量x返回调用函数，然后把该结点链域的值赋给栈顶指针Is，释放该结点，如图3.10所示。算法如下，若链栈为空则函数返回NULL，否则返回值" ID="14">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="为栈顶指针。算法3.13数据结构$Picture[00000067\00000067_new\0003.jpg]Picture$(a）原栈（b&gt;1除栈顶元素x后的链栈／，删除链栈is栈顶结点，／" ID="15">
          <fptr EndPN="00000067" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="16">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="linkstack关q:if(topNULLprintfunderflowreturn;)/，栈空，下溢出关／else{x=1s长＞data;/，栈顶结点数据存人xq=1s;is=1s长＞next;/，从链上去掉栈顶结点，／free(q/，释放原栈顶结点，／｝" ID="17">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)输出链栈经过若干操作后，用户一定想知道链栈中有些什么元素，该函数用于将链栈中元素从栈顶到栈底逐一输出." ID="19">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.14" ID="20">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="Void1inkprint(linkstack1s)／，从栈顶到栈底逐一输出链栈中的元素，／｛linkstackp;/，通过指针P来访问链栈is，以确保is不被破坏，／p=1s;while(pl=NULL)｛printf%d,p一＞data);P'P一仁＞next;" ID="21">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="22">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="｝对于链栈，通常不会发生栈满情况，当遇到多个栈共享空间的问题时，采用链栈是最好的解决方法，这也是链栈的主要优点之一。·56" ID="23">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="57" TITLE="3.3.3 典型应用举例" TYPE="Chapter">
        <fptr LogicalPageNum="68" PhysicalPageNum="68"/>
        <Paragraph CONTEXT="链栈的一个典型应用是存储管理中为实现动态存储分配而设置的可利用空间栈。例3.4可利用空间栈所谓可利用空间就是存储区中当前还没有使用的空间。由前面可知，每当往链表中插人一结点，首先需执行p=(linknode，)malloc&lt;sizeof(linknode))，在PASCAL语言中，使用标准过程new(p）来完成，这是从可利用空间中分配一个结点的存储空间，并将其起始地址保存在指针P中.每当从链表中删除一结点时，用函数free(p）回收空间（PASCAL语言中使用标准过程dispose&lt;p）来完成），释放P所指结点占用的存储空间，恢复到可利用状态。这是存储管理中动态存储分配的问题。简单起见，这里讨论PASCAL语言的两个标准过程newCp）和dispose&lt;p）的实现方法。为了便于上述动态的存储分配和回收操作的实现，通常在系统开始运行前，按各种已定义的指针类型，将整个可利用空间分成若干块，每块对于一种指针类型。每种指针类型的可利用空间又按该指针类型结点所需存储空间的大小，分成一个个结点存区，并将它们组织成二个链栈。设av是指针P的类型对应的链栈栈顶指针，执行new(p）时，只须将链栈av栈顶结点的存储区分配给申请结点空间的新结点P（即将此结点的存储地址赋给P+然后从av栈中删除它）；类似地，在执行dispose(p）时，就应将指针P所指的结点存储区回收n表示了上述两操作，其中，虚线图3.n存储区的分配与回收（a）结点存储区的分配（b）结点存储区的回收假定可利用空间栈按上述方案组织好，链栈av为指针p所对应的可利用空间栈。实现" ID="1">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="new（p）和dispose（p）的PASCAL过程分别用以下算法表示：" ID="2">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.15Voidnew（Iinkstackp）／二分配结点存储区，／" ID="3">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="飞P片sv；数据结构" ID="4">
          <fptr EndPN="00000069" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.16" ID="5">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="Voiddispose(linkstackp)" ID="6">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="／＊回收结点存储区，／" ID="7">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="8">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="P一仁＞next=av" ID="9">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="av=p;" ID="10">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="11">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="由于顺序栈和顺序表一样，受到最大空间容量的限制，虽然可以在“满员”时重新分配空间扩大容量，但也是不得已而为之，应该尽量避免。而且顺序栈保留着顺序存储结构的固有缺点，即在重新调整存储空间时（如多个堆栈共享指定空间），元素的移动量很大。为此，当应用程序无法预先估计栈的最大容量时，可采用链式存储结构表示栈，简称链栈。链栈是运算受限的单链表，其插人和删除操作仅限制在表头位置上进行。栈顶指针就是链表的头指针。" ID="1">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="58" TITLE="3.4 队列的逻辑特点" TYPE="Chapter">
      <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
      <Paragraph CONTEXT="队列（(Zueue）是限定只能在表的一端进行插人，在表的另一端进行删除的线性表。表中允许插人的一端称为'（尾（Rear)，表中允许删除的一端称为队头（Front假设队列为Q“（q，，q：，吼qn），那么q、是队头元素，qn则是队尾元素。队列中的元素是按QlfQ2fQ3fQ。的顺序进人的；出队列也只能按照这个顺序依次退出，图3.12是队列的逻辑结构示意图。队列同现实生活中的买票、等车的排队相似，新来的成员总是在队尾，每次离开的总是队头的成员.因此，队列又称为先进先出表，即为FIFO(FirstInFirstOut）表。队列的基本运算有：置队列为空队列、在队尾插人一个新的元素‘人队）、在队头删除一个元素（出队）、取队头元素、判队列是否为空等。同样，作为线性表的特例，队列也有顺序存储和链式存储两种结构方式，以下将分类别加以介绍。" ID="1">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="58" TITLE="3.5 队列的链式存储结构--链队列" TYPE="Chapter">
      <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
        <div ORDERLABEL="58" TITLE="3.5.1 链队列的类型定义" TYPE="Chapter">
        <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
        <Paragraph CONTEXT="链队列是限制仅在表头删除和表尾插人的单链表。显然仅有单链表的头指针不便于在表尾作插人操作，为此再增加一个尾指针，指向链表上的最后一个结点.于是，一个链队列由一个头指针和一个尾指针惟一确定，链队列的结点和链队列的类型定义如下：#include&quot;stdlib.h&quot;typedefintElemtype;／二定义链队列数据元素类型共/·58" ID="1">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="匕ypedefstructANODE" ID="2">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="【Etemtypedata;structANODE二next;｝ANODEJ，定义链队列结点类型，／typedefstruct{" ID="3">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="ANODE*front，关rear;}linkqueue;／二定义链队rj类型‘／linkqueue*1q;/＊1q是链队列指针，／和单链表一样，为了运算方便，也在队头结点前附加一个头结点，并且头指针指向头结点。当front=rear，即头指针和尾指针都指向头结点时链队列为空。带头结点的链队列逻辑结构如图3.13所示：" ID="4">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="lq一，front三III'`I" ID="5">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)图3.13链队列逻辑结构示意图&lt;a)空链队列（b)非空的链队列" ID="6">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="59" TITLE="3.5.2 基本运算的实现" TYPE="Chapter">
        <fptr LogicalPageNum="70" PhysicalPageNum="70"/>
        <Paragraph CONTEXT="链队列的基本运算将介绍以下5种操作的算法：" ID="1">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)里空链队列算法3.17" ID="2">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="*LQSETNULL&lt;Iq)/，生成空链队列，q$Picture[00000070\00000070_new\0005.jpg]Picture$linkqueue*1q;｛lq代＞front二（ANODEmalloc&lt;sizeof(QNODE／二申请头结点，／if(1.(lq&gt;frontret红rn(ERRORlq一＞front一＞next=NULL;／二头结点指针为空，／" ID="3">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="卫q-gear=lq长＞front;/＊尾指针也指向头指针，／" ID="4">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="5">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）判链队列是否为空" ID="6">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.18intLQEMPTY(lq)／二判断链队列，q是否为空‘／linkqueue*1q;" ID="7">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="｛ifq&gt;front1q一＞rear)return(TRUE);/，如果队列为空则返回“真／elsereturn(FALSE/，队列非空则返回“假”‘／｝&lt;3)取链队列头结点数据算法3.19ElemtypeLQFRONT(Iq)/，取出链队1*q的队头元素‘／linkqueue，1q;｛if(LQEMPTY(Iq)){printfthequeueisempty;returnNULL;}/，链队列为空则返回NULL*/elsereturn(lq&gt;front一）next一＞data);/，链队列非空则返回队头元素‘／｝" ID="8">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）入队链队列人队操作过程如图3.14所示。挤队列人队摸作示意图图3.14算法3.20" ID="9">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="LQENQUEUE(lq,x)/‘将结点x加人链队列＊lq的尾端‘／" ID="10">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="Linkqueue*lq;Elemtypex;｛lggear～－－：＞next二malloc(sizeof(QNODE/‘插入一个新结点到链队列尾端‘／lq&gt;rear=lq一＞rear一.仁＞next;/，尾指针指向新结点‘／lq&gt;reares－－：＞data=x;/‘给新结点赋值‘／" ID="11">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="lq一一＞reares－－：＞next=NULL;" ID="12">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）出队将队头元素x出链队列的操作如图3.15所示。算法3.21$Picture[00000072\00000072_new\0006.jpg]Picture$LQDEQUEUE(lq,e)’/＊若队列非空，删除，lq的队头元素，用e返同泪口右占」上二日nnuxi" ID="13">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="Linkqueue关1q:" ID="14">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="Elemtype关e;{ANODE*p;if&lt;lq一＞front1q&gt;rear){printfqueueisemptyreturnERROR;}/，如队列为空，则返回ERROR*/else{p=1q一二＞front;/*p指向头结点‘／*e=p一），data;／二e被赋值为头结点数据‘／lq一＞front&gt;next二P一＞next;/，删去队头元素，／指针就会丢失，则需要重新赋值队尾指针，／free(p/。释放原头结点，／" ID="15">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK;" ID="16">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="当队列采用链表作为存储结构时，被称作链队列。" ID="1">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="61" TITLE="3.6 队列的顺序存储结构--循环队列" TYPE="Chapter">
      <fptr LogicalPageNum="72" PhysicalPageNum="72"/>
        <div ORDERLABEL="62" TITLE="3.6.1 循环队列的类型定义" TYPE="Chapter">
        <fptr LogicalPageNum="73" PhysicalPageNum="73"/>
        <Paragraph CONTEXT="循环队列的设计思路是：设想向量sq一＞datalmaxsize〕是一个首尾相接的圆环，即sq一艺＞data〔0〕接在sqwe－＞data【maxsize-lj之后，这种意义下的向量称为循环向量，并将循环向$Picture[00000074\00000074_new\0004.jpg]Picture$的下界，这样就能利用到已被删除的元素空间，克服假上溢出的现象。因此人队操作时，在循环意义下的尾指针加1的操作可描述为：if(sggear-1J=maxsize)sq一＞rear=0;elsesq&gt;rear＋十；如果利用“模运算”，上述循环意义下的尾指针加1的操作，可以简洁地描述为：sq一）&gt;rear=(sq&gt;rear-1)%maxsize同样，出队操作时，在循环意义下的头指针加1操作，也可以利用“模运算”来实现：sq一）front=(sq一亡＞front-1)°omaxsize因为出队和人队分别要将头指针和尾指针在循环意义下加1，所以某一元素出队后，若头指针已从后面追上尾指针，即sq&gt;front=sq一亡＞rear，则当前队列为满。因此，仅凭等式sq-＞front二sq一＞rear是无法区别是循环队列是空队还是满队。对此，有两种解决的办法：其一是引人一个标志变量以区别是空认还是满队，另一种更为简单的办法是：人队前，测试尾指针在循环意义加1是否等于头指针，若相等则认为是队满，即判断队满的条件是：(sq1rear-1)°omaxsize=sq一）front从而保证了sqgear==sq一亡＞front是队空的判断条件.应当注意，这里规定的队满条件使得循环向量中，始终有一个元素的空间（即sq气＞data[sq7front]）是空的，即有max-size个分量的循环变量只能表示长度不超过maxsize-1的队列。这样做避免了由于判断另设的标志造成时间上的损失。" ID="1">
          <fptr EndPN="00000074" StartPN="00000073"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="63" TITLE="3.6.2 基本运算的实现" TYPE="Chapter">
        <fptr LogicalPageNum="74" PhysicalPageNum="74"/>
        <Paragraph CONTEXT="在循环队列上实现的5种基本运算如下：incluse&quot;stdlib,h&quot;" ID="1">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="defineTRUE1" ID="2">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="defineFALSE0" ID="3">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="defineNULL0" ID="4">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="defineOK1" ID="5">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineERROR0" ID="6">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="definemaxsize100" ID="7">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="玫据结构:ypedefintElemtype;:ypedefstruct" ID="8">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="Elemtypedata[maxsize];intfront,rear;Isequeue;／二顺序队列的类型＊／sequeue‘sq;/，sq是顺序队列类型的指针二／" ID="9">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)里空循环队列算法3.22" ID="10">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="sequeue-SQSETNULL(sq)sequeue二sq;/‘置队1sq为空循环队列‘／（sq一）front=maxsize-1;sq一亡＞Year=maxsize-1;return(sq}、/*SQSETNULL*/该算法中，令初始的队头、队尾指针等于maxsize-1，是因为循环变量中位置maxsize-1是位置。的前一个位t.当然也可将初始的队头、队尾指针置为一1," ID="11">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）判循环队列为空算法3.23" ID="12">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemtypeSQEVIPTY(sq)/，判:*sq是否为空‘／sequeue朴sq参｛if(sq一＞rear==sq一）front)return(TRUE);" ID="13">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn(FALSE);" ID="14">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="}SQEMPTY关／" ID="15">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)取循环队列的队头元素算法3.24ElemtypeSQFRONT(sq)/，取，sq的队头元素，／sequeue*sq;｛" ID="16">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="if(SQEMPTY(sq))｛printfqueueisempty;returnNULL;elsereturn(sq&gt;datasq一＞front+1)°omaxsize])}/*SQFRONT*i64该算法中；因为队头指针总是指向队头元素的前一个位置，所以算法中返回的队头元素是当前头指针的下一个位置上的元素。" ID="17">
          <fptr EndPN="00000076" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）入队" ID="18">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.25SQENQUEUE(sq,x)/，将新元素x插人队列二sq的队尾，／sequeue赞sq;" ID="19">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="Elemtypex;" ID="20">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="（if(sq&gt;front＝二（sq&gt;rear+1)°omaxsize){printfqueueisfull;returnERROR;)/，队列满，上滋出，／else{sq-gearsq－〕＞rear-1maxsize;sq一仁＞data[sq一＞rear]=x;return(OK);" ID="21">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝SQENQUEUE芳/" ID="22">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）出队" ID="23">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="算法3.Z6ElemTypeSQDEQUEUE(sq)sequeue关sq;" ID="24">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="25">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="if(SQEMPTY(sq))" ID="26">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="{printfqueueisempty" ID="27">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="returnNULL;}／二队列空，下滋出，／else{sq一今，front=(sq一＞front+l)%maxsize;return(sq一＞data[sq一＞front;｝一，SQDEQUEUE，/" ID="28">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="65" TITLE="3.6.3 典型应用举例" TYPE="Chapter">
        <fptr LogicalPageNum="76" PhysicalPageNum="76"/>
        <Paragraph CONTEXT="队列和堆栈一样，是计算机科学中比较简单而应用十分广泛的一种基本数据结构，其应用主要体现在以下两个方面：“是解决计算机的主机与外部设备之间速度不匹况的问题，二是解决由于多用户引起的资源竞争的问题。对于第一个方面，可以以主机与打印机之间速度不匹配的问题为例作一简要说明。主机输出数据给打印机进行打印，输出数据的速度比打印数据的速度快得多，若直接把数据送给打印机打印，由于速度不匹配，显然是不行的。所以，解决的方法是设置一个打印数据缓冲区，主·65数据结构机把要打印翰出的数据依次写人到这个缓冲区中，写满后就暂停输出，转去做其他的事情；打印机从缓冲区中按先进先出的原则依次取出数据并打印。这样做既保证了打印数据的正确，又使主机提高了效率。可见，打印缓冲区就是一个队列结构。对于第二个问题，也简要说明如下：在一个带有多终端的计算机系统中，当有多个用户需要各自运行自己的程序时，就分别通过终端向操作系统提出占用CPU的请求；操作系统通常按照每个请求在时间上的先后顺序将其排成一个队列，每次把CPU分配给队头请求的用户使用.当相应的程序运行结束或者用完规定的时间间隔后，则令其出队，再把CPU分配给新的队头请求的用户使用。这样既满足了每个用户的请求，又使CPU能够正常运行。舀.I2石KAbll4出i[i艺亡-e8o'共r若d二七彗ff`I-'Sri8hrE例3.6队列结构经常用于计算机模拟分析现实生活中的排队现象，这是计算机辅助决策的重要内容之一。以下是针对上面所说的第二个问题，也就是一个操作系统作业调度的简单模拟分析。程序采用“事件驱动方式”工作，共有3类事件：" ID="1">
          <fptr EndPN="00000077" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="1）作业提交作业进人等待队列，如果CPU（假定只有一个）不忙，从队列中取出一作业执行。这里假设有两台不同的终端可提交作业。" ID="2">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="2）作业完成进行规定的统计工作，从队列中取出一个新作业执行。" ID="3">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="3）时间片用完为防止一个作业占用CPU太久，规定每个作业一次最长占用CPU时间，如未完成则重进等待队列。用一个长度为4的数组eventtable存放4个事件（两个终端提交作业submitl，submitZ，作业完成plete，时间片用完timeout）中的每一个到下一次产生间隔的时间单位数，其值要随时间推移而修改，当值为。时相应事件发生.这里时间的修改是选出最近一个将发生的事件（在eventtable中值最小的事件），然后将时钟一下推进到发生时间上，所有与时间有关的信息必须同时修改。" ID="4">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="用一个专门的经验公式来生成作业提交时间间隔值与作业CPU时间需求值：val＝T，In（0～1之间一随机数）T为比例因子，对作业提交与CPU时间可选取不同的值，这里取15。每个作业片长取为" ID="5">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="20。每个作业（即队列中的元素）用如下记录结构表示：｝.提交时间」明待时间｝所需CPu时间种｝" ID="6">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="程序采用链队列加以实现，由于队列类型已发生改变，所以对于类型定义语句和基本操作" ID="7">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="函数要加以相应的修改.具体如下：" ID="8">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="tyPedefstruct（" ID="9">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="1叮tba昌e厂李intrun，｝ElemType；‘." ID="10">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="LQENQUEUE（Iinkqueu，e；铸Iq，ElemTypex）／，人队列操作二／lq一＞rearee－＞next=malloc(size&lt;QNODEifggear一＞next==NULL)returnERROR;lq一＞rear=1ggear一＞next;lq&gt;rear一＞data.base=x,base;Iq一＞rear.一＞data.elapse=x.elapse;lq&gt;rear一七＞data.run=x.run;lq一＞rear一＞next=NULL;returnOK;}以下是应用模块部分：算法3.27#include&quot;stdio.h&quot;#include&quot;math,h&quot;#include&quot;linkqueue.c&quot;#definesubmitl0#definesubmitl1#definecomplete2#definetimeout3defineemax4#definesmtmean15#definecpumean15#definecpulimit20#defineunused1000/＊eventtable表项缺省值＊／#definesimunum50/，模拟作业个数‘／linkqueue*Iq;intclock=O,eventtable[emaxcount=0;longtotalgt=0;" ID="11">
          <fptr EndPN="00000078" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypecurt;" ID="12">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="main()" ID="13">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="14">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="tntentry;jobsmtO;／二该函数处理作业提交，产生下一同类事件时间，／jobfin;／关该函数处理作业完成统计，启动新作业，／jobstartO;/，该函数处理作业启动，产生eventtable中时间片与作业完成项，／jobregO;/，该函数处理完时间片事件，重新人队列，／valO;/，该函数利用随机函数产生所需时间值，／nextevent/，该函数用于确定下一个该发生的事件二／newtime/，该函数用于修改时钟及eventtable中的各项值，／数据结构" ID="15">
          <fptr EndPN="00000079" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="lq=LQSETNULL(lq)" ID="16">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="srand(randU%20);eventtable[submitl]二val(smtmean);／关生成第1个终端提交作业，／eventtable[complete]二unused;eventtable[timeout〕片unused;curr,run=0;" ID="17">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="while(countsimunum)" ID="18">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="｛switch(entry=nextevent)｛" ID="19">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="casesubmitl;" ID="20">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="casesubmitl:" ID="21">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="if(jobsmt(entry)＝二ERROR" ID="22">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="break;" ID="23">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="casecomplete;" ID="24">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="jobfin;" ID="25">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="break;" ID="26">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="casetimeout;" ID="27">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="if(jobreq_=fail)｝" ID="28">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="｝printf％一lOs％一lOld°o5.2f\nCPUQtotalgr,totalgtfloat）count少其模拟过程及思路如上所述。具体的子函数的设计只介绍其功能，不再细化。有兴趣的同学可以将其进一步完成。" ID="29">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="队列的顺序存储结构称为顺序队列。顺序队列实际上是运算受限的顺序表，和顺序表一样，顺序队列也必须用一个向t空间来存放当前队列中的元素。由于队列的队头和队尾的位置均是变化的，因而要设！两个指针.分别指示当前队头元素和队尾元素在向量空间中的位置。顺序队列的类型sequeue和一个实际的顺序队列指针sq可以说明如下：" ID="1">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstruct" ID="2">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="3">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypedata[maxsizeintfront,rear;}sequeue;/，顺序队＃1的类型二／数据结构为了方便起见，规定头指针front始终指向当前队头元素的前一个位置，尾指针rear指向当前队尾元素的位置。初始状态为：队列的头、尾指针都指向向量空间下界的前一个位置，在此设为一1。若不考虑滋出，则人队可描述为：" ID="4">
        <fptr EndPN="00000073" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="sq一＞rear-/，尾指针加1，/" ID="5">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="sq一），data[sggearx;/*x人队，／" ID="6">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="出队运算可描述为：" ID="7">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="sq～一＞front;/，头指针加1" ID="8">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="图3.16表示了出人顺序队列的状态。（a）（b）（c）（d）图3.16出入顺序队列示意图显然，当前队对中的元素个数（也就是队列长度）是（sq三＞rear）一（sq一＞front）。如果sq$Picture[00000073\00000073_new\0017.jpg]Picture$$Picture[00000073\00000073_new\0018.jpg]Picture$$Picture[00000073\00000073_new\0019.jpg]Picture$$Picture[00000073\00000073_new\0020.jpg]Picture$一＞front＝sq一亡＞r臼r，则队列的长度为0，即当前队列是空队列，如图3.16的（a），（d）都表示空队列。队列为空时再做出队操作便会产生“下滋出”。队列满的条件是当前队列长度等于向量空间的大小，即：（sq一＞rear）一（sq一＞front）＝maxsize，队列满时再做人队操作就会产生“上溢出”。但是，如果当前尾指针等于向量的上界（即sq一＞rear＝maxsize-1），即使队列不满（即当前队列长度小于maxsize），‘再作人队操作时也会造成滋出。如图3.16（。）是当前队列的状态，即maxsize＝7，sq一＞rear＝6，sq一＞front今2，因为sq一＞rear＋1＞maxsize-1，故此时不能做人队操作，但当前队列并不满，这种现象称为“假上溢出“。产生该现象的原因是：被删除元素的空间在该元素别除后就永远使用不到。为了克服这一缺点，可以在每次出队时将整个队列中的元素向前移动一个位置，也可以在发生假上滋出时将整个队列中的元素向前移动直至" ID="9">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="头指针为一1，但这两称方法都会引起大量元素的移动，所以在实际应用中很少采用。通常采用的解决方法是使用循环队列." ID="10">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="68" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="79" PhysicalPageNum="79"/>
      <Paragraph CONTEXT="本章介绍了两种特殊形式的线性表：栈和队列。栈和队列广泛应用于各种程序设计中，是68非常有效而实用的设计手段，将其单独加以介绍是必要的。栈和队列虽然是线性表，但它们的运算与线性表的运算又有很多的不同之处。对栈进行结点的插入（进栈）、删除（出栈）操作只能在栈的一端（栈顶）完成。而队列的插人（人队）和删除（出队）只能分别在队列的两端（对列头、队列尾）进行。栈具有后进先出的逻辑结构特点，采用顺序存储和链式存储两种方式进行存储。在顺序栈中存储结构较简单，只需要采用一维数组并附设一个指针指示栈顶位置即可实现；但是由于顺序栈的空间是先做预分配，当发生溢出时才进行一定增量的再分配，所以需要考虑栈的空间大小及滋出处理.在顺序栈中，采用多栈共享空间的方法解决溢出情况，可以节省空间，但仍然存在移动大量数据元素的弊病。在链栈中，栈的空间在建立结点时临时申请并加以动态分配，只要内存空间允许就可以使用，不用考虑溢出情况，较为灵活.队列具有先进先出的逻辑结构特点，同样具有循环队列和链队列两种存储形式。循环队列结构简单，用一维数组加以实现，设置的指示队列头和队列尾的指针只要用简单变量即可，但需要附加判断队列是否为空（或满）的操作。链队列需要在单链表的基础上增加一个尾指针，指向链表上的最后一个结点，不必判断队列的滥出情况。本章分别给出了栈和队列的不同存储结构的定义和算法描述，并以数制账户转换、括号匹配、表达式求值、可利用空间栈及离散事件的模拟等应用实例具体说明。希望读者在了解了它们各自的基本操作后能熟练掌握栈和队列这两种抽象数据类型的特点，并能在解决具体问题" ID="1">
        <fptr EndPN="00000080" StartPN="00000079"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="69" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
      <Paragraph CONTEXT="3.1简述栈和队列这两种数据类型的相同点和差异处.3.2已知堆栈采用链式存储结构，初始时为空。试画出u,v,w,x四个元素依次进栈以后堆找的状态，然后画出此时的栈顶元素出栈后堆栈的状态。3.3若按从左至右的顺序依次读人已知序列{a,b,c,d,e,f,g｝中的元素，然后结合堆栈操作，能得到下列序列中的哪些序列（每个元素只进栈一次，下列序列应该是出栈的{e,f,d,g,b,c,a}{c,d,b,e,f,a,g}3.4用图表示出使用栈将表达式“9*(8-35+4”转换成后缀表达式并计算出结果的过程。3.5设中缀表达式E存放在字符数组中，并以＆作为结束标志。试写出判断一个中缀表达式中左、右圆括号是否配对的算法。试给出此循环队列的队满条件，并写" ID="1">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
      <Paragraph CONTEXT="4" ID="2">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="如份‘月卜超毖." ID="3">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="乒斤」眨生碑.数组和串卿兜麒螂招弧险脚翱麒缈摊琢咽分翻熬职涸梦吸多侧熟卿脚沙双孚沌雌甩派，卿罗烈魂哪吸脚橄，嗽娜秘职妙，那此沙顺孚限晚范派液华艇沙砸李，舀水那芬雌顺准陌，吸娜到或睡，致数组是一种最常见的数据结构，几乎所有的高级程序设计语言都设定数组类型为固有类型。数组也是一种线性数据结构，可以看成是线性表的一种扩充。本章首先介绍了数组的逻辑特点，第4.2节讨论了数组的顺序存储结构和在这种结构下数组元素的寻址公式推导；第4.3节介绍了特殊矩阵的压缩存储方法；第4.4节讨论了稀疏矩阵在压缩存储表示下运算的实现；第4.5节介绍字符串几种不同存储结构和字符串的基本操作，重点介绍了字符串的模式" ID="4">
        <fptr EndPN="00000081" StartPN="00000081"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="70" TITLE="第4章 数组和串" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="70" TITLE="4.1 数组的逻辑特点" TYPE="Chapter">
      <fptr LogicalPageNum="81" PhysicalPageNum="81"/>
      <Paragraph CONTEXT="在早期的程序设计语言中，数组通常是组织数据的惟一结构。目前，几乎所有的高级程序设计语言都设定数组类型为固有类型。读者在学习程序设计语言时，可能已经了解了数组的一些应用.例如可以用一维数组表示一组有序的数据；用二维数组表示一个矩阵等。数组是线性表的一种扩充。一维数组即为线性表，二维数组定义为“其数据元素为一维数组”的线性表，如图4.1所示的数组Am。可表示为列向量的线性表，AmxnIQfal,Q2f…,an一；），也可表示为行向量的线性表A,x。二（肠,尽1fRm一，），其中每个数据元素又是一个一维二维数组中的任一元素同时受到行关系和列关系的约束。a，既是同行元素a、一，(iJO)的后继，也是同列元素a，一：(j&gt;0)的后继，它既在一个行表中，又在一个列表中。可将上述定义推广到多维数组，如三维数组可看成“数据元素为二维数组的线性表”.数组是一种“均匀”结构，即同一个数组中各元素必须是同一类型的。数组也是一种“固70$Picture[00000081\00000081_new\0018.jpg]Picture$定”结构，即数组所含数据元素的个数不变，因此，没有插人和删除运算。数组又是一种随机存取结构，只要给定一组下标，就可以访问与其相关联的值.就数组而言，我们所关心的主要是两个操作：" ID="1">
        <fptr EndPN="00000082" StartPN="00000081"/>
      </Paragraph>
      <Paragraph CONTEXT="①值检索―给定一组有定义的下标，访问相应的数据元素；②值存储―给定一组有定义的下标，修改、存储相应数据元素的值。" ID="2">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="71" TITLE="4.2 数组的顺序存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="82" PhysicalPageNum="82"/>
      <Paragraph CONTEXT="在计算机中，表示数组最普通的方式是采用一组连续的存储单元顺序地存放数组元素。由于内存是一维的，而数组是多维结构。因此，我们所关心的是如何用一个一维内存表示n维数组，选择一种方法能任意存取数组元素.比如给定元素a，即可有效地确定其在内存中的位置。用一组连续的存储单元存放数组的元素有个次序约定问题。例如二维数组a[21[3〕可以看成图4.2&lt;a）的一维数组，也可以看成图4.2&lt;b)的一维数组。对应地，表示一个二维数组可以有两种方法，一是以行序为主次序的存储方式，即先存储第。行元素，再存储第1行元素，…，如图4.2(a)所示。一种是以列序为主次序的存储方式，即先存储第。列元素，再存储第1列元素，…，如图4,2(b)所示。助图4.2二维数组a[21[3」的存储方式由此，对于数组，一旦规定了它的维数和各维的长度，便可为它分配存储空间。只要建立起数组元素的下标和存储地址之间的对应关系，就苛由下标值随机地访问该数组的任一个先素。下面就以行为主次序的存储方式为例予以说明。假设数组a[21[3〕采用以行序为主次序的存储方式，并假定a[01仁。〕存储于单元100，则a[01[1」存储在单元lOl,a[11[2〕储存在单元105（假定每个数组元素只占一个内存单元）。这个地址是很容易猜出来的。一般地说，我们可以推导出一个给定下标值就能得到其地址的公式。这个公式称为寻址公式，这个公式只与数组的开始地址和数组的维数有关。" ID="1">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构数组元素。〔p〕a［ljatga(ja[n]地址aa-1a+2…a'Fian" ID="2">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="图4.3一维数组中元素与其存储地址的关系对于二维数组a[m][n]，每个元素对应两个下标值。我们可以将其解释为m行，即行0,行1，，行m-1，每一行由n个元素组成，如图4.4所示.第0行XXX第m-1行XXXn个元素n个元素" ID="3">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="第0行第1行第i行第m-1行卜一～、个元紊一－一叫(b)图4.4二维数组的以行为主的顺序表示法所以第i行第一个元素a[i0〕的地址是。十iXn.知道了a[i0〕的地址，根据一维数组的寻t＿.，、一J‘广·，r·，占‘.，LL.，r二气ai·.，二口一tayrl.‘v.a二」1.ti、-1JL.因此二维数组的寻址公式为：Loci,j]=a+iXn+j三维数组a可看成m个大小为nXp的二维数组，如图4.4所示，其中每个二维数组的表示如二共别毕r:〕厂n〕「nl今启台1乡.；洲从一-,i.,uac,一翻津幽粉咬目由八〕Fn飞66栩1书卜T；卜〕开一元素a〔ij［0〕〔0〕之前，有1个大小为nXp的二维数组。维数组的寻址公式，可求得到三维数组寻址公式为Q＋ixn％P＋jxp＋k卜－1口401间创口" ID="4">
        <fptr EndPN="00000083" StartPN="00000083"/>
      </Paragraph>
      <Paragraph CONTEXT="对于许多应用程序来说，数组仍然是完成任务的合适工具。" ID="5">
        <fptr EndPN="00000084" StartPN="00000084"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="73" TITLE="4.3 特殊矩阵的压缩存储" TYPE="Chapter">
      <fptr LogicalPageNum="84" PhysicalPageNum="84"/>
      <Paragraph CONTEXT="矩阵是许多科学与工程计算问题中出现的数学对象。在此，我们感兴趣的不是矩阵本身，我们所关心的是研究表示矩阵的方法，以使对矩阵的各种运算能有效地完成。一个矩阵一般由m行和n列元素组成，如图4.6所示。一般的mXn阶矩阵，可表示成一个mXn的二维数组，例如matrix[m][n],需要的存储$Picture[00000084\00000084_new\0008.jpg]Picture$空间是mXn。在这种表示方法下，可用matrix[ij〕来访问矩阵中任意元素，矩阵运算也比较简单.现在看图4.6所示矩阵MZ，就可发现，该矩阵中的元素是对称的，即矩阵中第i行第j列与第J行第i列元素的值相等，即matrix[i][j]=matrix[j][i]，我们把这种矩阵称为对称矩阵。对于nXn阶对称矩阵，我们可以为每一对对称元素分配一个存储空间，即只需要存储其下三角（包括对角线）或上三角中的元素即可。这样，就可将nZ个元素压缩存储到n(n十12个存储单元中。假设以一维数组a［n（n＋1）／2〕来存储nXn阶对称矩阵的下三角元素，注意矩阵的第0行只存储一个元素，第1行存储2个元素，依此类推。这样，第i行前面共有i行，总共要存储艺k一（(iZ-i2个元素。再增加l到达i行的第l个位置就会得到下面的对应关系，把原来拓陇巾的行晋「门「门拱施衡一堆扮拍中不确的待晋.matrix[ij]=aiz+i2+j]之，对所有的k=0,1,2,…,n(n十12-1，都能确定a[k〕中的元素在矩阵中的位置（(i,j)。由图4.7图4.6所示对称矩阵MZ的压缩存储当一个nXn阶矩阵的主对角线上方或下方的所有元素皆为零时，称该矩阵为三角矩阵。如图4.8所示。对于三角矩阵，我们同样也可采用对称矩阵的压缩存储方式将其上三角或下三角的元素存储在一维数组中，达到节约存储空间的目的。数据结构$Picture[00000085\00000085_new\0002.jpg]Picture$$Picture[00000085\00000085_new\0003.jpg]Picture$储在矩阵中的大量元素值为零，而且零元素的分布没有规律，这样的矩阵称为稀疏矩阵。图4.9给出了一个7行6列的稀疏矩阵。该矩阵有42个元素，其中8个是非0元素，34个0元素。对于稀疏矩阵，采用二维数组表示既浪费大量的存储单元来存储零元素，又要花大量的时间进行零元素的运算。·例如在做两个矩阵相乘运算时，零元素的运算可不必考虑。为此，我们为稀疏矩阵寻找一种新的存储其元素方法，这种表示法只存储矩阵中的非零元素。我们知道一个矩阵中的每个元素均由其行和列惟一确定，如第；行，第j列就惟一确定了矩阵中的一个元素，由此，可按三元组表示稀疏矩阵中的非零元素，即$Picture[00000085\00000085_new\0019.jpg]Picture$$Picture[00000085\00000085_new\0020.jpg]Picture$只i,，,a。：)对于任何一个稀疏矩阵，我们可以将它的非零元素转化成三元组形式，并按某种方式（如按行号递增的方式）存放在内存中。于是，图4.9(a)所示的稀疏矩阵I就可压缩存储在数组a仁t3」中，如图4,9(b)所" ID="1">
        <fptr EndPN="00000085" StartPN="00000084"/>
      </Paragraph>
      <Paragraph CONTEXT="示。其中t=8是矩阵中非零元素的个数，元素a[01[01,a[01[1〕和a[01[21表示稀疏矩阵的" ID="2">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
      <Paragraph CONTEXT="行数、列数和非零元素个数。" ID="3">
        <fptr EndPN="00000085" StartPN="00000085"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="75" TITLE="4.4 稀疏矩阵运算的实现" TYPE="Chapter">
      <fptr LogicalPageNum="86" PhysicalPageNum="86"/>
        <div ORDERLABEL="75" TITLE="4.4.1 矩阵转置" TYPE="Chapter">
        <fptr LogicalPageNum="86" PhysicalPageNum="86"/>
        <Paragraph CONTEXT="矩阵转置是移动矩阵中元素的位置，使位于（：，户的元素在转置矩阵中位于（(j,l)。换一个说法，就是把行与列对换，对角线上的元素因i=j将保持不变。图4.9(a)所示矩阵lul的转置矩阵T和T对应的三元组表b，如图4.10所示。" ID="1">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="T=" ID="2">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="ca)图4.，所示稀琉矩阵M的转置矩阵Tcb&gt;转置矩阵T的三元组表”设数组a表示矩阵I的三元组表，数组b表示矩阵i的转置矩阵T的三元组表，实现矩阵转置的一种方法是将矩阵Ii中的元素逐列从上而下（相当于在矩阵T中逐行从左到右）置人三元组表b中。为此，应对三元组表a中第1列元素进行多次反复扫描，第一次取出矩阵lu'J$Picture[00000086\00000086_new\0011.jpg]Picture$$Picture[00000086\00000086_new\0012.jpg]Picture$中列号为0（也即T中行号为0)的所有元素，将它们顺序放人b中，第二次取出矩阵M中列号为1（也即T中行号为1)的元素，将它们顺序放人b中，如此进行下去。直到a中所有元素均放人b中，转置过程结束。实现上述矩阵转置过程的C语言函数为transpose。其中m和n分别为矩阵lul的行数和列数，t为M的非零元素个数。P表示a中某行的下标，4表示b中某行的下标，col表示矩阵M中某列的列号." ID="3">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="算法4.1" ID="4">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="voidtransposs(a,b)" ID="5">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="｛m=a[01[01;n=a[01[11;t=a[01[21;b[01[01=n;b[01[1m;b[01[21=t;数据结构" ID="6">
          <fptr EndPN="00000087" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="if(t0)exit;Q=1;/，从b的第一行做起＊／for&lt;co1=O;col&lt;n;col{/，按III的1进行转置‘／for&lt;p=l;pt;p{／二对所有非零元素‘／｝" ID="7">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="8">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="｝$Picture[00000087\00000087_new\0012.jpg]Picture$以图4.9和图4.10为例，分析此算法的执行情况。算法首先由a的第0行元素得到矩阵的行m、列n和非。元素数目t，并将m,n和t分别赋给b的第0行元素。接下来对a的第1列元素从第1行到第8行进行6次扫描（因为矩阵M有6列，8个非零元素）。第一次扫描，挑出所有数值为。者，即在矩阵lul中的第0列者，逐个放人数组b中。此例中a的第1行和第7行元素的列号为0，分别放人b的第1行和第2行。第二次扫描，挑出所有数值为1的元素，只有第4行数值为1，将其放到b的第3行。接下来将a中第5行和第8行的元素分别放到b的第4,5行。如此做下去，直到a中所有元素都放到b中为止，转置结束。要注意的是，当a的某行放到b中时，a的第。列数值放到b的第1列，第，I列数值放到b的第0列。上述转置算法主要的运算时间花在两个for循环上，每循环一次，if语句就执行t次，由于for循环重复次数是nXt，所以算法的时间复杂性是O(nXt)。除了a和b所需空间外，该算法只需固定量的额外空间，即变量m,n,t,p,col和4所用的空间。我们知道，若把矩阵表示成二维数组时，矩阵转置经典算法的关键代码为：for（j，0犷j＜n，j＋＋）该算法可以在0（nXm）时间内完成矩阵转置。而当矩阵表示为三元组表时，其非0元素个数t的数量级为nXm时，算法trans卯se的时间复杂性0（nXt）便成为0（矿Xm）。这比用二维数组时的时间复杂度0（nXm）更差。另一种实现翅阵转t的书冲子舞法是按数组a中元素的次序逐个将元素放人b中相应的位置。如果能预先确定矩阵M中每一列（即T中每一行）的第一个非。元素在b中应有位置，那么在对a中的元素依次转置时，便可直接放到恰当的位置上去.为了确定a中元素在b中的位置，首先确定出M的每一列中非0元素的个数。这就提供了T中每行中非0元素的个数，有了这个信息，就可容易地获得M中每一列的第一个非。元素在b中起始位置，就可将a的元素逐个移到b中的适当位置.为此，需要附设两个一维数组5和T.数组5存放矩阵M中每一列非零元素个数，5［门表示矩阵M的第1列非零元素个数。数组T存放矩阵M的每一列第一个非零元素的起始位76置，T[i〕表示lul中第i列第一个非零元素在b中的起始位置。S[i］的值可通过统计稀疏矩阵M的三元组a中第1列i的出现次数，T[i〕的值可通过下述公式推出：T[i]=T[i-11+S[i-11图4.9&lt;a）所示矩阵的S和T的值如图4.11所示。导拱洲洲" ID="9">
          <fptr EndPN="00000088" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="图4.11图4.9(a)所示稀疏矩阵的数组S和T的值" ID="10">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="按照上述思想进行稀疏矩阵转置的算法称为快速转置，其C语言实现为：算法4.2intFastTranspose(a,b)｛m=a[01[01;n=a[01[11;t=a[01[21;b[01[01=n;b[01[11=m;b仁01[21=tn;if(t0)return;" ID="11">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=O;i&lt;n;iS[i]=0;/*S[i〕赋初值，／for&lt;i=1;iG=t;i十＋）S[a[i111=S[a[i111-1;／二计算S[i〕的值二／" ID="12">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="T[iT[i-11+S[i-11;/，计算T[i]*/" ID="13">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=l;it;i){a[i11;a[i01;a[i21;+1;｝｝上述快速矩阵转置算法中有4个循环，它们分别执行n,t,n-1和t次。这些循环每重复" ID="14">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="77" TITLE="4.4.2 矩阵相乘" TYPE="Chapter">
        <fptr LogicalPageNum="88" PhysicalPageNum="88"/>
        <Paragraph CONTEXT="其中OC1&lt;m,O（j&lt;p." ID="1">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="假设矩阵A,B[tC都采用二维数组表示，则两个矩阵相乘的经典算法是：for(i=O;i&lt;m:ifor(j=O;j&lt;P;j){" ID="2">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="c[ij]=0;" ID="3">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="这个算法的时间复杂性为O(mXnXp" ID="4">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="在矩阵相乘的经典算法中，不论a[ik〕和b[kj〕的值是否为零，都要进行乘法运算.而实际上我们知道，a[ik]和b[kj］有一个值为零时，其乘积也为零。因此，当A和B是稀疏矩阵并用三元组表表示时，就不能套用上述算法。在对稀疏矩阵进行运算时，应去掉这种无效操作。换句话说，稀疏矩阵相乘时，只需进行非零元素之间的运算。例如，假设稀疏矩阵A和B分别为一日" ID="5">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="它们的三元组表a,b和c如图4.12所示。" ID="6">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="图4.12稀疏矩阵A,B,C的三元组表’(0,1,2)，其在三元组表的位置是b[11，因此两者的乘积为6，该乘积是C的第。行第1列元素的一部分.a[21所表示的矩阵A的非零元素（(0,3,2)应与b[3〕所表示的矩阵B非零元素（3,$Picture[00000089\00000089_new\0026.jpg]Picture$1,1）相乘，其乘积2是c[0丁[1］的一部分，应累加到C中c[01[i］上，因此。[01[1〕的值为8a而a中元素a[3〕所表示矩阵A的非零元素（1,1,1)，应与矩阵B的第1行非零元素相乘，由于R中无行号为1的非零元素，因此，该元素不需要和·b中任何元素相乘。一般来说，假设从三元组表a中取出某元素，它在矩阵A中的行号为u=a[i][01，列号为k=a[i11，则需要在三$Picture[00000089\00000089_new\0031.jpg]Picture$$Picture[00000089\00000089_new\0032.jpg]Picture$$Picture[00000089\00000089_new\0033.jpg]Picture$.7g.元组表b中找出矩阵B中所有行号为k的非零元素。如果某元素在矩阵B中的行号为k，列号为v=bCj〕C1，则它与a中取出的该非零元素相乘，乘积应加到C的第u行第v列元素上。C的这个元素不一定只含一个乘积项，可能是多个乘积项之和，因A中第u行的其他非零元素与B中第v列的相应元素相乘，其乘积也是加到C的这个元素上。由上面的分析，稀疏矩阵相乘的基本操作是：逐个从数组a中取出元素，按其在A中的列号j在b中找出矩阵B中所有行号为i的非零元素，将它们分别与A中取出的该非零元素相乘，将乘积累加到C中相应的元素中去。为便于操作，应对每个乘积设一累计和的变量，其初值为零。假设A是一个mXn稀疏矩阵，非零元素个数为tl,B是一个nXp稀疏矩阵，非零元素个" ID="7">
          <fptr EndPN="00000090" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="tZ，且A与B已表示成三元组表的形式，A与B的乘积为C，表示成mXp的二维数组形" ID="8">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="如果矩阵C是稀疏的，还需要进行进一步的运算，将它表示成三元组表的形式。一个实" ID="9">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="数为t：，且" ID="10">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="式。" ID="11">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="现上述稀疏矩阵相乘的算法如下：算法4.3intMatrixMultiply（a，b，c）" ID="12">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Picture URL="00000090\00000090_new\0018.jpg">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Picture>
        <Paragraph CONTEXT="｛" ID="13">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="m＝a［0〕【0〕；n二a〔0〕［1〕；t，＝a〔0〕〔2〕；" ID="14">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="if（n＝＝b〔0］【0〕）｛" ID="15">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="P" ID="16">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="tZ＝｝if（tl，t0）return；for（1＝0；1＜n；1＋＋）5＝0；for（1＝1；1＜＝tZ；1＋＋）5［b仁、j［0〕〕二斗b〔1〕〔0〕〕＋1；T［0〕＝1；k二a［1］［1〕；.／二a中列号为k的非零元素，／" ID="17">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="for（j＝T「k〕；j＜＝T〔k＋1〕一1；j＋＋）／，b中第k行所有非零元素，／／，b中第k行所有非零元素，／a［1〕［2〕二b［j〕［2〕；｝此算法中数组5和T的意义与矩阵转置中相同，分别表示矩阵B中各行非零元素个数和" ID="18">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="19">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="80" TITLE="4.5 串" TYPE="Chapter">
      <fptr LogicalPageNum="91" PhysicalPageNum="91"/>
        <div ORDERLABEL="80" TITLE="4.5.1 串的存储表示与操作实现" TYPE="Chapter">
        <fptr LogicalPageNum="91" PhysicalPageNum="91"/>
        <Paragraph CONTEXT="串的存储表示主要着颇序表示和链接表示两种。‘究竟用哪一种袭示法，应考虑如何节约存储空间和芳使学符申的运算…" ID="1">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)顺序表示法采用这种表示法，一个字符串的相继字符存放在连续的存储单元的相应位置里。最简单的顺序表示法是采用非紧缩格式，即每个存储单元中存放一个字符，所占存储单元数目即为串每个存储单元可存放两个字符，存储空间利用率只有50。对每个单元可存放更多字符的情况，空间利用率更低。故非紧缩格式通常适用于程序中字符串变量不多，每个字符串变量的长度又不太长的情况。｛t一】h-IliIS-1簇15-i一卜一卜一i州iian图4.13字符串的非紧缩格式为了充分利用存储空间，也可采用紧缩格式的顺序表示，即在每个存储单元中存放多个字符。采用这种表示法，从所占存储单元数目不能确定出字符串的长度（因字符个数不一定是存储单元的整数倍，最后一个存储单元可能未占满），故需将字符串的长度在串前面明显给出。在串前面的单元中。｝1-61t！hli一】一11：一i-i,一州一.图4.14字符申的紧缩格式如果计算机是以字节为存取单位，则可以单字节格式存放字符串，一个字节存储一个字符。这种存储方式既便于随机存取又充分利用了空间，串的长度可在串的前面显示给出，也可不。卜ihi小日州'IIIFI1I·I=k°" ID="2">
          <fptr EndPN="00000092" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="4.巧字符申的单宇节存储格式，字符’＠’为串结束符图4.15字符串的顺序表示法对执行如求字符串的长度、字符串的连接，求子串等操作是合适的，但是当我们要在一个字符串的中间进行插人或删除操作时，这种表示法就不合适了。在字符串5的第1个位置插人字符串‘tltZ…t需把字符串5的某些字符进行移动。删除一个子串，" ID="3">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="其实现方法，或者用一个特殊符号来代替被删除的字符，或者将被删除字符的位置用其后继的有在被取代的字符串长度与取代串的长度相等的情况下，才是有效的，不然的话，这项操作也需要某种形式的串移动。串的单字节存储结构可用C语言描述为：" ID="4">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="chars［MAXSIZEj；" ID="5">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="其中MAXSIZE表示串的最大长度.假设字符串的长度没有显示给出，而是以字符‘＼0‘表示" ID="6">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="字符串的结束.下面以求串的长度、申连接和求子串为例讨论如何在这种存储结构表示时实" ID="7">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="现串的操作。" ID="8">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="1）求串的长度" ID="9">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="算法4.4" ID="10">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构for(k二1；5〔kj！＝‘＼0‘；k＋＋）；returnk;" ID="11">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="2）串连接concat(l,s,t)串的连接就是将串，和t首尾相连成一个字符串1，其中s在前，t在后。只是要注意当串假设串，和t的长度分别为slen和tlen.根据串5和t的长度不同的情况，串1的产生有3种情况：①slen＋den＜今MAXSIZE，则串1是串5和t的正确连接结果云②slen＋tlen＞MAXSIZE，而且slen＜MAXSIZE，则会将串t截断，串1包含串5的全部字符和串t的部分字符；③slen＝MAXSIZE，则串1完全由串5的字符组成。一个实现串连接的C语言函数如下：算法4.5void。oncat（charl［〕，charshart［〕）／，将串5和t首尾相连成一个字符串1＊／｛if（slen十tlen＜＝MAXS不ZE）｛movech（1，5，1，1，slen）；movech（1，t，slen十1，1，tlen）；if（（slen＋tle。＞MAX斗ZE）衣乙（slen＜MAx马1球））气movech（1，5，1，1，slen）；" ID="13">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="’、.！、尸’else｛if（slen＞二MAXSIZE）rnovech（1，5，1，1，MAXSIZE）丫｝.’‘”冬｝在函数concat中用到另一个函数movech（，，t，1，j，n）.该函数功能为将位于从串t的第j个位置起的n个字符序列依次传送封牢5的第凌个起始的位t，下面是该函数的实现。算法、4.‘…’义movech（5，t，1，j，n）" ID="14">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="／二从串t的第j个位置起的n个字符序列依次传送到串5的第1个起始位置上，／’" ID="15">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="（intk；for（k＝0；k＜n-1；k＋＋）" ID="16">
          <fptr EndPN="00000093" StartPN="00000093"/>
        </Paragraph>
        <Paragraph CONTEXT="3）求子串substr(s,t,start,length)求子串的过程是复制字符序列的过程。将申t中从第start个字符开始长度为length的字符序列复制到申s中。函数substr实现求子串的功能。算法4.7voidsubstr&lt;charschartintstart,int1ength)／二子串s即为从串t第start个字符开始长度为length的字符序列，／｛ifstrat-1ength&gt;slen)11(start&lt;0）日（length&lt;0/＊参数不合法，／" ID="17">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="exit;" ID="18">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="19">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="movech(s,t,l,start,length" ID="20">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="21">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）链接表示法和线性表的链式存储结构类似，也可采用链表方式存储串值。将串中的字符存储在结点中，每个结点有两个域：element和next,element存放串中的字符，next存放指向下一个结点的指针。由于串结构的特殊性，结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个结点大小的问题，每个结点可以存放一个字符，也可以存放多个字符。例如，图4.16&lt;a)是每个结点可以存放4个字符的链表，图4.16(b)是每个结点存放一个字符的链表。串的链式存储结构对某些串操作，如连接操作等有一定方便之处；但对在字符串中间进行插人操作时，可能要把一个结点一分为二，在进行删除操作时，可能出现结点的合并。总的来说，串的链式存储结构不如顺序存储结构灵活。链式存储结构的串操作与线性表在链表存储结构中的操作类似，在此不做详细讨论，读者可自行写出相应算法。" ID="22">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="83" TITLE="4.5.2 串的模式匹配算法" TYPE="Chapter">
        <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
        <Paragraph CONTEXT="给定两个字符串S和T，把T看成要在S中查找的模式。如果在S中找到T，就给出T在S中的起始位置，这称为串的模式匹配。串的模式匹配是各种串处理系统中最重要的操作之一。假设m表示主串S的长度，n表示子串T的长度，一个简单的模式匹配算法如下：算法4.8" ID="1">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="intindex(charS,charT)" ID="2">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="麦" ID="3">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="Intl" ID="4">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="5">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="i=1;j二1;" ID="6">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="whileim)(jn{" ID="7">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="if(S[i〕二＝TCiJ){" ID="8">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="9">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="10">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="j=1;" ID="11">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="if(j&gt;n)" ID="13">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="return(i-n" ID="14">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="15">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="·return(0" ID="16">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="算法index的思想是：从主串S的第一个字符和模式T中的第一个字符比较；若相等，比较后续字符，若不相等，从主串S中的第二个字符起重新和T的第一个字符比较，直至S中的一连续字符序列与T相等，则匹配成功，否则匹配不成功。这个算法很简单，可惜它的效率不高，若Saaa…a'相等，但T的第n个字符和‘a，不相等.指针i将移至S的第二个字符开始重新比较，于是T的n-1个’a，又和S重新匹配。第n个字符在S中找不到匹配，如此下去，就可看到S和T共同具有n-1个，a，的次数是m-n+1，即需m-n-I-1次匹配.每次匹配需n次比较，所以in-dex算法至少需要nm-n-1)次操作，其时间复杂度为O(mXn一种对前面字符串的匹配算味做了很大改进的算法是D.E.Knuth与J.H.Morris和" ID="18">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="V.R二att同时发现的，简称为KMP算法。此算法可以在O(n十,）的时间数量级上完成串的滋津沉即握作（冲甲m妻3%士出GfI裕F$_n弃录道才出的裕磨分析算法index的执行过程，造成index算法速度慢的原因是回溯，而这些回溯并不是必.我们希望在每越匹配后，指针i不回溯，而是由j退到某一个位tk上，使t中k前的要的。k-1个字符与，中i指针前的k-1个字符相等，继续进行比较。这将减少匹配的趟数，提高算法的效率，因此如何得到k值是KMP算法的关键。一般情况下，设tabcabcacab'，令s=‘s,sZsID，并假定要确定自s、开始是否有一个匹配。若S,a'，那么很清楚，可以进而比较s，与‘a，同样，若5，＝rarsa，并且s1笋'b，那么进而tabcabcacab'意指不知道在s中这个字符是什么.s中的第一个代表、t+z，并且st＋2笋,szc。此时，通过把t中的第一个字符和sz相比较，可以继续匹配过程。因为s+：和t的第二个字符'b‘是相同的，故，。十，并'a'，因此，无须将t的这个字符与s,十，相比较.现在再假设t的前4个字符匹配成功，而第5个字符不匹配，即s护’b，于是有：可以看出，把s。与t的第二个字符‘b’进行比较，就是将t向右移动到出现局部匹配的位置k,就可继续匹配过程，而无须在s中向后到退。为了将这一个位置固定下来，我们为t定义一个函数next(j)，若令next&lt;j)=k，则next(j）表示当t的第j个字符与s中相应字符不匹配时，模式t中重新和s中相应字符进行比较的字符位置。即当s,共t,时，模式t向右移j-next(j）个字符，模式t中的第k个字符与主串s的第i个字符继续比较下去。若next&lt;j)=0，则j移到t的第一个字符，即si与t；进行比较。根据上面的分析，KMP算法的C语言实现为：intKMP(charschart" ID="19">
          <fptr EndPN="00000096" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="20">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,J;" ID="21">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="i=1;j=1;" ID="22">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="whilei＜二m）＆＆（j＜＝n））｛" ID="23">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="ifj0川（5〔1〕“＝t［j〕））（" ID="24">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="i十十；" ID="25">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="26">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="elsej=next(j" ID="27">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="28">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="if&lt;j&gt;n)" ID="29">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="return(i’一n);" ID="30">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="31">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="return&lt;0" ID="32">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在KMP算法中，每次重复时i总是沿s向右移，而不左移，循环体中语句i＋最多执行m次，所以KMP算法的时间复杂性为O(mKMP算法是在已知模式串1Jnext函数值的基础上执行的，那么，如何求得模式串的next函数值呢？从上述讨论可知，next(j）有下列性质：①next(j）是一个满足于。&lt;next(j)&lt;j的整数。®next(j)=k，表明当模式t中第j个字符与主串中相应字符不匹配时，在模式t中需要重新和主串中该字符进行比较的字符为Lk。这说明模式中前k-1个字符与S中的i指针前的k-1个字符相等。" ID="33">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="34">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="而已经得到的部分匹配的结果是" ID="35">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="由式（4.1)和式（4.2)得到下列等式③如果在一趟模式匹配中，模式中的第一个字符与主串中的当前字符S.不匹配，下一趟匹配应将t：与s,十1继续比较，即next(1）二0,④如果在模式t中，不存在相同的子串，则下次匹配j应指向t的第一位，即t向右滑动l-1位，这时令next(j)=1。由此可得出next(j）的定义：next(j’一布max{k11&lt;k&lt;j，且有’tltptk-1’一”】一k+1”一“＋一’成立’以其他情况" ID="36">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="由next的定义，我们看到k值只取决于模式本身，而与主串无关，于是可以使用递推方法" ID="37">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="求得next的值。" ID="38">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="若tk=t,，则表明在模式申中存在'tttztk't，一、+It，一k＋2…tJ'k+2则next(j-1）二next(j)+1=k+1若tk笋t，表明在模式申的第j十1个字符之前，不存在长度为k+1&lt;next(j1)和首字符起的子串模式相匹配的子串，即‘tltztk'护't-k+ltl一、十2…t』'z',。此时可把求next函数值的问题看成是一个模式匹配问题，整个模式串既是主串又是模式串.而当前在匹配过程中，已有’" ID="39">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="t，tZtk一：’t，一、十；tk十ztl一则当tk摊t，时应将模式向右移动至模式中的第next(k)个字符一个长度为k‘的最长子串和模式串中从首字符起长度为k‘的子串相等，即't,tztk,'t,一、，+lt，一k，＋2…t』’（4.3）就是说next（1＋1）＝k‘＋1即next&lt;j1)=next(k)-1‘‘根据上述分析，求模式的next函数值实现如下：" ID="40">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="voidnextval(chart" ID="41">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="42">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="intj,k;" ID="43">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="j=1;" ID="44">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="next[11=0;" ID="45">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="while&lt;j&lt;n){" ID="46">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="47">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="｝求next值的算法的时间复杂性为O&lt;n)。通常，模式串的长度n比主串的长度m要小得多，因此，对整个匹配算法来说，所增加的计算next值的时间是值得的。" ID="48">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="串即字符串，是几种最简单的数据结构之一串是由有限个字符组成的序列。一般将串记为其中a,(1&lt;i&lt;n)可以是字母、数字或其他字符，单引号中的字符序列称为串值，S称为串名。n表示串中字符的数目，称为串的长度。假如串的长度等于零，即此串中一个字符也没有，这种串称为攀串。应注意，空格也是合法的字符，它可以出现在其他字符中间，也可单独出现。例如是长度为14的字符串，因为data与structure中间的空格也算一个字符，又如是长度为1的字符串，串中惟一的字符为一个空格。它与零串不同，零串的长度等于零。串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串称为主串。子串在'datastructure，的一个子串，T在S中的位置为6," ID="1">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="申的形式定义如下：其中，D={a,Ia;ECHARACTER,i=1,2,…,n,n&gt;0}D一｛a:｝a:ECHARACTER,i=1,2…,n,n&gt;0}R={N}" ID="2">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="Na：一，,ala：一，,a,ED,i=2,3,…,n}串的逻辑结构和线性表很相似，区别仅在于串的数据元素只能是字符。然而串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以单个元素作为操作对象，如取某个元素、在线性表中查找某个元素、在某个位置插人或侧除一个元素等.而在串的基本操作中，通查”了由的橄才＊刀七去到盛矛七甲净金翻叮加奋由的琴磨电女让万洲从由二东七仓艺匕＿或争云二由由出杆二乙由云二由献，常以串的整体作为操作对象。某个位置插人一个子串、删除一个子串、将已知串中从某字符开始的指定长度的子串用另一个" ID="3">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="给定串代替." ID="4">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="87" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="98" PhysicalPageNum="98"/>
      <Paragraph CONTEXT="数组是最常见的一种数据结构，它可看成是由下标和值组成的偶对，对每一个有定义的下标，都有一个值与其对应.一般将数组元素顺序地存储在一组连续的存储单元中，下标值和存储地址之间有一定的对应关系，这样，就可根据下标值随机地访问任一数组元素。因此数组是一种随机存取结构。将数组元素顺序地存储在一组连续的存储单元中，其缺点是它的维数和每个下标的范围必须事先给定，规定得不合适就可能造成内存的浪费或出现下标越界而使程序无法进行下去.一般来说，可用二维数组表示一个mXn阶矩阵，矩阵的运算很容易实现。但是对于对称矩阵或三角矩阵等一些特殊的矩阵，为了节约存储空间，可以将矩阵中的mXn个元素压缩存储在一个一维数组中。前提条件是能够找到某种方式，确定一维数组中对应于原来矩阵位置的元素。在所有元素中零元素占相当大比例的矩阵叫做稀疏矩阵。为了避免存储零元素和进行零元素的运算造成空间和时间的浪费，稀疏矩阵采用一种称为三元组表的数据结构来存储矩阵中所有的非零元素。采用三元组表这种表示法进行稀疏矩阵转置时可有两种办法。第一种办法是按原矩阵中列的顺序逐个把非零元素置人转置矩阵中，即先将原矩阵的第。列的非。元素转置，接着转置第1列的非0元素，…，如此下去，这种方法需要对原矩阵的三元组表反复扫视，较费时间.第二种实现稀疏矩阵转置的方法是只对原矩阵的三元组表扫视一遍，将各非零元素直接置人新矩阵的三元组表中应有的位置处。为了能预先确定各非零元素的位置，须设置两个辅助的一维数组。对用三元组表表示的稀疏矩阵进行相乘的运算时，只需进行非零元素之间的运算。本章介绍的算法得到的结果矩阵仍是用普通的二维数组表示，此算法的关键之处有两点：当处理第" ID="1">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构字符串是非数值处理领域里的主要对象，字符串是由字符组成的有限序列。一个字符串中的字符个数称为此字符串的长度，长度为零的字符串称为零串。应注意空格符也是合法的字符。字符串的基本操作有：求串的长度、字符串的连接，求子串，求串的插人、删除和替换。非紧缩的顺序表示法随机存取方便，但存储空间利用率不高。采用紧缩格式可以节省存储空间，但必须显示给出字符串的长度。对单字节为存取单位的计算机，每个存储单元恰好存放一个字符，既便于存取又能充分利用空间。在这种存储方式下，字符串的长度不必显示给出，只是在字符串的结束处填人串结束符即可。链接表示法将字符串的字符放在结点中，结点与结点之间由指针连接。每个结点可存放一个字符也可存放多个字符.顺序表示法的缺点是进行串的插人、删除、不等长的字符串替换等操作时需要移动元素，很不方便。对于这类操作，可考虑使用链接表示。总的来说，串的链式存储结构不如顺序存储结构灵活。串的模式匹配是判断某串是否是另一个已知串（主串）的子串，如是主串的子串，就给出子串在主串中的起始位置。本章介绍的KMP算法是模式匹配的经典算法，其最大特点是指示主串的指针不需要回溯，整个匹配过程中，对主串仅需要从头至尾扫描一遍。在学习本章内容时，读者可对照C语言对数组类型和字符串类型变量的处理来加深本章" ID="2">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="88" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="99" PhysicalPageNum="99"/>
      <Paragraph CONTEXT="4.1设有一个二维数组a[mn]，求元素a[ij〕的寻址公式。假定数组采用以行序为4.2设数组采用以列序为主次序的存储方式，做习题4.1," ID="1">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="4.3设有一个说明为a[UiuzIun]的数组，求元素a[ii1zIin］的寻址公式。假" ID="2">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="4.3的地址为。。" ID="3">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="4.4（a）写出图4.15所示矩阵的三元组表；4.5一个有t个非零元素的m行n列的稀疏矩阵，已将其存人二维数组中，编写一个函数将其表示成三元组表形式。" ID="4">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="阵a和b的和c，并将c表示成三元组表形式。4.7设有两个字符串s和t，编写一个算法将字符串t插人到字符串s的第k个字符的后面。4.8设有两个字符串s和t，编写一个算法将字符串t从字符串s中删去。4.9设有两个字符串s和t，编写一个算法将字符串s从第J个字符开始的k个字符用字符串t替换之。" ID="5">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT=".gg." ID="6">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="J" ID="7">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="第J章" ID="8">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="递归娜邸狮妙胭萝破卿绷魂班圈蹄钟熬缈纯班圈梦戮欧缈此瞬隅梦侧酬渺纯吩递归（Recursion)是计算机科学中的一个重要概念，也是软件设计中一种重要的方法和技术.在工程实际中，有许多概念是用递归来定义的，数学中的许多函数也是用递归定义的，它ttit,i16frrsiaaHlni曲.赴』二名舀毒小洲七.之上创卜引匕言奋握1之荣1匕仪1「衬J滚厅匕洲七.食」二七仕二企佗卜介，Ll沪日刁」七止煞1匕，L‘之」七愧鱿召士曰们的数学模型和算法设计方法本来就是递归的。读，可维护性好，且具有较高的开发效率，因此，读者应掌握递归算法设计方法，在以后的几章中，都将利用递归研究树、查找、排序等问题。所谓递归，是对于一个问题S，可划分为SSzS。等子问题，而解决S,，SzS。的方法与解决S的方法相同，这便是递归。描述递归的函数或求解递归问题的过程称为递归算法。一个递归算法，本质上是将较复杂的处理归结为较简单的处理，直到最简单的处理。实际上，要进行递归算法设计，必须先确定求解问题的递归模型，了解递归的执行过程。因此，本章首非递归算法，最后讨论广义表的递归定义、存储结构以及递归算法。" ID="9">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="90" TITLE="第5章 递归" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="90" TITLE="5.1 递归模型与递归算法" TYPE="Chapter">
      <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
      <Paragraph CONTEXT="为了描述问题的某一状态，必须用到它的上一状态，而描述上一状态，又必须用到它的上(n，f&lt;n-1)n&gt;0f(n" ID="1">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="n-0则当n&gt;0时，f(n）须用n*f&lt;n-1）来定义，f(n-1）又用（n-1)*f(n-1-1）来定义…，f(1）用1二f(0）定义，当n=0时，f(n1,由上例可看出，递归定义有两个要素：①递归终止条件（又称递归出口）：也就是所描述问题的最简单情况，它本身不再使用递归的定义.如上例，当n=0时，f(n1，不使用f(n-1)来定义.②递归体：使问题向终止条件转化的规则，必须能使问题越来越简单。如上例，求f(n）转化为递归体中求n二f(n-1)，逐步将f(n)冷f(n-1)冷f(n-2)冷f(1)，由“大问题”分解成“小问题”，越来越靠近目标f&lt;0)，直到找到递归终止条件f(01,一般地，一个递归模型是反映一个递归问题的递归结钩，由递归定义的递归终止条件和递以下三种情况适合使用递归模型，设计递归算法。" ID="2">
        <fptr EndPN="00000102" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)定义是递归的数学中常用的阶乘函数、幂函数、裴波那契数列等，它们的定义和计算都是递归的。针对上面阶乘函数的递归模型，可以设计递归算法，描述如下：算法5.1" ID="3">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="intfact(intn)" ID="4">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="｛if(n&lt;0){printf‘用户参数n不能为负数return0if(n＝二0)" ID="5">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="return1;/＊递归出口，／" ID="6">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="7">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="return(n*fact(n-1／二递归体二／" ID="8">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="｝在这个算法中，计算阶乘n！时，利用if语句块判断递归终止的条件：n=0，返回值1（即f&lt;n1)，而else语句块处理递归体，计算表达式n*f(n-1n*(n-1}!，并返回计算结果以完成递归。其中，函数fact(n）在执行过程中又调用了自己，这是直接递归的情况。此外，递归还可以是间接递归，例如函数P在执行过程中调用了函数Q，而函数Q在执行过程中又" ID="9">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="调用了函数P，或者更多的函数形成循环调用。" ID="10">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）数据结构是递归的有些数据结构的定义是以递归形式给出的，如前面讨论的链表就是一种递归的数据结构，图5.1单链表的结构链表每个结点的数据结构描述如下：" ID="11">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstructNode{" ID="12">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypeelement;" ID="13">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="structNode*next;｝二IinkList,LinkNode;链表结点LinkNode的定义由数据域element和指针域，next组成，而指针next又由LinkNode定义。对一个表头指针为head的单链表也可定义为一个递归结构，即：" ID="14">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="1)一个结点，其指针域为NULL，是一个单链表（递归出口）；" ID="15">
        <fptr EndPN="00000102" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="2)一个结点，其指针域为指向一个单链表，仍是一个单链表（递归体）。次据结构" ID="16">
        <fptr EndPN="00000103" StartPN="00000102"/>
      </Paragraph>
      <Paragraph CONTEXT="即法5.2" ID="17">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="ntFind(LinkListbead)" ID="18">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="f(head一＞nextNULL)/，递归出口，最后一个结点，／printfdhead气＞elementreturn1;｝else{" ID="19">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="Find（head一＞next);/，递归体：到下一结点的递归调用，／" ID="20">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝不仅仅是链表，后面要介绍的树形结构、图形结构也是常见的递归结构，有关树的遍历、图" ID="21">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="的搜索等运算通常采用递归算法。" ID="22">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）问题的解法是递归的有些问题的解法是递归的，汉诺（Hanoi）塔问题、迷宫问题、八皇后问题等都是典型的例" ID="23">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="Hanoi塔问题是一个关于世界末日的古老传说：在“世界中心”贝那勒斯（印度佛教圣地）子。的圣庙里，有一座汉诺塔，塔台上有3根标号为A,B,C的钻石柱子，在A柱上放着梵天创世纪留下的64块金盘，每一个都比下面的略小一点。值班僧侣日夜不停地搬运，把A柱上的金盘全部移到C柱的那一天，世界就将在一声霹雳中毁灭。移动的规则是这样：每次只能移动柱最上面的一个盘；任何盘都不得放在比它小的盘上，金盘可以插在A,B和C中的任何一个塔座上。全部的移动是2“一1次，如果每秒移动一次的话，需要500亿年。一位计算机科学家用递归方法快速求解了汉诺塔问题。设A柱上最初的盘子总数为n,可用下述算法解决此问题：如果n=1（即A柱上只有一个盘子），则直接将该盘子从A柱移到C柱上（这是递归终止条件）；直土述－今令！" ID="24">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="AB1:" ID="25">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="9.1'NI（。)（d," ID="26">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="否则，执行以下递归体" ID="27">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="·92" ID="28">
        <fptr EndPN="00000103" StartPN="00000103"/>
      </Paragraph>
      <Paragraph CONTEXT="1)将A柱上的（(n-1)个盘子移到B柱上；" ID="29">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="2)将A柱上的最后一个盘子直接移到C柱上；" ID="30">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="3)将B柱上的（(n-1)个盘子移到C柱上。图5.2表示了汉诺塔间题在n=3时执行以上三步后的状态.利用这种算法，将移动n个盘子的汉诺塔问题归结为移动（(n-1)个盘子的汉诺塔问题，移动（(n-1)个盘子的汉诺塔问题又可归结为移动（(n-2)个盘子的汉诺塔问题，依此类推，最后归结为只有一个圆盘的汉诺塔问题，问题得以解决。这是一个典型的递归算法。下面给出求解n阶汉诺塔问题的算法。算法5.3" ID="31">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="VoidHanoi(intn,charA,charC,charB)／，移动A柱上n个盘子到C柱上，B柱作为辅助过渡，即源塔座A，目标塔座C，辅助塔座B" ID="32">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="丈1Qif(n1)/，递归出口二／" ID="33">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="｛Qprintfn%s%c%s%c'movedisk1from',Ato',C/，将盘子1从A柱移到C柱，／" ID="34">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="3Qreturn;" ID="35">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="｝®Hanoi(n-1,A,B,C/，将n-1个盘子从A柱移到B柱，C柱作为辅助过渡，／Q5printfn%s%c%s°oc'movedisk',n,from,Ato',C/，将盘子n从A柱移到C柱，／©Hanoi(n-1，B，C，A）；／，将n-1个盘子从B柱移到c柱，A柱作为辅助过渡，／" ID="36">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="Qreturn" ID="37">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="｝综上所述，对于一个递归摸型，不论是哪种形式的递归，其递归算法的设计包括两个方面：" ID="38">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="1)找到递归终止的条件，确定与递归出口相对应的操作；" ID="39">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="2)确定非递归出口处即递归体所对应的操作：先假设在数据（参数及全局变量）接近递归出口时，函数功能正确。可通过适当调用这些功能来实现程序功能，这些操作的描述便构成了这部分的程序。" ID="40">
        <fptr EndPN="00000104" StartPN="00000104"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="93" TITLE="5.2 递归过程与递归工作栈" TYPE="Chapter">
      <fptr LogicalPageNum="104" PhysicalPageNum="104"/>
      <Paragraph CONTEXT="一个递归算法显然是一个递归函数，函数在执行中需多次进行自我调用，类似多个函数的数据结构下3件工作：①将所有的实在参数、返回地址等信息传递给被调用函数保存，②为被调用函数的局部变量分配存储区；③将控制转移到被调用函数的人口。而从被调用函数返回调用函数之前，系统也应完成3件工作：①保存被调用函数的计算结果；②释放被调用函数的数据区；③依照被调用函数保存的上一层的返回地址将控制转移到调用函数。为了保证递归过程每次调用和返回的正确执行，必须解决调用时的参数传递和返回地址保存问题，系统设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，通常包括如下内容：" ID="1">
        <fptr EndPN="00000105" StartPN="00000104"/>
      </Paragraph>
      <Paragraph CONTEXT="1)本次函数调用时的实在参数；" ID="2">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="2)返回地址（即上层中本次调用的语句的下一条语句或指令地址）；" ID="3">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="3)本层的局部变量。在每进人一层递归时，就建立一个新的工作记录压人栈顶。每返回一层递归，就从栈顶弹出一个工作记录，则递归工作栈栈顶的工作记录总是当前执行层的工作记录，又称之为“活动记录”。为了更好地理解递归算法的执行过程，针对上节中的函数Hanoi，设有如下主程序：main&lt;)" ID="4">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="5">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="tntn" ID="6">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="scanf（”％d即，＆n）；" ID="7">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Picture URL="00000105\00000105_new\0021.jpg">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Picture>
      <Picture URL="00000105\00000105_new\0022.jpg">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Picture>
      <Paragraph CONTEXT="Hanoi&lt;nACB;" ID="8">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="｝如果从键盘输人3，则主函数调用语句Hanoi(3ACB&quot;）递归调用和状态变化情况和图5.4所示，其执行过程中工作栈状态变化如表5.1所示。一个活动记录包含5个数据项：（返回地址，n,A,B,C)，其中，返回地址以＆加递归函数中的语句标号表示，如主函数的返回地址表示为&amp;o,n为盘子的数量，A,B,C为实在参数的值。94$Picture[00000106\00000106_new\0002.jpg]Picture$$Picture[00000106\00000106_new\0003.jpg]Picture$$Picture[00000106\00000106_new\0004.jpg]Picture$$Picture[00000106\00000106_new\0005.jpg]Picture$$Picture[00000106\00000106_new\0006.jpg]Picture$$Picture[00000106\00000106_new\0007.jpg]Picture$$Picture[00000106\00000106_new\0008.jpg]Picture$$Picture[00000106\00000106_new\0009.jpg]Picture$一图5.4n=3时Hanoi塔递归函数调用执行过程数据结构$Picture[00000107\00000107_new\0002.jpg]Picture$·96续表布则对应的输出如下：movedisk1fromAtoCmovedisk2fromAtoBmovedisk1fromCtoBmovedisk3fromAtoCmovedisk1fromBtoAmovedisk2fromBtoCmovedisk1fromAtoC一般来说，递归函数结构清晰、简洁，具有较好的可读性和可维护性，而且比较容易根据问题的定义或按所采用的解法直接写出，正确性也容易得到证明。利用允许递归调用的程序设计语言（如C语言、Pascal语言）进行程序设计时，给用户编制和调试程序带来很大方便。因为对这一类递归问题编程时，不需用户自己而由系统来管理递归工作栈，自动实现调用过程中" ID="9">
        <fptr EndPN="00000108" StartPN="00000105"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="98" TITLE="5.3 递归程序的阅读方法" TYPE="Chapter">
      <fptr LogicalPageNum="109" PhysicalPageNum="109"/>
      <Paragraph CONTEXT="利用递归思想解决实际问题的基础。在实际应用中，往往要求能够较快地求出某递归程序的;田4金月巨BR/iilnfnTi81r＿洲卜Ib$lsf7r.ichiy.月－飞一从法乌儿笨火耳妇立右奋月心奄大2‘4芭归〕一,Ufcfd*6ti内容变化情况进行分析，如表5.1所示。这种方法不能满足快捷、实用的要求，需要一种更有效的阅读方法，那就是嵌套层次图法。下面主要介绍这种方法.嵌套层次图法采用图形方式描述函数运行轨迹，从中可较直观地了解到各调用层次及其执行情况，是一种比较有效的方法。事实证明，灵活掌握这种方法对后续有关内容的学习有很大的帮助.方法描述如下：" ID="1">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="1)按次序写出算法当前调用层上实际执行的各语句，并用有向弧表示语句的执行次序。" ID="2">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="2）对算法中的每个调用语句，写出其实际调用形式（带实参），然后在其右边或下边写出本次调用函数实际执行语句，以区分调用主次和层次，同时也可清楚了解其实际执行情况。另外还要作如下操作：" ID="3">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="·在被调用层前面标明各形参的值；·从调用操作处画一有向弧指向被调函数的人口，以表示调用路线；·从被调函数的末尾处画一有向弧指向调用操作的下面，表示返回路线." ID="4">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="3)若函数有返回值，则在返回路线上标出本次调用所得的函数值。最后得到函数嵌套层次图，顺着有向弧所标出的执行路线执行各操作，可较方便地得出正确的运行结果。还是以主函数调用语句Hanoi(3'A'C'B''）为例，说明这种方法，如图5.5所示.主程序I层2层3层.，＿.＿＿、n_2，，.，。。。＿、＿a-IaL,c_二沪＼一比IUIf1" ID="5">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="99" TITLE="5.4 递归问题的非递归算法" TYPE="Chapter">
      <fptr LogicalPageNum="110" PhysicalPageNum="110"/>
      <Paragraph CONTEXT="说，递归并不是一种高效的方法。因为递归程序的执行是由上而下再由下而上求解的，即由调用点出发逐步展开到递归出口得到局部解，再逐层返回以得到全局解的，因此比非递归形式的程序要花费更多的时间和空间.若在程序中消除递归调用，则其运行时间可大为节省.而且，有些程序设计语言并不支持递归，如FORTRAN,BASIC等都不允许递归，因此，许多情况下，要求能写出求解问题的非递归算法。而有些问题（如Hanio塔问题）用递归算法容易描述，用非递归算法又不容易描述。可以先将算法写成递归形式，然后再按某种方法把递归算法转换为等价的非递归算法。对于程序中频繁使用的部分和不支持递归的程序设计语言，消除递归是非常必要的。当然，并非一概提倡消除递归，因为在很多时候，程序结构简单、可读性好，比运行时间的缩短更有意义。对于递归函数的执行是由编译程序利用递归工作栈来实现的，而非递归算法的实现则需用户自己设计堆栈来模拟递归工作栈的工作过程。基于5.2节对递归过程和递归工作栈的讨论，可以得出从递归算法到非递归算法转换的规则如下：" ID="1">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="1)设置一个栈存放当前层的活动记录，初始置为空；" ID="2">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="2)在子程序人口处设置一个标号Start;" ID="3">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="3)对子程序中的每一递归调用，用以下几个等价操作来替换：" ID="4">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="a.保留现场：开辟栈顶存储空间，用于保存返回地址（不妨设为i,i=1,2,3二，程序中用标号L：表示）和调用层中的形参和局部变量的值；" ID="5">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="b.准备数据：为被调子程序准备数据，即计算实在参数的值，并赋给对应的形参；" ID="6">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="c.转人子程序执行；" ID="7">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="d.在返回处设一个标号Li=1,2,3,…)，并根据需要设置以下语句：若有变参或是函" ID="8">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="数，从回传变量中取出所保存的值并传送到相应的实变参或位置。" ID="9">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="4)对返回语句，则可用以下几个等价操作来替换：如果栈不空，则依次执行如下操作，否则结束本子程序，返回." ID="10">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="a.回传数据：若有变参或是函数，将其值保存到回传变量中；" ID="11">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="b.恢复现场：从栈顶取出返回地址及各变量、形参的值，并退栈，" ID="12">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="c.返回：按返回地址返回。下面以Hanoi塔问题为例来说明如何利用堆栈实现从递归算法到非递归算法的转换。设n表示递归调用的某一层需要搬动的圆盘数，A,B和C分别表示该层的源塔座、辅助塔座和目标塔座，returnaddr表示执行完这一层后返回的地址。算法5.3中，求解函数Hanoi(n,A,C,B）的间题较复杂，一时难以完成，则分解为求解Hanoi(n-i,A,B,C)、移动第n个圆盘到目标塔座以及求解Hanoi(n-1,B,C,A）三个操作。当调用Hanoi(n-1,A,B,C）或" ID="13">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="Hanoi(n-1,B,C,A）时，则须将Hanoi(n,A,C,B)的参数及返回地址保存在栈中，以便返回" ID="14">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构时恢复现场。因此，设置栈HStack，其数据元素包括5个域，分别用于保存4个参数和一个返回地址。首先定义栈的元素类型和栈的数据类型：typedefstruct{;ntn;charx;chary;" ID="15">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="charz;intreturnaddr;}Hdata;" ID="16">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstruct{" ID="17">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="inttop;Hdataitem仁MAXSTACK];)HStack;" ID="18">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="算法5.4voidStackHanoi(intn,charA,charC,charB)HStackS;HdataCurTemp;/，临时活动记录二／Chartemp;／二临时变量，／intj;/＊返回地址，／IniStack(S/，初始化栈SCurTemp,n=n;/，待移动圆盘数nCurTemp.x=A;/塔座ACurTemp.y=B;/，辅助塔座CurTemp.z=C;/，目标塔座CCurTemp.returnaddr=1;/，主调函数的返回地址，／Push(s,CurTempstart:/‘递归模拟开始，／CurTemp=GetTop(s);if(CurTemp,n1)/，模拟递归出口二／｛printfn°os°oc°os°ocmovedisk1fromCurTemp,x,°toCurTemp,zi=CurTemp.Returnaddr;switch&lt;1){" ID="19">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="casel:gotoL1;" ID="20">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="case2:gotoL2;100" ID="21">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="22">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="CurTemp.n一一；Temp=CurTemp.y;CurTemp.y二CurTemp.z;CurTemp.z=Temp;CurTemp.Returnaddr=2;push(s,CurTemp);Gotostart;" ID="23">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="I.Z:／二模拟返回第一次递归调用＊／printf(”\n°os°oc%s%c”,’‘movedisk，‘,CurTemp.n,”from，‘,CurTemp.x,”to，，,CurTemp,n一一；Tmp=CurTemp.x;CurTemp.x=CurTemp.y;CurTemp.y=Temp;CurTemp.Returnaddr=3;push(s,CurTemp/，返址和下一层的参量进栈‘／Gotostart;/＊转向递归人口‘／L3:/＊模拟返回第二次递归调用，／pops,CurTemp);i=CurTemp.Returnaddr;switch(i){" ID="24">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="casel;gotoLl;" ID="25">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="case2;gotoL2;" ID="26">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="case3;gotoL3;｝" ID="27">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="L1:pops,CurTemp);Return;" ID="28">
        <fptr EndPN="00000112" StartPN="00000112"/>
      </Paragraph>
      <Paragraph CONTEXT="｝经过上述转换规则得到的不含递归的算法尚需进行化简，消去不必要的操作，如冗余进栈的内容等，并画出相应的流程图，从流程图中找到各循环的循环体和循环条件，从而消去GOTO语句，得到结构清晰的非递归算法。数据结构" ID="29">
        <fptr EndPN="00000113" StartPN="00000112"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="102" TITLE="5.5 广义表" TYPE="Chapter">
      <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <div ORDERLABEL="102" TITLE="5.5.1 广义表的递归定义" TYPE="Chapter">
        <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <Paragraph CONTEXT="广义表《GeneralLists）是n(n）0)个数据元素aa2,，a的有限序列，通常记作：其中，LS为表名，a,(0&lt;i&lt;n-1)是表中元素，或为不可分割的单元素（称为原子），或为广义表（称为子表或表元素）,n是表的长度，即表中元素的个数，长度为0的表为空表。显然，线性表可以看做广义表在数据元素为单元素时的特殊情况.例如，以下A,B,C,D,E,F都是广义表，习惯上，用大写字母表示表名，小写字母表示原子。" ID="1">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="A=()" ID="2">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="Bd,e)" ID="3">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="C=(a,(b,c" ID="4">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="D＝（A，B，C）＝（（），（d，e），（a，（b，c）））" ID="5">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="E＝（a，E）＝（a，（a，（a，…）））" ID="6">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="Fa,(a,ba,b)yc其中，A表是一个空表，其长度为0;B表是含两个单元素d,e的表，其长度为2;C表是含一个单元素a，一个表元素（b,c)的表，其长度为2;D表是含A,B,C三个表元素的表，其长度为3;E表是含一个单元素a，一个表元素E的表，其长度为2;F表只含一个表元素（aa,ba,bc，其长度为1。该表元素中又包含了三个元素，一个是单元素，两个表元素。若用圆圈表示表元素（或子表），方框表示单元素（或原子），用连线把表和它的元素连接起来（元素结点应在其表结点的下方），则可得到一个广义表的图形表示。上述五个广义表的图形表示如图5.6所示。可见，广义表是一种递归定义的线性结构。因为在表描述中又用到表，与线性表有着明显的区别.它又是一个多层次的线性结构，其图形表示像倒挂的树，树根结点代表整个广义表，各层树枝结点代表相应的子表，树叶结点代表单元素或空表。正因为如此，广义表在处理有层次特点的线性结构问题时有其独特之处，这种递归定义能够很简洁地描述庞大而复杂的结构。如在计算机图形学、人工智能等领域的实际应用中发挥着越来越大的作用。从以上广义表的定义和例子，可以得到广义表具有以下特点：" ID="7">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="1)有次序性广义表是一种线性结构，其数据元素以线性序列排列，有相对次序，每个元" ID="8">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="素至多一个直接前驱，一个直接后继。" ID="9">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Picture URL="00000114\00000114_new\0002.jpg">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Picture>
        <Picture URL="00000114\00000114_new\0003.jpg">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Picture>
        <Paragraph CONTEXT="鑫$Picture[00000114\00000114_new\0006.jpg]Picture$$Picture[00000114\00000114_new\0007.jpg]Picture$$Picture[00000114\00000114_new\0008.jpg]Picture$图5.6广义表的图形表示" ID="10">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="2)有长度广义表是个有限序列，元素个数一定，可以是空表，长度为o," ID="11">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="3)有深度广义表也是一种多层次结构，广义表的深度定义为所含括号的重数。因此，对广义表而言，“空表”的深度为1，而“原子”的深度为“0例如，广义表C的深度为2，广义表" ID="12">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="D,F的深度都为3," ID="13">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="4）可递归广义表也可以是一种递归结构，如广义表E。广义表可以是自己的子表，这种情况称为递归表。值得注意的是递归表的深度是无穷值，而其长度是有限值，如E表的长度为2," ID="14">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="5)可共享广义表可以为其他广义表共享。例如，表D中的A,B,C表为共享表，在D表中不必列出子表A,B,C表的具体值，而可以通过子表名来引用。在实际应用中，可以利用广义表的共享特性减少存储结构中的数据冗余，以节省存储空间。" ID="15">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="6）任何一个非空广义表LS＝〔a，，a：，…，a，）均可分解为两部分表头Head(LS)=a,，表尾＿Tail(LS）二（a2，a。)" ID="16">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="可见，非空广义表的表头可斗是原子，也可以是子表，而表尾必定是一个广义表。例如：，＿、飞LS=(B,B)Head(LS）二BTail(L5)_Head(BHeadd,ed,Tail(BTail(ld,ee)" ID="17">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="103" TITLE="5.5.2 广义表的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <Paragraph CONTEXT="广义表是一种递归定义的数据结构，数据元素可以具有不同的结构（或为原子，或为子表）。很难为每个广义表分配固定大小的存储空间，因此难以用顺序存储结构表示，通常采用数据结构头的指针域hp和指示表尾的指针域tp三部分组成.原子结点只需要两个域：标志域tag和值域data，如图5.7所示。子表结点｝叫中｝原子结点：I卜ataI$Picture[00000115\00000115_new\0006.jpg]Picture$广义表的结点结构和类型定义如下：typedefenum{ATOM=O,LIST=1}ElemTag;typedefstructGLNode{" ID="1">
          <fptr EndPN="00000115" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTagtag;" ID="2">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="Union{" ID="3">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="AtomTypedata;structGLNode*hp,*tp;）；" ID="4">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="}，GList;其中，tag作为标志域，取ATOM=0时表示原子结点，采用联合体中的data域，存储元素值；tag取LIST=1时表示子表结点，采用hp存储指向子表表头的指针，tp存储指向子表表尾图5.8广义表的链接存储结构示例另一种分析方法是将一个非空广义表分解为n个并列子表，如图5.9所示。若子表元素为原子，则原子结点结构为标志域tag、值域data和指向后继子表的指针域tp。若子表元素为：鞠聆搏毕一纯平。一一｝1川＋一11III＋一子表，则子表结点结构为标志域tag、指向子表中第一个结点的指针（即子表的表头指针）和指向后继子表的指针域印，如图5.10所示。这种情况下，广义表的结点结构和类型定义如下：typedefenum{ATOM=O,LIST=1}ElemTag;typedefstructGLNode{" ID="5">
          <fptr EndPN="00000116" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTagtag;" ID="6">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="Union{" ID="7">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Picture URL="00000116\00000116_new\0013.jpg">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Picture>
        <Paragraph CONTEXT="AtomTypedata;structGLNode关hp;｝；" ID="8">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="structGLNode‘tp;" ID="9">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；}*GList;图5.11给出广义表A,B,C,D,E的第二种存储结构示意图.礁御气图5.11广义表的另一种链接存储结构示例105" ID="10">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构比较两种存储结构各有特点。第一种存储结构除空表的表头指针为空外，对任何非空列表，其表头指针均指向一个表结点，且该结点中的hp指向子表表头（或为原子结点，或为子表结点）,tp指向子表表尾（若表尾为空表，则指针为空，否则必为子表结点）。从这种存储结构义表的长度。因此，使得广义表的某些运算较为方便，如：求广义表的长度和深度，求表头、表尾等。然而，其缺点也很明显，存储结构中表结点多，占用存储空间多，且与广义表中的括号对数不匹配。第二种存储结构的特点正相反，子表结点个数少并且和列表中的括号对数一致，但这种结构写递归算" ID="11">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="法不方便。" ID="12">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="106" TITLE="5.5.3 广义表的递归算法" TYPE="Chapter">
        <fptr LogicalPageNum="117" PhysicalPageNum="117"/>
        <Paragraph CONTEXT="广义表的运算主要有求广义表的长度和深度、向广义表插人元素和从广义表中查找或删除元素、建立广义表的存储结构、打印广义表等。由于广义表是一种递归的数据结构，所以对广义表的运算一般采用递归算法。下面讨论广义表的几种典型操作。首先约定所讨论的广义表都是非递归表且无共享子表，存储结构采用第一种头尾链表方式。" ID="1">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)求广义表的长度广义表的长度定义为广义表中元素的个数。在头尾链表存储结构中，第一层子表结点的个数即为广义表中元素的个数，这些子表结点通过tp域链接起来，可以看作是由印域链接起来的单链表。这样，求广义表的长度就是求单链表的长度，可以采用以前介绍的求单链表长度的方法求其长度。由于单链表的结构也是一种递归结构，递归体为在单链表非空时移动表头结点的指针域使其指向该结点的后继单链表，其长度等于1加上表头结点的后继单链表的长度，递归出口为单链表为空时，则其长度为。。求广义表长度的算法5.5如下所示。" ID="2">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="算法5.5" ID="3">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="intLength(GListGL)／，采用头尾链表存储结构，求广义表GL的长度，／" ID="4">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="return0;｝算法分析：此算法的每次调用，无论是从外部调用该函数，还是函数内的递归调用，都需要给值参GL分配存储空间，用以存储由实参传过来的指针值.所以算法的空间复杂度为O(n)，若采用非递归算法，其空间复杂度为O(1)，两者的时间复杂度均为O(nn为广义表的长度。" ID="5">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)求广义表的深度广义表深度定义为该表中括号嵌套的最大次数，可作递归定义：广义表的深度等于所有子表中最大深度加1。若一个表为空表，由定义可知，其深度为1采用第一种头尾链表存储结" ID="6">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="LS“（a，，aZ，…a。）设dep表示任一子表的深度，max表示LS所有子表中表的最大深度，Depth(LS)表示广义表I,S的深度，则有：｝司巨1、乌T之j卜J七，熟考口于当LS为非空时其中，max＝Max｛Depth（a，），Depth（a：），…，Depth（a。）｝，初值为0。由此可见，求广义表深度的递归算法有两个递归出口：空表和原子。递归体为遍历表中的" ID="7">
          <fptr EndPN="00000118" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="每一个结点，递归调用求出子表的深度。容易写出求广义表深度的递归函数如算法5.6所示。算法5.6intGlistDePth（GlistGL）／，采用头尾链表存储结构，求广义表L的深度，／（if（！GL）returnl；／，若为空表，其深度为1，／if（GL一＞tag＝＝ATOM）returno；／，若为原子，其深度为。＊／intmax＝0；／，赋max的初值二／while（GL！“NULL）／，遍历广义表中的每个结点，／（" ID="8">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="if（GL一亡＞tag＝二LIST）／，若为子表结点，则递归调用求出子表的深度，／｛if（dep＞max）max＝dep；／，保持max为同一层所求过的子表中深度的最" ID="9">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="大值，／" ID="10">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="｝GL＝GL一仁＞tP；｝returnmax＋1；／＊返回广义表的深度二／｝例如，对于广义表D二（A，B，C）＝（（），（d，e），，（a，（b，c）），按以上算法，图5.12展示T求广义表D深度的过程。如虚线箭头方向所示，虚线示意遍历过程中指针GL的变化情况，在指向结点的虚线左边标记的是将要遍历的子表，而在从结点射出的虚线右边标记的是返回的子表的深度。从图5.12中可见广义表D的深度为3.读者也可以按照5.3节介绍的递归程序的阅读方法，展开求深度函数的递归调用，了解工作栈状态情况，便于理解递归程序。算法分析：上述算法的执行过程实质上是遥历广义表各结点的过程.在遍历的过程中首先求得各子表的深度，然后综合得到广义表的深度.在遍历中，对原子结点需要访问2次，一次为读取tag域值，另一次读取tP域值；对于子表结点需要访问3次，分别为tag、hp和tP域" ID="11">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="值。所以该算法的时间复杂度为0（n），其中n为广义表中所有结点个数.该算法的空间复杂度0（m），假定m为广义表的深度。数据结构" ID="12">
          <fptr EndPN="00000119" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="c二（（（d,eab,c厂孔u”）”a，气D’c）’－一之一＿图5.12求广义表D深度的过程母，并假定广义表由键盘输人.如广义表D的输人格式为：（（＃），（d，e），（a，（b，。）））；，其中广义表以结束输人，空表在其圆括号内用“＃”字符表示。广义表是一个递归数据结构，建立其存储结构的算法同样是一个递归算法。该算法定义引用指针GL返回所建广义表的表头指针，其数据类型为GList。在算法的执行过程中，对于从键盘输人的广义表，需要从头到尾扫描每个字符。当读到左括号时，表明它是一个表元素的开始，则建立一个由GL指向的子表结点，并用它的hp域作为子表的表头指针进行递归调用，来建立子表的存储结构；当读到一个英文字母时，表明它是一个单元素，则建立一个由GL指向的单元素结点；当读到一个“＃”字符时，表明它是一空表，则应置GL为空；当建立了一个结点结构后，接着读到逗号，表明存在后继结点，需要建立当前结点的后继表；若读人的是右括号或分号，表明当前所处理的表已结束，置当前结点的tphp域为空。由此，得到建立广义表存储" ID="13">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="结构算法5.7。" ID="14">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="算法5.7voidCreateGList（GListGL）／二创建GL为头指针的头尾链表存储结构的广义表，／" ID="15">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="王charch；scanf（”纬c”，ch）；／，读人一个字符，该字符只能是英文字母、左括号或＃二／if（ch＝＝’＃‘）／，若输人空格，则置GL为空＊／GL＝NULL；Elseif（ch二＝’（’）／关若输人‘（‘，建立由GL指示的子表结点并递归构造子表二／｛GL二malloc（sizeof（structGLNode））；／＊分配子表结点空间，／" ID="16">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="GL－＞tag＝LIST；" ID="17">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="CreateGList（GL一＞hp）；" ID="18">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="19">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="20">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="（GL=malloc(sizeof&lt;structGLNode/，分配原子结点空间二／GL一），tag=ATOM;" ID="21">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="GL一）data=ch;" ID="22">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；scanf（”％cch）；／＊读人一个字符，该字符必为逗号、右括号或分号二／if（ch＝＝）" ID="23">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="CreateGList(GL一＞tp);" ID="24">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="Elseifch=)’川（。h＝＝））" ID="25">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="GLtp=NULL;" ID="26">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法分析：该算法扫描输人广义表中的所有字符，并且处理每个字符都是简单的比较或赋值操作。其时间复杂度为O(1)，所以整个算法的时间复杂度为O(nn为广义表中所有字符个数。由于平均每两个字符可以生成一个表结点或原子结点，所以n也可以看作是生成的广义表中所有结点的个数。在这个算法中，既包含向子表的递归调用，也包含向后继表的递归调用，所以递归调用的最大深度（即动态堆栈的最大深度）不会超过生成的广义表中所有结点的个数，因此其空间复杂度也为O(n" ID="27">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="109" TITLE="5.5.4 典型应用--m元多项式的表示" TYPE="Chapter">
        <fptr LogicalPageNum="120" PhysicalPageNum="120"/>
        <Paragraph CONTEXT="作为广义表应用的例子，讨论m元多项式的表示。在第2章作为线性表的典型应用讨论了一元多项式，一个一元多项式可以用一个长度为n且每个数据元素有系数（coef)和指数(exp）两个数据项的线性表来表示。而当m＞1时，一个m元多项式的每一项最多有m个变元。如果用线性表表示，则每个数据元素需要m+1个数据项来存储一个系数和m个指数。P(x,y,zx10y°zZ+2xby3zZ+3x5yZZ2+x'y'Z-6x3y'Z-2yZ-18如果三元多项式的每个数据元素采用包含。oef（系数）、expx(x指数）、expy(y指数）、ex-指数）,4个域的结构数组或加上链接指针link的单链表存储，则因多项式中各项的变元pz(z指数）数或多或少，将会造成存储空间的浪费；若按各项实际的变元数分配存储空间，就会造成结点大小不匀，给存储管理带来困难。所以可以考虑用广义表来表达三元多项式。设三元多项式P(x,y,z)，首先把变量z,zZ,…作为因子提出，得到P(x,y,zx10y2xby3+3x5yz)zzx°y`-6x°y°+2y)z+18=Azz-IBz+18其中，A,B是含有变量x,y的多项式。再把变量Y，Yz，，作为因子提出，得到B(x,yx°-6x3&gt;y2y=Ey°-Fy,E=xf-6xF=2zA,2B,118,0，则其他多项式都可以表示成如下的广义表：数据结构" ID="1">
          <fptr EndPN="00000121" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="变元，等等，最后用广义表来表示。存储m元多项式广义表可采用类似广义表的第二种存储结构。每个数据元素对应的结点结构为：Itag=11expIhpItp」卜ag-llexplcoefl.tp表结点原子结点其中，exp为指数域，coef为系数域，hp指向其系数子表，tp指向同层的下一结点，适合于这种广义表的类型说明如下：typedefenum{ATOM=O,LIST=1}ElemTag;typedefstructPolyNode{" ID="2">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTagtag;" ID="3">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="mtexp;" ID="4">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="Union{" ID="5">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="floatcoef;" ID="6">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="structPolyNode*hp;" ID="7">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；" ID="8">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="structPolyNode*tp;" ID="9">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="}＊PolyGList;三元多项式P(x,y,a）的广义表的存储结构如图5.13所示。在每一层上增设一个表头结点并利用exp指示该层的变元。若多项式的所有变元用一维数组存储，则exp域存储的是该变元在一维数组中的下标。为了清晰起见，图5.13中子表表头结点的exp域直接标注变元，头指针p所指表结点中exp的值，3为多项式中变元的个数。由此可见，这种结构可表示任何元的多项式。图5.13三元多项式P（x，y，2）的广义表的存储结构利用这种多项式链表表示，就能仿照一元多项式，实现多项式的加法和乘法运算，因篇幅" ID="10">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="原因，不再详述。" ID="11">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="前几章介绍了线性表、栈、队列、串、数组等基本数据结构，这些结构都是线性结构。栈、队列、串、数组等都可以看成是特殊的线性表，其共同特点是结构中的对象都是同一类型的数据元素。本节介绍的广义表，可看着线性表的推广，放宽对表中元素的限制，允许表中元素自身具有某种结构，而且不要求数据元素具有相同数据类型。把广义表看作一种基本数据结构，下面讨论广义表的递归定义、存储结构、基本运算以及典型应用。" ID="1">
        <fptr EndPN="00000113" StartPN="00000113"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="111" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="122" PhysicalPageNum="122"/>
      <Paragraph CONTEXT="术。所谓递归，是对于一个问题S，可划分为S1,S2,…,Sn等子问题，而解决S1,S2,…,Sn的方法与解决S的方法相同，这便是递归.描述递归的函数或求解递归问题的过程称为递归算法。一个递归算法，本质上是将较复杂的处理归结为较简单的处理，直到最简单的处理。要进行递归算法设计，必须先确定求解问题的递归模型。有3种情况适合使用递归模型：定义是递归的；数据结构是递归的；问题的解法是递归的。对于一个递归模型，不论是哪种形式的递归，其递归程序的设计包括两个方面：找到递归终止的条件，确定与递归出口相对应的操作以及递归体所对应的操作。递归过程和递归工作栈是理解递归程序的基础，而正确理解递归程序，又是利用递归思想解决实际问题的基础。因此，在5.2节、5.3节分别介绍了系统利用工作栈实现递归的执行过程以及阅读递归算法的常用方法―递归嵌套层次图。5.4节以Hanoi塔问题为例讨论了利用堆栈实现从递归算法到非递归算法的转换方法。除Hanoi塔问题外，还有背包问题、八皇巴向月面越翻限生乳有凡改自如，留氏们同且面广义表是线性表的扩展，表中的元素可以是单元素（原子），也可是表元素（子表），因此，广义表的定义是一种递归定义，具有次序性、有长度、有深度、可递归、可共享等特性。分析广义表的结构有两种不同的方法，可以将非空广义表分解为表头、表尾两部分，也可分解为n个子表。广义表通常采用链式存储结构，基于两种不同分析方法，广义表的链式存储可采用头尾链表方式，也可采用子表链接方式。广义表的递归定义和链式存储结构（可掌握其中任意一种）是本章的重点，本章的难点在于广义表的递归算法，求广义表的长度、深度。建立广义表的存储结构只是广义表递归算祛设计的范例，也是递归模型分析和递归算法设计方法的最好应用。广义表可用于表示较复杂的数据结构，后面将介绍到的树、阻都可用广义表来描述，如常" ID="1">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="111" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="122" PhysicalPageNum="122"/>
      <Paragraph CONTEXT="5.1编写如下定义的递归函数的递归算法，并根据算法画出求$(5,2)时栈的变化过程。" ID="1">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="十nm＞Q，n）0" ID="2">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构" ID="3">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="②利用堆栈，写出非递归算法；③根据非递归算法，画出akm(2,1)时栈的变化过程。已知h为单链表的表头指针，链表中存储的都是整型数据，试写出实现下列运算的" ID="4">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="5.3" ID="5">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="递归算法：①求链表中的最大整数；②求链表的结点个数；" ID="6">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="1背包问题】设有一个背包可以放入的物品的重量为s，现有n件物品，重量分别为,〔1〕+W【2，W〔n.间能否从这n件物品中选择若干件放人此背包中，使得放5.4间能否从这n件物品中选择若干件放人此背包中，使得放" ID="7">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="如果存在一种符合上述要求的选择，则称此背包问题有解人的重量之和正好为5‘：Trues＝0此时背包问题一定有解Falses＜。总重量不能为负数KNAP（5，n）＝Falses＞0且n＜1物品件数不能为负数KNAP（s，n一”或5＞。且n）1所选物品中不包括碗司时KNAP（s-w［n」，n-1）所选物品中包括试司时5.5【八皇后问题】设在初始状态下在国际象棋棋盘上没有任何棋子（皇后）.然后顺序在第1行，第2行，二，第8行上布放棋子。在每一行中有8个可选择位置，但在任一时刻t’棋盘的合法布局都必须满足3个限制条件，即任何两个旗子不得放在棋盘上的同一行、或者同一列、或者同一斜线上。试编写一个递归算法，求解并翰出此问题的所有合法布局·（提示：用回溯法。在第n行第j列安放一个棋子时，需要记录在" ID="8">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="行方向、列方向、正斜线方向、反斜线方向的安放状态，若当前布局合法，可向下一行" ID="9">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="递归求解，否者可移走这个棋子，恢复安放该棋子前的状态，试探本行的第1＋1列）。5.6画出下列每个广义表的两种不同存储结构，并分别计算出它们的表头、表尾、长度、" ID="10">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="深度。" ID="11">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="①A＝（（））②B＝（a，b，c）③C＝（a，（b，（c）））④D片（（a，b），（c，d））⑤E“（恤，（b，（。，d）），（e））" ID="12">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="⑥F“（（a，（b，（），c），（（d），e）））" ID="13">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="5.7编写一个建立广义表的头尾链接表存储结构的算法，假定广义表由字符串值参提" ID="14">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
      <Paragraph CONTEXT="供。" ID="15">
        <fptr EndPN="00000123" StartPN="00000123"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="113" TITLE="第6章 树和二叉树" TYPE="Chapter">
    <fptr LogicalPageNum="124" PhysicalPageNum="124"/>
      <div ORDERLABEL="113" TITLE="6.1 树的逻辑结构" TYPE="Chapter">
      <fptr LogicalPageNum="124" PhysicalPageNum="124"/>
        <div ORDERLABEL="113" TITLE="6.1.1 树的递归定义" TYPE="Chapter">
        <fptr LogicalPageNum="124" PhysicalPageNum="124"/>
        <Paragraph CONTEXT="树（Tree）是n(n&gt;0)个结点的有限集合。当n=0时称为空树，否则，在任一非空树中：①有且仅有一个称为该树之根《Root)的结点；②除根结点之外的其余结点可分m(m）0)棵互不相交的集合T1,T2,Tm，且其中每一个集合本身又是一棵树，并且称为根的子树（Subtree),显然这是一个递归定义，即在树的定义中又用到了树的概念.树的定义描述了树的本质" ID="1">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="特征，因为树的结构本身是一种递归结构，即一裸树是由根结点和若干棵子树构成的。而子树" ID="2">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="寸可由忿不坦百'il.fifr与莽姗灼汾＿树山的左注＿洲卜姑占撅上乳布玄七廿山览＿泪组与乙七廿的娜全全占图6.1树的示例(a)只有根结点的树（b）一般的树棵有9个结点的树，其中A是这棵树的根结点，余下的8个结点分成3个互不相交的集合：" ID="3">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="T，，T：，T3都是树，而且是根结点A的子树。对一个结点的子树中所有结点都称为该结点的子孙（Descendent)。图6.3中，G的祖先是A和" ID="4">
          <fptr EndPN="00000126" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="B,B的子孙有E,F,G,结点的层数：若根结点的层数为1，其余任一结点的层数《level)等于它的双亲的层数加le如图6.3中结点B的层数为2,树的高度：树T中各结点的层数的最大值称为树T的高度《Height)，如图6.3所示的树的高度为3。因树是倒立向下生长的，有时也称树的深度（Depth森林（forest)森林是m(m&gt;0)棵互不相交的树的集合。若将一棵树的根结点移去，所剩恰是一森林。如图6.4所示。" ID="5">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="⑥" ID="6">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.4树移去树根变成森林" ID="7">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="114" TITLE="6.1.2 树的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
        </div>
        <div ORDERLABEL="115" TITLE="6.1.3 树的表示" TYPE="Chapter">
        <fptr LogicalPageNum="126" PhysicalPageNum="126"/>
        <Paragraph CONTEXT="对树的表示，通常用一个圆圈表示一个结点，并在圆圈中标一个字母、一个数字或一个字符串，作为结点名字或结点值，以区别不同的结点.在根结点与它的子树的根结点之间加一条连线，表示它们之间的逻辑关系。通常把根结点画在上面，它的子树画在下面，与自然界中树屯'd:不*B后巨t互3erl#tfifrteF卜#ch1shf37az合奋」习.3xFhErdfraF+l月甘$Picture[00000126\00000126_new\0005.jpg]Picture$上节中的图6.3就是树的典型表示。$Picture[00000126\00000126_new\0007.jpg]Picture$除此之外，树还可以有其他的表示形式。广义表也是树常用的表示方法，根作为由子树森林组成的表的名字写在表的左边，每个子树用一个子表表示。.如图6.3所示的树可用广义表表示为（A（B（E，F，G），C（H，D，D））。这种表示方法常用于树结构的输人或输出中。另外，图6.5所示也是树的表示方法，其中6.5（a）是以嵌套集合的形式表示的；6.5（b）用的是凹人表示" ID="1">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="法。（a）（b）图6.5树的其他表示方法（a）嵌套集合表示法（b）凹人表示法文据结构勇导气乒弃一居" ID="2">
          <fptr EndPN="00000127" StartPN="00000126"/>
        </Paragraph>
        <Picture URL="00000127\00000127_new\0006.jpg">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Picture>
        <Picture URL="00000127\00000127_new\0007.jpg">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Picture>
        <Picture URL="00000127\00000127_new\0008.jpg">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Picture>
        <Picture URL="00000127\00000127_new\0010.jpg">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Picture>
        <Paragraph CONTEXT="叮匀" ID="3">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="(a）用树表示行政关系结构（b)用树表示家庭结和(c)用树表示书的组成结构（(d）用树表示表达式a，（b＋c）／d的结利11R组成结构。树在计算机软件中的应用也非常广泛，如操作系统中文件的目录结构、高级语言的语法结构、应用系统的菜单结构等。计算机中的算术表达式也可用树结构来表示，如图6.6(d)所示。" ID="4">
          <fptr EndPN="00000128" StartPN="00000127"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="117" TITLE="6.2 二叉树" TYPE="Chapter">
      <fptr LogicalPageNum="128" PhysicalPageNum="128"/>
        <div ORDERLABEL="117" TITLE="6.2.1 二叉树的递归定义" TYPE="Chapter">
        <fptr LogicalPageNum="128" PhysicalPageNum="128"/>
        <Paragraph CONTEXT="二叉树也是n个结点的有限集合，它或者是空二叉树（(n=0)，或者是由一个根结点和不多于两个互不相交的子树构成。也就是说，每个结点有零个、一个或两个子树，这些子树可区分左子树（LeftSubtree）和右子树（RightSubtree)。如图6显示T一棵含有两个子树的二叉树.注意，每个子树本身也是二叉树。显然，这也是斗个递归时定义。为了更好理解二叉树，图6.8中列出了二叉树的5种基本形态。其中图6.8(a)为空二叉树，用符号币表示；图6.8(b)为仅有一个根结点的二叉树；图6.8(c）为右子树为空的二叉树，称为左单支树；图6.8(d)为左子树为空的二叉树，称为右单支树；图6.8&lt;e）为左右子树均非空的二叉树。由此看出，二叉树并不要求子树对称。必须指出：尽管二叉树与树有许多的联系，而且都使用一些相同的术语，但二叉树与树是两个不同的概念。它们之间的主要差别有：树的根结点可有任意棵子树，而二叉树的任一结点数据结构至多只有两棵子树（即每个结点的度都不大于2)，并且明确地区分为左子树和右子树.特别注意的是：当二叉树中的某个结点的一棵子树为空，另一棵子树非空时，也要明确指出它们的左、右次序。因此，图6.8中的（。）和（d)所示的是两棵完全不同的二叉树，但是如果把它看做为一般的树，那么它们是相同的树，只是画法不一样。" ID="1">
          <fptr EndPN="00000129" StartPN="00000128"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="117" TITLE="6.2.2 二叉树的性质" TYPE="Chapter">
        <fptr LogicalPageNum="129" PhysicalPageNum="129"/>
        <Paragraph CONTEXT="二叉树具有许多良好的性质，简述如下：性质1在二叉树的第i(i&gt;1)层上至多有2'一’个结点。证明利用数学归纳法可以容易地证得此性质。当i二1时，只有根结点，2'一”=1，命题正确；假设当k=i-1时命题成立，即在二叉树的第i-1层上至多有2z个结点，则当k=i时，因为第i-1层上的结点的度至多为2，所以第i层上至多有2X2，一’=2，一’个结点，命题得证。性质2深度为H的二叉树至多有2H-1个结点。证明由性质1可见，深度为H的二叉树的最大结点数为：对任何一棵二叉树，如果其终端结点（叶子）数为no，度为2的结点数为nz，则" ID="1">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="性质3no=nz1,证明设二叉树中度为1的结点数为n,，因为二叉树中所有结点的度均小于或等于2，所N=no+n；十nz(6.1)另设二叉树中的分支总数为B，从每个结点的两个不同角度来看分支数。首先从结点的射入分支看，除根结点外，其余结点都有一个分支进人，则B=N-1；再从结点的射出分支看，由于这些分支是由度为1或2的结点射出的，度为1的结点射出1个分支，度为2的结点射出" ID="2">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="nl-2nz=N-1即N=n2nz-1(6.2)no二nz1注意掌握性质3引人分支数B的证明方法，在许多类似结点数问题的证明中均可借用这种思想方法。下面讨论一下二叉树的高度与结点数N之间的关系。Hm,x=N含有最大高度的二叉树是很少的，只出现在如图6.8&lt;c）左单支树和图6.8(d)右单支树" ID="3">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="H。_L1ogzNJ+1" ID="4">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="N。二＝2H-1和Nm,n=H一棵深度为H且有N，二2”一1个结点的二叉树称为满二叉树（FullBinaryTree)。如图6.9所示分别为一棵深度为1,2,3的满二叉树，这种树的特点是每一层上的结点数都是最大结点数。" ID="5">
          <fptr EndPN="00000130" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)(b)r）$Picture[00000130\00000130_new\0007.jpg]Picture$$Picture[00000130\00000130_new\0008.jpg]Picture$对满二叉树从根开始，从上到下从左到右进行顺序编号，如图6,9(c）所示由此引出完全二叉树的定义。假如深度为H含有N个结点的二叉树，当且仅当其每一个结点都与深度为H的满二叉树中编号从1至N的结点一一对应时，称之为完全二叉树（CompleteBinaryTree)。如图6.10(a6,10(b6.10(c）所示均为深度为3的完全二叉树，图6,10(d）为非完全二叉树。一棵深度为H的完全二叉树中，前H-1层的结点都是“满”的，且第H层的结点集中在左边.显然，满二叉树本身也是完全二叉树。l8）\h）（c）1d完全二叉树在很多场合下得到应用，它有两个非常重要的特性：性质4具有个N结点的完全二叉树的深度为［Iog2NJ-1,证明假设完全二叉树的深度为H，根据性质2和完全二叉树的定义有：取对数便有H-1GlogZN&lt;H，因为H是整数，所以H=LIogZN」-E-1性质5如果对一裸有N个结点的完全二叉树（其深度为L1ogZNJ+1)的结点按层序（从第1层到L1og2N」十1层，每层从左到右）从1起开始编号，则对任一编号为i的结点（(1&lt;i&lt;n)，有①如果i=1，则编号为i的结点是根结点，无双亲；如果i11，则其双亲结点的编号是Li/2」。②如果2i＞n，则编号为i的结点无左孩子（编号为i的结点为叶子结点）；否则，其左孩子结点的编号为2i,$Picture[00000130\00000130_new\0030.jpg]Picture$$Picture[00000130\00000130_new\0031.jpg]Picture$$Picture[00000130\00000130_new\0032.jpg]Picture$$Picture[00000130\00000130_new\0033.jpg]Picture$③如果2i-l＞n，则编号为i的结点无右孩子；否则，其右孩子结点的编号为2i+1,数据结构如图6.11所示该性质的编号关系。在此省略该性质的证明，读者可以从图6.10中直观验证这种关系." ID="6">
          <fptr EndPN="00000131" StartPN="00000130"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="120" TITLE="6.2.3 二叉树的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="131" PhysicalPageNum="131"/>
        <Paragraph CONTEXT="(1)顺序存储结构$Picture[00000131\00000131_new\0002.jpg]Picture$顺序存储结构就是用一个连续的一维空间来存储二叉树，不仅能存储二叉树的结点元素，而且能在存储结构中反映出结点之间的逻辑关系。因此，必须将二叉树中的结点依照一定规律安排在这组连续的存储单元中。对于完全二叉树，因其结点编号是连续的，则可以按完全二叉树的结点编号顺序依次存人一维数组中。编号为i的结点元素存储在一维数组下标为i-1的分量中，如图6.12&lt;a)是一棵完全二叉树及其相应的顺序存储结构。根据完全二叉树具有的特性（性质5)，由编号为i的结点所在的存储位置可以确定该结点的双亲、左孩子和右孩子的存储位置，对应存储数组的下标分别为Li/2J-1,2i-1,2i,对于一般的二叉树，可以对照完全二叉树的编号进行相应的顺序存储，如图6.12(b)，没有结点的分量中填人空白字符。二,图s.12二叉树的顺序存储结构―一维数组&lt;a）完全二又树（b)一般二叉树这种顺序存储结构的优点是对任意结点都能很容易地找到其双亲、孩子结点及其兄弟，而且每个结点的存储空间不大，只占用数组的一个内存单元.但这种存储结构的缺点也很明显，只适合于完全二叉树。对于一般二叉树，特别是分布不均匀的匕叉树，内存的利用率偏低，容$Picture[00000131\00000131_new\0023.jpg]Picture$$Picture[00000131\00000131_new\0024.jpg]Picture$件：2“一’&lt;m&lt;21。最坏的情况是一个深度为H且只有H个结点的单支树也需要占2“一1个结点的存储空间。另外，这种存储结构在插人或删除结点时需要移动其他数据元素方可完成。二叉树的顺序存储结构定义如下：" ID="1">
          <fptr EndPN="00000132" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="defineMAX_TREE_SIZE100" ID="2">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefElemTypeSgBiTree[MAX_TREE_SIZE" ID="3">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="SgBtTreebt;以上是采用一维数组顺序存储二叉树，除此之外，还可采用如图6.13所示结构数组的方式顺序存储二叉树。每个结点结构包含Lchild,Data,Rchild3个域，Data用于存放结点的数据内容，Left,Right则分别存放左子树和右子树在数组中的索引值，若子树不存在则存值一1（A（h图6.13二叉树的顺序存储结构―结构数组" ID="4">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Picture URL="00000132\00000132_new\0020.jpg">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Picture>
        <Picture URL="00000132\00000132_new\0021.jpg">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Picture>
        <Paragraph CONTEXT="(a）结点结构‘b)二叉树及结构数组" ID="5">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="二叉树的这种顺序存储结构定义如下：" ID="6">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="defineMAX_BiTree_Size100" ID="7">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructSgBNode{ElemTypedata;intLchild,Rchild;" ID="8">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="}SgBNode;typedefstruct{SgBNodeBiNodes[MAX_BiTree_Size];intn;/／结点数}SgBiTree;这种结构数组存储二叉树的方式改善了一维数组存储二叉树中插人或删除结点需要移动数据结构与二叉树的结构数组存储非常相似，结点结构如图6.14(a）所示，不同之处仅在于结构数组中Lchild,Rchild分别用来存储左右子树的索引值。而链式存储结构则分别是指向左、右子树的指针，前者以静态方式处理，后者则以动态分配的方式建立。$Picture[00000133\00000133_new\0007.jpg]Picture$$Picture[00000133\00000133_new\0009.jpg]Picture$$Picture[00000133\00000133_new\0010.jpg]Picture$图6.14(b)所示为采用了图6.14(a)所示结点结构的二叉树链式存储结构，称为二叉链表，定义如下：" ID="9">
          <fptr EndPN="00000133" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructBiTNode{" ID="10">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;" ID="11">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="structBiTNode关Lchild，关Rchild;" ID="12">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="}BiTNode,，BiTree;在实际应用中，通常用二叉链表作为二叉树的存储结构，后面涉及二叉树的有关算法也采用这种存储结构。利用这种二叉链表，可以很方便地由某个结点找到它的孩子或子孙，反之则不然。为了便于找到结点的双亲，可以在以上结构上再增加一个双亲域（parent)，双亲域也是一个链域，指向结点的双亲，这样存储结构就是如图6.15所示的三叉链表.相应的定义语言描述请读者参照以上给出。" ID="13">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="二叉树（BinaryTree)也称为二分树或二元树，是一种重要的树型结构。在树的应用中，它起着特别重要的作用，这是因为处理树的许多问题转化二叉树形式解决就变得非常简单，而且任何树或森林和二叉树之间可以通过简单的操作而相互转换。" ID="1">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="123" TITLE="6.3 二叉树遍历" TYPE="Chapter">
      <fptr LogicalPageNum="133" PhysicalPageNum="133"/>
        <div ORDERLABEL="123" TITLE="6.3.1 二叉树遍历的定义" TYPE="Chapter">
        <fptr LogicalPageNum="133" PhysicalPageNum="133"/>
        <Paragraph CONTEXT="所谓二叉树遍历，就是按某种规则访问二叉树的每个结点，且每个结点仅被访问一次.“访问”的含义十分广泛，包括对结点所做的各种操作与处理。如有关学生考试成绩的信息存储在一棵二叉树中，每个结点含有学号、姓名、成绩等信息，在对这些信息进行管理时常常需要做这样的工作：①打印每个学生的学号、姓名、成绩等信息；" ID="1">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Picture URL="00000134\00000134_new\0002.jpg">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Picture>
        <Picture URL="00000134\00000134_new\0004.jpg">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Picture>
        <Picture URL="00000134\00000134_new\0005.jpg">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Picture>
        <Paragraph CONTEXT="②将每个学生的成绩由百分制记分改为五级制记分；③统计优、良、中、及格和不及格各档次的人数。在①中“访问”的含义是打印每个结点的信息；对于②，“访问”是对成绩进行修改的操作；“访问”是统计操作。不管访问的具体操作是什么，都必须做到既无重复，又无遗漏。③中“访问”是统计操作。一棵二叉树由根结点、左子树、右子树3个基本单元组成。根结点处于一个分割左子树和右子树的位置，若能遍历这3部分，则完成对一棵二叉树的遍历.假如以N(NodeL(LeftR(Right）分别代表访问根结点、遍历左子树、遍历右子树，则访问二叉树结点的规则可有NLR,LNR,LRN3种遗历和NRL,RNL,RLN3种逆遍历方式。一般限定先左后右，仅讨论前3种遍历，分别称之为前序遍历（PreorderTraversal)、中序遍历（InorderTraversal）和后序'ostorderTraversal)。基于二叉树的递归定义，可得3种遗历二叉树的递归定义：东井｛遍历（Postorder数据结构树时的结点访问序列为：ABDEGCFHI；中序访问序列为：DBGEACHFI；后序访问序列为：DGEBHIFCA," ID="2">
          <fptr EndPN="00000135" StartPN="00000134"/>
        </Paragraph>
        <Picture URL="00000135\00000135_new\0005.jpg">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Picture>
      </div>
        <div ORDERLABEL="124" TITLE="6.3.2 前序遍历算法描述" TYPE="Chapter">
        <fptr LogicalPageNum="135" PhysicalPageNum="135"/>
        <Paragraph CONTEXT="(1）递归算法由前序遍历二叉树的递归定义，容易得到相应的递归算法.前序遍历首先访问根结点，再访问左子树，然后访问右子树。对左子树的访问，也是先访问其根结点，再访问其左子树，然后访问其右子树，如此反复，逐步将“大树”的访问分解为“左、右子树”的访问，直到其子树为空。这是一个典型的递归模型.假设二叉树以二叉链表存储，对结点的访问操作简化为输出打印结点值，可根据实际应用具体化为其他操作，则前序遍历二叉树的递归算法如下：算法6.1" ID="1">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="voidPreorder(BitreeT)" ID="2">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="／，前序遍历二叉树的递归算法二／" ID="3">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="4">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="If(T)" ID="5">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="{Printf%dT一）data):/／访问根结点return;" ID="6">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="｝如图6.17所示为前序遍历二叉树的过程示意图。带箭头的包围虚线表示前序遍历过程中所走的一条搜索路径。其中向下的箭头表示向更深一层的递归调用，向上的箭头表示从递归调用返回，包围虚线旁方形内的字符表示搜索路径中访问的结点，访问序列为：ABDEC" ID="7">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="F," ID="8">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）非递归算法月卜戈泛少J开.石阮一个具有递归特点的问题，如果用非递归的程序实现，通常可以借助于栈来实现递归层次调用时的参数传递。前序遍历的顺序为：NLR，在访间根结点后对根的左子树遍历，当左子树遍历完后沿走过的路线返回到根结点，再通过根结$Picture[00000136\00000136_new\0002.jpg]Picture$$Picture[00000136\00000136_new\0003.jpg]Picture$IAlB.DE1口FI(a)(b)(a）前序遍历二叉树―ABDECF(b)前序迫历过程示意图点找到其右子树，因此，为了在左子树遍历完后能够找到其右子树，该根结点必须在左子树遍历前人栈保存.假设栈为一顺序栈.二叉树遍历的非递归算法涉及栈的人栈、出栈等多种操作，将充分展示栈的威力，是栈结构的一个极好的应用。算法6.2" ID="9">
          <fptr EndPN="00000136" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="defineMAXLEN100" ID="10">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="voidpreorder(BitreeT)／，前序遍历二叉树的递归算法，／{BitreeStack[MAXLENp;inttop=0;" ID="11">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="p=T;" ID="12">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="do" ID="13">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="14">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="While(p！片NULL)" ID="15">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="‘Printf0odp&gt;data/／访问根结点top一；根结点人栈stack[top]=p;P二p&gt;Lchild;指向左子树｝" ID="16">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="if(top＞0)" ID="17">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="｛P二stack[top];/／根结点出栈top一一；" ID="18">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="19">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="｝while(pNULL)日（top0当根结点不为空或者栈不空时｝" ID="20">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;3)算法分析假定是n个结点的二叉树，由于每个结点仅被访问一次，每个结点要进一次栈，出一次栈。因此算法中的基本操作（进栈、出栈、访问等操作）均被执行一次，算法的时间复杂度为O(n)算法中的栈所需最大容量与二叉树的深度直接相关。从6.17(b）中可以看出，栈中元素序列实际上是由二叉树的根结点到某个结点所经分支上的结点所组成的，所以栈中元素的个数最多等于二叉树的深度。而有n个结点二叉树深度的最大值为n（单支树的情况），因此，栈所需要的最大容量不超过n," ID="21">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="126" TITLE="6.3.3 中序遍历算法描述" TYPE="Chapter">
        <fptr LogicalPageNum="137" PhysicalPageNum="137"/>
        <Paragraph CONTEXT="中序遍历与前序遍历算法思想非常类似，以下只简单给出中序遍历递归与非递归算法。" ID="1">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）递归算法中序遍历的顺序为：LNR，中序遍历与前序遍历的区别仅在于访问根结点、遍历左子树、遍历右子树三个操作的次序不同而已，访问根结点的操作在遍历左子树与遍历右子树之间。只要重新安排三个操作的次序就可以得到中序遍历递归算法" ID="2">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.3voidInorder(BitreeT)／，中序遍历二叉树的递归算法＊／" ID="3">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="4">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="If(T)｝" ID="5">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="return;｝如图6.18所示为二叉树中序遍历过程。从A开始，向其左子树递归调用，直到左子树为空。访问其根结点，第甲个被访问的结点为D，再遍历D的右子树，为空返回到结点B，遍历其右子树，依次类推，得到中序遍历的序列为：DBEACF," ID="6">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）非递归算法中序遍历的过程是遍历根结点的所有左子树的左结点并人栈，直到结点为空返回，结点出栈，被访问，然后转右子树结点。中序遍历的非递归算法在算法6.2的基础上稍作修改即得算" ID="7">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="法6.4," ID="8">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.4" ID="9">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="#1defineMAXLEN100" ID="10">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="voidInorder(BitreeT)" ID="11">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Picture URL="00000138\00000138_new\0002.jpg">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Picture>
        <Picture URL="00000138\00000138_new\0003.jpg">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Picture>
        <Paragraph CONTEXT="lioBai口，口1i(a&gt;b）(a)中序遍历二叉树―DBEACF(b)中序遍历过程示意图／＊中序遍历二叉树的非递归算法，／{BitreeStack[MAXLENp;inttop=0;" ID="12">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="P二T;" ID="13">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="do" ID="14">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="15">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="While(pl=NULL)" ID="16">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="（top节;根结点人栈‘’＿，.‘‘卜「心石六门，。·" ID="17">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="p，p一＞Lchild，刀指向左子树口" ID="18">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="、·‘｛P二stack〔top’/／根结点出栈toffs一一；Printf°odp&gt;data);／“’Printf衅％d”，p今data）；刀访问根结点" ID="19">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="一’－·，，一，.铸乙" ID="20">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="P，pee＞Rchi［d；｝；｝while（p！＝NULL）｛｝（top！＝0）；／／当根结点不为空或者栈不空时" ID="21">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="22">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）算法分析数据结构法的复杂性。因此，n个结点的二叉树，中序遍历算法的时间复杂度仍为O(n)，栈所需要的最大容量不超过二叉树的深度。" ID="23">
          <fptr EndPN="00000139" StartPN="00000138"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="128" TITLE="6.3.4 后序遍历算法描述" TYPE="Chapter">
        <fptr LogicalPageNum="139" PhysicalPageNum="139"/>
        <Paragraph CONTEXT="(1）递归算法后序遍历的顺序为：LRN，后序遍历与前序遍历的区别在于访问根结点的操作在遍历左子树与遍历右子树之后。调整3个操作的次序就可以得到后序遍历递归算法。算法6.5voidPostorder(BitreeT)／，后序遍历二叉树的递归算法＊／（" ID="1">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="If(T){Postorder(T一＞Lchild/／遍历左子树Postorder(TRchild);/／遍历右子树Printf0odT&gt;data/／访问根结点｝" ID="2">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="return;" ID="3">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="｝如图6.19所示为二叉树后序遍历过程。从A开始，向其左子树递归调用，直到结点D;左子树为空，再遍历D的右子树，也为空返回，访问结点D，再返回到结点B，遍历其右子树，依次类推，得到后序遍历的序列为：DEBFCA，如图6.19(b)中包围虚线旁的三角内字符为访问结点。｝国国习口国1AI" ID="4">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)(b)·128" ID="5">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;2）非递归算法后序遍历的非递归算法比前序遍历、中序遍历要复杂。在后序遍历时，如果存在左子树，则首先查看该结点的左子树。在按后序遍历左子树时，该结点进栈保存，以便返回时遍历其右子树。在按后序遍历其右子树时，该结点还得进栈保存，因为该结点需在右子树访问完后才被访问。这样，树中的每个结点都应两次进栈、两次出栈。第一次出栈是在遍历访问完所有的左子树结点，出栈的目的是为了访问其右子树；第二次出栈是在遍历访问完所有的右子树结点，出栈的目的是为了访问该根结点。如何区分两次出栈？方法一是为每个结点设置标志位tag[i;" ID="6">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="r.IO访问左子树，需出栈找右子树访问右子树，需出栈访问该结点" ID="7">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.6" ID="8">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="defineMAXLEN100voidPostorder(BitreeT)／二后序遍历二叉树的非递归算法一＊／{BitreeStack[MAXLENp;inttag[MAXLENtop=0,b;" ID="9">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="p=T;" ID="10">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="do" ID="11">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="12">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="While(pNULL)｛top什；根结点人栈stack[top]=p;tag〔topj＝0；／／设置标志位P=P一）Lchild;指向左子树" ID="13">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="b=1;" ID="15">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="while(top0)b｛p＝stack〔top〕；／／根结点出栈" ID="16">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="if(tag[top1)" ID="17">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="19">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="20">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="｝，}while(pl=NULL)If(top0/／当根结点不为空或者栈不空时｝方法二是设一指针q，用于记住最近一次被访问的结点.这种方法不需要记住什么时候应访问根结点，不必为每个结点设立标志位，只需在结点每次出栈前判断其右子树是否为空，若为空，即不存在右孩子，则该结点出栈应被访问；若右子树非空但已遍历完毕，即它的右孩子恰好是最近一次访问的结点，则栈顶元素出栈应被访问；若右子树非空而且尚未遍历，即它的右孩子不是最近一次访问的结点，则现在不访问栈顶元素所指结点，而应去遍历右子树。因此，在遍历过程中，只需要用一指针记住最近访问过的结点即可。" ID="22">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.7" ID="23">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="defineMAXLEN100voidPostorder(BitreeT)／，后序遍历二叉树的非递归算法二＊／{BitreeStack[MAXLENp,q;mttop=u,b;p=T;" ID="24">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="do" ID="25">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="＜" ID="26">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="While(pNULL)（topes;根结点入栈stack[toppqP=P一）Lchild;/／指向左子树｝b二l;q=NULL;while(top0)b｛p＝stack［top〕；／／根结点出栈或者其右子树是否为最近被访问的结点" ID="27">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="（top一一；Printf%dp一＞data)／访问根结点q=P+9指向最近被访问的结点" ID="28">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="29">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="30">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="31">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；}while(pNULL)11(top!=0／当根结点不为空或者栈不空时｝" ID="32">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)算法分析上述算法与前序、中序遍历算法相比要复杂一些，理论上分析需要二次人栈，二次出栈，但从算法的实现来看，第一次并未真正出栈，只需取栈顶元素作判断即可，也就不需二次人栈.因此，对算法的复杂性并没有多大影响，n个结点的二叉树，后序遍历算法的时间复杂度仍为O(n)，栈所需要的最大容量在小于二叉树的深度时不会出现溢出." ID="33">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="131" TITLE="6.3.5 遍历算法的应用" TYPE="Chapter">
        <fptr LogicalPageNum="142" PhysicalPageNum="142"/>
        <Paragraph CONTEXT="遍历二叉树是二叉树各种操作运算的基础，很多操作可以在遍历过程中完成.如前所述，遍历算法中对每个结点进行一次访问操作，而访问结点的操作可以是多种形式及多个操作。利用这一特点，根据遍历算法的程序框架，适当修改访问操作的内容，便可得到求解许多问题的算法，如求二叉树的结点数、叶子数，判定结点的层次等。因此，二叉树遍历算法是二叉树应用算法的基础，其程序框架是非常基础又相当重要。下面给出几个典型问题的求解。例6.1求二叉树T中的叶子结点数本算法求二叉树T中的结点数，只需将遍历算法中的访间操作改为条件计数操作。即在累加到一个全局变量n中（n初值为0），每个结点被访问时即被判断、条件计数。算法如下：" ID="1">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.8voidlnord-Leaves（BitreeT）／，将二叉树T中的结点数累加到全局变量n中，n初值为。，／" ID="2">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="3">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="if（T）Inorder-Leaves（T一＞Lchild）；If（（T一＞Lchild＝＝NULL）＆＆（T一亡＞Rchild＝＝NULL））" ID="4">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="n＝n＋1；" ID="5">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="Inorder-Leaves（T一＞Lchild）；" ID="6">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="））算法6.8是一个“标准”中序谊历算法，其访问操作为是否为叶子的判断和累加计数。该" ID="7">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="算法也可很方便地改为前序遍历和后序遍历算法。例6.2建立二叉树的存储结构―二叉链表建立二叉树的存储结构是对二叉树进行操作的前提，也就是说，对二叉树的操作必须是在建立二叉树存储结构的基础上进行，包括遍历操作。如图6.20（a）所示的二叉树，如何建立其数据结构（空子树用“＃”表示）输人来建立二叉链表，T为指向根结点的指针，首先输人一个根结点，若输人的是一个特殊字符如“＃”，则表明该二叉树为空树，即T=NULL；否则，申请一个结点空间，输人的字符赋给T&gt;data，之后依次递归建立其左子树T一＞Lchild和T一＞Rchild。按前序遍历算法框架设计该算法如下：" ID="8">
          <fptr EndPN="00000143" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.9$Picture[00000143\00000143_new\0010.jpg]Picture$$Picture[00000143\00000143_new\0011.jpg]Picture$voidCreateBiTree(BiTree&amp;T)／二按前序遍历序列输人结点字符，建立二叉链表存储结构，／｛" ID="9">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="scanf（衣ch）；if(ch＝二’T=NULL;/＊建空树，／elseif(1(TBiTNodemalloc(sizeof(BiTNodeexit(OVERFLOW／二生成根结点‘／{printfOVERFLOW;return;}T一）data=ch;CreateBiTree(TLchild/，递归建立左子树，／CreateBiTree&lt;T&gt;Rchild);/，递归建立右子树二／｝" ID="10">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="return;" ID="11">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法6.9是一个“标准”前序遍历算法，其访问操作为根结点生成操作。例6.3求二叉树的高度二叉树的高度为二叉树中所有结点的最大层次数。结点的层次从根结点开始递推，设二叉树根结点的层次数为1，其子树根结点在第2层上，依此类推，第k层结点的子树根结点在第k1层.因此求二叉树的高度，可在前序遍历二叉树的过程中求每个结点的层次数，其中的最大值即为二叉树的高度." ID="12">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.10voidBiTreeHeightfBiTreeTinthint&amp;Height)／，求二叉树的高度Height，初值为O,h为T所指向的结点所在层次，初值为1｛" ID="13">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="132" ID="14">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="if(T){" ID="15">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="if(h&gt;Height)Height=h;BiTreeHeight&lt;T一＞Lchild,h-1,HeightBiTreeHeight(T一＞Rchild,h+1,Height);｝" ID="16">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法6.10也是一个“标准”的前序遍历算法，其访问操作为当前访问结点的层次数h与当前求得的最大层次数Height比较，Height取“大值”。该算法参数表中设置的值参h，始终保持和当前T所指结点层次一致，这是很多遍历应用算法中采用的一种技巧，请注意掌握这种技巧的应用。图6.20(a)所示的二叉树，求其高度算法执行过程如图6.21所示。向下的虚线表示递归调用，虚线旁边括号内的值为调用传递的参数值，向上的虚线表示调用返回，虚线旁的值为调用返回值。Height简化表示为H，注意H与h值得区别。" ID="17">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="求二叉树高度也可通过后序遍历二叉树来得到.二叉树高度可递归定义为：若二叉树为空，则其高度为。，否则其高度等于左（或右）子树的最大高度加1。由此递归定义得到递归模型为：133" ID="18">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构Heirht&lt;T）一！0T-NULLT护NULL" ID="19">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="从而得到以下算法：算法6.11voidBITreeHeight（BITreeT）／／求二叉树的高度Height" ID="20">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="21">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="if（！T）returno" ID="22">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="else｛" ID="23">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="HL今BITreeHeight（T一＞Lchild）；" ID="24">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="HR＝BITreeHeight（T一仁＞Rchild）；if（HL＞＝HR）returnHL＋1；" ID="25">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturnHR＋1；" ID="26">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="27">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例‘.4表达式求值表达式的计算曾在第3章作为栈的典型应用进行了讨论，这里，选择二叉树这种数据结构存储表达式，讨论其求值间题.一般情况下，一个表达式由一个运算符和两个操作数构成.两个操作数之间有次序之分，并且操作数也可是表达式，这种结构类似于二叉树，因此，可以用二叉树表示表达式。表示表达式的二叉树称为表达式树（ExPressionTrees），这类二叉树具有以" ID="28">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="下特点：" ID="29">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="①每个叶子是操作数；" ID="30">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="②根结点和内部结点是操作符；③子树是子表达式树。如表达式a，（b＋c）十d，可表示成图6.22所示的二叉树。前序遍历这棵二叉树，得到线东卜闷一书卜。月二寺生乳习匕斗七二卜以1亩命4翻书二d‘石七羞分J卜切七从二主；声.七已岂之自！不二寺坦三一习七廿蛋且习蚀转性序列：十，a十bcd，这是表达式的前缀形式，或称为波兰表示。中序遍历这棵二叉树，得到线，d十，这是表达式的后缀形式，或称为逆波兰表示.下面主要研究算术表达式求值问题，而逻辑表达式的计算可类似实现。简化为：表达式中只有二元运算，运算符为＋、一八操作数以单字符的简单变量表示。表达式求值需按运算符的优先关系，从左至右计算。表达式a*(b十。）十d按优先关系分解成：第一操作数：a*(b-c)" ID="31">
          <fptr EndPN="00000146" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="运算符：＋" ID="32">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="第二操作数：d在进行该运算时，必须先计算出第一操作数的值，类似将第一操作数分解为：a,*,b-c,依此类推。因此，在处理一“运算符”前，必须先求出其左、右操作数表达式的值。由此可见，表达式求值的过程实际上是后序遍历二叉树的过程，先计算子树，直到整个表达式变成单值为止。对表达式树采用二叉链表存储时，每个结点增加一个结果域，结点的形式为1’一Idata｝一｝一］基于此，给出算术表达式求值的算法如下：算法6.12voidvalue(BiTreeT)/，算术表达式求值二／" ID="33">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="34">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="35">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="if(！T)" ID="36">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="{T一》result二O;returnelse{value(T一＞Lchild);/／求左子树的值value(T&gt;Rchild/／求右子树的值switch(T&gt;data){case:T&gt;result=(T一＞Lchild一＞result)-(T&gt;Rchild&gt;result);break;’一‘:Tresult=(T一＞Lchild一）result）一（TRchildresult);break;case'，T&gt;resultT一＞Lchild一）result)，(T&gt;Rchild一＞result);break;case:Tresult=(T一艺＞Lchild一＞result)/(T&gt;Rchild－一＞result);break;default：Tee＞result=Tes＞data;break;" ID="37">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="38">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="return;" ID="39">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="40">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="135" TITLE="6.4 线索化二叉树" TYPE="Chapter">
      <fptr LogicalPageNum="146" PhysicalPageNum="146"/>
        <div ORDERLABEL="136" TITLE="6.4.1 二叉树的线索化" TYPE="Chapter">
        <fptr LogicalPageNum="147" PhysicalPageNum="147"/>
        <Paragraph CONTEXT="加上线索的二叉树称为线索二叉树（ThreadedBinaryTree）。对二叉树以某种次序遍历示，其中实线为指针（指向左、右孩子），虚线为线索（指向前驱和后继），图6.23(b)为其中序线索链表。为仿照线性表的双向链表，在中序线索链表上添加一个“头结点”。该结点的指针Lchild指向二叉树的根结点，左标志ltag为。，指针Rchild指向中序遍历序列的最后一个结点，右标志rtag为1。同时也让中序遍历序列中第一个结点的左线索和最后一个结点的右线索指向“头结点”，这样线索链表就构成一个双向循环链表，如图6.23(b)为带头结点Head的线索链表。的过程，实际上只需在遍历算法中，在访问结点的同时将空链域改为指向前驱或后继的线索，为了在当前访问的结点与其前驱之间建立线索，需附设一个指向“当前访问结点”的“前驱”的指针pre.算法6.13实现“头结点”的建立和中序线索化.$Picture[00000148\00000148_new\0016.jpg]Picture$$Picture[00000148\00000148_new\0017.jpg]Picture$算法6.13ThreadTreep;/／指向当前结点的指针ThreadTreepre;/／指向当前结点前驱的指针VoidInOrderThreading(ThreadTreeT,ThreadTreeHead／，建立二叉树T的中序线索链表，Head指向头结点，／｛Head二（ThreadTree)malloc(sizeof(ThreadTNode;if&lt;!Head)/／分配失败(printfOVERFLOW;return;}Head一＞Itag=O;Head一＞Rtag=1;/／建立头结点137数据结构Head一代＞Rchild=Head;/／头结点右指针指向自己if&lt;!T)Head一＞Lchild=Head;/／若二叉树T为空，则左线索指向自己else{Head一）Lchild=T;若二叉树非空，则左线索指向二叉树根结点pre=Head;pre指向当前结点的前驱InThreading(T);/／中序遍历进行中序线索化Pre&gt;Rchild二Head;pre一＞rtag=l;中序遍历序列中最后一个结点线索化Head&gt;Rchild=pre;" ID="1">
          <fptr EndPN="00000149" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="2">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="return;" ID="3">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="4">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="VoidInThreading(ThreadTreeroot)中序遍历二叉树root，在遍历中线索化{p=root;" ID="5">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="if(pInThreading(p一＞Lchild);/／左子树线索化if(tp&gt;lchild)/／建前驱线索{p一＞.ltag=l;pIchild=pre;)if(1prerchild)/／建后继线索{pre一＞rtag=1;pre一＞rchild=p;}pre=p;/／保持pre指向P的前驱InThreading(p&gt;Lchild/／右子树线索化｝；该算法给出的是二叉树中序线索化算法，对于前序和后序的线索化算法与该算法大致相同，留给读者作为练习。" ID="6">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="138" TITLE="6.4.2 线索二叉树的遍历" TYPE="Chapter">
        <fptr LogicalPageNum="149" PhysicalPageNum="149"/>
        <Paragraph CONTEXT="在二叉树线索化后，就容易找到结点的前驱或后继结点.线索二叉树的遍历实际上是找到序列的第一个结点，’然后依次找结点后继的问题，不再需要递归，也不需要设栈。" ID="1">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）线索二叉树的中序遥历在对中序线索二叉树进行遍历时，首先找到根结点的左子树，直到左指针域为空的结点，此结点即为遍历的第一个结点；然后反复寻找每个结点的后继结点，就可以遍历这棵二叉树。以图6.23的中序线索链表为例来看，若某结点P的右标志rtag=1，则右链域P一一＞Rchild为线索，直接指示结点的后继。如结点E的后继为结点C。若某结点P的右标志rtag=0，则右链域P一＞Rchild为指针，则无法直接后继的信息。但根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点，如结点A的后继为其右下列算法是以带头结点的线索链表为存储结构对二叉树进行中序遍" ID="2">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="历。" ID="3">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.14voidInOrder-Thr(ThreadTreeHead)／，中序遍历中序线索二叉树T,Head指向头结点＊／｛ThreadTreep=Headchild;while(pHead){while(p一＞ltag0)p=p一＞lchild;/／找根结点左子树左指针域为空printf°odp一＞data);/／访问第一个结点while(p气＞rtag一一1p一＞rchild！一Head)/／访问每个结点的后继结点｛" ID="4">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="p=p代＞rchild;printfd',p一＞data);｝；" ID="5">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="P=Prchild;" ID="6">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="return;" ID="8">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="｝分析算法6.15，在中序线索二叉树上遍历二叉树，其时间复杂度亦为O(n)。但常数因子比一般二叉树上遍历的算法小，且不需设栈。因此，若需经常遍历或查找遍历线性序列中的前驱或后继，则应采用线索链表作存储结构。线索化是提高重复性访问非线性结构效率的重要手段之一。" ID="9">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）线索二叉树的前序遮历在前序线索树上前序遍历二叉树，实际上就是一个求后继结点的问题。在前序线索链表中，若某结点P的左标志P一＞ltag二。，则结点P有左孩子，即为结点P的后继；否则无左孩子，结点P的后继或为结点P的右孩子或为P一＞Rchild所指示的后继。前序线索二叉树前序遍历算法如下：" ID="10">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="算法6.15voidPrerder-Thr(ThreadTreeHead)／二前序遍历前序线索二叉树T,Head指向头结点，／｛ThreadTreep=Head&gt;lchild;while(p!=Head){printf%dp一）&gt;data/／访问结点if(p&gt;Itag0)p=p&gt;Lchild;有左孩子，左孩子即为后继结点elseP=P一＞Rchild;无左孩子，右孩子或右线索所指即为后继结点" ID="11">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="｝；" ID="12">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="return;" ID="13">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="14">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在前序线索二叉树上前序遍历二叉树的算法6.15更简单，其时间复杂度亦为U&lt;n)，但该算法中仅在根结点无左孩子时使用了右线索找其后继结点，而左线索没有起作用，可以取消。仅设右线索的二叉树称为右线索二叉树。若前序右线索二叉树仅为了满足遍历的需要，标志位Itag,rtag也可取消，算法中用到的P一＞ltag是否为0的判断可改用P一＞Lchild是否为空，以判断结点P是否有左孩子，从而更进一步提高结点的存储密度。" ID="15">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;3）线索二叉树的后序遍历图6.24所示的是一棵后序线索二叉树。在后序线索二叉树中找结点的后继较复杂，可分3种情况：" ID="16">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.24后序线索二叉树$Picture[00000151\00000151_new\0014.jpg]Picture$①若结点P是二叉树的根，则其后继为空，如根结点A的后继为空；②若结点P是其双亲的右孩子或是其双亲的左孩子且其双亲无右子树，则其后继为其双亲结点，如结点E,H,C的后继分别为其双亲结点B,E,A,F的后继也是其双亲结点C;③若结点P是其双亲的左孩子且其双亲有右子树，则其后继为其双亲右子树上按后序遍历得到的第一个结点，如B,D,G的后继分别为F,G,H可见，在后序线索二叉树上找后继时需知道双亲结点，一种方式是在遍历中借助栈实现；另一种方式是将线索链表增加Parent指针指向双亲结点，改用三叉链表作存储结构。总之，" ID="17">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="从前面的讨论可知，遍历二叉树就是将非线性结构的二叉树线性化，即按一定规则将二叉树中的结点排列成一个线性序列依次访问。如图6.20(a)所示的二叉树，经中序遍历得到线数据结构这些线性序列中，二叉树中的每个结点（除第一个和最后一个外）有且仅有惟一的一个前趋和惟一的一个后继，很容易找到各个结点的直接前驱和直接后继。但当以二叉链表作为二叉树的存储结构时，只能找到结点的左、右孩子，而不能直接找到前驱和后继，只有在遍历的动态过程中得到这些信息.如果将这些信息在第一次遍历时保存起来，在需要再次对二叉树进行“遍历”时就可以将二叉树视为线性结构进行访问，从而简化遍历操作。那么，如何存储遍历中得到的结点前驱和后继的信息呢？一个简单的办法是在每个结点上增加两个指针域fwd和bkwd，分别指向存储遍历中得到的结点前驱和后继。这是采用多重链表来表示二叉树。这种方法虽简单易行，但这种结构的存储密度将大大降低，浪费存储空间。另一种方法，是利用原有链域Lchild和Rchild的空链域。在n个结点的二叉链表中有2n个孩子链域，其中仅有n-1个链域是用来指示结点的左右孩子，而另外n+1个链域是空链域。现在把这些空链域利用起来，使其指向结点的前驱或后继；对那些原来就不为空的链域，则仍然指向左或右孩子.如果把指向前驱和后继的指针称为线索（Thread),｝LcbildI1！二｝d-lrt-i一｝如果把指向前驱和后继的指针称为线索（Thread），那么，如何区定义为：＿四Lchild为左指针，指向左孩子＿10Rchild为右指针，指向右孩子" ID="1">
        <fptr EndPN="00000147" StartPN="00000146"/>
      </Paragraph>
      <Paragraph CONTEXT="ltag＝凡滋＿，…、，，＿，卜一，。二＿、＿＿rlag一、。。，.二，.、于。二一，“typedefstructThreadTNode｛enum｛0，1｝ltag，rtag；ElemTyPedata；StructThreadTNode关Lchild，，Rchild；｝ThreadTNode，，ThreadTree；为了节省内存空间，用C语言的位段方法将结点中的左标志域和右标志域与数据域合并在一个存储单元中（即各用一位表示左标志和右标志，其余各位表示结点值）。" ID="2">
        <fptr EndPN="00000147" StartPN="00000147"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="140" TITLE="6.5 树和森林" TYPE="Chapter">
      <fptr LogicalPageNum="151" PhysicalPageNum="151"/>
        <div ORDERLABEL="140" TITLE="6.5.1 树的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="151" PhysicalPageNum="151"/>
        <Paragraph CONTEXT="树的结构较二叉树复杂，不如二叉树结构规整。树中每个结点都可能有多个孩子。因此，若直接用多个链域表示父子关系，则结点大小难以确定；若按树的度来设计结点，则必然会造" ID="1">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="将介绍树的几种常用存储表示法。" ID="2">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)广义表表示法利用广义表表示一棵树，既可存储树的数据元素，又可用广义表中的括号表示数据元素之间的父子关系，是一种非常有效的方法。树中的结点可以分为叶子结点、根结点和分支结点三种，在广义表中正好也有三种结点与之对应：原子结点、表头结点和子表结点.如图6.25&lt;a）所示的一棵树，其广义表表示为（A(B(EC(F,GD(H,I(KJ，其存储结构如图6.25(b）所示。" ID="3">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="A$Picture[00000152\00000152_new\0011.jpg]Picture$馋锤留" ID="4">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)双亲表示法树中每个结点只有一个双亲，根结点的双亲为空。利用这一特性，在存储树的结点信息的同时在每个结点附加一个指示双亲位置的指针，并将所有结点以顺序存储结构组织在一起。图6.26为图6.25(a）所示树的双亲表示。" ID="5">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="在树的双亲表示中，树的结点结构和树的结构类型定义如下：" ID="6">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="defineMAX_TREE_SIZE100" ID="7">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="结点结构：" ID="8">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="9">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Picture URL="00000153\00000153_new\0002.jpg">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Picture>
        <Paragraph CONTEXT="intparent;/／双亲位置域}PTNode;" ID="10">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="树结构：" ID="11">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct{PTNodenodes[MAX_TREE_SIZEintr,n;/／根结点的位置和结点个数}PTree;显然，在树的双亲表示中找一个结点的双亲是非常容易的，可以在O&lt;1)时间级内完成查询结点双亲的操作，而要查询结点的孩子则需遍历整棵树。&lt;3)孩子链表表示法树中每个结点可以淆。个或多个孩子。用孩子链表表示树，就是将每个结点的孩子排列起来，看成线性表，且以单铸表存储，则n个结点就有n个孩子链表（叶子结点的孩子链表为空表）。而由每个结点信息和头指针又构成一个线性表，为了便于查找，可采用顺序存储结构。图6.27为图6.25(a)所示树的孩子链表表示。树中结点的存放顺序一般不作特殊要求，但为了操作实现的方便，存放顺序也有一定规律，如按层次遍历顺序或按前序遍历的顺序存放树中的各个结点。在树的孩子链表中，树的结点结构和树的结构类型定义如下：孩子结点结构为：typedefstructCTNode{" ID="12">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="intchild;" ID="13">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="structCTNode*next;｝二ChildPtr;" ID="14">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="双亲结点结构为：" ID="15">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct{" ID="16">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;" ID="17">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="ChildPtrfirstchild;/／孩子链的头指针}CTBox;" ID="18">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="·142" ID="19">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Picture URL="00000154\00000154_new\0002.jpg">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Picture>
        <Paragraph CONTEXT="树结构：" ID="20">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct{CTI3oxnodes[MAX_TREE_SIZEintn,r;/／结点数和根结点的位置}CTree;这种表示法，与双亲表示法相反，查询某结点的孩子方便，却不适宜查询结点的双亲。若需要时，我们可以将这两种方法结合起来，在双亲结点中增加一个Parent域，使其指向该结点data的双亲所在的位置." ID="21">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）孩子一兄弟表示法又称二叉链表表示法，类似二叉树的二叉链表，只是树结点中的两个指针域分别指向其“最左”孩子结点和紧邻的“右兄弟”结点，分别用firstchild域和nextsibling域代替二叉树二叉链表中的两个指针域Lchild和Rchild;如图6.28为图6.25(a）所示树.孩子一兄弟链表表示。孩子一兄弟链表中结点结构定义如下：typedefstructCSNode(" ID="22">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypedata;structCSNode关firstchild，二nextsibling;}CSNode,*CSTree;在孩子兄一弟表示中，若要查询某结点的所有孩子，只需通过该结点的firstchild指针，找到它的第一个孩子；再通过该孩子的nextsibling指针找到它的下一个兄弟；依次往下查找，直到nextsibing指针为空，则找出某结点的所有孩子。这实际上是沿nextsibling指针链作一次扫描。在这种表示中，可方便实现查询根、双亲、孩子以及兄弟结点等操作。数据结构盛补四" ID="23">
          <fptr EndPN="00000155" StartPN="00000154"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="144" TITLE="6.5.2树、森林与二叉树的转换" TYPE="Chapter">
        <fptr LogicalPageNum="155" PhysicalPageNum="155"/>
        <Paragraph CONTEXT="从图6.28可以看出树的孩子一兄弟链表表示实际上是二叉链表存储结构。就图6.28所示的二叉链表可对应一棵二叉树，如图6.29所示。这样，图6.25(a)中的树与图6.29中的二与二叉树之间的一个对应关系，即给定一棵树，可以找到惟一的一棵二叉树与之对应。容易证明：一裸有n&lt;n）1)个结点的d度树，若用多重链表表示，树中每个结点都有d个链域。那么在树的nd个链域中，有n&lt;d-11个是空链域，只有u-1个是非空链域。由此可见，d度树的链域利用率为（(n-1nd，约为1/d。随着树的度数的降低，其链域的利用率升$Picture[00000155\00000155_new\0010.jpg]Picture$高。除1度树外，2度树的链域利用率最高.因此，用二叉树来表示树是有意义的，而且把树转化成二叉树，可利用二叉树的有关算法来实现对树的操作。&lt;1)树与二叉树的转换" ID="1">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="将一裸树转换成二叉树的步骤如下：①在树中各兄弟结点（堂兄弟除外）之间加一连线；·②对于任一结点，只保留它与最左孩子的连线，删去它与其余孩子之间的连线；③以树根为轴心，将整棵树按顺时针方向旋转约45°，形成二叉树的结构。如图6.30所示为一般树转换为二叉树的过程。$Picture[00000156\00000156_new\0003.jpg]Picture$$Picture[00000156\00000156_new\0004.jpg]Picture$$Picture[00000156\00000156_new\0005.jpg]Picture$可以看出，由一般树转换而成的二叉树有如下特点：根结点的右子树总是空的，这是因为原树的根不会有兄弟；生成的二叉树中各结点的右孩子结点是原树中该结点的兄弟结点，左孩子结点还是原来该结点的左边第一个孩子结点。相反，对于任何根没有右孩子的二叉树，按上述转换过程的逆过程，就可以转换成一棵树。" ID="2">
          <fptr EndPN="00000156" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）森林与二叉树的转换森林是树的有限集合，可以利用树与二叉树的转换思路将森林转换成二叉树。从树的孩子一兄弟链表表示中可以看出，任一棵与树对应的二叉树，其根的右子树必为空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可以导出森林与二叉树的对应关系。因此，可以得到森林转换为二叉树的步骤为：①将森林中的每棵树转换成相应的二叉树；" ID="3">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="②将森林中各裸树的根相连；" ID="4">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="③以第一棵树为轴心顺时针旋转约45°,图6.31展示了森林（a)转换成二叉树（d)的过程。森林转换成二叉树的过程形式化定义为：设森林F＝（T：，T：，…，Tn），它所对应的二叉树B(Root,LB,RB）可按如下规则得到：①若F二中(n=0)，则B二。，即二叉树为空树；②若F护i&lt;n护0)，则森林中第一棵树的根即为二叉树B的根（Root),B的左子树LB是从T,的子树集合{tii,tiZtm}转换而成的二叉树；B的右子树RB是从森林中余下的树{T2,TT°｝转换而成的二叉树。可以看出，森林到二叉树的转换过程是递归的。将上述过程反过来，就是将一棵二叉树转换为森林的过程。若B(Root,LB,RB)是一裸二叉树，Root是二叉树B的根，LB,RB分别是二叉树B的左、右子树，则可按如下规则转换成森林F＝（TJ，T：，…，T。）：①若B=c，则F=cp:②若B，则二叉树B的根（Root)为F中第一棵树T,的根，B的左子树转换成的森林数据结构$Picture[00000157\00000157_new\0003.jpg]Picture$$Picture[00000157\00000157_new\0004.jpg]Picture$$Picture[00000157\00000157_new\0005.jpg]Picture$$Picture[00000157\00000157_new\0006.jpg]Picture$$Picture[00000157\00000157_new\0011.jpg]Picture$$Picture[00000157\00000157_new\0012.jpg]Picture$构成T,根结点的子树集合｛t：1，tl：，…，tlm｝；B的右子树转换成的森林构成其他的树的集合（T：，T：，…，T。）。这也是一个递归过程，图6.31(d)所示的二叉树可以转换成图6.31(a）所示的森林。由此，森林的各种操作均可对应到二叉树的操作来完成.换而言之，和树对应的二叉树，其左、右子树的概念改变成：左是孩子，右是兄弟。" ID="5">
          <fptr EndPN="00000157" StartPN="00000156"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="146" TITLE="6.5.3树和森林的遍历" TYPE="Chapter">
        <fptr LogicalPageNum="157" PhysicalPageNum="157"/>
        <Paragraph CONTEXT="介绍了二又树的前序、中序、后序3种遍历方法，树和森林的遍历也是按照某种次序访问树和森林中的每个结点，而且仅被访问一次。由树结构的定义可知，树的遍历可有两种遍历方法：一种是前序遍历，即若树不空，则先访问根结点，然后依次先根遍历各棵子树；另一种是后序遍历，即若树不空，则先依次后根遍历各棵子树，然后访问根结点。这是一个递归过程。例如，对图6.30(a)所示的树进行前序遍历，其前序序列为ABECF-GD。若进行后序遍历，得到的后序序列为EBFGCDA。对该树对应的二叉树（图6.30(c”进行前序、中序、后序遍历，得到前序序列为：ABECFGD，中序序列为：EBFGCDA，后序序列为：EGFDCBA。由此可见，前序遍历树与前序遍历该树对应的二叉树得到相同的前序序列，而后序遍历树与中、前序遍历该树对应的二叉树得到相同的序列。类似树的遍历方法，对森林的遍历也有两种方法：前序遍历森林和中序遍历森林。若森林不空，则可按以下规则前序遍历森林：" ID="1">
          <fptr EndPN="00000158" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="①访间森林中第一棵树的根结点；" ID="2">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="②前序遍历森林中第一棵树的子树森林；③前序遍历森林中（除第一棵树之外）其余树构成的森林。若森林不空，则可按以下规则中序遍历森林：" ID="3">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="①中序遍历森林中第一棵树的子树森林；" ID="4">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="②访问森林中第一棵树的根结点；③中序遍历森林中（除第一棵树之外）其余树构成的森林。若对图6.31(a)中森林进行前序遍历和中序遍历，则分别得到森林的前序序列为ABC-DEFGHUK，中序序列为BDCEAGFIKJH。若对图6.31(d)中森林对应的二叉树进行前序和中序遍历，得到同样的前序序列和中序序列。由此可见，当树以孩子一兄弟二叉链表存储时，树的前序遍历和后序遍历可借用二叉树的" ID="5">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="本节主要介绍树的存储表示及其遍历操作，并建立树、森林与二叉树之间的转换关系。" ID="1">
        <fptr EndPN="00000151" StartPN="00000151"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="147" TITLE="6.6 哈夫曼树及其应用" TYPE="Chapter">
      <fptr LogicalPageNum="158" PhysicalPageNum="158"/>
        <div ORDERLABEL="147" TITLE="6.6.1 基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="158" PhysicalPageNum="158"/>
        <Paragraph CONTEXT="&lt;1)路径和路径长度从树中一个结点到另一个结点之间的分支构成这两个结点的路径，路径上的分支数目称为路径长度。一般情况下，结点的路径长度定义为从根结点到该结点的路径上分支的数目。树的路径长度等于树中每个结点的路径长度之和。因树中每个结点只有一个双亲，从根结点到达树的其他结点有且仅有一条路径。若树根的层数为1，树中某结点的层数为k，则该结点的路径长度为k-1。例如，在图6.32(a）所示的二叉树中，从根A到其他结点B,C,D,E,F,G,H的路径长度分别为1,1,2,2,2,2,3。该树的路径长度为PL=。十1+1十2+2-2-23=13，而图6.32&lt;b)所示的二叉树的路径长度为PL=01+1+2-2-F-2+3-3=14。显然，前者的路径长度短。由二叉树的性质可推出完全二叉树的路径长度最短。" ID="1">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）结点的带权路径长度实际应用中，如解决某些判定问题时，判定过程可利用树来描述。而各种不同的情况出现数据结构" ID="2">
          <fptr EndPN="00000159" StartPN="00000158"/>
        </Paragraph>
        <Picture URL="00000159\00000159_new\0002.jpg">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Picture>
        <Paragraph CONTEXT="苗$Picture[00000159\00000159_new\0005.jpg]Picture$加的这个有着某种意义的实数，称为该结点的权（weight)。结点的带权路径长度是从树根结点到该结点之间的路径长度与该结点上权的乘积.&lt;3)树的带权路径长度" ID="3">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="树的带权路径长度定义为树中所有叶子结点的带权路径长度之和，通常记为：" ID="4">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="n,Wklt" ID="5">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）哈夫受树假设有n个权值（w：，wz，w。}，每个权值赋给一个叶子，可以构造出多棵含n个叶子结点的二叉树。其中，必存在一棵其带权路径长度WPL取最小值的二叉树，称为最优二叉树。因为构造这种树的算法最早是哈夫曼于1952年提出来的，所以被称为哈夫受树（HuffmanTree),例如，有叶子结点a,b,c,d，分别带权为5,4,7,2，构成三棵不同的二叉树（当然还可有其他形状的二叉树），如图6.33所示。每棵二叉树的带权路径长度WPL分别为：忘©WPL=4X3-2X35X2-7X1=35" ID="6">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="其中，图6.33(c）二叉树的WPL最小，而满二叉树或完全二叉树不一定是最优二叉树。" ID="7">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="直观地看，权值越大的结点离根越近的二叉树才是最优二叉树。稍后可以验证图6.33(c）所示的二叉树是最优二叉树。$Picture[00000159\00000159_new\0032.jpg]Picture$$Picture[00000159\00000159_new\0033.jpg]Picture$$Picture[00000159\00000159_new\0034.jpg]Picture$148" ID="8">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="148" TITLE="6.6.2 构造哈夫曼树" TYPE="Chapter">
        <fptr LogicalPageNum="160" PhysicalPageNum="160"/>
        <Paragraph CONTEXT="如何构造哈夫曼树？D.A.Huffman最早研究出一个带有一般规律的构造算法，俗称哈夫曼算法，其基本思想是让权值最大的叶子离根最近。构造方法如下：”由给定的n个权值｛wi,wZ。}，构造n棵扩充二叉树的集合F二｛T、，TZT。其中每棵扩充二叉树中均只含一个带权值w、的根结点，其左、右子树均为空；" ID="1">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="2）重复下列步骤，直到F中只含一棵树为止：在F中选取其根结点的权值为最小的两棵扩充二叉树，分别作为左、右子树构造一棵新的二叉树，并置这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和；从F中删去这两棵树，同时加入刚生成的新树；" ID="2">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="3)按上述步骤得到的二叉树就是哈夫曼树。例如，设给定的权值集合为（5,4,7,2}，构造哈夫曼树的过程如图6.34所示。首先构造每棵树只有一个结点的森林，如图6.34&lt;a)所示；然后每次选择两个根结点权值最小的二叉树，以它们为左、右子树构造新的二叉树，步骤参看图6.34（b），（。）和（d)，最后得到一棵扩充二叉树。图中带权外结点用小矩形框表示，内结点用小圆框表示。(a）初始（b）合并树｛24｝后（。）合并树（56｝后（d）合并树｛711｝后哈夫曼树是一棵严格二叉树（即每个非叶子结点均有两个孩子）。一棵有n个叶子结点的哈夫曼树共有2n-1个结点，可以用一个大小为2n-1的一维数组存储。每个结点设有存放权值的数据域，以及两个指针域，分别指示该结点的左、右孩子结点在数组中的下标。哈夫曼树的类型定义为：typedefstruct{" ID="3">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Picture URL="00000160\00000160_new\0027.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Paragraph CONTEXT="intweight;" ID="4">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="intIchild,rchild;" ID="5">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="}HTNode" ID="6">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Picture URL="00000160\00000160_new\0031.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Paragraph CONTEXT="typedefstruct{" ID="7">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Picture URL="00000160\00000160_new\0033.jpg">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Picture>
        <Paragraph CONTEXT="HTNode*HTree;" ID="8">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="introot;" ID="9">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="10">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT=")HuffmanTree;" ID="11">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="t构造哈夫曼树的算法如下：算法6.16voidCreateHTree(HuffmanTree&amp;HT,int*w,intnw存放n个叶子结点的权值，构造哈夫曼树HT＊/if(nG=二1)return;" ID="12">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="m=2关n-1;HT.HTreeHTNode二）malloc(m，sizeof&lt;HTNode;/／为哈夫曼树分配一组顺序空间for&lt;p二HT.HTree,i二l;in；井i，什P，什w)n个带权结点形成初始化的森林fori&lt;m;斗十户i，朴P)/／对尚未使用的结点赋初值for(i二n;i&lt;m；什i){/／建哈夫曼树Select(HT.HTree,i-l,si,sz／在HT.HTree[0…i-11前可选的结点中选择权HT.HTree[iI.(child=sHT.NTree[iI.rchild=sz;／／取左右子树根结点权值之和" ID="13">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="HT.root=m-1;｝" ID="15">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="150" TITLE="6.6.3 哈夫曼树的应用" TYPE="Chapter">
        <fptr LogicalPageNum="161" PhysicalPageNum="161"/>
        <Paragraph CONTEXT="哈夫曼树的应用十分广泛，在不同的应用中，对叶子结点的权和带权路径长度有不同的解释。哈夫曼树的应用之一是用于优化判断过程，利用哈夫曼树得到最佳判定算法。例如，将百1魂吞大岛姗了妞翻1的怕.七卜且点要w怕.盈ta苗口理此,i田；‘i叁fjUG»P@Ile了分制转换成五级制的算法。if(x&lt;60)" ID="1">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="score=’不及格‘；" ID="2">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="elseif(x&lt;70)" ID="3">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="score=‘及格‘；" ID="4">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="elseif(x&lt;80)" ID="5">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="score=‘中’；" ID="6">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="elseif(x&lt;90)" ID="7">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="score=‘良’；" ID="8">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="score=’优，；，此判定过程可以用图6.35(a)的判定树来表示。如果学生规模很大，该算法需反复多次执行，就应该考虑算法执行的时间问题。在实际应用中，学生的成绩呈正态分布，大部分在70-89分之间，优秀和不及格的概率较小。假设不及格、及格、中、良、优的百分比为51240358°0，则上述算法80％以上的成绩需要进行三次或三次以上的比较才能得到结果。若以这些百分比值5,12,40,35,8为权值，使用哈夫曼算法来构造一棵判定树，则得到图6.35&lt;b)所示的判定过程，可使多数成绩经过较少的比较即可得到结果。但由于每个判定框都有两次比较，将两次比较分开，得到如图6.35(c）所示的判定树，按此判定树构造程序，显然可以大大减少比较次数。" ID="9">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.35百分制转换五级制的判定过程哈夫曼树在通信、编码和数据压缩等技术领域也有着广泛的应用。下面介绍哈夫曼树在月粉i俘拍x山的r田9nlifri甲8t拐r,n,s.召白xnr且面在数据通信中，需要将传送的文字转换成二进制的字符申，用。,1码的不同排列来表示字符。例如，需传送的报文为“AFTERDATAEARAREARTAREA&quot;，这里用到的字符集为“A,E;RT,F,D&quot;，各字母出现的次数为｛8,4,5,3,1,1现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000,001,010,011,100,101对“A,E,R,T,F,D”进行编码发送，当对方接收报文时再按照三位一分$Picture[00000162\00000162_new\0021.jpg]Picture$$Picture[00000162\00000162_new\0022.jpg]Picture$进行译码。显然编码的长度取决报文中不同字符的个数。若报文中可能出现26个不同字符，则固定编码长度为5。然而，传送报文时总是希望总长度尽可能短。在实际应用中，各个字符$Picture[00000162\00000162_new\0025.jpg]Picture$数据结构编码时，让使用频率高的用短码，使用频率低的用长码，以优化整个报文编码.但这样长短不等的编码又会产生一个新问题，即如何解译成原文？除非设计时能够保证任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀，符合此要求的编码称为前缀编码。为使不等长编码为前缀编码，可用字符集中的每个字符作为叶子结点生成一棵编码二叉树。为了获得传送报文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，求出此树的最小带权路径长度就等于求出了传送报文的最短长度。因此，求传送报文的最短长度问题转化为求由字符集中的所有字符作为叶子结点，由字符出现频率作为其权值所产生的哈夫曼树的间题。利用哈夫曼树来设计二进制的前缀编码，既满足前缀编码的条件，又能保证报文编码总长最短.用上述各字母出现的次数（8,4,5,3,1,1}作为权构造哈夫曼树，如图6.36所示。约定左分支表示字符“0&quot;，右分支表示字符“1&quot;，则可以从根结点到叶子结点的路径的分支上的字符组成的字符串作为该叶子对应字符的编码。可以证明，如此得到的必为二进制前缀编码，而且是本例中字母A,E,R,T,F,D的哈夫曼编码分别为11,00,01,011,0100,0101。可以看出，出现次的编码，长度均为4。报文的最短传送长度为：L-WPL=艺(walk）一4X2+5X2+8X23X3-1X4-1X4-51若采用等长编码，报文的传送长度为：显然，哈夫曼编码比等长编码所得到的报文长度要短得多.哈夫曼编码是最优前缀编码。图6.36哈夫曼编码树一个任意长度的编码序列可被惟一地翻译为一个字符序列（单词）。依次取出编码序列中曼树的根结点处，依次译出余下的字符，最后得到一个单词。" ID="10">
          <fptr EndPN="00000163" StartPN="00000162"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="哈夫曼树（HuffmanTree)，又称最优二叉树，是带权路径长度最短的二叉树.在实际应用中，路径长度是一个重要概念，特别是在涉及算法分析和数据编码中。因此，首先讨论路径长度及相关概念。" ID="1">
        <fptr EndPN="00000158" StartPN="00000158"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="152" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="163" PhysicalPageNum="163"/>
      <Paragraph CONTEXT="和二叉树是两种不同的树型结构，二叉树并非树的特例，请注意二叉树与度为2的树的区别。树和二叉树的递归定义是这两种数据结构的逻辑特点，也是本章构建递归算法的思想基础或递归模型，要求读者理解好。二叉树具有许多良好的性质。熟练掌握二叉树的结构特性，了解相应的证明方法，特别是性质3的证明方法，务必掌握。从两个不同的角度来分析分支数B与结点总数n的关系，是解决有关结点数的问题的关键。二叉树的存储结构有顺序存储结构（一维数组、结构数组两种）和链式存储结构（二叉链表、三叉链表等），它们具有不同的结构特点和适用范围。用一维数组存储完全二叉树是利用完全二叉树的性质5来进行的，具有较好的存储密度，对结点的访问、求双亲结点、求左右孩子结点都非常方便。但对于一般的二叉树，必须对照完全二叉树的编号进行相应的顺序存储，对于n个结点深度为H的二叉树需要m个存储单元，其中：2&quot;一’&lt;m（2“一1。最坏的情况是一个深度为H且只有H个结点的单支树也需要占2H-1个结点的存储空间。而且，这种存储结构在插人或删除结点时需要移动其他数据元素方可完成。而结构数组存储二叉树的方式改善了一维数组存储二叉树中插人或删除结点需要移动大量数据的问题。在实际应用中，通常用二叉链表作为二叉树的存储结构。遍历二叉树是二叉树各种操作的基础。实现二叉树遍历的具体算法与所采用的存储结构有关。不仅要熟练掌握各种遍历策略的递归和非递归算法，了解遍历过程中“栈”的作用和状态，而且能灵活运用遍历算法实现二叉树的其他操作。二叉树线索化的实质是建立结点与其在相应序列中的前驱或后继之间的直接联系，熟练掌握二叉树的线索化过程以及在中序线索化树上找给定结点的前驱或后继的方法。二叉树的线索化过程是基于对二叉树进行遍历，而线索二叉树的线索又为相应的遍历提供了方便。熟悉树的各种存储结构及其特点，掌握树和森林与二叉树的转换方法。建立存储结构是进行其他操作的前提，因此读者至少应掌握1-2种建立二叉树和树的存储结构的方法。为。和度为2的二叉树。熟悉哈夫曼算法思想，掌握建立哈夫曼树和哈夫曼编码的方法。" ID="1">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="153" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="164" PhysicalPageNum="164"/>
      <Paragraph CONTEXT="6.1对于图6.3？所示的树，请回答以下问题：①从图中找出树的根结点、叶子结点、分支结点；②从图中找出结点H的双亲、祖先，结点F的孩子、子孙，结点E的兄弟、堂兄弟；③树的度是多少？各个结点的度是多少？" ID="1">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="④树的高度是多少？结点I,E的层数是多少？以结点F为根的子树的高度是多" ID="2">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="少？" ID="3">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="6.2画出下列广义表表示的树，并说明树的高度。" ID="4">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构" ID="5">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Picture URL="00000165\00000165_new\0006.jpg">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Picture>
      <Paragraph CONTEXT="6.已知一棵度为k的树中有n，个度为1的结点，nZ个度为2的结点，…,n、个度为1的结点，问该树中有多少个叶子结点？多少个分支结点？6.5一棵含有n个结点的k叉树，可能达到的最大深度和最小深度分别是多少？两种情况下分别有多少叶子和多少分支结点？6.6已知一棵具有n个结点的完全二叉树被顺序存储于一维数组的A[11A[n]元素中，试编写一个算法打印出编号为i的结点的双亲和所有孩子。6.7已知一棵二叉树如图6.38所示，试分别画出它的一维数组存储结构、结构数组存储结构以及二叉链表存储结构。6.8写出对图6.38所示的二叉树分别按前序、中序、后序遍历时得到的结点序列。6.9找出所有满足下列条件的二叉树：①它们在先序遍历和中序遍历时，得到的结点访问序列相同；②它们在后序遍历和中序遍历时，得到的结点访问序列担同；③它们在先序遍历和后序遍历时，得到的结点访问序列相同。6.10通过算法证明，中序和后序序列可以惟一确定一棵二叉树。6.116.12假定用两个一维数组L【卜二n〕和R【卜。·n〕作为n个结点的二叉树的存储结构，是否为结点v的子孙。6.13编写递归算法，求在二叉树前序序列中处于第k个位置上的结点。6.14编写递归算法，分别计算二叉树的结点和叶子的数目。6.1S编写递归算法，计算二叉链表中某一结点所在的层数.6.16编写递归算法，将二叉树中所有结点的左、右子树相互交换。$Picture[00000165\00000165_new\0030.jpg]Picture$6.17编写递归算法，求二叉树中以元素值为x的结点为根的子树的深度。" ID="6">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="6.18编写复制一棵二叉树的非递归算法。" ID="7">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="6.”编写按层次顺序（同一层自左至右）遍历二叉树的算法。6.20编写一个算法，输出以二叉树表示的算术表达式，若该表达式中含有括号，则在输出时应添上。6.21对图6.38所示的二叉树，试分别画出其前序、中序、后序线索二叉树。6.22请将图6.38所示的二叉树转换成森林。6.23将下列图6.39所示的森林转化为相应的二叉树，并分别按以下说明进行线索化：①先序前驱线索化；" ID="8">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="②中序全线索化；" ID="9">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="③后序后继线索化。" ID="10">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="(a)(b)(。)（d)6.24对图6.39(a）所示的树：①写出前序、后序遍历得到的结点序列；②写出按层遍历得到的结点序列；$Picture[00000166\00000166_new\0018.jpg]Picture$③画出转换后得到的二叉树和二叉链表.6.25数据通信中，字符dl，d2,d。，d4,ds,d6,d，，d。出现的频率为2,3,7,13,19,29,17,8,$Picture[00000166\00000166_new\0021.jpg]Picture$请构造一个Huffman编码树，给出各个字符的二进制编码。" ID="11">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="7" ID="12">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT="第1章" ID="13">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT="图分闷哆晒脚斌乡戮多卿豁妙塔滚顺谁闷田戳卿绷腆妙，叩用李峨箩蛇留螂娜沙脚多螂职螂职绷多晚曰那明吵月娜纯沙潮哪谬卿诚沙娜娜螃湘净，邪周沙液派只邪朔邓瞬贬脚孽落冷蔽沙汹图是比线性表和树更为复杂的一种数据结构。在线性表中，数据元素之间存在线性关系，每个数据元素只有一个前驱和一个后继。在树型结构中，数据元素（结点）之间有明显的层次关系，一个数据元素（结点）可以和其下层多个数据元素（孩子结点）相联系，但只能和其上层的一个数据元素（双亲结点）相联系。而图中数据元素之间的关系是任意的，任意两个元素之间都可能相邻。可，以说线性表和树是受限图，因此，从某种意义上说，图是最基本、最常用的数据结构。图被广泛应用于模拟真实事件或抽象问题，下面是用图来解决的几类主要问题：①表示一张地图的一组坐标以及坐标之间的距离，以求得最短路径；②模拟计算机与通信网络的联接；" ID="14">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT="③模拟交通网络的流量；④为复杂活动的各子任务的完成寻找较优顺序，如大型建筑的构造、课程安排、工程计划等；⑤模拟家庭、商业活动和自然科学中动植物分类中的各种关系、印刷电路板的布局布线等." ID="15">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT="可以说，在所有的数据结构中，图的应用最广泛。本章内容安排如下：第7.1节首先给出图的定义和一些术语；第7.2节介绍图的4种存储结构：邻接矩阵、邻接表、十字链表和邻接多重表；第7.3节介绍两种最常用的图的遍历算法：深度优先搜索和广度优先搜索；第7.4节给出了图的一些应用，主要有：①图的连通性和寻找最小生成树的算法，这对于确定网络联接的最小代价很有价值；②可用来解决先决条件间题的拓扑排序；③寻找最短路径问题。" ID="16">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="卿召滋翻邵咽脚橄脚俄娜鱿娜卿留酬在前面几章中，主要讨论了线性表、栈、队列、数组和串等线性数据结构。而许多问题是不能或难以用线性结构表示的，如各种社会组织机构、人类家族的分支等是一种层次结构，而非线性结构。基于这一点，有必要研究非线性结构。树型结构就是一种应用十分广泛和重要的非线性结构，其中以树和二叉树最为常用。直观上看，树是一种以分支关系定义的层次结构，因此它为计算机应用中出现的具有层次关系或分支关系的数据提供了一种自然表示方法。" ID="1">
      <fptr EndPN="00000124" StartPN="00000124"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="156" TITLE="第7章 图" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="156" TITLE="7.1 图的定义和术语" TYPE="Chapter">
      <fptr LogicalPageNum="167" PhysicalPageNum="167"/>
      <Paragraph CONTEXT="圈（Graph）可看成是由两个集合组成：一个是有限、非空的顶点集合，另一个是由顶点的偶对所组成的集合，这些偶对称之为边.可以用G＝（V，E）表示一个图，V（G）和E（G）分别表示图G的顶点集合和边集合。如果图中的边限定为从一个顶点指向另一个顶点，则此图称为有向图（DigraPh）。如果图的边无方向性，则称之为无向图（UndigraPh）。一条边所连接的顶点是相邻的，称为相邻顶点。连接一对相邻顶点u，v的边被称为与顶点u和v相关联的边。在有向图中，与顶点u和156‘v相关联的边记作（u,vu称为该边的尾（Tail),v称为该边的头（Head)。所以，(u,v)和＜v,u)代表两条不同的边。在无向图中，与u和v相关联的边记作（u,v)。由于无向图的边无方向，所以，与u和v相关联的边也可记作（v,u" ID="1">
        <fptr EndPN="00000168" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT="图7.1(a)中的G；是无向图，其顶点集和边集分别为：V(G0,1,2,3E(GI)0,10,20,31,21,32,3图7.1(b）中的G：是有向图，其顶点集和边集分别为：V(GZ)_{0,1,2,3,4E(GZ)_0,1&lt;0,4&lt;1,2&lt;2,3&lt;3,4&lt;4,1" ID="2">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="令（a)(h)(c)(d)(a)一个完全无向图G,(b&gt;一个有向图Gz(c）一个带权图G,(d）一空完全有向图G,有时图中的每条边可能附有一个值，称为边的权（Weight)。边上附有权的图称为带权图，如图7.1(c）所示图G,。带权图的应用极为广泛，例如，可用带权图表示一个城市的交通网络，顶点表示城市，边上的权可以表示从一个城市到另一个城市的距离或乘车所需要的时间等。$Picture[00000168\00000168_new\0018.jpg]Picture$$Picture[00000168\00000168_new\0019.jpg]Picture$$Picture[00000168\00000168_new\0020.jpg]Picture$在一个具有n个顶点的无向图中，边的数目至多为n(n-12，这是任何n个顶点的无向图中的最大边数。一个n个顶点有n(n-12条边的无向图，称为完全无向圈，如图7.1(a)中的G；所示。n个顶点的完全有向圈恰好有n(n-1)条边，如图7.1(d)中的G,所示。在图中，从顶点Vp到顶点Vy的一条路径是顶点Vp,Vll,VyVm,V，的一个序列，使得（Vp,Vl1)f(VA,Vi2f(YinfV9）都是图中的边。一条路径的长度也就是这条路径上边的数目。如果路径上各顶点均不相同，则称此路径为简单路径.如果一条路径将某个顶点连接到它本身，且其长度大于等于3，则称此路径为回路。在7.1所示图G：中，从顶点。到顶点2存在一条包括顶点0，顶点1和顶点2的简单路径。顶点1,2,3,4再到顶点1构成一个简单回路。顶点的度（Degree)是与该顶点相关联边的数目。对有向图，我们把一个顶点v的入度&lt;Indegree）定义为以v为头的边的数目，出度（Outdegree）定义为以v为尾的边的数目。顶点v的人度和出度之和称为顶点v的度。在7.1所示图GZ中，顶点1的人度为2，出度为1图G的子圈GSubgraph）是指由G中选出其顶点集的一个子集V&lt;G（即V(GCV(G）以及与V(G'）中顶点相关联的一些边所构成的图）。如图7.2所示是一些子图的示例。如果一个无向图中任意一个顶点到其他顶点都至少存在一条路径，则称此无向图为连通的。无向图的最大连通子图称为连通分f，图7.2给出了一个有三个连通分量的无向图示例。在有向图中，对于每一对不同顶点u,v，若从u到v和从v到u都存在路径，则称此有向图是强连通图。有向图中最大强连通子图称为有向图的强连通分量。图7.3给出了一个有两数据结构" ID="3">
        <fptr EndPN="00000169" StartPN="00000168"/>
      </Paragraph>
      <Picture URL="00000169\00000169_new\0002.jpg">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Picture>
      <Picture URL="00000169\00000169_new\0009.jpg">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Picture>
    </div>
      <div ORDERLABEL="158" TITLE="7.2 图的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="169" PhysicalPageNum="169"/>
        <div ORDERLABEL="158" TITLE="7.2.1 邻接矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="169" PhysicalPageNum="169"/>
        <Paragraph CONTEXT="所谓邻接矩阵就是用一维数组存储图中顶点信息，用二维数组表示图中顶点之间的相邻关系。设G二（V,E）是，个具有n个顶点的图（n,l)，各顶点依次标记为vo,vl,vZv。一：，G的邻接矩阵是一个nXn矩阵。如果从顶点v。到顶点v，存在一条边，则矩阵的第i行的第l个元素标记为1，否则标记为。。图7.4(b)和图7.5&lt;b)是邻接矩阵的图示。息.在这种情况下，可以用。到n-1作为图中顶点的编号.图的邻接矩阵存储结构可简单地用一个二维数组来表示，其C语言描述形式如下：intmatrix[nn邻接矩阵可用于存储有向图和无向图。我们可以很容易地从邻接矩阵判断任意两个顶点" ID="1">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="是否相邻，求一个顶点的度也很方便。对于无向图，顶点v.的度是对应矩阵中第i行或第i列$Picture[00000170\00000170_new\0002.jpg]Picture$$Picture[00000170\00000170_new\0006.jpg]Picture$(c)图7.4无向图的存储结构表示方法(a）一个无向图（(b）为（a)所示图的邻接矩阵（。）为（(a）所示图的邻接表从邻接矩阵的定义及图7.4(b)和图7.5(b)所示的邻接矩阵可知，无向图的邻接矩阵是对称矩阵。因此，可采用4.2节介绍的矩阵压缩存储方法把邻接矩阵的上三角部分或下三角部分存储起来即可，空间复杂性为O(n(n-12)。对于有向图，由于图中的边具有方向性，所" ID="2">
          <fptr EndPN="00000170" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="以有向图的邻接矩阵通常是一个非对称矩阵。对有n个顶点的有向图来说，其邻接矩阵的空间复杂性为O(nz)" ID="3">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="159" TITLE="7.2.2 邻接表" TYPE="Chapter">
        <fptr LogicalPageNum="170" PhysicalPageNum="170"/>
        <Paragraph CONTEXT="邻接表是一个以链表为元素的数组。在图的邻接表存储结构中，对图的每个顶点建立一个单链表，第i个单链表中的各结点（称为表结点）代表与顶点i相邻的顶点。每个表结点至少有两个域：vertex和next,vertex域表示与顶点i相邻的顶点在图中的序号，next是指向与顶点i相邻的下一个顶点的指针。为了方便地随机存取任何一个顶点的邻接表，将每个顶点的链表的头指·存人一个一维数组中，如图7.4(c）和图7.5(c）所示。图的邻接表存储结构的C语言描述形式如下：" ID="1">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="structnode/，表结点类型说明，／" ID="2">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="3">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="intvertex;structnode补next;｝；structnodeadjlist[n/‘存放单链表头指针的一维数组，n为图中顶点个数，／数据结构$Picture[00000171\00000171_new\0007.jpg]Picture$$Picture[00000171\00000171_new\0008.jpg]Picture$$Picture[00000171\00000171_new\0016.jpg]Picture$$Picture[00000171\00000171_new\0017.jpg]Picture$比较复杂，需要对整个邻接表扫描一遍。在所有链表中其邻接顶点域的值为1的结点个数是顶点1的人度。为了方便起见，可为有向图建立一个逆邻接表，即为每个顶点V。建立一个以V,为始端的链表，这样，从逆邻接表求每个顶点的人度就方便多了，只要计算相应邻接表的结点数即可。图7.5(a）所示有向图的逆邻接表如图7.5(d)所示。对于有n个顶点和e条边的无向图，邻接表需要n个头结点和2e个表结点.对于有向图，则需要n个头结点和e个表结点。" ID="4">
          <fptr EndPN="00000171" StartPN="00000170"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="160" TITLE="7.2.3 十字链表" TYPE="Chapter">
        <fptr LogicalPageNum="171" PhysicalPageNum="171"/>
        <Paragraph CONTEXT="十字链表是有向图的另一种链式存储结构，可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链接表示。在十字链表中，对应于图的每一条有向边有一个结点，结点结构i；二小…Ihli一’1tli一｝tvex和hvex分别表示有向边的两个顶点，blink是指向以hvex为头的下一条边的指针，tlink指向以tvex为尾的下一条有向边的指针。指向以该顶点为末端的第一条边和以该顶点为始端的第一条边的指针存储在一维数组中。图7.5(a)所示有向图的十字链表存储结构表示如图7.6所在十字链表中既容易找到以顶点v。为末端的边，也容易找到以巩为始端的边，因而很容易求得顶点的人度与出度。在某些有向图的应用中，十字链表是一种很有效的存储结构。一戴斗不厂一4一已一二洲二匕上且剑‘～－－～一～－－－－－－－一一图7.s有向图的十字链表示例" ID="1">
          <fptr EndPN="00000172" StartPN="00000171"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="161" TITLE="7.2.4 邻接多重表" TYPE="Chapter">
        <fptr LogicalPageNum="172" PhysicalPageNum="172"/>
        <Paragraph CONTEXT="邻接多重表是无向图的另一种链式存储结构。在无向图的邻接表中，每一条边（vv）有两个结点，分别在第i个链表和第l个链表中。在进行图的一些运算时，常常需要给被处理过一个链表中，操作很不方便。如果用邻接多重表表示一个无向图，处理上述问题就容易得多。在邻接多重表中，无向图的每条边用一个结点表示，结点结构为：" ID="1">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="i。二‘'’Iwex一’i一｛jlink'I其中mark标记1边是否被访问过，ivex与jvex表示该边的两个顶点，ilink指向下一条与顶" ID="2">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="点ivex相关联的边，jlink指向下一条与顶点jvex相关联的边。与邻接表相同，指向与该顶点" ID="3">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="相关联的第一条边的指针也存储在一维数组中。图7.7是图7.4(a)所示无向图的邻接多重" ID="4">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="表的表示方法。" ID="5">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="n23图7.7无向图的邻接多重表示例在邻接多重表中，表示边的结点同时被链接到该边的两个顶点的链表中，起到邻接表中两$Picture[00000172\00000172_new\0017.jpg]Picture$个结点的作用。因此邻接表与邻接多重表的区别，仅在于同一条边在邻接多重表中用一个结数据结构可将矩阵元素的值改为权值。如使用邻接表、十字链表和邻接多重表，则可在表结点中增加一个字段，把权值存储在该字段中." ID="6">
          <fptr EndPN="00000173" StartPN="00000172"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="从图的定义可知，图由两部分组成：一部分是顶点，另一部分是顶点与顶点之间的关系―边。因此图的存储绩构要完整、准确地反映这两部分的信息。下面介绍图常用的4种存" ID="1">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Paragraph>
      <Paragraph CONTEXT="储结构：邻接矩阵、邻接表、十字链表和邻接多重表。具体选用哪一种存储结构，则要看对图进行何种操作和图的具体应用。" ID="2">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="162" TITLE="7.3 图的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="173" PhysicalPageNum="173"/>
        <div ORDERLABEL="162" TITLE="7.3.1 深度优先搜索" TYPE="Chapter">
        <fptr LogicalPageNum="173" PhysicalPageNum="173"/>
        <Paragraph CONTEXT="图的深度优先搜索DFS(DepthFirstSearch)是按下面方法对图的顶点进行访问的。首先访问出发顶点v；接着，选择一个与v相邻、且未曾访问过的顶点w；然后从w出发访问w的一个未被访问的相邻顶点x，然后从x出发，访问x的一个未被访问的相邻顶点，…，如此进行下去。当到达一个其所有相邻顶点都已被访问过的顶点时，就退回一步到前一个顶点，看它是否还有未被访问过的相邻顶点，如果有，则访问此顶点后再从该顶点出发进行与前述类似的访阿。如果退回一步后前一个顶点也无未被访问过的相邻顶点，则再回退一步进行搜索，重复上述过程，一直到所有顶点均被访问过为止。162之后，下一个要访问的是顶点。的相邻顶点。与顶点0相邻的顶点有1和4且均未被访问过，可任意选取一个。假定选择顶点1，访问顶点1，接着应访问顶点1的相邻顶点。因为顶点1的相邻顶点有。,2和5，顶点0已访问过，不再考虑。在顶点2和J之间选择一个，假设选择顶点2，同样访问过顶点2之后，下一个访问顶点是3或5，选择3并访问之。在访问过顶点3之后，由于顶点3的相邻顶点只有顶点2，而且已被访问过，根据深度优先搜索的原则，应退回到顶点2，看顶点2是否还有未访问过的顶点.由于顶点2还有一个顶点5未被访问，因此，访问之，最后访问顶点5的相邻顶点4。根据深度优先搜索原则，在访问完顶点4之后，图中全部顶点访问完毕，访问顶点顺序为0,1,2,3,5,4,图7.8图的示例适用。假设matrix和adjlist分别表示图G的邻接矩阵和邻接表.visited为保存顶点访问标记的数组，visited[i]=0表示图中第i个顶点未被访问过，visited[i]=1表示图中第i个顶点已被访问过。下面分别以邻接矩阵和邻接表作为图的存储结构，给出相应的深度优先搜索算法的C语言实现。算法7.1" ID="1">
          <fptr EndPN="00000174" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="voidDFS&lt;inti)" ID="2">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="／二从顶点i开始对图进行深度优先搜索遍历，matrix表示图的邻接矩阵二／｛visit(i);/＊访问顶点ivisited[i]=1;/，置访间过标记、，／for(j=0;j&lt;n;jam)/，对所有与i格邻接的顶点‘／｛ifvisited[j]0)(matrix[ijDFS&lt;j" ID="3">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Picture URL="00000174\00000174_new\0028.jpg">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Picture>
        <Paragraph CONTEXT="｝" ID="4">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="算法7.2" ID="5">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="voidDFS(inti)" ID="6">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="／，从顶点i开始对图进行深度优先搜索遍历，图由邻接表adjlist表示关／｛visit(i／二访问顶点ivisited[i]=1;/，置访问过标记‘／·163数据结构p=adjlist[i/*p为顶点i的链表头指针‘／while(p!=NULL){/＊对所有与i相邻接的顶点‘／]=P一）vertex;if(visited[j]0)P=P一＞next;｝" ID="7">
          <fptr EndPN="00000175" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="｝分析上述算法，在遍历图时，对图中每个顶点至多调用一次DFS函数。因为一旦某个顶点被标记为已访问过，就不再从它出发进行搜索.因此遍历图的过程实质上是对每个顶点查若图由邻接表表示，对图在进行教土仑习r妻矛圈Ffr4Zfk`r油壹uC'Ip-I.'Iwl''松'l(、(n-fin)田教注拓陇毒录＿欣1确宁研右若图用邻接矩阵表示，则确定所有与v相邻接的顶点需要O(n)时间。由于最多访问n个顶点，故时间复杂性为（n2)a深度优先搜索过程也可以写成非递归形式，此时需借助一个栈。设栈由一个一维数组构" ID="8">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="成，数组名为s，栈顶指针为top。进栈函数为push，出栈函数为pop，判断栈空函数为isEmp-" ID="9">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="力匡主J压奎会口翻交」一x冶些d身命J庵a月配1石1.自去二tJ'3F二.FL'.t匕:3FKbftJk:Etk1:F习i;2Sq日JEr.ty。算法7.3" ID="10">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="voidDFS（1）" ID="11">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="／，从顶点1开始对图进行深度优先搜索遍历，图由其邻接表adjhst表示，／" ID="12">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="13">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="visit（1）；visited〔1〕＝1；p＝adjlist［ij；" ID="14">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="do｛" ID="15">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="while（P！＝NULL）｛" ID="16">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="if（visited〔p一.仁＞vertexj＝＝0）｛" ID="17">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="j＝pes－－：＞vertex；" ID="18">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="visited［j］令1；visit（1）；" ID="19">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="Push（5，P）" ID="20">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="p＝adjlist［j〕；｝elseP“P一它＞next；｝PoP（5，P）；" ID="21">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="P＝p一＞next；" ID="22">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="165" TITLE="7.3.2 广度优先搜索" TYPE="Chapter">
        <fptr LogicalPageNum="176" PhysicalPageNum="176"/>
        <Paragraph CONTEXT="广度优先搜索的过程如下：首先访问出发顶点v，并将它标记为已访问过。它与深度优先搜索不同之处在于，下一步访间的是所有与v相邻的顶点wl,wz，然后再顺序访间wi,wZ,…，到各个顶点的所有相邻顶点。当然，已被访问过的顶点则不再被访问，如此做下去，直到所有顶点均被访问过为止。对于图7.8所示的无向图，若从顶点。出发进行广度优先搜索遍历，则首先访问顶点0，接着访问与顶点0相邻的全部顶点1和4，然后访问与顶点1相邻的全部顶点2和5，下一个访问的顶点是与顶点4相邻的全部顶点，…，最后访问顶点3是与顶点2相邻的顶点。顶点访问顺序是0,1,4,2,5.3,根据广度优先搜索规则，很容易写出它的实现算法。与深度优先搜索相同，在进行广度优先搜索时，也需要设置一个标记数组visited，用于标记图中各顶点是否被访问过。此外，还需要借助一个队列，用以存储已被访问过的顶点。广度优先搜索算法的基本思想是：从出发顶点开始，每访问一个顶点，就将其人队，然后从队列取出一个顶点，访问该顶点的所有未被访问的相邻顶点，如此下去，当队列为空时，图中所有由出发顶点能到达的顶点均已被访问过。设队列为q，队头指针为front，队尾指针为rear。人队函数为EnQueue，出队函数是DelQueue，判断队空函数为isEmpty。假设队列足够大，不考虑溢出的可能。下面给出广度优先搜索算法的一种实现：" ID="1">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="算法7.4" ID="2">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="voidBFS(inti)" ID="3">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="｛front=0;/，初始化队头与队尾指针‘／rear=0;visit(i);/，访问顶点ivisited〔1〕＝1；／，置访问过标记，／E乒Queue（q，1）；／‘顶点i人队‘／do{v＝DeQueue（q）；／，从队列中取出一个顶点‘／P=while(p!=NULL)/‘访问顶点v的所有相邻顶点二／｛if(visite谁[p一＞vertex〕二＝0){j=P一）vertex;｝" ID="4">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一＞next;" ID="5">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="7">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="}while(stackempty(q;" ID="8">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="）与图的深度优先搜索遍历‘样，对于图的广度优先搜索遍历，若用邻接矩阵表示图，时间复杂性为O(nZ)。若图由邻接表表示，则时间复杂性为O(n+e),需要说明的是，不论采用深度优先搜索还是广度优先搜索对图进行遍历，如果选定的出发点不同，或者所建立的存储结构不一样，则遍历结果可能不同。" ID="9">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="有些问题要求以特定的顺序依次访问图中各个顶点，这种访问称为图的遍历。从概念上讲图的遍历与树的遍历是类似的。我们回顾一下，二叉树的遍历是指以某种特定的顺序，如先根遍历、中根遍历和后根遍历，对每个结点恰好访问一次。图的遍历也存在类似的顺序，而且每种顺序适用于解决某些特定的问题。按照遍历时访问相邻顶点的顺序，图的遍历有深度优先搜索和广度优先搜索两种。对每种搜索顺序，访问各顶点的先后顺序也不是惟一的。在图的遍历过程中，必须处理两个问题。首先，从一个顶点出发可能到达不了图中所有其他顶点，非连通图就可能发生这种情况。其次，有些图存在回路，我们必须确定算法不会因回路而陷人死循环。历开始时，所有顶点的标记位清零。在遍历过程中，当某个顶点v：被访问时，其标记位被标记(visited[i]=1)。如果在遍历过程中遇到被标记过的顶点，则不再访问它，这样就避免了回路问题。遍历算法一结束，我们就可以通过检查标记位数组来查看是否已处理了图中所有顶点。如果还有顶点未被标记，我们可以从某个未被标记的顶点开始继续遍历。这样，非连通图的遍历就得到了解决。图的遍历过程可用C语言描述为：voidgrapkt二verseEintn){inti;" ID="1">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i=0;i&lt;n;i十十）visited[i]=0;" ID="2">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="for&lt;i=0;i&lt;n;i＋十）" ID="3">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="if(visited[i]（二0)" ID="4">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="do-traverse(i);" ID="5">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="其中“do＿traverse(i)”过程可以由下面介绍的深度优先或广度优先搜索方式代替。" ID="6">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="166" TITLE="7.4 图的应用" TYPE="Chapter">
      <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
        <div ORDERLABEL="166" TITLE="7.4.1 图的连通性" TYPE="Chapter">
        <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
        <Paragraph CONTEXT="在对无向图进行遍历时，对于连通图，只要从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图的所有顶点。对非连通图，则只能够访问到出发顶点所在连通分量中的所有顶点，其他连通分量中的顶点是不可能访问到的。为了求一个图的所有连通分量，只要反复调用DFS(v)或BFS(v)即可，其中v是一个尚未访问的顶点。求无向图的所有连通分量的C语言实现如下：" ID="1">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="算法7.5" ID="2">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="voidcomp(intn)" ID="3">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="4">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=O;i&lt;n;i十十）" ID="5">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=O;i&lt;n;i＋十）" ID="6">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="｝上述算法使用DFS，当然也可采用BFS。对于有向图来说，深度优先搜索同样可以求有向图的强连通分量。若图G是一个连通图，那么从任一顶点出发进行一次深度优先搜索或广度优先搜索，就可以将G中的所有顶点都访问到，但并不会走过图中所有边。在遍历过程中，G的边被分为T和B两个集合，其,'：是搜索过程中使用过的各边的集合，而B是其余各边组成的集合.把连通图G的最小连通子图称为图G的一棵生成树（SpanningTree)。这棵树包含G的所有顶点，但只包含G的n-1条边。显然T(G）和G中所有顶点一起构成一棵生成树。我们将由调用DFS而得到的生成树称为深度优先搜索生成树，若用BFS，则所得到的生成树称为广度优先搜索生成树。图7.9是图7.8所示图的深度优先搜索生成树和广度优先搜索生成树。显然，无向连通图的生成树不是惟一的，对连通图的不同遍历，就得到不同的生成树。" ID="7">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="166" TITLE="7.4.2 最小生成树" TYPE="Chapter">
        <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
        <Paragraph CONTEXT="给定一个连通无向图G，且它的每条边均有相应的权值，则图G的最小生成树（Minimum" ID="1">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Picture URL="00000178\00000178_new\0002.jpg">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Picture>
        <Picture URL="00000178\00000178_new\0003.jpg">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Picture>
        <Paragraph CONTEXT="capch)(a)图7.8所示图的DFS生成树（&lt;b）图7.8所示图的BFS生成树图7.10给出了一个图及其最小生成树的图示.解决最小生成树问题的方法可用于解决下列问题：如果图G的各顶点代表城市，各边代表把两个城市连在一起的电话线路，各边的权代表线路的长度，怎样使得在n个城市之间建立电话网所需要的线路最短？这个问题实质上是在n个城市之间可以架设的n(n-12条线路中选择n-1条构成一棵生成树，使总的代价最小。最小生成树常常是最小代价生成树的简称。一棵生成树的代价就是树上各边的代价" ID="2">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="（权值）之和。" ID="3">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="图7.10图及其最小生成树示例(a）带权图（(b)7.10(al所示带权图的最小生成树构造图的最小生成树的算法主要有两个：一是Prim算法，另一个是Kruskal算法，下面分" ID="4">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="别进行讨论。" ID="5">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Picture URL="00000178\00000178_new\0018.jpg">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Picture>
        <Picture URL="00000178\00000178_new\0019.jpg">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Picture>
        <Paragraph CONTEXT="(1)Prim算法假设GV,E）是一个具有n个顶点的连通带权图，TV,TE）是G的最小生成树，其中V是’T的顶点集合，TE是T的边组成的集合，V和TE的初值均为空集。Prim算法首先从图中任意选取一个顶点v，并将其加人最小生成树的顶点集合V(T）中，此时最小生成树中只有一个顶点v。然后选出与v相关联的边中权最小的一条，设其连接顶点v与另一顶点w,把顶点w加人到最小生成树的顶点集合V(T）中，边（v,w）加人T的边的集合TE中。接下来应从与v或w相关联的所有边中选出权最小的一条，设其连接另一个新顶点，将此边和新顶点添加到最小生成树中。反复进行这样的处理，每一步都通过选出连接当前已在最小生成树中的某个顶点以及另一个不在最小生成树中的顶点的权最小的边而扩展最小生成树，直到n-1次后就把所有n个顶点都加人到最小生成树T的顶点集合V中，TE中含有n-1条边，" ID="6">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="7">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="’飞$Picture[00000179\00000179_new\0004.jpg]Picture$令孕，矩阵.为了便于选出权最小的边，引人两个数组closevertex和lowcost,closevertex[i〕表示最$Picture[00000179\00000179_new\0012.jpg]Picture$$Picture[00000179\00000179_new\0013.jpg]Picture$小生成树中的一个顶点，该顶点和不是最小生成树中的一个顶点i构成的边（closevertex[ii）具有最小的权。lowcost[i〕表示边（closevertex[i],i）的权。起初，将顶点。作为最小生成树ittTi5占＿fifrf`I1/1CPVPTt。Yf；ltrh才吉峡rn1.91riit八，t，。八。rf:〕'ltinbfttn；二i…，n-1。由于n个顶点的生成树共有n-1条边，所以，选择边的过程共需要重复n-1次。每次扫描数组lowcost，找出当前与生成树中顶点最近的顶点，令其为w，得到最小生成树的一条边（closevertex【w〕，w）。然后，令lowcost〔w」＝0（表示顶点w已加人最小生成树中）。由于顶点w的加人会引起fowcost和。losevertex的变化，因此，一旦有一个新顶点加人到最小生成树中，就需要根据具体情况修改数组lowcost和closevertex。Prim算法的C语言实现如" ID="8">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="下：" ID="9">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="算法7.‘" ID="10">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="voidprim（intmatrix［n］〔n〕，intn）；｛lowcost〔0〕今。；closevertex〔0〕“0；" ID="11">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="for（1＝1；1＜n；1＋＋）｛" ID="12">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="lowcost［ij＝matrix〔oj〔ij；" ID="13">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="closevertex〔1〕二0；" ID="14">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="15">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="for（1＝1；1＜n；1＋＋）｛mincost二HUGE;/*HUGE表示一个大于图中最大权的一个数‘／k=i;for(j=1;j&lt;n;j-if1owcost[j]&lt;mincost)g-＆(lowcost仁j=0{mincost=1owcost[jk=j;" ID="16">
          <fptr EndPN="00000180" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="输出k与closevertex[k]" ID="18">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="lowcost[k]=0;for(j=1;j&lt;n;j)/，调整lowcost和closevertex数组的值＊／ifmatrix[kjlowcost[j(lowcost[j=0{closevertex[j]=k;｝" ID="19">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="20">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="｝图7.12给出了用上述Prim算法在构造图7.10(a)所示带权图的最小生成树的过程中，数组lowcost和。losevertex的变化情况。" ID="21">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="、" ID="22">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="169" ID="23">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构$Picture[00000181\00000181_new\0003.jpg]Picture$图7.12上述Prim算法中，第一个for循环的执行次数为n-1，第二个for循环中又嵌套了两个for循环，执行的次数为2(n-1)Z，所以Prim算法的时间复杂性为O(nZ)&lt;2)Kruskal算法Kruskal算法是按边的顺序来构造最小生成树的。其思想是按图中边的权值由小到大顺序逐个选取边，若选中的边与已是最小生成树的边不构成回路，就把此边作为最小生成树的边。如果选取的边与已是最小生成树的边构成回路，则将此边舍去。由于图是连通的，只要选择n-1条边即得到最小生成树。作为一个例子，请看图7.10(a)中所示的图，此图中的各边放人最小生成树是按次序（4,51,50,40,11,22,53,4）和（2,3）进行的。前面三条边（4,51,5)和（0,4)放在最小生成树中，下一条要考虑的边是（(0,1)。由于该条边的加人将与已在生成树的边形成回路，故将它舍去。继续选择（1,2)，而舍去（2,5)，最后选择（3,4此时，最小生成树已有5条边，余下的边不必再考虑，图7.10(a)所示带权图按Kruskal算法构造最小生成树的过程如图7.13所示。Kruskal算法的关键之处是在选取某条边时应判断该边是否与已是生成树的边形成回路。一种解决方法是将图的顶点划分为集合，开始时假定n个顶点分属于n个集合，即每个集{012345}当确定图中某条边为最小生成树的一条边时，就将该边的两个顶点所属的两个集合合并为一个，表示原来属于两个集合的各个顶点已被这条新的边连通.如果选取的某条边的两个顶点属于同一个集合时，该边应舍去。例如，上述例中，当选取完（4,51,5)和（0,4)三条边后，顶{0,1,4,523}下一条边（0,1)的两个顶点属于同一个集合，故舍去。构成边（1,2)的两个顶点属于不同的集{0,1,4,5,23}下一条边（2,5)的顶点也属于同一个集合应舍去，边（3,4)的两个顶点属于不同的集合，可加到{0,1,4,5,2,3}当所有顶点均属于一个集合时，此时图的最小生成树就生成了。Kruskal算法最坏情况下时间复杂性为O&lt;eloge)，其中e为图中边的数目。0③④000O" ID="24">
          <fptr EndPN="00000182" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="已＝合丫亡＝合0000①叮o" ID="25">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Picture URL="00000182\00000182_new\0008.jpg">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Picture>
        <Paragraph CONTEXT="（8)«)（c)0Q3o3匕＝今" ID="26">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="O（d)fie)(f)图7.13Kruskal算法构造最小生成树的过程" ID="27">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="171" TITLE="7.4.3 拓扑排序" TYPE="Chapter">
        <fptr LogicalPageNum="182" PhysicalPageNum="182"/>
        <Paragraph CONTEXT="所有的工程除了最简单的以外都可划分成若干个子工程，将这些子工程称为活动。通常情况下，这些子工程有的附有一些先决条件，先决条件规定了活动之间的先后关系。如某些子工程的开始必须在另一些子工程完成之后。我们希望以某种线性顺序组织这些活动，以便能够在满足先决条件的情况下逐个完成各项活动。可以使用一个有向无环图来模拟这个问题。图中顶点表示活动，有向边表示先决条件，当且仅当活动T；是活动T，的一个先决条件时，图中才有一条有向边＜TT。图是需要无回路的，因为回路中隐含了相互冲突的条件，从而使某些条件不可能在不违反任何先决条件的情况下得到实现。将一个有向无环图中所有顶点在不$Picture[00000182\00000182_new\0008.jpg]Picture$$Picture[00000182\00000182_new\0009.jpg]Picture$$Picture[00000182\00000182_new\0010.jpg]Picture$违反先决条件规定的基础上排成线性序列的过程称为拓扑排序，拓扑排序所产生的序列称为拓扑序列。由于某些活动之间不存在先决条件，它们在拓扑序列中的位置可以是任意的，所以拓扑排序的结果一般不是惟一的.图7.14为拓扑排序的示例.本例的一个可行的拓扑序列为T，，Tx,T3,T4,Ts,Te,拓扑排序算法的思想很简单，在有向图中选择一个没有前驱的顶点，并把它排到拓扑序列中去，凡取出某顶点，即将它和与它相关联的边从图中删去。随着一些边的被删去，又会有顶点变成新的无前趋顶点。此过程重复进行下去，直到将全部顶点都排列到拓扑序列中为止，此时，原有向无环图中的所有顶点和边都被删去了。" ID="1">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构$Picture[00000183\00000183_new\0002.jpg]Picture$以图7.14为例，初始时只有顶点T：无前驱，将其排到拓扑序列中，同时删去和它相关联的边（T；，TZ(T：，T,）与＜T，，T。此时三个顶点TZ,TT；变成无前驱顶点，任选一个顶点，假设选择TZ，将其排到拓扑序列中，并将它和它的关联边（TZ,TS＞从图中删去，此时无前驱的顶点有T,和Ta。假设我们选择T,将其排到拓扑序列中，并将与它相关联的边（T3，T、＞，（T3，T6）从图中删去。如此重复下去，最后得到的有序序列为：T：，T：，T3，T。，TT，整个拓扑排序的过程如图7.15所示。" ID="2">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="解嘿贯(a)侧去T，及与其相关联的边（b)剧去T：及与其相关联的边(c)侧去T：及与其相关联的边（(d)删去T。及与其相关的边（(e)剐去TS(f)删去T6例如图7.16图7.16有向回路$Picture[00000183\00000183_new\0023.jpg]Picture$$Picture[00000183\00000183_new\0024.jpg]Picture$从上面所述可知，为实现拓扑排序，必须解决两个问题：①如何知道一个顶点没有前驱；②怎样删除一个顶点及与其相关联的所有边。如果对每个顶点的直接前驱予以计数，则问题①就解决了。若图采用邻接表表示，则问题②就容易实现。·把以顶点v为末端的所有边删除，只要把该顶点的前驱计数减去1即可。在拓扑排序过程中，为了避免重复检测入度为零的顶点，可以设立一个栈，用来存放人度的顶点。每次取人度为零的顶点输出，就是取栈顶元素输出。函数topological_orde：是为零的顶点。拓扑排序算法的实现。其中数组count有两个用处：一是用来统计图中每个顶点的前驱顶点个数，二是用来表示栈，存放无前驱顶点；top表示栈顶指针，图本身用邻接表表示。算法7.7voidtopological_order(intn);" ID="3">
          <fptr EndPN="00000184" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="｛top=0;for(i=O;i&lt;n;i十十）／，将所有入度为。的顶点人栈，／if（。ount［1〕＝＝0）｛count=top;" ID="4">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="top=t;｝for(i=O;i&lt;n;i){if(top二＝0)exit;/，图中存在回路二／J=top;top=count[top输出顶点Jptr=adjlist[jwhile(ptr！=NULL){／二删去以顶点J为末端的边关／k=ptr一＞vertex;count[k]=count[k］一1;" ID="5">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="if（count〔k」幸＝0）｛top=k;｝ptr=ptr一仁＞next;" ID="6">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝对一个具有n个顶点和e条边的有向图而言，将人度为零的顶点人栈所r时间为O(n)对顶点i来说，while循环执行的时间为o(d，其中a，为顶点i的出度。由于每输出一个顶点时，就发生一次这样的循环，所以上述拓扑排序的时间复杂性为O(n-f-e)," ID="8">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="173" TITLE="7.4.4 最短路径" TYPE="Chapter">
        <fptr LogicalPageNum="184" PhysicalPageNum="184"/>
        <Paragraph CONTEXT="我们可以用图来表示一个城市或一个国家的公路结构。图的顶点表示城市，边表示城市数据结构段路所用的时间。一个驾驶员若从A城驱车到B城，他就想知道下列问题的答案：" ID="1">
          <fptr EndPN="00000185" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="1)从A城到B城有路吗？" ID="2">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="2)若从A城到B城的路不止一条，那么哪一条最短？把一条路径的长度定义为这条路径上各边权的总和，而不是边的数目.求图中两个顶点之间的最短路径这并不是一个简单的问题，因为最短路径不一定恰好就是连接两个顶点的边，而可能是一条包含一个或多个中间顶点的路径。例如，图7.17中，直接从A到D的边长度为30，从A经B到D的路径长度为25，从A到C再经B到D的路径长度为20。因此，从A到D的最短路径长度为20（但它并不是从A直接到D的" ID="3">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="图7.17最短路径示意图" ID="4">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)单源最短路径我们要研究的第一个最短路径问题称为单源最短路径.已知有向图GV,E)，各边权值均大于零，找出从某个给定顶点s(sEV(G”作为源点，求顶点s到图中其他顶点的最短路解决这个问题的一个方法是，用固定的顺序对顶点进行处理.假设将图G的n个顶点依次标记为vo,vl，v一，，并设源点为vp。当处理v：时，记录v。到v；的边的长度作为顶点vp到v：的最短路径长度。处理vZ时，将v。到v，边的长度加上v；到v：边的长度之和与vp到vZ边的长度比较，取小者为vp到v：的最短路径长度，并将其记录下来，…，依此类推。处理v、时，将记录的v。到v一，的最短路径长度加上v。一，到v，边的长度，与从vp到v，边的长度相比较，记录其小$Picture[00000185\00000185_new\0023.jpg]Picture$者为v。到v；的真正最短路径.但是这样做可能会产生一个问题：也许从vp到v：的最短路径要经过v,，而jai。使用上述思想就会遗漏这种路径。如果按路径长度递增次序对各个顶点进行处理就可避免上述问题。假设按路径长度递增的次序处理了从vp出发所到达的路径最短的前i-1个顶点，这些顶点组成的集合为S。现在准备顺序处理第i个顶点，称之为u。从vp出发到u的最短路径或者是从v。直接到达u，或者是中间经过集合S中的顶点到达u，但决不会经过集合S以外的任何其他顶点。换句话说，从v。到u的最短路径为：从集合S中任取顶点w，计算从v。到w的长度，加上＜w,u＞的边的长度，取这些和中的最小者。要证实这一点，就得证明，所有位于通往顶点u的最短路径上的中间顶点都一定在集合S中。假定这条路径上有一个顶点x不在S中，于是，从Vp到u的路径上还有一条从v。到x的路径，这条路径的长度小于从v。到ll的路径长度。根据假定，最短路径是按路径长度递增次序生成的，故由v。到x的较短的路径必定已上述按路径长度递增求最短路径的方法称为Dijkstra算法。设有向图GV,EG的n个顶点编号为。到n-1.集合S为一个数组，若顶点v：不在S中，则S[i]=0，若顶点v.在S中，则S[i]=1。matrix表示G的邻接矩阵，matrix[i][j〕为边（i,j）的权。若不存在有向边（i,l)，则matrix[ij〕置成某个大数（大于图中最大权值的一个数）。若i=j，则matrix[ij〕可置成0。数组元素distance〕记录从源点v。出发到顶点v,的当前最短路径长度，其初值为ma-trix[01[jj=1,2,…,n-1,Dijkstra算法的执行过程是：首先从S之外的顶点集合V-S中选出一个顶点u，使dis-tance[u」值最小，把u加人到集合S中（S[u1)，顶点u也成为S中的一员。这时从v。出发，中间只经过S中的顶点并以不在S中的一个顶点w为终点的最短路径长度可能会减小，就是说，distance[w］的值可能发生变化。如果distance[w〕的值真的发生了变化（减小），是因为有一条从vo到u，再到w的路径，而且v。到u的路径为最短路径，自u到w的路径是边＜u,w的缘故。这条路径长度是distance[u]+matrix[u][w]。因此接下来要调整distance中记录的从源点到V-S中每个顶点v的最短路径长度：调整是从原来的distance仁v」和distance[umatrix[uv」中选择较小值作为新的distance[v]，使distance[v〕始终保持到目前为止最短的路径长度.重复上述过程，直到S中包含V中的全部顶点。结果数组distance记录了从源点到图中其余各顶点的最短路径长度。函数short_path是Dijkstra算法的C语言实现。其中i为源点，mincost函数实现从“S之外的顶点集合V-S中选出一个顶点w，使distance[w］的值最小”的目的.算法7.8voidshort_path(intmatrix[nnintminti" ID="5">
          <fptr EndPN="00000186" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="6">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=O;j&lt;n;j{" ID="7">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="s[j]=0;" ID="8">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="distance二matrix[i][j];" ID="9">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="10">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="s[i]=I;number=1;" ID="11">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="while(number&lt;n){" ID="12">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="u二mincost(distance,s,n" ID="13">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="s[u]=1;" ID="14">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="number--f-;" ID="15">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=O;j&lt;n;j" ID="16">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="if（5［j〕”＝0）｛" ID="17">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="dist=distance[u]-matrix[ujdistance〕二（distance&lt;distdistance:dist;" ID="18">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="｝，" ID="19">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="20">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="22">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="｛mindist=HUGE;HUGE是大于图中权值最大的一个数‘／for(j=O;j&lt;n;j)ifs[j〕二＝0)(distance[jmindist{｝" ID="23">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="return(w);" ID="24">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="｝对n个顶点的图，Dijkstra算法的时间复杂性为O(nz)。这是因为，算法中第一个for循环执行次数为n,while循环共执行n-1次。这个循环每执行一次，需要花费O(n)时间才可选出下一个顶点，调整distance的时间也是O(n)。所以，while循环的总计时间为O(nZ)。如果图用邻接表表示，调整distance数组的时间可降低为O(ee为图中边的数目），选取下一个顶点的时间仍为O(n)，所以总的时间也为（nZ对于图7.17所示的有向图，按照Dijkstra算法求从顶点A到其余各顶点的最短路径的过程中，集合S,distance的变化情况如图7.18所示。重复S选取的顶点distance0(A)1(B)＿2(C3(D)4(E)初始010230m1{0}20S230122{0.21105220123{0,2,1)405220124(0,2,1,4}30S22012" ID="25">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)每对顶点之间的最短路径第二个最短路径问题是求图中每一对顶点之间的最短路径长度，也被称为每对顶点之间的最短路径。为了求出每对顶点之间的最短路径，一种可以解决这个问题的方法就是运行Dijkstra算法n次，每次以图中的一个顶点作为源点，这种方法的时间复杂性为O&lt;n')。除此之外，还可以用另外一种称为Floyd算法来解决这个问题。Floyd算法的时间复杂性也为O(n')，但和Dijkstra算法相比，Floyd算法简便、清晰，易于实现。设有向图GV,E)，其中v（G）＝｛0，1，…，n-1)。G用邻接矩阵matrix表示，matrix[11[J〕表示有向边（(i,j》的权，若不存在有向边（(i,j)，则matrix[ij]置成某个大数（大于最大权值的一个数）。若i=j，则matrix[ij〕可置成0,Floyd算法的基本思想是，递推产生一个矩阵序列：Ao,At,A2，A，其中AkCI]C1〕表示从1到j的最短路径长度，这条最短路径所经过的顶点序号小于k,Ao[i]Cj〕二matrix[ij假设已经生成了A卜1［1〕［j〕，则就可以生成AkC17Cj]。因为我们知道，顶点i到l的最短路径要么经过，要么不经过顶点k。如果它经过顶点k，这两条路径必然是由i至k以及由k至j的路径组成.且路径上所经过的顶点序号小于k-1，路径长度为Ak-t[i]Ck」与A、一；Ck]Ci]。如果该路径不经过顶点k，此时，该路径长度与顶点i到j的路径上所经过的顶点序号小于k-1最短路径相同，为Ak一：Ci]Cj]。于是，可以得到计算Ak[1〕仁J〕的公式：AkC11仁J]=minlAk一；Ci]Cj]，Ak-，Ci]Ck]+Ak一：[k]Cj]}这个公式是一个迭代公式，每迭代一次，从顶点1到顶点J的最短路径上就多考虑一个顶点。因为G中不会有序号大于n的顶点，所以经过n次迭代后，A。[i]C]〕就是G中顶点i到顶点j的最短路径长度。设matrix表示带权有向图的邻接矩阵，二维数组a用于存储矩阵Ak（k＝。，1.2，…，n）的值，Floyd算法的C语言实现如下：" ID="26">
          <fptr EndPN="00000188" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="算法7.9voidALL_PATH(intmatrix[nnintn)｛" ID="27">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i今O;i&lt;n;i＋十）" ID="28">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=O;j&lt;n;j十＋）a[ij]=matrix[ijfor&lt;i=O;i&lt;n;i十＋）" ID="29">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="a[ii]=0;" ID="30">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="for(k=O;k&lt;n;ki" ID="31">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=O;i&lt;n;ifor(j=O;j&lt;n;j" ID="32">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
        <Paragraph CONTEXT="if(a[ik]-a[kj]&lt;a[ij｝图7.19给出了一个有向图及用Floyd算法求其每对顶点之间最短路径长度时矩阵A的变化情况。" ID="33">
          <fptr EndPN="00000188" StartPN="00000188"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="177" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="188" PhysicalPageNum="188"/>
      <Paragraph CONTEXT="一个图由两部分组成：一部分是顶点，另一部分是顶点的偶对，称之为边。通常，图的任意一对顶点间都允许有一条边，可以说，图是最基本的数据结构。如果图中的边有方向性，则称为有向图，否则，称为无向图。如果图中每条边附有权值，这样的图称为带权图。邻接矩阵表示图中各顶点之间的邻接关系。无向图的邻接矩阵是对称的，有向图则不一定。邻接矩阵适用于以顶点为主的运算。邻接表是由邻接矩阵改进而来的，与顶点v相邻的所有顶点构成一个单链表，单链表的头指针存储在一个一维数组中。对于有向图而言，十字链表是一个很有效的工具。十字链表可以看成是将有向图的邻接表和逆邻接表结合起来的一种存储结构。在十字链表中，有向图的每条边表示成一个结点，该结点既链在该边始端顶点的链表中，又链在该边末端顶点的链表中。邻接多重表是由邻接表进一步改进而来的无向图的一数据结构$Picture[00000189\00000189_new\0002.jpg]Picture$$Picture[00000189\00000189_new\0003.jpg]Picture$$Picture[00000189\00000189_new\0007.jpg]Picture$$Picture[00000189\00000189_new\0010.jpg]Picture$$Picture[00000189\00000189_new\0011.jpg]Picture$种存储结构。在邻接多重表中，无向图的每条边只对应一个结点，它克服了无向图的每条边对应邻接表中两个结点，因而不便于处理的缺点。以特定的顺序依次访问图中各顶点称为图的遍历。同一个图可有很多种遍历次序，本章主要介绍的是深度优先搜索和广度优先搜索遍历两类。深度优先搜索是按尽量向前走，到头才退回，再向其他路径搜索的原则进行的。这是一个递归过程，因而很容易为其设计出递归形式的算法。广度优先搜索是一种逐层横向搜索的过程，广度优先搜索的算法需用一个队列。对于非连通图，如果陆续以尚未访问过的顶点作为出发点进行某种次序的遍历，就可确定出此图的各个连通分量.取一无向连通图的全部顶点和一部分边构成一个子图，如果其中所有顶点仍是连通的，但各边又不形成回路，这个子图叫做原图的一个生成树。同一个图可以有多个不同的生成树。解决最小生成树问题的方法可用于以下问题：怎样使电路板上连接一系列接头所需要焊接的线路最短，或者怎样使得在几个城市之间建立电话网所需要的线路最短。Kruskal算法和Prim算法是求最小代价生成树的两种有效算法。Kruskal算法是将带权图中各边按权值由小到大的次序顺序选取，保留不形成回路的边，舍弃形成回路的边，直至得到整个生成树为止。这种算法的关键在于判断新选择的边与已保留的边是否形成回路，可利用将已连通的顶点组成集合并判断新边的两个顶点是否处在同一个集合的方法来解决。Prime算法与Kruskal算法不同，它是采用将顶点逐个连人最小生成树的办法实现的。具体做法是，从所有已在生成树的顶点，和所有不在生成树的顶点组成的边中，选取具有最小权值的边，然后将最小权值的边中不在生成树的顶点加人到生成树的顶点集合中扩重复上述过程，直到所有顶点均加人到最小代价生成树中。所有的工程除了最简单的以外都可划分成若干个子工程，这些子工程称为活动。通常情况下，这些子工程有的附有一些先决条件，如某些子工程的开始必须在另一些子工程完成之后.我们希望以某种线性顺序组织这些活动，以便能够满足在先决条件的情况下逐个完成各项任务。拓扑排序可用来解决上述问题，拓扑排序算法很简单，重复下述两步，直到所有顶点均已输出：①在有向图中选出一个没有前驱的顶点并输出之；②从有向图中删除该顶点和所有以它为末端的边。对于一个带权的有向图，求从某一顶点出发到其余各顶点的单源最短路径（所经过的有向边权总和最小的路径）或求每一对顶点之间的最短路径叫做最短路径问题。单源最短路径可以采用Dijkstra算法。它的技巧在于为图中所有顶点保留了一个当前最短路径长度的值distance[v]，并且按照从源点出发所到达图中所有其他顶点的路径长度递增次序来处理每个顶点。处理某一个顶点w时，它的任意一个相邻顶点x的distance[x」值都可能随之改变。求每一对顶点之间的最短路径问题可以使用Floyd算法。定义ElkCi]Cj」表示从i到j的）公忿v3奖.F_;守2b1熟4百R匕36G47;ttsftr5x良习-.i.4；Un习;tkaxne._r:r:门ni著,出百ec,e最短路径长度，这条最短路径所经过的顶点序号小于k.Floyd算法通过一个三重循外检查丁所有的叫" ID="1">
        <fptr EndPN="00000190" StartPN="00000188"/>
      </Paragraph>
      <Paragraph CONTEXT="能性。学习完本章内容后，读者需要：①了解有关图的一些基本术语，特别是：无向图、有向图和加权图，顶点、顶点的度，子图、②掌握图的几种存储结构.能够由给定能够由给定的图写出与其对应的某种存储结构，由一个图的" ID="2">
        <fptr EndPN="00000190" StartPN="00000190"/>
      </Paragraph>
      <Paragraph CONTEXT="③能够利用图解决实际问题。" ID="3">
        <fptr EndPN="00000190" StartPN="00000190"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="179" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="190" PhysicalPageNum="190"/>
      <Paragraph CONTEXT="7.1试求出图7.20所示图的" ID="1">
        <fptr EndPN="00000190" StartPN="00000190"/>
      </Paragraph>
      <Paragraph CONTEXT="①每个顶点的人度与出度，②图的邻接矩阵表示；③图的邻接表表示。7.2证明，在一个n个顶点的完全无向图中，边的数目是n（n-1）／2。7.3给出图7.20所示图从顶点1开始的深度优先生成树。7.4给出图7.20所示图从顶点1开始的广度优先生成树。7.5写一个算法确定一个有n个顶点的有向图是否包含回路。此算法的时间复杂性应该是0（n）.7.6写一个算法确定一个有n个顶点的无向图是否包含回路.此算法的时间复杂性应该是0（n）。" ID="2">
        <fptr EndPN="00000190" StartPN="00000190"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构7.8把Kruskal最小生成树算法写成一个完整的程序。7.9写出对图7.20从顶点A出发，使用Dijkstra最短路径算法产生的单源最短路径、画出距离数组distance中数值的变化过程。7.10修改单源最短路径算法，使它确实能存储并返回最短路径而不仅仅计算其长度。7.11给出对图7.20所示图使用Floyd每对顶点间最短路径算法的结果。写出求解过程中矩阵的数据变化情况。7.12设计一个算法找出从各顶点到某一个指定顶点的最短路径。产，致乒汹必黝纷溯峥砚哪锢扭东孜瑟瀚汾爸介，鱿扮也‘可弓如，叱矫鱿郊晒华呕怒魂准翔妙双笋锢洲曦岁破笋跳娜卿互锡脚魏脚呼派孚服项双盼服沙翅沙吸班镶睡距扭砸孚旭润吸多卿腆娜筑吵陌少澡七查找也称为检索，是数据处理中非常基本且非常重要的运算之一。可以把查找抽象地看成这样一个过程，这个过程确定一个具有特定值的数据元素是不是一个特定集合中的元素。在一个特定集合的元素中进行查找可选用的方法和该集合中元素的存储结构有很大关系。本章将针对数据的不同存储组织来讨论几种常用的查找方法，并对查找算法进行分析以比较各种查找方法的优劣.在8.1节首先介绍查找的基本概念；8.2节介绍查找最简单的形式：顺序查找以及折半查找；8.3节介绍索引查找技术；8.4节介绍一种基于二叉树的查找方法，它能很好地使记录的插人与查找有效完成；最后在8.5节介绍哈希查找方法，这种方法把记录组织到一个表中，根据关键字的值确定表中每一个记录的位置。" ID="3">
        <fptr EndPN="00000192" StartPN="00000191"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="181" TITLE="第8章 查找" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="181" TITLE="8.1 查找的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="192" PhysicalPageNum="192"/>
      <Paragraph CONTEXT="日常生活中，“查找”几乎天天发生。查字典、查火车时刻表，在图书分类目录中找所需的书，在学生成绩表中查某学生的成绩等等都是查找。查找是计算机应用系统中使用频率很高的操作，提高查找效率是本章讨论问题的出发点。查找（Search)可形式的定义为：假定有一个查找表T,T中有n个数据元素或记录RRZR，记录的关键字分别为Kl，KZK，且关键字的值互不相同，给定一个关键字K,查找就是在T中找到某个记录R,，使得RK,查找表（SearchTable）是由同一数据类型的数据元素或记录组成的集合，由于集合中的记录之间存在着完全松散的关系，因此查找表是一种非常灵活的数据结构。如字典、火车时刻表、图书分类目录、学生成绩表都是查找表。" ID="1">
        <fptr EndPN="00000192" StartPN="00000192"/>
      </Paragraph>
      <Paragraph CONTEXT="对查找表的操作常有：" ID="2">
        <fptr EndPN="00000192" StartPN="00000192"/>
      </Paragraph>
      <Paragraph CONTEXT="①查询某个“特定”的数据元素是否在查找表中；" ID="3">
        <fptr EndPN="00000192" StartPN="00000192"/>
      </Paragraph>
      <Paragraph CONTEXT="②检索某个“特定”数据元素的各种属性；" ID="4">
        <fptr EndPN="00000192" StartPN="00000192"/>
      </Paragraph>
      <Paragraph CONTEXT="③在查找表中擂人一个数据元素；" ID="5">
        <fptr EndPN="00000192" StartPN="00000192"/>
      </Paragraph>
      <Paragraph CONTEXT="④从查找表中剔除某个数据元素。对于“特定”的数据元素以一个给定的关键字值来识别，如果经过查找找到关键字等于这个值的记录，如称此次查找是成功的，否则称此次查找是失败的。数据结构次数和平均比较次数作为两个基本的技术指标，前者称为最大查找长度MSL(MaxmumSearch.Length)，后者称为平均查找长度ASL(AverageSearchLength),对于含有n个记录的查找表，查找成功的平均查找长度为其中，C：为查找第i个记录所需的比较次数；P。为查找第i个记录的查找概率，且;P,=1，若查找各个记录的概率相等，则每个P.二1/n,在本章讨论各种查找算法时假定表中记录的类型为ElemType，关键字类型为KeyType,同时也认为对于任何一种记录都可以找到一个取得它的关键字函数，记为key。另外，本章介绍的各种查找算法不考虑两个或多个记录具有相同关键字值的情况，如果遇到这种情况，这些查找方法一旦查找到其中一个记录就认为查找成功。" ID="6">
        <fptr EndPN="00000193" StartPN="00000192"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="182" TITLE="8.2 顺序表查找" TYPE="Chapter">
      <fptr LogicalPageNum="193" PhysicalPageNum="193"/>
        <div ORDERLABEL="182" TITLE="8.2.1 顺序查找" TYPE="Chapter">
        <fptr LogicalPageNum="193" PhysicalPageNum="193"/>
        <Paragraph CONTEXT="顺序查找（SequentialSearch)也称线性查找，是最简单的一种查找方法。设有n个记录存放于查找表a中，顺序查找从表的第一个记录开始，依次将每个记录的关键字值同给定值K进行比较。若某个记录的关键字值等于K，则查找成功，返回该记录所在位置，若直到所有记录都比较完毕，仍未找到与K相等的关键字记录，表明查找失败，返回失败信息。顺序查找的C语言实现为：" ID="1">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="算法8.1intsearch1(ElemType,a[nKeyTypeK,intn)｛" ID="2">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="inti;" ID="3">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=0;i&lt;n;i-I" ID="4">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="return-1;" ID="5">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="｝下面给出的算法search2也是实现顺序查找的算法，其算法思想与searchl一致，只是在search2中查找之前先对a[n]的关键字赋值K。查找时，从前向后比较时，最多比较到这个位置上，一定会找到关键字等于K的记录，从而免去查找过程中每一步都要检测整个表是否查找完毕。在此，能司起到了“监视哨仲的作用。这仅是程序设计中一个非常有用的技巧，然而实践证明，这一技巧的使用使查找算法在n,1000时，进行一次查找所需的平均时间几乎节省一半。" ID="6">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="·182" ID="7">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="算法8.2" ID="8">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="intsearch2(ElemTypea[pKeyTypeK,intn)" ID="9">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="10">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="mtt;" ID="11">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="key（a［n〕）＝k；" ID="12">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="i=0;" ID="13">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="while(key(a[i!=k)i" ID="14">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="if(i二＝n)" ID="15">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="return-1;" ID="16">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="returnt;" ID="17">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="｝如果表中没有一个记录具有关键字K，则上述算法需要执行n次比较。也就是最坏情况下顺序查找需要比较n次，因此MSL二n,进行一次成功的查找所作关键字比较的次数C,，取决于关键字在表中的位置。如果所有关键字都互不相同，而且查找的关键字是K,，则需要进行i次关键字比较，即C：二i，因此，顺序查找成功时的平均查找长度为。二。，占。。1石.1、，n（n＋1）n＋1HJL=7,Y,l7,1n－一＝一二，一ua’一ninGL这样最大查找长度和平均查找长度的数量级均为O&lt;n)顺序查找的优点是对表中记录的排列次序无任何要求，另外它既可适用于顺序表，也适用于链表。如需增加记录，只要将记录插在表的最后，不需要移动元素。请读者自己完成链表的lily序查找算法。从上述的分析可以看出，顺序查找方法虽然简单，但查找效率低。如果已知各记录的查找频率不等时，可以改变记录的存储顺序，把查找频率高的记录尽可能放到表的前面，而把查找" ID="18">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="频率低的记录放到表的后面，这样就可以提高顺序查找效率。另外，也可以将表中记录按关键率." ID="19">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="183" TITLE="8.2.2 折半查找" TYPE="Chapter">
        <fptr LogicalPageNum="194" PhysicalPageNum="194"/>
        <Paragraph CONTEXT="如果n个记录存放于查找表a中，且已按关键字的值由小到大递增的顺序排列。我们可以采用一种称为折半查找的方法进行查找.折半查找从检查教组中间位置的记录开始，把这个位置记为mid，相应的元素为a[mid如果K二key(a[mid])，那么查找就成功了。当然，这种情况出现的可能性不大.不过，这个中间位置记录的关键字值能提供一些信息，帮助继续进行查找。当key（a〔midj）＞K时，知道K不可能在mid后面的位置上出现，因此，在以后的查找中不必再考虑后半部分的记录。相反地，如果key（a[mid&lt;K,K就不可能出现在mid前面的位置，以后的查找就可以忽略mid数据结构" ID="1">
          <fptr EndPN="00000195" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="半查找的示意图。！④" ID="2">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="46485682忠！｛蕊图8.110个记录的折半查找示意图，标号①，②，③和④表示比较的顺序折半查找的C语言实现为：算法8.3intbinsearch（ElemTypea〔n］，KeyTypeK，intn）" ID="3">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="｛Intl，n，nlld；1＝叭h“n-1；／，1和h分别表示查找范围的上限与下限，／while（1＜“h）｛mid＝（1＋h）／2；" ID="4">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="if（K＜key（a〔mid〕））h“mid-1；" ID="5">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="if（K“＝key（a〔mid〕）returnmid；if（K＞key（a［mid〕））1二mid＋1；》return-1；折半查找也可用递归方式实现，留给读者练习.以图8.1为例，考查K＝56的查找过程。按照折半查找方法思想，第1步检查4号位置的记录的关键字值，因为K＞a〔4〕＝46，因此K不可能存放在小于4的位置。第2步，折半查幸分7习.才台月浮配.4口福落由月p犷之产。厂7〕＝只9习匕日日为六浏匕封》配，4口云落已下望七才吞月睁哎右1叹今1曰翻台幼J仁习双七袅第3步要检查的是5号位置的记录，因为K＞a〔5」＝48，所以下一步要检查的应是6号位置的记录，恰恰是要找的记录，这样binsearch函数最终返回的值为6。如果K＝70，查找过程几乎完全相同，不过检查完6号记录之后，1＞h，函数binsearch返回一l（查找失败）。折半查找最好的情况是第一次比较即找到所找的记录，即使第一次比较没有找到，查找范" ID="6">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="围也被缩小一半，每比较一次均使查找范围减半。在进行了k次关键字的比较之后，待查找的" ID="7">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="185" TITLE="8.3 索引表查找" TYPE="Chapter">
      <fptr LogicalPageNum="196" PhysicalPageNum="196"/>
        <div ORDERLABEL="185" TITLE="8.3.1 索引查找" TYPE="Chapter">
        <fptr LogicalPageNum="196" PhysicalPageNum="196"/>
        <Paragraph CONTEXT="8.2节介绍的顺序查找和折半查找方法只能找到具有特定值的一个记录。如果要查找关键字值在某个范围之内的所有记录，或者需要按照关键字值的顺序访问所有记录。一种方法就是把整个表处理一遍，找到所有与此项查找有关的记录，这种方法效率不高。另一个解决方法是根据关键字值的顺序排序记录，在这种方法中，需要创建一个索引表，把所有记录的关键图8.2索引示例索引查找在索引表中直接进行，由于索引表的记录按关键字有序，因此索引查找可采用折找方法。索引表为记录提供一种顺序，而不需要改变记录的物理位置。索引查找支持对半查找方法。大量记录的高效率访问，允许直接访问特定的记录，而不管记录原来的顺序。" ID="1">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="185" TITLE="8.3.2 分块查找" TYPE="Chapter">
        <fptr LogicalPageNum="196" PhysicalPageNum="196"/>
        <Paragraph CONTEXT="分块查找又称为索引顺序查找。它是顺序查找和折半查找方法的一种结合。在分块查找$Picture[00000196\00000196_new\0002.jpg]Picture$方法中，查找表中的记录被分成若干块，每一块中的记录可以是无序的，但是块间必须有序.所谓块间有序，是指第二块中所有记录的关键字值均大于第一块中记录的最大关键字值，第三块中所有记录的关键字值均大于第二块中记录的最大关键字值，…，依此类推。数据结构分块查找分为两步进行.首先根据K在索引表中找出包含该关键字值的记录所在的块，然后在块中顺序查找。例如，在图8.3中查找关键字值为36的记录，则先将36依次与索引表中的关键字进行比较，因为18&lt;36G48，则表明关键字为36的记录若存在，必定在第二块中。然后根据索引表的指针可知第二块的第一个记录是表中的第5个记录，接下来应从第5个记录起在查找表中进行顺序查找，直到第7个记录为止，查找成功。由于索引表是按关键字值有序，所以索引表的查找可以采用顺序查找，也可以采用折半查找。但是块中各记录是无序的，所以在块中查找只能采用顺序查找。假设长度为n的查找表被分成m块。为了找到记录所在的块，需要折半查找索引表，在最坏情况下需要时间O(log(m十1在相应块中用顺序查找法进行查找，在最坏情况下需要时间为O(n/m)，平均情况下需要花费O(n/2m）时间。因此分块查找的时间复杂性为O(log(m+1-n/2m)" ID="1">
          <fptr EndPN="00000197" StartPN="00000196"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="186" TITLE="8.4 树表查找" TYPE="Chapter">
      <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
        <div ORDERLABEL="186" TITLE="8.4.1 二叉排序树" TYPE="Chapter">
        <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
        <Paragraph CONTEXT="从前面介绍的查找方法知道，折半查找较顺序查找速度快。但折半查找要求表中记录必须有序，因此当插人记录时需要时间为O(n)，因为当在已排序的表中找到新记录恰当的位置时，需要移动许多记录以便为新记录腾出位置.有没有哪一种组织记录的方法使得记录的插入与查找都能够很快地完成呢？本节介绍的二叉排序树就能够很好地解决这个问题。二叉排序树是指满足下列条件的二叉树：二叉排序树的任何一个结点，设其值为k，则该结点左子树的任意一个结点的值都小于" ID="1">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="k，该结点右子树的任意一个结点的值都大于或等于k.图8,4给出了一个二叉排序树例子。图8.4一裸二叉树排序树较。如果根结点存储的值为K，则查找结束.如果K小如果K大于根结点的值，则用同样的方法在右子树中继续查找。这个过程一直持续到K被找到或者遇到一个叶结点。如果遇到叶结点仍未发现K，那么K就不在这个二叉排序树中。若以二叉链表作为二叉排序树的存储结构，则上述查找过程的C语言实现为：" ID="2">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="186" ID="3">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="算法8.4BinNodesearch(BinNode*t,KEYTYPEK)｛" ID="4">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="if(tNULL)returnNULL;" ID="5">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="elseif(K&lt;t一＞key)return(search(t一＞lchild,K;elseif(Kt&gt;key)returnt;elsereturn(search(t一＞rchild,K;｝例如在图8.4所示的二叉排序树中查找值30。由于30小于根结点的值46，查找过程进入左子树，由于30比23大，查找23的右子树，此时找到包含值30的结点。如果查找值32，查找的路径是相同的，直到找到包含30的结点。由于这个结点没有右子树，可以判断出32不在这个二叉排序树中。在二叉排序树中插人值为K的结点时，必须要保证插人后的二叉树仍然满足二叉排序树的定义。因此，插入时必须首先找到合适的插人位置。实际上新插人的结点是一个叶结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子.图8.5给出了插人过32作为结点30的右孩子插人算法8.5voidinsert(BinNode关t,BinNode*s,KEYTYPEK)／，在二叉排序树中插人结点.t为根结点指针，s为当前结点指针，／" ID="6">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="｛if(sNULL){$Picture[00000198\00000198_new\0027.jpg]Picture$s=malloc(sizeof(BinNodes一＞key=K;slchild=s&gt;rchild=NULL;if(t&gt;key&lt;K)t一＞rchild=s;" ID="7">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="elset&gt;lchild=s;" ID="8">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="9">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="10">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="11">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="｝对于给定值的集合，反复调用上述插人算法，可生成一棵二叉排序树。例如，按照95,27,46,6,30,23的顺序将值插入，得到的二叉排序树如图8.6所示。该二叉排序树与图8.4所示的二叉排序树完全不同。因此，对一组给定的值，如果输入的顺序不同，则对应的二叉排序树也不同。" ID="12">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="图8.7从图8.4中删除根结点后" ID="13">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="应注意的是从二叉排序树中删除一个结点要比插人一个结点复杂一些。因为被插人结点$Picture[00000199\00000199_new\0014.jpg]Picture$$Picture[00000199\00000199_new\0015.jpg]Picture$都是被链接到树的叶子结点上，因而不会破坏树的结构。但在进行删除时，被删除结点可能是叶子结点，也可能不是叶子结点。从二叉排序树中删除一个结点，首先必须找到这个结点（假设为R)，接着将它从二叉排序树中删除掉。因此，侧除操作的第1步就是查找R的存在.如果找到R，有多种可能。" ID="14">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="1)若R没有子结点，即R是叶结点，那么删除结点R很简单，将R的双亲结点指向它的指针改为NULL即可。" ID="15">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="2)若R有一个子结点，那么将R的双亲结点指向它的指针改为指向R的子结点就完成了删除。" ID="16">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="3)若R有两个子结点，间题就比较麻烦了，因为待删除的结点有两个子树要处理。一种方法是将R的双亲结点指向R其中的一棵子树，然后将剩下的另一个子树的结点一个一个重新插人。这种方法简单但代价高。‘二二‘谧入击下试J抽月企，合」.去月.宜Dr,H二巴七踌日，J」》d」月陌白匕沼J3会鑫t〕诵记，石士.七树的性质，这个代替结点是那些大于（或等于）被替换值中的最小者，或者那些小于被替换值中的最大者。例如，假设将值46从图4的二叉排序树中删除，把46的左子树包含最大值（30)的结点删除，然后用30代替46。图8.7给出了删除46以后的二叉排序树。读者可根据上述分析写出在二叉排序树上删除结点的算法。二叉排序树的查找和插人的时间代价取决于结点被找到／插人的深度。删除结点的时间代价取决于被删除结点的深度。这样，这几个操作中任意一个的最差情况都等于该树的深度。一般情况下，n个结点二叉树的高度大约为logn。但是如果二叉树变成一链表的形状，则其高·188" ID="17">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="口度可达到n。因此二叉排序树查找的平均时间复杂性为O(logn)，最差情况下时间复杂性为O(n" ID="18">
          <fptr EndPN="00000200" StartPN="00000199"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="189" TITLE="8.4.2 平衡二叉树" TYPE="Chapter">
        <fptr LogicalPageNum="200" PhysicalPageNum="200"/>
        <Paragraph CONTEXT="平衡二叉树是由Adelson-Velskii和Landis于1962年提出的，所以也称为AVL树。这是一种附加了一定条件的二叉树。把二叉树中每一结点的左子树高度减去右子树高度定义为该结点的平衡因子.所谓平衡二叉树是指一个二叉树中任一结点的平衡因子的值只能是十1,0或一1，换句话说，平衡二叉树的每一个结点的左右子树的高度之差的绝对值不超过1,图8.8给出了一个平衡二叉树的例子。每个结点旁所标数字为该结点的平衡因子。因为平衡二叉树的每一个结点的左右子树的高度之差不超过1，可以证明它的深度和logn是同数量级的，因此它的平均查找时间复杂性为O(logn利用平衡二叉树进行查找，虽然可以较利用普通二叉排序树有更快的最坏情况查找速度，但是因为平衡二叉树附加了任一结点左右子树高度之差不超过1的限制条件，因此在构成平衡二叉树时或向平衡二叉树插人结点时，可能会使它失去平衡，就需要进行调整，以使其总能符合这个限制条件。为了说明在插人结点时，维持平衡二叉树时所涉及的各种处理，我们以数值序列（30,46,95,23,6,27,82)为例构造平衡二叉树，并分析其调整过程。插人30和46，结果产生图8.9(a）的平衡二叉树。当把95插人树中时，结点30的平衡因$Picture[00000200\00000200_new\0015.jpg]Picture$子变为一2，出现不平衡。为了使树重新平衡，执行一次旋转，使30成为46的左子结点，46成为树根，如图8.9(b)所示。插人23，树是平衡的，如图8.9(c）所示。然而，插人6时，就再度使树失去平衡。为了保持树的平衡，再执行一次旋转，这次是顺时针旋转。30变成23的右子结调整要比前面两次调整复杂一些。30成为树根，23连同其左子树一起成为30的左子树，30fh1匕与声为廿r.Pii7Zltt'旨与芬七睑_dR7t't乙七廿r.6'hqndhf与己igFfin日Isto，el6俘石芬i,1,fct.s2插人结点82时，树又失去平衡，调整82代替46成为子树的根，46变成82的左子树，46的右子树变成82的右子树，如图8.9（f）所示。在上述的例子中已看到，在平衡二叉树某个结点的左子树插人一个新结点，可能会使它失" ID="1">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="1）若原来其左子树高度与右子树高度相等，即原来此结点的平衡因子为0，插人新结点后" ID="2">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="3">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="飞$Picture[00000201\00000201_new\0004.jpg]Picture$$Picture[00000201\00000201_new\0010.jpg]Picture$$Picture[00000201\00000201_new\0012.jpg]Picture$$Picture[00000201\00000201_new\0013.jpg]Picture$$Picture[00000201\00000201_new\0015.jpg]Picture$$Picture[00000201\00000201_new\0017.jpg]Picture$$Picture[00000201\00000201_new\0019.jpg]Picture$RL‘二书＞(f)图8.9在平衡二叉树插人结点时指针变化情况" ID="4">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="2)若原来其左子树高度小于右子树高度，即原来此结点的平衡因子为一1，插入新结点后将使得平衡因子变为0，平衡更加改善，也不需要调整。如果给平衡二叉树某结点的右子树插人一个新结点，且此新结点使右子树的高度增加1,则也会出现上述三种情况。对于第1)种情况，平衡因子将由。变为一1，不需要调整。对于第" ID="5">
          <fptr EndPN="00000202" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="2)种情况，平衡因子由1变为。，也不需要调整。第3)种情况平衡因子由一1变为一2，需要进行调整。从图8.9所示情况我们已看到，当平衡二叉树失去平衡时。基本上是用4种不同的旋转" ID="6">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="I,L,LR,RR和RL进行调整使其重新达到平衡的。这些调整都是基于距插入结点最近而平衡因子为士2的结点（不妨将该结点设为A）进行的。可以证明，只要调整结点A的子树中的有关结点的链接关系，使之符合平衡条件，就不需要调整树中其他结点。上述4种调整的特征如下：" ID="7">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)LL型调整LL型调整指的是新结点插人A结点的左子树的左子树里，如图8.10(a)所示。图中矩形表示子树，矩形的高度表示子树的高度，带阴影的方形则表示插人新结点后造成子树高度加" ID="8">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="1，各结点旁所标数字为该结点的平衡因子。调整规则为，将结点B向上旋转代替A的位置，而令结点A向下旋转成为B的右子树的根结点，B的右子树成为A的左子树。此调整过程需" ID="9">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="要修改3个指针." ID="10">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)LR型调整LR型调整指的是新结点插人A结点的左子树的右子树里。调整是将结点B的右儿子C代替原来A的位置。因为结点C的关键字值大于结点B而小于A的关键字值，故将结点B和结点A分别变成C的左儿子和右儿子。原来结点C的左子树，其所有关键字值均大于结点B而小于结点C，将变成结点B的右子树；类似地，结点C的右子树成为结点A的左子树.这" ID="11">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="种调整需要修改五个指针，如图8.10&lt;b)所示。" ID="12">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)RR型调整RR型调整指的是新结点插人到A结点的右子树的右子树里，使得结点A的平衡因子由-1变为一2。调整规则为，将结点B向上旋转代替A的位置，而令结点A向下旋转成为B的左子树的根结点，B的左子树成为A的右子树。此调整过程与LL型调整过程对称，需要修改" ID="13">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="3个指针，如图8.10(c）所示。" ID="14">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)RL型调整RL型调整指的是新结点插人A结点的右子树的左子树重，使得结点A的平衡因子由一1变为一2。调整是将结点B的左儿子C代替原来A的位置。因为结点C的关键字值小于结点B而大于A的关键字值，故将结点B和结点A分别变成C的右儿子和左儿子。原来结点C占rat,-t二与pig+BE,全出,athf二乙iv+.w;因自f44F名曰七TDAal田自Ib+SFtv-4S！，闷L'iFi4二‘二liL个指针。如图8.10(d）所示。为进行这4种不同的旋转，就必须找到结点A。前面已说过，结点A就是平衡因子已成为士2，离新插人结点最近的那个祖先结点。一个结点的平衡因子要成为士2，那么，在插人之前，该结点的平衡因子必定为士i。而且，其平衡因子要变为士2的最近祖先结点，在插人前也是平衡因子为士1的最近祖先。因此，插人前，在A至新插人结点的路径上的所有结点的平衡数据结构" ID="15">
          <fptr EndPN="00000203" StartPN="00000202"/>
        </Paragraph>
        <Picture URL="00000203\00000203_new\0002.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0003.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0006.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0007.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0009.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0010.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0012.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Picture URL="00000203\00000203_new\0013.jpg">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Picture>
        <Paragraph CONTEXT="易地完成调整。在平衡二叉树上进行查找的过程与二叉排序树相同，但查找过程中和给定关键字值进行比较的次数不超过树的高度h，因此其查找所需时间为O(h&gt;。由于n个结点的平衡二叉树的高度h至多为O(logn)，因此，最坏情况下，在平衡二叉树上进行查找的时间复杂性为O(logn)," ID="16">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="192" TITLE="8.4.3 B-树" TYPE="Chapter">
        <fptr LogicalPageNum="203" PhysicalPageNum="203"/>
        <Paragraph CONTEXT="B-树是由R.Bayer和E.Maccreight于1970年提出的。它是一种平衡的多路查找树，广泛用在文件系统中." ID="1">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="·192一棵m阶的B-树，或者为空树，或者是满足以下特性的m叉树：" ID="2">
          <fptr EndPN="00000204" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="1)根是一个叶结点或者至少有两个子女。" ID="3">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="2)除了根结点和叶结点以外，每个结点有「m/2〕到m个子女。" ID="4">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="3)所有叶结点在树的同一层，因此树总是高度平衡的。" ID="5">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="4)所有非终端结点中包含下列信息：其中P,(0&lt;i&lt;n)是指向子树根结点的指针，K1&lt;i&lt;n)是关键字值，且KK，一1(1&lt;i&lt;n),指针P.所指字树中所有结点的关键字值均小于关键字值K.十：(0&lt;i&lt;n),P。所指子树中所有结点的关键字值均大于Knm/2〕一1&lt;n&lt;m-1)为关键字的个数。图8.11是一棵3阶B-树，每个结点包含两个关键字，终端结点最多有3个子女。在E树上进行查找的过程与在二叉排序树上的查找过程类似。为了在B一树中查找关键字为K的记录，首先取出根结点，使K依次同根结点中的每一个关键字进行比较，直到K&lt;K,$Picture[00000204\00000204_new\0015.jpg]Picture$(1&lt;i&lt;n)或K&gt;K。时为止.若K=K,，则表明查找成功，否则值为K的关键字记录必定在这个过程一直持续进行到查找成功或进行到叶子结点而查找失败为止。例如，在图8.11的3阶B-树上查找关键字值45。因45大于30所以应在P；所指的子树中继续查找；因45大于40，再在该结点P，所指的子树中继续查找；因45等于结点8的关键字K：的值，所以查找成功。查找不成功的过程类似。例如在图8.11所示的3阶仔树上查找值为27的记录。从根结点开始，因为27&lt;30，则沿该结点指针P。找到b结点；因为b结点只有一个关键字20，且20&lt;27，所以沿结点P，找到e结点；因为25&lt;27，沿结点e的P：往下找，此时P,为空，查找失败。在B树上插入类似于在二叉排序树上的插人，新元素也是放到相应的叶结点.与二叉排序树插人不同的是：在各树中不是创建新的叶结点，而是直接把关键字值插人到相应的叶结要对B-树进行进一步修改。例如，把关键字38插人到图8.11中的B-树.首先，从根结点开根据B-树的查找过程，38应添加到叶结点f中，由于f结点只有一个关键字值，所以它还有能容纳另一个关键字值的空间。因此，38作为右边的值加进来，数据结构空间可放新插人的值，需要进行结点的“分裂”。结点P可分裂成两个结点P和P1，它们的格式如下：" ID="6">
          <fptr EndPN="00000205" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="结点P:" ID="7">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="[m/21-1,Po,KP,K[m，,P[m/z1结点P/I！一〔m/21,P[m/21,K[m/21t1fP[m/21t1，一，Km,Pm余下的关键字值K[、z〕和指向新结点P‘的指针插人到结点P的双亲结点中。如果双亲结点的关键字个数未超过m-1，插人过程结束.如果双亲结点的关键字超过m-1，那么双亲结点也要进行“分裂”.在最坏情况下，这种从叶结点开始产生的分裂，要一直传递到根结点，使根结点产生分裂，从而导致树的高度增加一层.在图8.11所示的B-树中插人值55.对图8.11中的B-树进行一次查找就知道这个关键字值应插人到结点S中。然而，结点S已经含有（m-1)个关键字值.因此，结点8被分裂成两个结点8和8。关键字值50和指向8，的指针被插人到结点B的双亲结点c中。由于结点c只有一个关键字值，插人结束。于是得到图8.12(b)所示的B-树。从E树中侧除一个关健字值的情况也和在二叉排序树的删除类似.首先要经过一个从树根结点到被栩除关键字值所在结点的查找过程，然后再分情况进行删除。若被蒯除的关键字所在结点是叶子结点，且该结点的关键字数目不少于〔m/21，则关键字可从该结点直接删除.例如从图813(x)所示B-树中侧除关键字值K=58,除后的B-树如图8.13(b)所示.若被删除的关键字K,不在一个叶子结点中，只要以指针P。所指子树中的最小关键字值Y代替K;，然后在相应的结点中翻除Y。例如，若从图8.13(a）的B-树中侧除K=50，只要用结点f中的55代替50，然后从结点f中删除55即可。从B-树叶结点中删除一个关键字后，留下的关键字数目低于【m/2］一1，此时应分下列两种情况进行处理：" ID="8">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT=".194" ID="9">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Picture URL="00000206\00000206_new\0002.jpg">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Picture>
        <Paragraph CONTEXT="'20" ID="10">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Picture URL="00000206\00000206_new\0005.jpg">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Picture>
        <Paragraph CONTEXT="d20$Picture[00000206\00000206_new\0008.jpg]Picture$$Picture[00000206\00000206_new\0010.jpg]Picture$①若该结点的右兄弟（或左兄弟）结点中的关键字个数大于〔m/2〕一1。则需将其兄弟结点中的最小（或最大）的关键字值上移至其双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字值的关键字下移，移至被删除关键字所在的结点中.例如，从图8.13(b)结点8中删除关键字值K=65，留下的关键字数目小于「m/2〕一1。查看一下8的最近兄弟结点h，就可知道它有大于或等于〔m/2〕个关键字.然后把h中最小关键字值75，上移至双亲结点。，关键字值70则下移至结点8。经过这种变换后，8和h中的关键字个数大于等于〔m/2〕一1,。中" ID="11">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构②若该结点的右兄弟（或左兄弟）结点中的关键字个数均等于〔m/2］一1。在这种情况下，就无法从它的右兄弟（或左兄弟）中通过双亲结点调节到关键字以弥补自己的不足。假设该结点有右兄弟，且由双亲结点中的关键字P。指向其右兄弟结点，则在删除关键字之后，它所在结点中的剩余关键字和指针连同双亲结点中的关键字K，一起合并到右兄弟（若没有右兄弟，则合并到左兄弟）结点中，然后删除该结点。例如，从图8.13(c）的B一树中删除关键字值K=55;我们看到f的最近右兄弟结点g只有「m/2〕一1个关键字，而f没有最近左结点，则把该结点中剩余的关键字值（在此没有）和指针（在此为空）连同双亲结点中的关键字60一起合并到右兄弟结点中，然后将包含被删除关键字55的结fit删除。删除后的B-树如图8.13&lt;d)所示。" ID="12">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="196" TITLE="8.5 哈希表查找" TYPE="Chapter">
      <fptr LogicalPageNum="207" PhysicalPageNum="207"/>
        <div ORDERLABEL="196" TITLE="8.5.1 哈希表与哈希函数" TYPE="Chapter">
        <fptr LogicalPageNum="207" PhysicalPageNum="207"/>
        <Paragraph CONTEXT="前面介绍的各种查找算法都是基于比较的方法，在查找过程中都需要根据关键字进行若干次的比较判断，最后确定查找表中是否存在关键字值等于某个给定值的记录。查找的效率依赖于查找过程中所进行比较的次数。这一节提供一种与前面所述完全不同的方法：通过把关键字值映射到表中一个位置，从而根据记录的关键字值直接访问记录。把关键字值映射到表中位置的函数称为哈希函数，通常用h来表示。存放记录的数组称为哈希表，用T表示。哈希表T中单元的数目用变量M表示，哈希地址从。到M-1编号，哈希方法的目标是使得对于任何关键字值K和某个哈希函数h,0&lt;h(K)GM，得到key（T〔1〕）＝K.哈希方法不适用于允许多个记录有同样关键字值的应用程序，也不适用于范围检索。就是说，我们不可能很容易找到关键字值在一个特定范围的所有记录。也不可能找到最大或者最小关键字值的记录，或者按照关键码值的顺序访问记录.考虑一下相对于记录数目关键字范围很小的例子。例如，当有n个记录，每个记录有惟一的关键字，关键字值范围在0n-1。在这个例子中，带有关键字值i的记录可以存储在T[i]中，哈希函数只是h(k)=k。要找到带有关键字值i的记录，只要简单地查看T[i]一般来说，关键字范围中的值比哈希表中的单元多。考虑一个更为实际的例子，假定关键字可以取0-x65535范围内的任何值，而且需要存储将近1000个记录。在这种情况下使用一个带有65535个单元的哈希表是不可行的，其中大部分都会为空.因而，必须设计一个哈希函数，把记录存储在一个更小的表中。由于关键字的范围可能比表的大小大，至少有些位置可能映射多个关键字值。给定一个哈希函数h和两个关键字k，和kZ，如果h（k，）＝b＝h（k2），其中b是表中的一个位置，那么就说k：和k2对于函数h有冲突。在一个根据哈希方法组织的查找表中找到带有关键字值K的记录包括两个过程：①计算K在表中的位置h(K②从表中单元h(K）开始，使用一种冲突解决策略定位包含关键字值K的记录。一般说来，我们希望选择的哈希函数能够把记录以相同的概率分布到哈希表的所有单元中。换句话说，就是使关键字经过哈希函数得到一个随机的地址，以便使一组关键字的哈希地址均匀分布在整个哈希表中，从而减少冲突.下面介绍几种常用的哈希函数。196" ID="1">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)直接定址法直接定址法是以关键字值本身或关键字值加上某个数值常量。作为哈希地址的方法。即：直接定址法的优点是计算简单，如果关键字不重复，就不会发生冲突。其缺点是当关键字的分布不连续时，浪费存储空间。直接定址法适用于关键字的分布基本上连续的情况。&lt;2）除留余数法除留余数法是用关键字k除以不大于哈希表长度M的数P所得余数作为哈希地址。即：这是一种简单，也是最常用的构造哈希函数的方法。这种方法中P对哈希函数的好坏很关键。若P是关键字基数值的幂次，其结果哈希地址将只依赖与关键字的低位，如P取10，则哈希地址是关键字的个位数。若P取某个偶数值，其结果是偶数关键字的记录映射到偶数哈希地址，奇数关键字的记录映射到奇数哈希地址.因此产生的哈希地址是不均匀的。" ID="2">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）平方取中法平方取中法对关键字值取平方，然后取出结果的中间r位用于大小为10·的哈希表。由于与关键字值的大多数位都有关系，从而使哈希地址的分布较为均匀，减少了冲突的可能性。例如，若关键字K=1234,r=3，则KZ=1522756，哈希地址可取227," ID="3">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）折登法折叠法是首先将关键字分割成位数相同的几部分（最后一部分的位数可能会少一些），然后取这几部分的狡加和（舍去最高位进位）作为哈希地址的方法.例如，关键字k=187249653，要求每部分的长度为三位，则将此关键字从左到右分成187,249和“3,加和为089，此值就是k的哈希地址.折盛法适用于关键字位数较多，而且关键字中每一位上数字分布大致均匀时的情况。" ID="4">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="197" TITLE="8.5.2 处理冲突的办法" TYPE="Chapter">
        <fptr LogicalPageNum="208" PhysicalPageNum="208"/>
        <Paragraph CONTEXT="尽管哈希函数的目标是使得冲突最少，实际上冲突一般是无法避免的。这样，哈希方法的实现必须包括某种形式的冲突解决策略。冲突解决方法可以分为两类：链地址法和开放地址法。这两种方法的不同之处与冲突存储在表外（链地址法）还是导致把记录之一存储在表中另一个哈希地址（开放地址法）有关。" ID="1">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="&lt;1）链地址法链地址法是把哈希表中的每个单元定义为一个链表的表头.哈希地址是同一个单元的所有记录都存放到这个单元的链表中。表中每一个单元存储一个记录和一个指向链表其余冲突记录的指针。例如，考虑7个数存储在长度为10的哈希表中，使用的哈希函数是h&lt;K）二Kmod11,数的插人顺序是1090,9004,1656,5047,2948,1126,2866.生成的哈希表如图8.14所不。给定一个大小为M存储N个记录的哈希表，在理想情况下，哈希函数将把记录平均放在表中，使得平均每一个链表中有N/M个记录。在一个链表为空或者只有一个记录的情况下，查找只需要访问一次链表。这样，哈希方法的时间复杂性就是O&lt;1)。然而，如果聚集使得许数据结构" ID="2">
          <fptr EndPN="00000209" StartPN="00000208"/>
        </Paragraph>
        <Picture URL="00000209\00000209_new\0002.jpg">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Picture>
        <Paragraph CONTEXT="尹多记录哈希到有限的几个位置中，那么当必须查找链表中的许多元素时，访问一个记录的代价就很高." ID="3">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)开放地址法开放地址法把所有记录直接存储在哈希表中。每个记录i有一个基位置，即由哈希函数h&lt;K,）计算出来的位置。如果要插人一个记录R，而另一个记录已经占据了R的基位置，那么就把R存储在表中的其他位置，至于放在表中哪一个位置，则由冲突解决策略确定。查找时也要像插入时一样遵循同样的策略，以便重复冲突解决过程，找出在基位置没有找到的记录.在开放地址法中，当记录的基位置已经被占用时，那么冲突解决策略就会从发生冲突的基位置开始查找下一个位置。如果这个位置也被占用了，那么就必须找到另一个位置，如果这个位置也雄占用了，就找另一个位置，依此类推，这组在处理冲突的过程中得到的一组地址称为探查序列。寻找下一个位置的方法有多种，每一种都对应着一定的查找次序，都产生一确定的探测序列。寻找下一个位置可以描述为：其中d，为增量序列。根据d.的取值方法有下列解决冲突的方法.”线性探查法线性探查法是最简单的解决冲突的方法。如果记录的基位置被占用，那么就在表中下移，直到找到一个空位置。一旦到达表的底部，下一个探查的位置是表的开始处。也就是说，d1,2,3,…,M-1,例如，假设有5个记录，其关键字插入顺序是6415,3516,2948,1360和7117，使用的哈希函数是h(k)=kmod11。关键字2948在第。个位置，7117的哈希位置也为。，与2948冲突，按线性探查找下一个地址，即位置1，此位置是空的，故将7117置人。6415放到位置2,3516在表中位置7,1360的哈希地址也为7，与3516冲突，按线性探查法将其放到位置8,表中还剩下5个位置，如图8.15所示。0123456789吓948’1711716415I11’1｝35161’131111601’I图8.15线性探查示例利用线性探查法解决冲突时，当连续几个位置被占用时，紧接在它们后面的地址下一步被占用的可能性大大增加。例如，在图8.15中，如果下一个记录关键字的基位置是。，线性探查位置是3的记录自然要放到位置3。这样，下一个记录放到位置3的概率就是4/10。类似地，可以把哈希地址为7和8的记录放到第9个位置.只有哈希地址是4,5和6的记录其概率为1/10。更糟糕的是，如果下一个记录的哈希地址是9，那么接下来的记录放到第3个位置的概率将是7/10。因此，线性探查使记录的分布很不均匀，越是已被占用的位置集中的地方越是更加集中，造成“基本聚集”，小的聚集又能结合成大的聚集，聚集最终会导致很长的探查序列。为了避免聚集，可采用其他线性探查方法。我们可以以常数c而不是以1为步长寻找下一个位置。也就是说，第i次探查的位置是（h&lt;k)十ic)modM。通过这种方式，与基位置相邻的记录就不会进人同一个探查序列了。" ID="4">
          <fptr EndPN="00000210" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="2）伪随机探查考虑上述步长。=2的情况，想要插人一个记录，它的关键字是K：，h（K，）＝4。K，的探查序列是4,6,8等等.如果另一个关键字K：的记录的基位置是6，那么它的探查序列就是6,8,10等等.K，和K：的探查序列将链到一起，从而导致聚集。也就是说，步长为。的线性探查不能解决聚集问题。理想的探查序列应当在探查序列中随机地从未访问过的位置中选择下一个位置，即探查序列应是哈希表位置的一个随机排列。但是，实际上我们不能随机地从探查序列中选择一个位置，因为在查找关键字的时候不能建立起同样的探查序列。然而我们可以使用伪随机探查序列，在伪随机探查中，d，是1到M-1之间的“随机”数序列。所有插人和查找都使用相同的“随机”数." ID="5">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="3)二次探查消除聚集的另一种方法是二次探查，其d=iz，即二次探查第i次探查的位置是（h&lt;K）十iZ)modM,伪随机探查和二次探查都能够消除基本聚集，然而，如果两个关键字的基位置是同一个哈希地址，那么它们就会具有同样的探查序列。这是因为随机探查和二次探查产生的探查序列只是基位置的函数。如果哈希函数在一个基位置导致聚集，那么在伪随机探查和二次探查之下聚集仍然会保持下来，这称为二次聚集。" ID="6">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="4)再哈希法为了避免二次聚集，我们需要使得探查序列是原来关键字的函数，而不是基位置的函数。当发生冲突时，使用另一哈希函数计算哈希地址，这种方法称为再哈希法。其第i次探查的位置是i，h2(K)。这种方法不易产生聚集，但增加了计算时间。" ID="7">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="199" TITLE="8.5.3 哈希表的查找" TYPE="Chapter">
        <fptr LogicalPageNum="210" PhysicalPageNum="210"/>
        <Paragraph CONTEXT="给定关键字K，从哈希表中查找K的过程为：根据哈希函数求得基位置h(K)，若哈希表中此位置没有记录，则查找不成功；否则将该位置记录的关键字值与K比较。若和K相等，则查找成功；否则根据使用的冲突解决方法找下一个位置，直到哈希表中某一个位置为空或者表中记录的关键字值等于给定值K。其C语言实现为：" ID="1">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="算法S.6" ID="2">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="ElemTypehashsearch&lt;KeyTypeK)" ID="3">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="／二在哈希表中查找关键字为K的记录，／" ID="4">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="5">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构inthome;／二记录R的基位置＊／intpos=home=h(Kfor(i二l;key(T[pos!=K)key(T[posEMPTYiIpos=(home-f-d°om;/，计算下一个位置‘／if(key(T[posK)return(T[pos/，查找成功，／elsereturn-1;／二查找不成功‘／｝当在哈希表中未找到关键字为K的记录，可将该记录插人到哈希表中，插人过程为：算法8.7voidhashinsert(ELEMTYPER)／，在哈希表T中擂人记录R，其关键字为K｛inthome;/，记录R的基位置二／intpos=home=h(key(Rfor(i=1;key(T[pos!=EMPTYiF)谧pos=(home-d°om;/，计算下一个位置‘／if(key(T[poskey&lt;R)ERROR;/，不容许有重复记录，／｝T[pos］二R;/长插人记录R｝哈希法插人和查找过程都假定每个关键字的探查序列中至少有一个位置是空的，否则它们就会进人一个无限循环中。当哈希表为空时，插人的第一条记录总会找到它的基位置。这样找到一个空位置只需要一次比较。随着记录的不断插人，记录插人某个位置的可能性就会减小。如果一条记录在哈希表中已被占用，那么冲突解决策略必须能够找到另一个位置来存放它。如果要查找的记录没有存放在它的基位！，也需要进行比较。随着表的不断填充，越来越多的记录有可能放到离其基位置更远的地方.因此，哈希表的效率依赖于哈希表的填充程度。把哈希表的装填因子定义为Q=N/M，其中N是哈希表中当前记录的数目，M是哈希表的长度。直观地看，a越小，发生冲突的可能性就越小，反之，a越大，表明表中记录越多，在插人记录时，冲突的可能性就越大。令S，表示查找记录的比较次数，U。为查找一个不在哈希表中的记录时的比较次数，则有" ID="6">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="1）线性探查’U。、1/2(1-11-a)Z)" ID="7">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="2)随机探查、二次探查" ID="8">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="3)链地址法" ID="9">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="·200当从哈希表中删除一个记录的时候有两点要重点考虑：①删除一个记录一定不能影响后面的查找。这样，刷除过程就不能简单地把删除记录的位置标记为空，因为这样会影响后面记录的查找。例如，在图8.15中，关键字2948和7117的哈希地址都是第。个位置。根据冲突解决策略，把关键字7117放到第1个位置。如果从表中删除2948，对7117的查找必须仍然" ID="10">
          <fptr EndPN="00000212" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="②释放的位置应该为将来的插人使用。通过在被删除记录的位置上放一个特殊标记，这两个问题就可以解决。这个标记表明一个记录曾经占用这个位置，但现在已经不再占用了。如果在沿着一个探查序列查找到一个标记的位置，查找过程应继续下去.当在插人时遇到一个有标记的位置，这个位置可以用来存放新记录.然而，为了避免插人两个相同的关键字，查找过程仍然需要沿着探查序列找下去，直到找到一个真正的空位置为止。" ID="11">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="201" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="212" PhysicalPageNum="212"/>
      <Paragraph CONTEXT="组织和查找信息是大多数应用程序的核心，而查找是所有应用程序中最常使用的，查找方法的优劣对整个应用程序的效率影响很大。查找是在一组有特定值的记录中找到某个记录，或者找到值符合特定条件的某些记录。作为查找依据的那个域称为查找关键字。在元素集合中查找的方法和集合中元素的存储结构有很大关系.可以将查找方法分为四类：顺序方法、索引方法、树型方法和哈希方法。对于给定的关键字值，如果经过查找找到相应记录，则我们称此次查找是成功的，否则称此次查找是失败的。当查找失败时，有时需要将记录进行插人。顺序查找是查找的最简单形式。其思想是：从查找表的第一个记录开始，依次将每个记录的关键字值同给定值进行比较，直到找到与之相同者，查找成功，返回该记录所在位置。若直到所有记录都比较完毕，仍未找到与给定值相等的记录，表明查找失败。顺序查找的优点是对表中的记录的排列次序无任何要求，如需增加记录，只要将记录插在表的最后，不需要移动元素。其缺点是查找速度较慢。在一个未排序的查找表中顺序查找，时间复杂性是O(n)。对于重复查找大量记录，顺序查找慢得难以忍受。对于已排序的查找表，最常用的方法是折半查找。折半查找的每步都是将查找范围的中间位！的记录的关键字值与给定值进行比较，如果没有找到，这个位置的记录的关键字值使查找范围又缩小一半。故最差情况下比较次数为O(logn)。折半查找速度较快，但要求表中的记录必须有序。如果查找失败后需要将新记录插人到表中，则要花费相当长的时间移动记录。如果查找表中含有大量记录，按照关键字值的顺序访问所有记录，或是查找记录的关键字值在某个范围之内的所有记录，索引查找提供了很好性能。树型查找是利用二叉排序树来存放记录，查找过程首先将树根结点记录的关键字值与给定值进行比较，如果相等，查找成功，否则转向左子树或右子树继续查找。与折半查找类似，每次与树根结点比较之后，查找范围就限定在左子树或右子树中。由于插人只是将记录作为叶数据结构二叉排序树的查找过程的比较次数取决于树的高度，当二叉排序树的高度变为n时，其查找效率与顺序查找一样。为了防止二叉排序树的高度变为n，可以通过限制树的左、右子树的高度之差只能为一1,01-1来达到目的。如果二叉排序树的每个结点的左右子树的高度之差都限定在一1,0,E-1，则称为平衡二叉树。平衡二叉树的高度接近满二叉树的高度，因此平衡二叉树在最差情况下查找的时间复杂性为O(logn),为了保证平衡二叉树的结点的平衡因子满足条件，当向平衡二叉树插人结点后，破坏了平衡因子，需要调整。调整分为四种情况，分别是LL型、LR型、RR型和RL型。哈希查找是一种基于计算的查找方法。对“找到有关键字值为K的记录”形式的查找，哈希查找有很好的性能。哈希法是通过把关键字值映射到哈希表中一个位置来访问记录的，因此可以直接由关键字查找到记录。把关键字值映射到哈希表中位置的函数称为哈希函数，哈希函数的目标是使得冲突最少，实际上冲突一般是无法避免的。这样，哈希方法的实现必须包括某种形式的冲突解决策略。冲突解决方法可以分为两类：链地址法和开放地址法。这两种方法的不同之处与冲突存储在表外（链地址法）还是导致把记录之一存储在表中另一个哈希地址（开放地址法）有关。哈希方法不适用于允许多个记录有同样关键字值的应用程序，也不适用于范围检索。就是说，我们不可能很容易找到关键字值在一个特定范围的所有记录.也不可能找到最大或者最小关键字值的记录，或者按照关键字值的顺序访问记录。" ID="1">
        <fptr EndPN="00000213" StartPN="00000212"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="202" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="213" PhysicalPageNum="213"/>
      <Paragraph CONTEXT="8.1设给定的顺序表A=(10,20,30,40,50,60,70,80,90,100,110,120,130,140,150分别采用顺序查找算法和折半查找算法查找元素20，各需经多少次比较才能找到，六鲍撰愈榕刃翻丈习嵘，仑吩th的习么构喇峪乡仑琴宙欠毛之小，8.2用递归方式实现折半查找算法。8.3对1年中的12个月份构造一棵平衡二叉树。插人按MARCH,MAY,NOVEM-BER,AUGUST,APRIL,JANUARY,DECEMBER,JULY,FEBRUARY,JUNE," ID="1">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="OCTOBER和SEPTEMBER的次序进行。" ID="2">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="8.4将关键字50擂人到如下3阶B-树中." ID="3">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="8.5从下列3阶B-树中删去关键字50,8.6写出B-树的插人与别除算法。8假定哈希表有7个位置（编号从0-6使用哈希函数h(k)=kmod7和线性探查，将线性表（3,12,9,2)放到该表中，给出最后的结果哈希表." ID="4">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Picture URL="00000214\00000214_new\0002.jpg">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Picture>
      <Paragraph CONTEXT="8.8写出在哈希表中删除记录的算法。" ID="5">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="9" ID="6">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="第之尸章" ID="7">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="排序留犯脚谬峨卿动拥沙峨娜娜娜班圈娜邸明浑网排序是数据处理中经常使用的一种很重要的运算。排序的目的之一是方便查找和处理数据。从第8章的讨论中容易看出，若在排序的基础上对有序表进行查找，则可采用折半查找算法，其平均查找长度为O(logn)。而无序的顺序表只能进行顺序查找，其平均查找长度为（&lt;n+" ID="8">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="12，为O(n因此，为提高查找效率，排序是非常必要且经常使用的一种数据处理方法。这一章介绍几种常用的内排序方法，主要包括插入排序、交换排序、选择排序、归并排序和基数排序。所介绍的排序算法中，一些排序算法最差和平均情况下时间复杂性为O(nZ)。有" ID="9">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="204" TITLE="第9章 排序" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="204" TITLE="9.1 排序的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="215" PhysicalPageNum="215"/>
      <Paragraph CONTEXT="如果没有特别说明，本章中的待排序数据元素都是存储在数组中的一组记录。数组中的每一个记录都有一个域称为排序关键字，简称为关键字。这个关键字可以是任何一种可比的有序数据类型，例如，整数、实数、字符、字符串、或者别的更复杂的类型。给定一组记录R：,RRn，其关键字分别为kl,kZkn，排序就是将这些记录排成顺序为RRs,…,R，的一个序列S，该序列满足条件k&lt;k…&lt;kan.换句话说，排序就是按照关键字值重排一组记录，使记录的关键字值具有不减的次序。根据定义，排序中的记录可以具有相同的关键字值。当对具有相同关键字值的多个记录来说，如果一种排序方法不改变这些记录的相对顺序，则称所用的排序方法是稳定的，否则是不稳定的。如果排序过程中，待排序元素是存储在计算机随机存储器中，这种排序称为内排序。如果待排序元素太多，以至于内存中存放不下，可借助于外存。排序过程中需要不断地进行内存和外存之间的元素交换，这种排序称为外排序。本章只讨论内排序。本章在讨论各种内排序算法时，假定n个待排序记录存于一维数组a中，记录类型为EL-EMTYPE，而且我们也假设比较关健字的运算符已经有了定义。另外我们认为对于任何一种记录都可以找到一个取得它的关键字函数，记为key。算法中所用到函数swap用于交换两个记录的内容。通常，在排序的过程中需要进行下列两种基本操作：①比较记录关键字值的大小；②将记录从一个位！移动至另一个位置。因此在分析排序算法时，主要是衡量关键字之间进行比较" ID="1">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="的次数和记录的移动次数。" ID="2">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="205" TITLE="9.2 插入排序" TYPE="Chapter">
      <fptr LogicalPageNum="216" PhysicalPageNum="216"/>
        <div ORDERLABEL="205" TITLE="9.2.1 直接插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="216" PhysicalPageNum="216"/>
        <Paragraph CONTEXT="直接插人排序是一种最简单的排序方法。对n个待排序的记录来说，直接插人排序首先取出第二个记录，根据其关键字值将其插人到已排好序的记录中（第一个记录）；接着处理第3个记录，将其插人到前面已排好序的两个记录的合适位置；依此类推，直到最后一个记录，将其与前面已排好序的n-1个记录进行比较，并将其插人到正确的位置。下面是直接插人排序的C语言实现。" ID="1">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="算法9.1voidinsertsort(ElemTypeaintn)（" ID="2">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,temp;" ID="3">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=1;i&lt;n;i4{" ID="4">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="temp=a[i];" ID="5">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="j=i-1;whilej＞二0)&lt;key(a[jkey(temp厦" ID="6">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="a［j＋1〕＝a〔j〕；" ID="7">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="J一一；" ID="8">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="9">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="a[j11=temp;" ID="10">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="11">
          <fptr EndPN="00000216" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="｝考虑insertsort处理第i个记录的情况，a[01,a[11,…,a[i-11已经是排好序的记录序列。取出第i个记录将其暂存于变量temp中，temp依此与第1i-1,…,0)个记录比较，当temp的关键字值小于记录a[j」的关键字值时，就把记录a[j〕后移一个位置，temp接着同前一个记录比较，直到遇到一个关键字值比temp小或者temp与它相等的记录时，本次插人完成，因为再往前记录的关键字值一定都比它小了。数组的第j-1位置即为第i个记录的位置。直接插人排序过程如图9.1所示.直接插人排序由两个嵌套的循环组成。for循环总共执行n-1次，while循环执行次数依赖于在第i个记录前的i-1个记录中有多少个记录的关键字值大于第i个记录的关键字值。最差的情况是如果数组中记录是逆序的，每个记录都必须移动到数组的顶端。这时while循环共做i-1次比较。因此，比较次数最多为：数据结构" ID="12">
          <fptr EndPN="00000217" StartPN="00000216"/>
        </Paragraph>
        <Paragraph CONTEXT="1i=51730465682909515去i＝61730465682909515厂一－一－一一－一Ji=7图9.1直接插人排序说明万‘一O(nZ)如果数组中的记录是按关键字值从小到大排列的，在这种情况下，每个记录只做一次比较，没有记录需要移动.总的比较次数为n-1次，因此最好情况下直接插入排序算法的时间" ID="13">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="复杂性为O(n)在处理第i个记录时，第i个记录前的i-1个记录中哪些关键字值大于第i个记录的关键字值的记录都会引起while循环的执行。平均情况下，前i-1个记录中有一半记录的关键字值比第i个记录的关键字值大吕因此，直接插人排序平均时间复杂性是最差情况的一半，其时间复杂性仍为O(na因为比较一次就要交换一次，因此总的交换次数是总比较次数减去n-1，它在最好情况" ID="14">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="下为0，最差及平均情况下为O(nZ" ID="15">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="206" TITLE="9.2.2 折半插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="217" PhysicalPageNum="217"/>
        <Paragraph CONTEXT="前面介绍的直接插人排序算法中，第i次插人时，为了寻找第i个记录的插人位置，我们需要不断地与。一1-1的记录进,L't7顺序比较与交换。回顾8.2.2节介绍的折半查找算法，其性" ID="1">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="能优于顺序查找。因此，我们不妨利用折半查找方法来确定第i个记录的插入位置。如此进" ID="2">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="行的插人排序称为折半插人排序。其算法如下：算法，.2" ID="3">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="4">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="｝for&lt;j-i;j&gt;l;j一）a[j」一a[j-11;a[j]=temp;" ID="5">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="｝折半插人排序只是减少了关键字的比较次数，而记录的移动次数与直接插人排序相同。因此，折半插人排序的时间复杂性也为O&lt;nZ)," ID="7">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="207" TITLE="9.2.3 希尔（shell）排序" TYPE="Chapter">
        <fptr LogicalPageNum="218" PhysicalPageNum="218"/>
        <Paragraph CONTEXT="希尔排序又称缩小增量排序，是由D.L.Shell‘于1959年提出的。从对直接插入排序算法分析得知，直接插人排序算法的时间复杂性为O(nZ但是，若待排序记录为正序时，其时间复杂性变为O(n)。希尔排序试图将待排序记录变成“基本有序”，然后再调用直接插人排序来完成最后的排序工作.如果能正确实现，在最差情况下，希尔排序肯定具有比O(n2）好得多的性能。希尔排序基本思想是将待排序记录分成若干个“逻辑”子序列，每个子序列中的记录在整个数组中的间距（增量）相同.然后分别对每个子序列中的记录用直接插人排序方法进行排序。例如，设数组中的记录个数为偶数，希尔排序首先将它分成n/2个长度为2的子序列.如果数组有16个记录，下标为。^15，那么首先将它分成8个各有两个记录的子序列，第一个子序列记录的下标是。和8，第二个子序列记录的下标是1和g，，依此类推。第二次希尔排序将数组分成n/4个长度为4的子序列。第一个子序列的记录的下标为。,4,8,12，第二个子序列的下标是1,5,9,13,，依此类推，每个子序列仍然用直接插人排序。第三次将对两个子序列进行直接插人排序，其中一个包含数组中奇数位上的记录，另一个包含偶数位上的记录，最后一次将是一次完全的直接插人排序。图9.2中解释了对于一个含有16个记录的数组希尔排序的过程，其中记录间距分别为8,4,2和1,为了写出希尔排序算法，我们首先对直接插人排序算法进行修改，使其能对间距为gap的一组记录进行排序，修改后的直接插人排序算法如下。算法，.3voidinsertsort(ElemType*a,intmintgap)｛" ID="1">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,J,temp;for(i=gap;i&lt;n;igap){temp=a[i];" ID="2">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="J=i-gap;whilej＞二0)(key(a[jkey(temp{" ID="3">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="a[j+gaP]-a[j]" ID="4">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="J一＝gap;" ID="5">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="6">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Picture URL="00000219\00000219_new\0003.jpg">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Picture>
        <Paragraph CONTEXT="一比丰毕其其弃套圣到－" ID="7">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="－一～一." ID="8">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="4617415482682585630926071799590" ID="9">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="一抢兰全匕长七份分二长二长生j二二兰士创L＿_I」1_iIlILIIIa,I二IA" ID="10">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="4151726304648565860717982909295" ID="11">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="图9.2含有16个记录的数组希尔排序过程" ID="12">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="｝a[j-gap]=temp;｝｝" ID="13">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="一个实现希尔排序算法的C语言函数是，hellsort，它由两个嵌套的for循环组成，外层" ID="14">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="for循环控制增量，内层for循环对每个分组的记录进行直接插人排序。其中insertsort函数" ID="15">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="是上述修改过的直接插人排序。" ID="16">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="算法，.4voidshellsort(ElemTypeaintn)｛" ID="17">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j;" ID="18">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=n/2;i&gt;2;i2)/，增量序列为n/2,n/4,…,1二／" ID="19">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="for（j“0，j＜1；j＋＋）insertsorta[j],n-j,iinsertsort(a,n,l｝希尔排序中，开始记录之间间隔较大，分组较多，每个分组内的记录个数较少，因而记录的比较和移动次数也都较少。随着记录之间的间隔越来越小，分组也越少，每个分组的记录个数越多，但同时记录更加有序.经过每次对分组的处理使待排序的记录更加有序.因而记录的比较与移动次数也较少。因此与直接插人排序相比，希尔排序有较好的性能。" ID="20">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="插人排序是选择一个记录，根据其关键字的值将其插人到已排序记录的合适位置。插人排序主要有三种实现方法：直接插人排序、折半插人排序和希尔排序。" ID="1">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="209" TITLE="9.3 交换排序" TYPE="Chapter">
      <fptr LogicalPageNum="220" PhysicalPageNum="220"/>
        <div ORDERLABEL="209" TITLE="9.3.1 冒泡排序" TYPE="Chapter">
        <fptr LogicalPageNum="220" PhysicalPageNum="220"/>
        <Paragraph CONTEXT="冒泡排序又称起泡排序.其基本思想是先将数组中的第n-1个记录与第n-2个记录的关键字值进行比较，如果第n-1个记录的关键字值小于第n-2个记录的关键字值，则两个记录交换位置，否则不交换。然后比较第n-2个记录与第n-3个记录的关键字值，若第n-2个记录的关键字值小于第n-3个记录的关键字值，两个记录交换位置，否则不交换，…，依此类推，直到第1个记录与第0个记录进行比较。经过如此一趟的比较与交换，n个记录中关键字值最小的记录就会被交换到数组的第0个位置。此后，再对数组中位置1n-1的记录进然后再对n-2个记录重复上述过程，…，直到某一趟排序过程中不出现记录交换位置，排序结束.由于每一越排序具有最小关键字值的记录就向数组的顶部移动。就像水底的“水泡”冒到水面上一4695905682173015厂蕊蕊蕊认二下蕊i司IS469590568217一口1二I15ti7469590568230r一一门―-Ji=215173046上I" ID="1">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="i.41517304656829590" ID="2">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="粗" ID="3">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="i二S1517304656829095" ID="4">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="." ID="5">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="i=6IS17304656829095" ID="6">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="." ID="7">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="i二71517304656829095" ID="8">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="图9.3胃泡排序的工作过程" ID="9">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构冒泡排序算法比较容易理解和编程，但它不是一个高效率的算法。不考虑数组中记录的排列情况，冒泡排序的比较次数总将是1，因此冒泡排序的时间复杂性为：艺一。(nz)我们可以假定这个概率为平均情况下比较次数的一半，因此冒泡排序算法交换记录的时间复杂性也为" ID="10">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="O(n2)&lt;" ID="11">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="210" TITLE="9.3.2 快速排序" TYPE="Chapter">
        <fptr LogicalPageNum="221" PhysicalPageNum="221"/>
        <Paragraph CONTEXT="快速排序是一种基于“分治法”的排序方法。快速排序首先选择一个“基准值”，然后按照基准值调整其他记录的位里。假设数组中待排序的记录中有k个记录的关键字值小于基准值，于是，这些记录放在数组的最左边的k个位置上，而大于基准值的记录被放在数组最右边的n-k个位t上，这个过程称为一次划分。在给定划分中的点不必被排序，而基准值的位置就是下标k。第一次划分之后，再用相同的算法对“基准值”左右子序列分别进行类似的操作，其中一个子数组有k个记录，而另一个子数组有n-1-k个记录。即从每部分中选择一个基准值，将其划分成更小的两部分。依此递归地做下去，直至每个子序列中的记录个数均不超过一个为止，排序过程结束。“基准值”的选择有多种方法，最简单的方法是使用第一个记录的关键字值。但是，如果输入的数组是正序或者是逆序的，就会将所有的记录分到“基准值”的一边。较好的方法是随机选取“基准值”，这样可以减少由于原始输人对排序造成的影响，但随机选取“基准值”的开销较大。下面以第一个记录的关键字值作为基准值来看快速排序的过程。为了实现一次划分，可以从数组的两端移动下标，必要时交换记录，直到数组两端的下标相遇为止.为此，附设两个指针i与j，通过7从当前序列的右端向左扫描，越过不小于基准值的记录，当遇到小于基准值的记录时，扫描停止。通过i从当前序列的左端向右扫描，越过小于基准值的记录.当遇到不小于基准值的记录时，扫描停止。交换两个方向扫描停止的记录a[i」与a[j]。然后，继续扫描，直至i与J相遇为止.扫描和交换的过程结束.这时，i左边的记录的关键字值都小于基准值，右边的记录的关键字值都不小于基准值。下标1即为基准值记录的位置，图9.4给出了快乌古到卜良配，＿肠，知！篇冬从图9.4可以看出，作为基准值46，多次与别的记录进行比较与交换。为了节约运算时" ID="1">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="间，可先将其暂存于一个临时变量temp中，以后只移动其他记录，基准值不参与交换，直到" ID="2">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="i=j时才将其放人正确位t。图9.5给出了快速排序的全部过程，递归形式的快速排序算法的" ID="3">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="C语言实现为：" ID="4">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="算法，.6" ID="5">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="voidquicksort(ElemTypeaintpintq)" ID="6">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="7">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,temp;" ID="8">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="／，越过不小于基准值的数据‘／" ID="9">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="＆＆（j＞1））j一一；" ID="10">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="if&lt;j&gt;i){" ID="11">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="a[i]=a[j" ID="12">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="i／，越过小于基准值的数据，／whilekey(a[ikey（temp(i&lt;ji-F-" ID="13">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="if(i&lt;j){" ID="14">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="a[j]=a[ij一一；" ID="15">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="16">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="）a[i]=temp;if(pi-1))quicksort(a,p,i-1/，快速排序左子序列，／if((j-1)&lt;q)quicksort(a,j+l,q/，快速排序右子序列二／｝" ID="18">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="308290561795154630829056179515l5个j46个j" ID="19">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="82" ID="20">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="今1今1" ID="21">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="30829056179546基准值＝46" ID="22">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="153b肠卯561：958乏一［153017］46〔56。。，5：2个j.95个j19546宁i17l530179（）56肠9582790个i肠" ID="23">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="24">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="其中。n是一次划分所用的时间，。是一个常数。快速排序的平均情况介于最佳与最差情况之间。假设，在每一次分割时，基准值处于最终排好序的位置的概率是一样的，基准值将数组分成长度为。和n-1,1和n-2,…的概率都是1/n。在这种假设下，快速排序算法的平均时间复杂性为：1/n艺(T(kT(n一卜kT(0）一c,T(1）一cT(n)=cn-" ID="25">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="这是一个递归公式。算法所花费的时间，根据公式所推算出来的时间为O&lt;nlogn)。因此，快速排序平均时间复杂性为O(nlogn),快速排序需要栈空间来实现递归，如果像上述分析所说，数组按均等方式被分割时，则最大递归深度为logn，需要的栈空间为O&lt;logn)。最坏的情况是，在递归的每一级上，数组分割成长度为0的左子数组和长度为n-1的右子数组.在这种情况下，递归的深度就成为n,需要的栈空间为O(n" ID="26">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="212" TITLE="9.4 选择排序" TYPE="Chapter">
      <fptr LogicalPageNum="223" PhysicalPageNum="223"/>
        <div ORDERLABEL="212" TITLE="9.4.1 简单选择排序" TYPE="Chapter">
        <fptr LogicalPageNum="223" PhysicalPageNum="223"/>
        <Paragraph CONTEXT="简单选择排序的基本思想是第i次选择数组中第i小的记录，并将这个记录放到数组的第1个位置。换句话说，选择排序首先在n个记录中寻找关键字最小的一个记录，将其放在数组中第一个位置，然后在余下的n-1个记录中再寻找关键字值最小的，将其放在数组中第二个位置，如此做下去，进行n-1次选择后，排序过程结束.图9.6给出了简单选择排序过程。算法的C语言实现为：算法，.7" ID="1">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="voidselectsort(ElemTypeaintn)" ID="2">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="3">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k;" ID="4">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i=O;i&lt;n-1；1＋＋）｛" ID="5">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="k=i;" ID="6">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j=i十1；j＜n；j＋＋）if(key(a[jkey(a[kk=j;｝" ID="7">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="8">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="·212$Picture[00000224\00000224_new\0002.jpg]Picture$i=6151730465682图9.6简单选择排序的一个示例简单选择排序共需要进行n-1次选择与交换，每次选择共需进行n(n-12次比较，因此简单选择排序的时间复杂性为O(nZ)。此算法比较独特的地方是交换次数少。在寻找下一" ID="9">
          <fptr EndPN="00000224" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="个较小关键字的记录时，需要查找整个未排序的序列，但是只用一次交换即可将待排序记录放到正确位置，这样最多要用n-1次交换." ID="10">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="213" TITLE="9.4.2 堆排序" TYPE="Chapter">
        <fptr LogicalPageNum="224" PhysicalPageNum="224"/>
        <Paragraph CONTEXT="堆排序是借助于堆数据结构的一种排序方法，堆由两个性质来定义。首先，它是一个完全二叉树，所以往往如第6.2.3节用数组表示完全二叉树那样用数组来实现。其次，结点的值与其子结点存储的值之间存在某种关系。父结点与子结点存储的值关系的定义不同，导致有两种不同的堆：最大值堆和最小值堆。最大值堆的性质是堆中任意一结点的值都大于或者等于其任意一个子结点存储的值。由于根结点包含大于或者等于其子结点的值，而其子结点又依次大于或者等于各自子结点的值，所以根结点存储着所有结点的最大值。最小值堆是堆中每一个结点存储的值都小于或者等于其任意，个子结点存储的值。由于根结点包含小于等于其子结点的值，而其子结点又依次小于或者等于各自子结点的值，所以根结点存储了所有结点的最小值。基于最大值堆排序算法的思想是首先将待排序记录建成堆，然后将堆顶的关键字值最大的记录输出，再对剩下的记录重新建堆，再取出堆顶记录，…，如此下去，便得到一个有序序列。由此，实现堆排序需要解决两个问题：①如何由一个无序记录序列建成一个堆？②如何在输出堆顶记录之后，调整剩余记录成为一个新的堆？下面首无讨论第一个问题，可以采用两种方法建立堆.一种方法是从根结点开始把记录一个接一个地插人到堆中。因为堆必须保持完全二叉树的形状，为此在插人记录时，首先将插人记录置于堆的末尾。当然，此时该记录所在结点可能不在正确的位置，将其与其父结点相比数据结构" ID="1">
          <fptr EndPN="00000225" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="结点到达其正确的位置为止。由于插人的结点可能要从树的底部移动到树的根部这个最长距离，因此插人一个记录需要的时间代价为O&lt;logn)，因而插人n个结点的时间复杂性为O&lt;nlogn)另一种更高效的建堆方法是先把所有记录按输人次序置人完全二叉树的各结点中，然后由下而上逐层进行父子结点值的比较，并利用一种称为“筛”的运算进行互换调整，直至使其最后完全满足堆的性质。下面讨论对某个分支结点进行“筛”运算的过程.假设以此结点为根的左、右子树都已经是堆，并且根的记录名为R，序号为i，在这种情况下，有两种可能：①记录R的关键字值大于或等于其两个子结点所存储记录的关键字值，此时，以R为根的子树已经是堆，不需调整；®R的关键字值小于其某一个或全部两个子结点所存储记录的关键字值，此时R应与两个子结点中值较大的一个交换，结果得到一个堆，除非R仍然小于其新子结点的一个或全部两个的值。在这种情况下，只需要继续将R“筛”下去，直至到达某一层使它大于它的子结点，或者它成了叶结点，函数siftdown实现上述“筛”过程。" ID="2">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="算法9.8" ID="3">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="intsiftdown(inti,intn)" ID="4">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="5">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="intt,j;" ID="6">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="j=2*i1;" ID="7">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="while(j&lt;n)" ID="8">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="比较，／" ID="9">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="if(key(a[ikey(a[jreturn0＊父子结点比较，／" ID="10">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="swap(a[i],a[j;/，交换交子结点，／i" ID="11">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="j=2*i-1;｝｝由于叶子结点已经处在最底层，它不能再往下筛了，因此建堆的算法从完全二叉树的第一" ID="12">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="个分支结点开始，不断调用筛过程。建堆过程的C语言实现为：" ID="13">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="算法，.，intbuildheap(ElemTypeaintn)｛for(i=n/2-l;i0;i一一）siftdown(i,n｝当堆建成之后，堆顶记录的关键字值最大。为了节约存储，我们将堆顶记录取出放在堆的最后一个位置.假设n个记录存于数组的。n-1个位置上，当将堆顶记录取出时，应该将它放到数组的第n-1位置，将n-1位置的记录换至堆顶。这时堆中的记录个数为n-1个，新根结点的值可能不是新堆中的最大值，需对根结点做一次筛运算，就又形成了一个堆.将堆顶记录与数组的第n-2位置上的记录进行交换，再进行调整。由堆中取出的记录越来越多，堆录中的最小值，堆排序过程全部结束。图9.7给出了堆排序部分过程。、" ID="14">
          <fptr EndPN="00000226" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="Al！除90" ID="15">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Picture URL="00000226\00000226_new\0005.jpg">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Picture>
        <Picture URL="00000226\00000226_new\0007.jpg">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Picture>
        <Picture URL="00000226\00000226_new\0008.jpg">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Picture>
        <Paragraph CONTEXT="图9.7堆排序步骤" ID="16">
          <fptr EndPN="00000226" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="按照上述算法，得到实现堆排序的函数heapsort。函数首先调用建堆函数buildheap，将n个待排序记录建立一个初始堆，然后函数heapsort重复执行n-1次swap和siftdown进行堆排序。·215数据结构" ID="17">
          <fptr EndPN="00000227" StartPN="00000226"/>
        </Paragraph>
        <Paragraph CONTEXT="算法，.10voidheapsort(ElemTypeaintn)《" ID="18">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="buildheap(a,n);" ID="19">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i二0；1＜n；1＋＋）｛" ID="20">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="swap(a[ia［一一n" ID="21">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="siftdown(O,n-i-1｝" ID="22">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在整个堆排序过程中，构成堆要进行n/2次筛运算，堆排序要进行n-1次筛运算，每次筛运算比较次数与交换次数都不会超过完全二叉树的高度。因此，整个堆排序过程的时间复杂性是O(nlogn)" ID="23">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="216" TITLE="9.5 归并排序" TYPE="Chapter">
      <fptr LogicalPageNum="227" PhysicalPageNum="227"/>
        <div ORDERLABEL="216" TITLE="9.5.1 两个有序文件的归并" TYPE="Chapter">
        <fptr LogicalPageNum="227" PhysicalPageNum="227"/>
        <Paragraph CONTEXT="归并排序是一种想法很简单的排序方法。在讨论如何进行归并排序之前，先来看看如何将两个有序表合并成一个有序表的过程。将两个有序表和并成一个有序表的过程称为归并。将两个已排序的表合并成一个有序表的算法是很简单的。假定待归并的两个有序表分别存于数组a中从下标s到m和从下标m-i-1到下标t的单元中，合并后得到的一个有序表存于数组b中，下标从s到t。令i,j分别为数组a中第一个有序表和第二个有序表待处理元素的下标，k为数组b中下一个待存人元素单元的下标。初始时，i,j,k分别指向各个表的第一个单元。归并过程为：比较a[i〕与a[j]，若a[i〕小于等于a口〕，则将a[i〕复制到b[k〕中，并令i和k分别加1，分别指向下一个单元；否则将元素a[j〕复制到b[k〕中，并令j和k分别加1，如此循环下去，直到其中的一个有序表比较和复制空；然后再将另一个有序表中剩余的元素复制到b中，从下标k到下标t的单元。图9.8给出了将两个有序表合并成一个有序表的过程.其c语言实现：" ID="1">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="算法，.11voidmerge(ElemTypeaElemTypebints,intmintt)｛" ID="2">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k;" ID="3">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="i=s;j=m-f-l;k=s;while((i＜二m）＆＆（j＜＝士））｛" ID="4">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="if(key(a[ikey(a[j" ID="5">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="else{" ID="7">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="·216" ID="8">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="b[k]=aCi7;" ID="9">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="j＋十；" ID="10">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="11">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="k" ID="12">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="13">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="while&lt;im){" ID="14">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="b[k]=a[i" ID="15">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="i" ID="16">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="k十＋；" ID="17">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="while（j＜片t）｛" ID="19">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="b[k]=a[j" ID="20">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="j十十；" ID="21">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="k" ID="22">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="23">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="｝(a）归并前的两个有序表，有序表1的下标为。,1,2，有序表2的下标为3,4,5,6,7" ID="24">
          <fptr EndPN="00000228" StartPN="00000228"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="217" TITLE="9.5.2 归并排序" TYPE="Chapter">
        <fptr LogicalPageNum="228" PhysicalPageNum="228"/>
        <Paragraph CONTEXT="归并排序就是利用归并过程进行排序，首先将n个记录看成为n个长度为1的已排序子$Picture[00000228\00000228_new\0002.jpg]Picture$把这些子表成对地合并，得到n/2个长度为2的子表。然后又将这n/2个子表成对地合表。并，得到n/4个长度为4的有序表，…，如此重复做下去，直到只有一个长度为n的有序表为止，上述一次归并过程称为一趋.图9.9给出了对含有8个数的归并排序过程.第一行给出的是8个待排序的数，归并排序首先将待排序数分成8个长度为1的有序表.第二行是进行第一趟归并后的4个长度为2的有序表。第三行是对第二行的4个有序表进行归并后，形成的2个长度为4的有序表。第四行是对第三行的2个长度为4的有序表进行归并后，最后形图9.9归并排序步骤说明数据结构中每个有序表的长度为1，进行两两归并后，形成一些长度为21的有序表，并把结果存于数组b中。如果n不是21的整数倍，虽然前面进行合并的有序表长度均为1，最后不可能再剩下一对长度都是1的表。此时，出现两种情况，一是剩下一个长度为1的表和一个长度小于1的表，仍可调用merge将两者合并。。二是只剩下一个表，它的长度小于等于1，由于没有另一个表与它合并，只能将它直接抄到数组b中准备参加下一趟的合并过程。进行一趟归并算法的C语言实现为：" ID="1">
          <fptr EndPN="00000229" StartPN="00000228"/>
        </Paragraph>
        <Paragraph CONTEXT="算法9.12voidmergepass(ElemTypeaElemTypebintmint1)咬" ID="2">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="intp,t;P＝;P为每一对待合并有序表的第一个单元下标，初值为1二／whilen-p＋1）＞＝2，1）（merge(a,b,p,p-1-1,p+2*1-1个表的下标从P到（p1-1)，第二个表下表从（p+1)到（p-f-21-1)，结果存人数组b私/p＝p＋2，1；／‘p向后移21，准备下一次合并＊／乒" ID="3">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="ifn-p+11)merge(a,b,p,p+1-l,n/‘长度为1的表与长度小于1的表合并，／else/，将剩下一个长度不大于1的表抄到数组b中，／fora二p；1＜n；1＋＋）b〔ij＝a［1〕；｝整个归并排序要进行许多趟’，第一趟有序表的芳度1为1,以后每一趟有序表的长度I加倍。＿.设待排序记录存在数组“中，第一趟归并的结果放人数组b中。第二趟对数组b的有序表进行归并，结果放人数组a中，如此反复进行。归并排序的C语言实现为：算法，.13voidmergesort(ElemTypeaintn)咬" ID="4">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="int1;" ID="5">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="wciiie气inn)t" ID="6">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="、卜－" ID="7">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="mergepass(a,b,n,1);" ID="8">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="1=2共1;" ID="9">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="mergepass(b,a,n,l);" ID="10">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="1二2*1;" ID="11">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="｝n1LA7行归并排序，需要归并的趟数是‘ogn。而在对“个长度为‘的数组归并，需要。步，对n／2个长度为2的数组归并，需要n步，…，依此类推。每一趟归并都需要0（n）的时，218·" ID="13">
          <fptr EndPN="00000229" StartPN="00000229"/>
        </Paragraph>
        <Paragraph CONTEXT="间，因此归并排序的时间复杂性为O(nlogn)o归并排序需要一个与原数组一样大小的辅助数组，所以其空间复杂性为（n)" ID="14">
          <fptr EndPN="00000230" StartPN="00000230"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="219" TITLE="9.6 基数排序" TYPE="Chapter">
      <fptr LogicalPageNum="230" PhysicalPageNum="230"/>
      <Paragraph CONTEXT="前面所介绍的几种排序方法都是根据关键字值的大小而实现的。本节则讨论按组成关键字的各位值进行排序的一种方法。考虑关键字值范围为0”的一个序列，将关键字K理解为由两个关键字（KKZ）组成，其中K'为十位数，KZ为个位数。假如有10个盒子，首先以关键字的个位为标准将记录放到10个不同的盒子中。然后，按照顺序从盒子中收集这些记录，接着，根据关键字的十位数的值将它们再放人到盒子中，并收集它们。每个盒子中的记录都链接成一个链接表，F[i〕是指向第i个盒子中第一个记录的指针，E[i」是指向第i个盒子中最后一个记录的指针，图9.10展示了这种过程。在这个例子中，盒子数r=10，待排序的关键字个数为10，关键字值介于。一rZ-1之间，各个关键字以个位的大小顺序放人盒子中。然后再按照较左边一位的大小重排，…，依此类推，直到最左边的一位处理完毕，这种排序称为基数排序。因为它是基于对关键字的某个位来分配盒子，这个排序方法可以扩展到对任意位长的关键字进行比较。我们从最右边的位开始，到最左边的位为止，每次按照关键字某位的数字把它分配到盒子中。如果关键字有k位数，那么就需要进行k次分I，上述基数排序称为基10排序。若关键字的分解利用关键字的二进制表示法进行，便可得基2排序.一般来说，可以选用任一基数r，得到基r排序，这时需要的盒子数为r,对于n个记录的序列，假设基数是r，对n个记录进行一次分配的时间为O(n+r)，如果关键字有k位，则需要k次分配工作，因此总时间为O(k&lt;nr。在对数值数据进行排序时，k的值取决于对基数r的选择，同样也取决于最大的关键宇的值.对于不同的基数r所用的时间是不同的。" ID="1">
        <fptr EndPN="00000230" StartPN="00000230"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="219" TITLE="9.7 各种排序方法的比较" TYPE="Chapter">
      <fptr LogicalPageNum="230" PhysicalPageNum="230"/>
      <Paragraph CONTEXT="性，③稳定性。三种简单的排序方法：直接插人、直接选择、冒泡排序时间复杂性均为O&lt;nZ)。堆排序、快速排序和归并排序这兰种排序方法的平均情况的时间复杂性是O(nlogn)。希尔排序介于O(nz）与O&lt;nlogn)之间。但在最坏情况下，快速排序的时间复杂性为O(nZ)。最坏情况对其他排序方法影响不大。从空间复杂性看，归并排序的空间复杂性为O&lt;n)。快速排序的空间复杂性为O(logn),但快速排序在最坏情况下的空间复杂性为O&lt;n)，其他排序方法的空间复杂性为O&lt;U各种排序方法中，直接插人、冒泡和归并排序是稳定的，直接选择、快速排序和堆排序是不·219数据结构国恒沁获外巨乎匡随弓匡随弓国$Picture[00000231\00000231_new\0003.jpg]Picture$E[01E[11E[21E[31E{41" ID="1">
        <fptr EndPN="00000231" StartPN="00000230"/>
      </Paragraph>
      <Paragraph CONTEXT="一、" ID="2">
        <fptr EndPN="00000231" StartPN="00000231"/>
      </Paragraph>
      <Paragraph CONTEXT="1，.F[O]FF[21F[3JF[41F(51F[61F[7JF[81F[91区距弓巨工巨工巨工区比弓邑邑包E[O]E[11E[21E[31E[41E[51E[61E[71E[81E[91F[01F[11F[21F[31F[41F[51F[61F[71F[81F(91国扭互弓回坯矩砚虱邑巨工国图9.1。一个基数排序的例子，此例中的数字为两位数，aa.w日31祀5f出.ca百J拍日】1c巴纽Ge稳定的。除了基数排序以外，本章介绍的所有的排序算法都决定于两个关键字的直接比较。例如，冒泡排序不断地比较相邻记录的关键字值，直到升到正确的位置.相反地，基数排序并没有直接比较关键字的值，而是取决于关键字值中各位数字的值。实验数据表明，基于比较的排序算法是较好的。对于任何基于比较的排序算法来说，在最坏情况下能达到的最好的时间复杂性为O(nlogn),综上所述，在本章讨论的排序方法中，没有哪一种是绝对最优的.有的适用于n较少的情片的牛苦田月p”右吞十的右含刃＿1纷二旦二去田门件排良招寻主尤＊右良的水合刃幽盆竺FFIiWft;l'Bar田寸一勺习日气r排序是数据处理中经常使用的一种很重要的运算。排序就是重排一组记录，使其关键字的值具有不减的次序。插人排序逐个处理待排序的记录，每个新记录与前面已排好序的子序列中记录进行比较，将它插人到子序列中合适的位置。冒泡排序包括一个简单的双重for循环，每一趟的内循环从待排序记录的底部比较到顶部，比较相邻记录的关键字值。如果下面的关键字值比其上面相邻的关键字值小，则将二者交换，如此反复做下去，最小关键字值的记录就会被推到顶部。选择排序第i次是选择记录中第i小的记录，并将这个记录放到数组的第i个位置。换句话说，选择排序首先从未排序的序列中找到最小关键字值记录，接着是次小的，如此反复找出较小的关键字值记录，直到排序完成，它的特点是很少交换。插人排序、选择排序和冒泡排序的平均及最差情况下的时间代价都是O(nZ)希尔排序试图将待排序序列变成“基本有序”，然后再用直接插人排序来完成最后的排序工作。希尔排序是这样来分组并排序的：将序列分成为互不相连的子序列，子序列的元素在整个数组中的间距相同，然后分别对子序列用插入排序方法进行排序.另一组子序列也是如此选取，然后排序，…，依此类推。当最后一次调用擂人排序时，记录已基本有序了。因此，希尔排序比直接插人排序效率高.快速排序是一种基于“分治法”的排序方法。首先选择一个“基准值”，按照基准值调整其他记录的位置，将记录分成两部分，而基准值的位置就是它最终的位置。以后的排序只在划分的每部分里进行，两部分之间不会再有记录的交换。一次划分之后，再用相同的算法对“基准值”左右两部分进行类似运算，依此递归地做下去，直至每个子部分中的记录个数均不超过一个为止，排序过程结束.如果输人的数据是正序或者是逆序的，选择第一个记录的关键字值作为基准值就会将所有的记录分到“基准值”的一边石较好的方法是随机选取“基准值”，这样可以减少由于原始输入对排序造成的影响，但随机选取“基准值”的开销较大。也可采用将中间记录的苯键字值作为基准值。归并排序也是基于分治法的。它不断地利用将两个有序表合并成一个有序表的归并过程。它首先将n个记录看成n个长度为1的有序表，这些有序表被归并成n/2个长度为2的有序表，然后是长度为4的，…，依此类推。归并排序的运行时间并不依赖于待排序记录的原始顺序，这样，它就避免了快速排序的最差情况。堆排序是一个基于完全二叉树结构的排序算法。首先将存于数组中的记录转化为一个满足堆定义的序列；然后将堆顶的最大元素取出，再对剩下的记录排成堆，再取堆顶数值，…，如此下去，直到堆为空。堆排序有许多优点：①整个树是平衡的；②它的数组实现方式对空间的利用率也很高。基数排序是利用多次分配和收集过程进行的排序。它基于关键字的某个位将关键字分配数据结构某位的数字把它分配到盒子中，然后按顺序将它们再收集在一起。如果关键字有k位，那么就搜套习万卜协，寸斗沼签二乙2、丽口名八翻由J续沈‘.护、2，JJ】】乙JZJ曰目了、佑叼‘J.夕际应用选择合适的排序算法。" ID="3">
        <fptr EndPN="00000233" StartPN="00000231"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="221" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
      <div ORDERLABEL="222" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="233" PhysicalPageNum="233"/>
      <Paragraph CONTEXT="9.1当待排序的记录含数据量很大时，进行记录的移动或交换花费较长时间，而采用链表往往可提高运算速度。请写出以单链表为存储结构的直接插人排序算法.9.2对冒泡排序做习题9.1,9.3冒泡排序的某一趟如果没有记录交换，则说明记录已排好序。修改冒泡排序算法，当没有记录交换时，结束排序。9.4在9.3.2节介绍的快速排序算法总是将第一个记录的关键字值作为基准值，如果输入的记录是正序或逆序的，就会将所有的记录分到基准元索的一边。一种较好的方法是选取中间记录的关键字值或随机选取记录的关键字值作为基准值，写出这种选择基准值的快速排序算法。" ID="1">
        <fptr EndPN="00000233" StartPN="00000233"/>
      </Paragraph>
      <Paragraph CONTEXT="9.5下面的各个操作中，哪一个最适用于先进行排序处理？对于这些操作，写出其实现" ID="2">
        <fptr EndPN="00000233" StartPN="00000233"/>
      </Paragraph>
      <Paragraph CONTEXT="的算法.并分析算法的时间复杂性。" ID="3">
        <fptr EndPN="00000233" StartPN="00000233"/>
      </Paragraph>
      <Paragraph CONTEXT="⑥找最小值" ID="4">
        <fptr EndPN="00000233" StartPN="00000233"/>
      </Paragraph>
      <Paragraph CONTEXT="⑥找最大值⑧找中间值印计算算术平均值9.6简单选择排序的最少交换次数为O(n)。因为算法并不检查第i个记录是否已经在第i个位置；这就是说，那可能带来不必要的交换，改进算法以使之消除不必要的交换。这种改进能加快排序速度吗？万即随班朋幽吸娜脚翻缈璐级涸梦戮脚邵或鲜纯瞬阴澎吸梦脚哪酗燕睡盛沙艇净曦娜娜此瞬雄瞬截多螂坎攀汽形典凑吻娜那拥沙烟脚孽肋孚处溯更孚触蹄沁孚闷脚戮卿哪砍彭姻前面几章的介绍仅涉及主存中的数据，在实际的操作过程中，由于受计算机的内存容量的限制，必须把大量的记录数据集合存放在外存中。习惯上称存储在主存储器（内存夕中的记录集合为表，称存储在辅助存储器（外存）中的记录集合为文件。文件在数据处理方面，尤其是事务型的软件编制工作中具有很重要的意义.通过文件可以有效地组织数据，提供方便而又高效地利用数据信息的方法。本章介绍文件在外存储器中的表示方法及其各种运算的实现方" ID="5">
        <fptr EndPN="00000234" StartPN="00000233"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="223" TITLE="第10章 文件" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="223" TITLE="10.1 外部存储设备" TYPE="Chapter">
      <fptr LogicalPageNum="234" PhysicalPageNum="234"/>
        <div ORDERLABEL="223" TITLE="10.1.1 磁带" TYPE="Chapter">
        <fptr LogicalPageNum="234" PhysicalPageNum="234"/>
        <Paragraph CONTEXT="计算机的1／0磁带在原理上与录音机磁带类似，是一条涂有一层磁性材料的窄带.数据录制在宽约1／2英寸（约合12mm）、长约2400英尺（约合731m）的磁带上。该磁带表面平行地涂有7至9条磁道，盘绕在一个卷盘上。磁道上的每个点都可以作正、反方向磁化，并用来代表二进制的。和1.各磁道上的。和1的组合则可用来表示一个字符。磁带上的信息密度一般为160ObPi（每英寸位数），移动速度为300英寸／秒。把磁带装人徽带机。当需要读写数据时，开动磷带机，收受卷盘转动，带动磁带前进。当" ID="1">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="收受卷一可（‘）（·夕卜一源卷" ID="2">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="图1O.1磁带运动示意图" ID="3">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构磁带机不是连续运转设备，而是启停设备，启停时间约为5ms。在磁带停止后再行启动。要经过一个加速过程才能达到正常读写速度；反之，在读出或写完一个字符组后，要经过一个加速过程才能完全停止。所以，在字符组之间要留有间隙，通常为1/4-3/4英寸。为了有效地利用磁带，常常不是按用户给出的字符组记人磁带，而是将若干个字符组合并成块后一次写人磁带。因而在字符组之间就不再有间隔，只在块间才有间隔IBG(InterBlockGap)，一般约为3/4英寸（如图10.2所示）.成块之后，可以减少耗时的I/O操作。为了加快读写速度，通常在内存中开辟输人输出缓冲区。正常情况下，一次读写总是读满缓冲区，或把缓冲区内容全部写到磁带上，因此磁带的存储块长度取决于缓冲区的长度。由于间隔的存在，块越长，存储效率就越高，读写速度就越快，要求内存缓冲区也越大，但是内存中可作为I/O缓冲区的总容图10.2一条磁带上的数据块磁带是一种典型的顺序存取设备。存取时间取决于读／写磁头的当前位置与所读信息的位置之间的距离。距离愈大，所需时间愈长。比如读／写磁头当前位于磁带的第一块，而所要存取的数据在第i块，那么磁带必须向前移过（i-1)块才能进行存取；如读／写磁头当前位于第雨僻名的士觅协占＿公愉去知林裔惜自誉容不庙田，冲撇泌＿努田不左胳翻赫细亦粉／.，目口" ID="4">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Picture URL="00000235\00000235_new\0018.jpg">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Picture>
        <Paragraph CONTEXT="因此，磁带一般用于存储和处理变化少且只进行顺序存取的大量数据。" ID="5">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="224" TITLE="10.1.2 磁盘" TYPE="Chapter">
        <fptr LogicalPageNum="235" PhysicalPageNum="235"/>
        <Paragraph CONTEXT="磁盘是一种直接存取的存储设备，读／写磁头可直接移到要进行读／写信息的磁盘任何位置上，不仅可以进行顺序存取，还可以直接存取任一记录，其存取速度比磁带快得多。磁盘有硬盘和软盘两种.硬盘与软盘相比，不仅容量大，而且存取速度也快。磁盘的外形像唱片，盘片组装在磁盘驰动器上就构成磁盘存储器（其构成见图10.3磁盘驱动器的功能是控制磁盘的读写，盘片组是由固定在同一轴上的若干张盘片组成。每个盘片组的盘片数目可多可少，每张盘片都是可装可卸的。除去盘片组的最上面和最下面这两面不用以外，其余每张盘片的两面都可以存放信息。·每一面都配备一个读／写磁头，所有读／写磁头固定在一起，可作同步移动。读／写时盘片高速旋转，而磁头则暂时固定不动.在一个盘片上，读／写磁头的轨道称为磁道，每个盘片上有几百个磁道，各个盘面上半径相同的磁道构成一个柱面。在一个磁道上又划分成若干个扇区。扇区是磁道中最小的寻址单位，每个扇区不论其弧段长短，存放的信息是相等的.数据以记录为单位写到盘面磁道的扇区弧段上。当一个磁道写满后，可以接着往同一柱面的下一个盘面的磁道上写，因此在读／写数据时，必须确定柱面号、盘面号以及数据块的起始" ID="1">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Picture URL="00000236\00000236_new\0002.jpg">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Picture>
        <Paragraph CONTEXT="柱面个数，也就是活动臂径向移动所用的时间.②等待时间（(i，)：等待磁道上指定扇区转到读／写磁头下面所需的时间。③传送时间（t)：将数据块写人磁盘或从磁盘读出数据块所需的时间。的最大值为磁盘转一周所用的时间。若转速为2400转／分，则所用的等待时间最多为0.025s。可见寻找时间比等待时间大得多.因而应该设法避免不必要的寻找时间，尽量把信息放到同一个或相邻的柱面上。数据的传输时间与数据传输率有关。" ID="2">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="文件通常存放在外部存储设备上，为了更好地了解文件的结构，就要先了解主要的外部存储设备及其存取特性。外部存储设备有两类：一类是顺序存取的设备（如磁带）；另一类是直接" ID="1">
        <fptr EndPN="00000234" StartPN="00000234"/>
      </Paragraph>
      <Paragraph CONTEXT="存取的设备（如磁盘）。本节以磁带和磁盘为例做简要介绍。" ID="2">
        <fptr EndPN="00000234" StartPN="00000234"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="225" TITLE="10.2 文件的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="236" PhysicalPageNum="236"/>
        <div ORDERLABEL="225" TITLE="10.2.1 文件的定义及其分类" TYPE="Chapter">
        <fptr LogicalPageNum="236" PhysicalPageNum="236"/>
        <Paragraph CONTEXT="&lt;1)文件的定义文件（File）是由大量性质相同的记录组成的集合。因为文件的数据量通常很大，所以被女从左卜粉娜姑灼山石泞书于翻卜的寸胜士宜互.簇主幽七洲录虎奋仃卜的白亡.左免万石丈月.创压你玄玄尔奋诊" ID="1">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="放置在外存上.上的文件。操作系统中研究的文件仅是一维连续的字符序列.没有结构，也没有解释.它也是记录的集合，但这种记录仅只是一个字符组，用户为了存取方便、加工方便，把文件中的信息划分为若干组，每一组信息称为一个逻辑记录，并且可将其按顺序编号。数据库中所研究的文件是带有结构的记录集合，每个记录可由一个或多个数据项构成。记录是文件中存取的基本单位，数据项是文件可存取的最小的、不可再分的单位。数据项在数数据结构数据项的组合称为主关键字项，其他不能惟一标识一个记录的数据项则称为次关键字项。相应地，主（或次）关键字项的值称为主（或次）关键字。在不产生混淆的情况下，可将主（或次）关键字项简称为主（或次）关键字，并且可假定主关键字项只包含一个数据项。如表10.1所示的是一个简单的学生档案文件，每个学生的情况是一个记录，它由8个数据项组成。其中“学号”可作为主关键字，它能惟一标识一个记录，亦即它的值对任意的两个记录都是不同的；而姓名、性别等数据只能作为次关键字，因为它们的值对不同的记录可以是相同的。裹io.i学生档案文件粼共垂｝" ID="2">
          <fptr EndPN="00000237" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)文件分类文件可按记录中信息长度的特性分为定长记录文件和不定长记录文件。若文件中每个记录含有的信息长度相同，则称这类记录为定长记录，由这类记录组成的文件称为定长记录文件；若文件中含有信息长度不等的记录，则称为不定长记录文件。如表10.1所示的文件就是一个定长记录文件。文件还可以按照记录中关键字的多少，分为单关键字文件和多关键字文件.若文件中的记录只有一个惟一标识记录的主关键字，则称为单关键字文件；若文件中的记录除了含有一个主关键字外，还含有若干个次关键字，则称为多关键字文件。" ID="3">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="226" TITLE="10.2.2 文件的逻辑结构及物理结构" TYPE="Chapter">
        <fptr LogicalPageNum="237" PhysicalPageNum="237"/>
        <Paragraph CONTEXT="同其他数据结构一样，文件结构也包括逻辑结构、存储结构以及在文件上的各种操作三个方面。文件的操作是定义在逻辑结构上的，但操作的具体实现要在存储结构上进行。" ID="1">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)文件的逻辑结构文件是记录的汇集，文件中的记录之间存在着逻辑关系，当一个文件的记录按照某种次序（可以是记录中关键字的大小，也可以是记录存人文件的先后等）排列起来时，各记录之间就自然地形成了一种线性关系。在这种次序下，文件中的每个记录最多只有一个后继记录和一个前趋记录，并且文件的第一个记录只有后继记录没有前趋记录，而文件的最后一个记录只有前" ID="2">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="趋记录没有后继记录。因此，文件可以看成是一种线性结构。" ID="3">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）文件的操作1文件的操作主要有两类：检索和维护。" ID="4">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="1)文件的检索检索就是在文件中查找满足给定条件的记录，文件的检索有下列三种" ID="5">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="方式：" ID="6">
          <fptr EndPN="00000237" StartPN="00000237"/>
        </Paragraph>
        <Paragraph CONTEXT="这两种存取方式都是根据记录序号（即记录存人文件时的顺序编号）或记录的相对位置进行存取的。③按关键字存取：给定一个值，查询一个或一批关键字与给定值相关的记录。对数据库文件可以有如下4种查询方式（以表10.1为例）：a)简单查询：查询单个关键字等于给定值的记录。如：查询学号＝&quot;20000101&quot;，或姓名＝“于海山”的记录。b)区域查询：查询单个关键字属于某个辱域内的记录。如：查询综合考评＞90分的所有学生记录。。）函数查询：规定单个关键字的某个函数，查询该函数的某个值。如：查询所有学生的平盛空A刁匕;月口二空.i.d)布尔查询：以上3种查询用布尔运算（与、或、非）组合起来的查询。如：查询所有综合考评高于80的计算机应用专业的学生以及综合考评低于90的男生，查询条件为：（综合考评＞80)AND（专业二“计算机应用＂OR（综合考评＜90)AND（性别＝“男”）." ID="7">
          <fptr EndPN="00000238" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="2)文件的维护维护操作主要是指对文件进行记录的插人、删除以及修改等更新操作.此外，为提高文件的效率，还要进行再组织操作，文件被破坏后的恢复操作，以及文件中数据的安全保护等。文件的检索和更新操作，都可以有实时和批量两种不同的处理方式。通常，实时处理的应答时间要求严格，应当在接受询问后几秒内完成检索和更新。而批量处理则不然，应答时间要求宽松一些，不同的文件系统有不同的要求。例如，一个民航自动服务系统，其检索和更新都应当实时处理；而银行的账户系统需要实时检索，但可进行批量更新，即可以将一天的存款和提款记录在一个事务文件上，在一天的营业后再进行批量处理." ID="8">
          <fptr EndPN="00000238" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)文件的存储结构" ID="9">
          <fptr EndPN="00000238" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="文件的存储结构是指文件在外存上的组织方式，采用不同的组织方式就得到不同的存储结构。基本的组织方式有4种：顺序组织、索引组织、散列组织和链组织。文件组织的各种方" ID="10">
          <fptr EndPN="00000238" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="d、圣上蛋」二上王二寺月石七生t创始嗦犷d‘tt,吞rn由于文件组织方式的重要性，通常把不同方式组织的文件给予不同的名称。目前文件的组织方式很多，人们对文件组织的分类也不尽相同。选择哪一种文件组织方式，取决于对文件中记录的使用方式和频繁程度、存取要求、外存的性质和容量等因素。本章介绍几种常用的文件组织方式：顺序文件、索引文件、散列文件和多关键字文件.评价一个文件组织的效率，是执行一个文件操作所花费的时间和文件组织所需的存储空间。通常文件组织的主要目的，是为了能高效、方便地对文件进行操作，而检索功能的多寡和速度的快慢，是衡量文件操作质量的重要标志。因此，如何提高检索的效率，是研究各种文件组织方式首先要关注的问题。" ID="11">
          <fptr EndPN="00000238" StartPN="00000238"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="12">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="228" TITLE="10.3 顺序文件" TYPE="Chapter">
      <fptr LogicalPageNum="239" PhysicalPageNum="239"/>
      <Paragraph CONTEXT="顺序文件（SequentialFile）是记录按其在文件中的逻辑顺序依次进人存储介质而建立的，即顺序文件中物理记录的顺序和逻辑记录的顺序是一致的。如果顺序文件中的记录按其主关键字有序，则称此顺序文件为顺序有序文件；否则称为顺序无序文件。为了提高检索效率，经常将顺序文件组织成有序文件，本节假定顺序文件是有序的." ID="1">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)磁带顺序文件" ID="2">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="磁带是一种典型的顺序存取设备，存储在磁带上的文件只能是顺序文件。磁带顺序文件适合于文件的数据量较大、平时记录变化少、只做批量修改的情况.只能按顺序查找法存取，即顺序扫描文件，按记录的主关键字逐个查找。若要检索第i个记录，必须检索前面1-1个记录.这种查找法对于少量的检索是不经济的，但适合于批量检索，即把用户的检索要求先进行积累，一旦待查记录聚集到一定数量之后，便把这批记录按主关键字排序，然后，通过一次顺序扫描文件来完成这一批检索要求。" ID="3">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="磁带顺序文件不能按线性表那样的方法进行插入、删除和修改（若修改主关键字，则相当于先做删除后做插人），因为文件中的记录不能像向量空间的数据那样“移动”。若需插人一个新记录，则只能添加在文件的末尾；若需更新文件的某记录，则必须将整个文件进行复制，在复制中对要修改的记录用新记录代替。为了减少对顺序文件操作的代价，通常也可采用批量处理的方式来实现对顺序文件的更新，即在积累了一批更新要求后，统一进行一次性处理，其工作原理如图10.4所示。这一方式必须引人一个附加文件（常称为事务文件），把所有对顺序文件（以下称主文件）的更新请求，都放人这个较小的事务文件中，当事务文件变得足够大时，将事务文件按主关键字排序，再按事务文件对主文件进行一次全面的更新，产生一个新的主文·228" ID="4">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="例如有一个学校的工资文件，其工资主文件保存着各教职工的应发工资；每个教职工作为一个记录，教职工的工资号为关键字，记录按关键字从大到小顺序排列。每个月的补款和扣款集中在一个事务文件中，事务文件也按工资号排序，成批地更改工资主文件并得到一个新的工资主文件，其过程如图10.5所示。图lo.5工资文件成批修改示意图更改后的文件（new)。新文件开始为空，主文件和事务文件都是有序的。如果事务文件无序，$Picture[00000240\00000240_new\0010.jpg]Picture$需事先对其排序。事务文件中每个记录都含有表示修改方式的标志域：Insert（插人）,Delete（删除）,Update（更新）。采用合并的方法把主文件、事务文件复制到新文件中。其对应的算法如下所述：输人主文件main和事务文件replace," ID="5">
        <fptr EndPN="00000240" StartPN="00000240"/>
      </Paragraph>
      <Paragraph CONTEXT="输出新文件new," ID="6">
        <fptr EndPN="00000240" StartPN="00000240"/>
      </Paragraph>
      <Paragraph CONTEXT="算法：" ID="7">
        <fptr EndPN="00000240" StartPN="00000240"/>
      </Paragraph>
      <Paragraph CONTEXT="①以只读方式打开主文件main和事务文件replace，以只写方式打开文件new,②比较main和replace当前记录的关键字：mr.key和rr,key,若mr.key&lt;rr.key则把main的首记录移人new，取main下一个记录，转步骤③。若mr.key&gt;rr.key且replac2首记录的修改标志为Inert，则把replace的首记录移人new，取，replace的下一个记录，转步骤③。若mr,key=rr.key且replace首记录的修改标志为Delete，则废弃这两个记录。main和.‘。刁t习七飞：＿‘滋、名口茗禹右出口匕丽食了勺六若mr,key=rr.key且replace首记录的修改标志为Update，则按replace记录的内容修改main记录的数据项，并把修改后的记录移人new,main和replace各取下一个记录，转步骤③。" ID="8">
        <fptr EndPN="00000240" StartPN="00000240"/>
      </Paragraph>
      <Paragraph CONTEXT="不属于上述几种情况，则表示出现错误。" ID="9">
        <fptr EndPN="00000240" StartPN="00000240"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构" ID="10">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="④如main不空，则把main的余下部分全部转人new，转步骤①。" ID="11">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="⑤如replace不空，且余下记录的修改标志都是Insert，那么去掉这些标志，把它们全部移" ID="12">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="入new，否则（如含有Delete和Update标志）出现错误。⑥置new的a束标志，关闭文件。" ID="13">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)磁盘顺序文件" ID="14">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="磁盘顺序文件的处理方法和磁带文件类似，除顺序存取外，由于磁盘本身具有随机存取的" ID="15">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="特性，还可对文件记录进行随机存取和修改。对磁盘顺序文件，可按记录号或关键码进行随机存取，如果是顺序有序且记录大小相等，还可用分块查找法或二分查找法进行存取。分块查找法在查找时不必扫描整个文件中的记录.例如，按主关键字的递增顺序，每100个记录为一块，各块的最后一个记录的主关键字为Kioo+Kzoo,,Kioo。,。查找时，将所要查找记录的主关键字K，依次和各块的最后一个记录的主关键字比较，当K大于Kioot。一、）且小于或等于Kiou时，则在第i块内进行扫描。二分查找法只能对较小的文件或一个文件的索引进行查找，当文件很大，在磁盘上占有多" ID="16">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="个柱面时，二分查找将引起磁头来回移动，增加寻查时间。对磁盘这种直接存取设备，还可以对顺序文件进行插值查找和跳步查找，在此不再介绍了。磁盘顺序文件修改记录时，如果更新后的记录不比原记录大，则可在原存储位置上作随机" ID="17">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="修改，随机剔除记录采用暂作侧除标记的方式，等到批处理时才真正删除；插人记录时，为了减少数据移动，可采用的方法一是最初在每个页块中预留空闲空间，插人时只在块内移动记录，但只能解决少量记录的插人；方法二是建立一个附加文件，以存储新插人和更新后的记录，待附加文件增大到一定程度时再进行批处理，把附加文件和主文件进行归并，同时删去作删除标记的记录。在检索时可以先查主文件，若不成功再查附加文件。显然这将增加检索的时间，但可以采取其他措施弥补之‘" ID="18">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="230" TITLE="10.4 索引文件" TYPE="Chapter">
      <fptr LogicalPageNum="241" PhysicalPageNum="241"/>
      <Paragraph CONTEXT="张指示逻辑记录和物理记录之间一一对应关系的表―索引表。这类包括文件数据区和索引表两大部分的文件称为索引文件。" ID="1">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="索引表中的每一项称为索引项，一般索引项都是由主关键字和该关键字所在记录的物理地址组成的。显然，索引表必须按主关键字有序，而主文件本身则可以按主关键字有序或无序.，前者称为索引顺序文件（IndexedSequentialFile)，后者称为索引非顺序文件（IndexedNonSequentialFile" ID="2">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="对于索引非顺序文件，由于主文件中记录是无序的，则必须为每个记录建立一个索引项，这样建立的索引表称为稠密索引。对于索引顺序文件，由于主文件中记录按关键字有序，则可4:f-f日宁口后丢葵扮飞乍＿刁卜创汾己1们而加1介n考卜弋r应生dJ左己沪水币.七红甘沙「台一刁滩、刊毕己咚t6t.;寺iih司毕Hl习林ilr-少.E," ID="3">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="对一组记录建立一个索引项。" ID="4">
        <fptr EndPN="00000241" StartPN="00000241"/>
      </Paragraph>
      <Paragraph CONTEXT="疏索引。通常可将索引非顺序文件简称为索引文件，本节只讨论这种文件。索引文件在存储区上分为两个区：索引区和数据区，前者存放索引表，后者存放主文件。在建立文件过程中，按输人记录的先后次序建立数据区和索引表，这样的索引表其关键字是无序的，待全部记录输人完毕后再对索引表进行排序，排序后的索引表和主文件一起形成了索引文件。例如，对于表10.2的数据文件，主关键字是“学号”，排序前的索引表如表10.3所示，排序后的索引表见表10.4，表10.4和表10.2一起形成一个索引文件。" ID="5">
        <fptr EndPN="00000242" StartPN="00000241"/>
      </Paragraph>
      <Picture URL="00000242\00000242_new\0007.jpg">
        <fptr EndPN="00000242" StartPN="00000242"/>
      </Picture>
      <Picture URL="00000242\00000242_new\0008.jpg">
        <fptr EndPN="00000242" StartPN="00000242"/>
      </Picture>
      <Picture URL="00000242\00000242_new\0009.jpg">
        <fptr EndPN="00000242" StartPN="00000242"/>
      </Picture>
      <Paragraph CONTEXT="数据结构索引文件的检索方式为直接存取或按关键字（进行简单询问）存取，检索过程和分块查找相类似，应分两步进行：首先，查找索引表，若索引表上存在该记录，则根据索引项的指示读取外存上该记录；否则说明外存上不存在该记录，也就不需要访问外存。由于索引项的长度比记录小得多，故通常可将索引表一次读人内存，由此在索引文件中进行检索只访问外存两次，即一次读索引，一次读记录。并且由于索引表是有序的，故查找索引表时可用折半查找法。当记录数目很大时，索引表也很大，以致一个页块容纳不下。在这种情况下检索索引仍要多次访问外存。为此，可以对索引表建立一个索引，称为查找表。例如表10,4中的索引占用了3个页块的外存，每个页块能容纳3个索引项，则可为之建立一个查找表。查找表中，列出索引表的每一个页块最后一个索引项中的关键字（该块中最大的关键字）及该块的地址，如表10.5所示.检索记录时，先查找查找表，再查索引表，然后，读取记录，三次访问外存即可。若查找表中的项目还才良多，则可建立再高一级的索引.通常最高可达四级索引：数据文件－今》索引表一.）查找表一＞第二查找表一＞第三查找表。而检索过程从最高一级索引―第三查找表开始，需要5次访问外存。而索引文件的修改也很容易进行。删除一个记录时，仅需删去相应的索引项，而不必移动数据区中的记录；播人记录时，应将记录置于数据区的末尾，同时在索引表中插人索引项；更新记录时，应将更新后的记录置于数据区的末尾，同时修改索引表中相应的索引项。由索引文件的操作特点可知，索引文件只能是磁盘文件。下一节将介绍适用于组织大型文件的索引方法。" ID="6">
        <fptr EndPN="00000243" StartPN="00000243"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="232" TITLE="10.5 索引顺序文件" TYPE="Chapter">
      <fptr LogicalPageNum="243" PhysicalPageNum="243"/>
      <Paragraph CONTEXT="在实际应用中，索引顺序文件是被经常采用的一种文件结构。它是在顺序文件的基础上索引而形成的。文件中的记录按关键字大小顺序存放在磁盘的连续或相邻的存储区中。增加索引而形成的。由于记录按关键字排序，因此不必为每个记录设立一个索引项，而把文件划分为若干个记录块，只为每块中关键字最大（或最小）的记录设立一个索引项，这种组织文件的方法称为索引顺$Picture[00000243\00000243_new\0006.jpg]Picture$序存取法，简称ISAM(IndexedSequentialAccessMethodISAM建立起来的索引文件称为ISAM文件，这是一种专为磁盘存取设计的文件组织方式。根据10,1节的介绍，磁盘分为若干柱面，有柱面号；每个柱面由同一半径上的所有磁道组成，有磁道号；每个磁道划分为若干扇区，有扇区号。由于磁盘是由盘组、柱面和磁道三级地址组成，因此可对磁盘上的数据文件建立盘组、柱面和磁道（实际为柱面中某一磁道，即是盘面）" ID="1">
        <fptr EndPN="00000243" StartPN="00000243"/>
      </Paragraph>
      <Paragraph CONTEXT="三级索引。它们分别是：" ID="2">
        <fptr EndPN="00000243" StartPN="00000243"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)磁道索引每个柱面上的记录按磁道分块.每个柱面建一个磁道索引块，对该柱面基本数据区的每个磁道建有一个索引项，由基本索引项和滋出索引项两部分组成，如图10.6所示.基本索引项滋出索引项图io.s磁道索引项的结构示意图其中，基本索引项中的关键字是基本区某磁道中最大的关键字，指针则为该磁道的首地址；滋出索引中的关键字是从该磁道溢出的记录中的最大关键字值，而溢出索引项中的指针是" ID="3">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="溢出链表中的头指针。在基本区某磁道没有溢出时，相应的溢出索引项与基本索引项内容一样。c2）柱面索引为ISAM文件所占的所有柱面空间建一个柱面索引。其中，对每个柱面的磁道索引块有" ID="4">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="一个索引项，给出在每个柱面上磁道索引块中的最大关键字及该磁道索引块的首地址。柱面索引是磁道索引的索引。" ID="5">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）主索引当柱面索引很大时，其本身就占有多个磁道。这时，可以建立柱面索引的索引，称为主索引。把柱面索引以磁道为单位分成若干块，在主索引中对柱面索引的每一块保留一个索引项，给出每个柱面索引块的最大关键字值及该块所在磁道的首地址.ISAM文件存放时，把每一个柱面分为索引区、基本区和滋出区。初始创建文件时，记录在基本区按排序连续顺序结构存放.每个柱面的最后几个磁道留作溢出区，以供插人操作时存放从基本区滋出的记录。滋出区的记录采用线性链表结构，通过指针映射记录的排序顺序，图10.7示例了一个磁盘上的ISAM文件。在ISAM文件上检索记录时，先从主索引出发找到相应的柱面索引，再从柱面索引找到记录所在柱面的磁道索引，最后从磁道索引找到记录所在磁道的第一个记录的位置，由此出发在该磁道上进行顺序查找直至找到为止；反之，若找遍该磁道而不存在此记录，则表明该文件中无此记录.例如，查找关键字为47的记录。先查主索引，因47&lt;600，故记录应在第1个柱面上（若存在的话）；查第1个柱面的磁道索引，因47&lt;50，故记录应在第一个磁道上；最后顺序查到记录K；,，其查找路径如图10.7中的粗实线所示。滋出区和徽出索引项是为插人记录所设置的。由于ISAM文件中记录是按关键字顺序存放的，则在插人记录时需移动记录并将同一磁道上的最末一个记录移至溢出区，同时修改磁道索引项。通常滋出区可有三种设置方法：" ID="6">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="1)集中存放整个文件设一个大的单一的滋出区，" ID="7">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="2）分散存放每个柱面设一个滋出区；" ID="8">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="3)集中与分散相结合滋出时记录先移至每个柱面自己的滋出区，待满之后再使用公共溢出区。" ID="9">
        <fptr EndPN="00000244" StartPN="00000244"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构$Picture[00000245\00000245_new\0003.jpg]Picture$基本索引项滋出索引项幕本索引项溢出索引项" ID="10">
        <fptr EndPN="00000245" StartPN="00000245"/>
      </Paragraph>
      <Picture URL="00000245\00000245_new\0007.jpg">
        <fptr EndPN="00000245" StartPN="00000245"/>
      </Picture>
      <Paragraph CONTEXT="T几滋出区图10.8ISAM文件某一往面上的状态例如：有ISAM文件某一柱面上的状态如图10.8所示.在其中依次插人记录Rzs.Rv、和" ID="11">
        <fptr EndPN="00000245" StartPN="00000245"/>
      </Paragraph>
      <Paragraph CONTEXT="R,s的过程如图10.9所示。(a）为插人RZ、时，将第二道中关键字大于25的记录顺次后移，且使R5o滋出至滋出区的情况；(b)为插人RZ、之后的状态，此时2道的基本索引项的关键字改为" ID="12">
        <fptr EndPN="00000245" StartPN="00000245"/>
      </Paragraph>
      <Paragraph CONTEXT="40，且溢出索引项的关键字改为50，其指针指向第四道第一个记录即Rso;(c）是插人Res后再插人R,。后的状态，R7s插人在第三道的第一个记录的位置而使R,zo溢出。而由于40&lt;45&lt;" ID="13">
        <fptr EndPN="00000245" StartPN="00000245"/>
      </Paragraph>
      <Picture URL="00000246\00000246_new\0002.jpg">
        <fptr EndPN="00000246" StartPN="00000246"/>
      </Picture>
      <Paragraph CONTEXT="(a)140iTz.150;T.：1120iTj,1｝八｝磁道“$Picture[00000246\00000246_new\0007.jpg]Picture$｝。iT1城T｝115｛TI.：1120i40;Ts,50;T1115;T3,120T,｝磁道索引$Picture[00000246\00000246_new\0012.jpg]Picture$图10.9ISAM文件的插人和滋出处理(a）插入Rzs时记录移动的情形；(b)插人R2。后的状态1(C）先擂入R,：再插人R45后的状态位置，同时修改第2道索引的滋出索引项的指针指向R.SISAM文件中侧除记录的操作，要比插人操作简单得多，只要找到待删除的记录，在其存储位置上作删除标记即可，而不需要移动记录或改变指针。在经过多次增删后，文件的结构可能变得不合理.此时，大量的记录进人滋出区，而基本区中又浪费很多空间。因此，通常需要周期性地整理ISAM文件，把记录读人内存，重新排列，复制成一个新的ISAM文件，填满基本区而空出滋出区。当文件主要用于检索时，ISAM文件效率高，既能随机查找，又能顺序查找。但若增删频繁，则存取效率退化，且需定期重组，所以不宜作更新型的操作。ISAM文件的索引是一种典型的静态索引，若需要适应更新操作，则应考虑建立动态索引，这种索引以B＋树为代表，其典型的文件组织以VASM(VirtualStorageAccessMethod）为代表.由于是动态索引，既便于检索，又便于更新." ID="14">
        <fptr EndPN="00000246" StartPN="00000246"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构" ID="15">
        <fptr EndPN="00000247" StartPN="00000247"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="236" TITLE="10.6 散列文件" TYPE="Chapter">
      <fptr LogicalPageNum="247" PhysicalPageNum="247"/>
      <Paragraph CONTEXT="散列文件是利用散列法组织的文件，亦称直接存取文件。它类似于散列表，即根据文件中的关键字的特点，设计一个散列函数和处理冲突的方法，将记录散列到存储设备上。与散列表不同的是，对于文件来说，磁盘上的文件记录通常是成组存放的，若干个记录组成一个存储单位。在散列文件中，这个存储单位叫做桶（Bucket),假如一个桶能存放m个记录，这就是说，m个同义词的记录可以存放在同一地址的桶中，称为基桶。而当第m1个同义词出现时才发生“滋出”，需要将第m-I1个记录存放到另一个桶中，通常称此桶为溢出桶。溢出桶和基桶大小相同，相互之间用指针相连接。当在基桶中没有找到时，就按指针所指到溢出桶中进行查找，因此，希望同一散列地址的溢出桶和基桶在磁盘上的物理位置不要相距太远，最好在同一柱面上。例如，某一文件有21个记录，其关键字分别为20,16,17,13,12,76,09,14,02,22,62,39,06,07,23,01,33,41,30,29,03。桶的容量m=3，桶数b=7。用除留余数法作哈希函数H(key)=keyMOD7。由此得到如图10.10所示的直接存取文件.图10.10直接存取文件示例在直接存取文件中进行查找时，首先根据给定值求出哈希桶地址（即基桶号），将基桶的记录读人内存进行顺序查找，若找到关键字等于给定值的记录，则检索成功；否则，读人溢出桶的T＝a（t。＋t：）其中：a为存取桶数的期望值，对链地址处理滋出来说，a二1a/2;t.为存取一个桶所需的时" ID="1">
        <fptr EndPN="00000247" StartPN="00000247"/>
      </Paragraph>
      <Paragraph CONTEXT="间；t。为在内存中顺序查找一个记录所需的时间。a为装坟因子，在散列文件中：a=nbm)其中：n为文件的记录数，b为桶数，m为桶的容量。显然，增加m可减少a，也就是减少a，此$Picture[00000247\00000247_new\0029.jpg]Picture$时虽然也使t.增大，但是由于t.»t,，则总时间T仍可减少。图10.11展示了。和a的关系。在直接存取文件中姗除记录时，仅需对被删除的记录作一标记即可。总之，直接存取文件的优点是：记录无须排序，文件随机存取，速度快，插人、删除方便，不需要索引区，节省存取空间。其缺点是：不能进行顺序存取，只能按关键字随机存取，且仅限于简单查询。在经过多次插人、删除后，也可能造成文件结构不合理，此时需要重组文件。" ID="2">
        <fptr EndPN="00000247" StartPN="00000247"/>
      </Paragraph>
      <Picture URL="00000248\00000248_new\0002.jpg">
        <fptr EndPN="00000248" StartPN="00000248"/>
      </Picture>
    </div>
      <div ORDERLABEL="237" TITLE="10.7 多关键字文件" TYPE="Chapter">
      <fptr LogicalPageNum="248" PhysicalPageNum="248"/>
        <div ORDERLABEL="237" TITLE="10.7.1 多重链表文件" TYPE="Chapter">
        <fptr LogicalPageNum="248" PhysicalPageNum="248"/>
        <Paragraph CONTEXT="多重链表文件（Multilistfile）的特点是：①记录按主关键字的顺序构成一个串联文件，并建立主关键字的索引（称为主索引）；②对每一个次关键字项建立次关键字索引（称为次索引），所有具有同一关键字的记录构成一个链表，" ID="1">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="③主索引为非稠密索引，次索引为稠密索引，" ID="2">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="④每个索引项包括次关键字、头指针和链表长度。例如，图10.12所示为一多重链表文件。其中：图10.12(a）为基本数据文件；图10.12(b)为以“编号”主关键字建立的索引，按编号（10061006（编号&lt;1046.1046＜编号（1088为标准分为三个链表，每个链表中按职工的编号排序；图10.12(c）为以“性别”为次关键字的次索引；图10.12&lt;d)为以“年龄”为次关键字的次索引；图10.12(e）为以“职称”为次关键字的次索引；图lo.12(f）为以“专业”为次关键字的次索引。" ID="3">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构$Picture[00000249\00000249_new\0003.jpg]Picture$$Picture[00000249\00000249_new\0004.jpg]Picture$$Picture[00000249\00000249_new\0005.jpg]Picture$$Picture[00000249\00000249_new\0006.jpg]Picture$图10.12多重链表文件示例这种文件便于处理以各种关键字为条件的查找。例如，要查找职称为“副教授”的全部记录，只需根据图10.12(e）的次索引找到“副教授”链表的头指针，对“副教授”链表进行遍历，便可很快找到全部“副教授”记录，而不必再对整个职工数据文件进行查找。若查找“计算机专业职称为副教授的记录”，则涉及两个次索引表。为节省查询时间，比较有关索引项的链表长度，选取较短的进行查找，在遍历过程中同时检查各记录的另一个次关键字找出符合条件的记录。多重链表文件适宜于多关键字查询，易于编程，易于修改，但对记录的插人、删除比较麻烦，需" ID="4">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="在主文件和相应的辅助文件中进行相应修改。" ID="5">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="238" TITLE="10.7.2 倒排文件" TYPE="Chapter">
        <fptr LogicalPageNum="249" PhysicalPageNum="249"/>
        <Paragraph CONTEXT="倒排文件和多重链表文件一样，由一个主文件和多个索引表组成，其区别在于次关键字索引的结构不同。通常，称倒排文件中的次关键字索引为倒排表，具有相同次关键字的记录之间不设指针相链，而在倒排表中直接存放这些记录的物理记录号。例如，图10.IZ中数据文件的$Picture[00000250\00000250_new\0005.jpg]Picture$$Picture[00000250\00000250_new\0006.jpg]Picture$$Picture[00000250\00000250_new\0007.jpg]Picture$$Picture[00000250\00000250_new\0008.jpg]Picture$倒排文件作索引的好处在于检索记录较快。特别是对某些查询，不用读取记录，只需对倒排表中相关项进行必要的交、差等逻辑运算，求出符合条件的记录号，再访问外有记录，因此，查询速度快。例如，查询“计算机专业职称为副教授和讲师的职工情况”，由“专业”例排表的列计算机专业的记录物理号的集合为{2,5,8,10}，由“职称”倒排表的列副教授和讲师记录物理号的集合分别为{1,3,4,7,11｝和｛8,12}，则满足条件的记录物理号集合为｛2,5,8,10｝门（{1,3,4,7,11}J{8,12{g由此可知，地址为8的记录满足上述查询条件，读取该记录，即为查询结果。在插入和删除记录时，倒排表也要作相应的修改，在倒排表中具有同一关键字的记录号是有序排列的.若数据文件非串联文件，而是索引顺序文件（如ISAM)，则倒排表应存放记录的主关键字，而不是物理记录号。·倒排文件的缺点是维护困难，因为在同一索引表中，不同的关键字其记录数不同，各倒排表的长度不等，同一倒排表中的各项长度也不等." ID="1">
          <fptr EndPN="00000250" StartPN="00000249"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="前面所提到的几种文件结构仅适用于对单一关键字的查询，然而要回答对其他属性项的查询非常困难。多关键字文件的特点就是在对文件进行检索操作时，不仅对主关键字进行简单查询，还经常需要对次关键字进行其他类型的查询。例如，表lo.1所示的学生档案文件中，“学号”为主关键字，“姓名性别专业综合考评”等为次关键字。可对此文件查询：计算机应用专业中综合考评低于so分且性别为男的记录.如果文件中只有主关键字索引，则为回答以上查询只能顺序存取文件中的每一个记录进行比较，效率很低。为此，对多关键字文件，除了按以上几节的方法组织文件之外，还需建立一系列的次关键字索引。次关键字索引表可以是顺序表，也可以是树表。每个索引项应包含次关键字及具有同一次关键字的各个记录的主关键字或物理记录号。下面讨论两种多关键字" ID="1">
        <fptr EndPN="00000248" StartPN="00000248"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="239" TITLE="10.8 典型应用举例" TYPE="Chapter">
      <fptr LogicalPageNum="250" PhysicalPageNum="250"/>
        <div ORDERLABEL="239" TITLE="10.8.1 顺序文件的批量处理实例" TYPE="Chapter">
        <fptr LogicalPageNum="250" PhysicalPageNum="250"/>
        <Paragraph CONTEXT="商品文件中记录了商品的有关信息，它的格式为" ID="1">
          <fptr EndPN="00000250" StartPN="00000250"/>
        </Paragraph>
        <Paragraph CONTEXT="要求根据商品更改文件中的内容对商品文件进行更新处理。①如果商品文件中存在和更改文件中相同商品代码的记录，则用商品更改文件中的记录修改商品文件中的记录。" ID="2">
          <fptr EndPN="00000250" StartPN="00000250"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构②如果商品文件中不存在相同的商品代码，则把更改文件中的商品记录插人到商品文件中.商品更改文件和商品文件中的记录是按商品代码降序排列的，不存在两个以上相同商品代码的记录。商品更改文件的记录格式与商品文件的记录格式相同。商品文件被修改后放在一个新文件中.C语言程序如下：include&quot;stdio.h&quot;" ID="3">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="4">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="{intcode;" ID="5">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="charname[201;" ID="6">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="doublecost,price;" ID="7">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="intnumber;" ID="8">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="charfactory[201;" ID="9">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="}record;FILE*producefile,*modifyfile,*newfile;main()" ID="10">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="{recordp,m;" ID="11">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j;ifproductfile=fopenproduct,old&quot;rb_=NULL){printfcannotopenproductfile\n;" ID="12">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1}ifmodifyfile=fopenmodify&quot;rb_=NULL){printfcannotopenmodifyfile\n" ID="13">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="fclose(productfile);" ID="14">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="exit(1newfile=fopenproduct,datwbi=fread(.p,sizeof(p),1,productfile);j=freadm,sizeof(m),1,modifyfile);while(il=0jl=0)/，主文件和更改文件中都有未处理的商品记录时，／{if(p,code＞m,code)主文件记录写人新文件并读人下一个主文件记录，／{fwritep,sizeof(p),1,newfile);" ID="15">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="i=freadp,sizeof(p),1,productfile);}elseif(p,codem.code)该记录写人新文件，并且主文件和更改文件同时读人下一个新记录，／" ID="16">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="{fwritem,sizeof(m),1,newfile);" ID="17">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="i=freadp,sizeof(p),1,productfile);·240j=freadm,sizeof(m),1,modifyfile);}else／，主文件中记录的商品代码小于更改文件的记录的商品代码时，将更改文件插人新文件并读人下一个更改文件记录，／" ID="18">
          <fptr EndPN="00000252" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="{fwritem,sizeof(m),1,newfile);" ID="19">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="j=freadm,sizeof(m),1,modifyfile);}｝" ID="20">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="while(i&gt;0)／，只有主文件中还有未处理的新记录时，依次将其读出并写人新文件，／{fwrite(＆p,sizeof(p),1,newfile);" ID="21">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="i=freadp,sizeof(p),1,productfile);}while0)／＊只有更改文件中还有未处理的新记录时，依次将其读出并写人新文件二刀＊" ID="22">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="{fwritem,sizeof(m),1,newfile);" ID="23">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="i=freadm,sizeof(m),1,modifyfile);}fclose&lt;productfile);" ID="24">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="fclose(modifyfile);" ID="25">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="fclose(newfile);" ID="26">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="241" TITLE="10.8.2 文件的随机访问实例" TYPE="Chapter">
        <fptr LogicalPageNum="252" PhysicalPageNum="252"/>
        <Paragraph CONTEXT="设有两个文件：主文件main,dat和索引表文件index.dat。主文件由若干记录组成，每个记录登记了学生的基本情况，包括以下几个数据项：脍瑞概器目禺楞稠索引表文件的每个记录有两个域：学号和相应的学生在主文件中的位置。它的格式如下：索引文件中的记录是按学生学号的升序排列的。要求读人学生的学号，从索引表中找出该学生在主文件中的位置并打印出该学生的所有信息。解首先把索引表文件读入，然后读人学生的学号，采用折半检索法检索是否有该学生的'Illl右＿id田V拙:C\I函911CPPI[iW1.V胜C\ISII俗:C\I晋_1中聋庄的系攀1T" ID="1">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="记录。" ID="2">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="打印。C语言程序如下：" ID="3">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="include&quot;stdio.h&quot;" ID="4">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="include&quot;string.h&quot;" ID="5">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="敬据结构FILE，mainfile,＊;ndexfile;typedefstruct/，定义学生结构＊／typedefstruct/＊定义索引表结构‘／index*ind;" ID="6">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="int1en;／，函数readindexfile用于读人索引表文件，／readindexfile()" ID="7">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="8">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="indexx;" ID="9">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,J;indexfile=fopenindex.dat&quot;rb;/，打开索引文件二／if(indexfileNULL)（" ID="10">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="printfcannotopenindexf;le\n;exit(0);/，打开失败时退出，／｝j=filelength(fileno(indexfile;len=j/sizeof(index);/，取文件长度，计算文件中记录的个数，／indindexmalloc(j/，为索引表文件分配空间，／(read(ind,sizeof(index),1en,indexfile);／二读人索引文件＊／fclose(indexfile);/‘关闭索引表文件，／｝／，函数：earch用于在索引表文件中检索学号为num的学生，返回学生在索引表文件中的记录号，／search(num)" ID="11">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="charnum[b" ID="12">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="{inti,l,r,comp;" ID="13">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="1二0;" ID="14">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="r=ten-1;while（1＜＝r）／，折半检索，／{i二（1-r)12;" ID="15">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="·242comp=strcmp(ind[inumber,numif(comp0)r=i-1;" ID="16">
          <fptr EndPN="00000254" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="if(comp0)1=i--1if&lt;1-r&gt;1)return(i/，找到时返回记录号‘／elsereturn（一1" ID="17">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="main()" ID="19">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="20">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="'charnum[81;" ID="21">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="students;" ID="22">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="inti;readindexfile;/，读人索引文件，／mainfile=fopenmain,dat&quot;rb;/，打开主文件，／while(1)" ID="23">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="｛printfninputstudentnumbergets(num／二读人学生学号，／if(num[01＝二‘qbreak;" ID="24">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="else{i=search(num);/＊在索引表文件中查找学生学号，／if(i&lt;0)printfstudent°osnotexit\nnumelse{fseek&lt;mainfile,ind[ioffset,0" ID="25">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="freads,sizeof(student),1,mainfile);" ID="26">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="printfss,°oc,°ods.%s,°oss,number,s.names,sex,s.age,）" ID="27">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="｝fclose(mainfile);/，关闭主文件＊／｝" ID="28">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="29">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="244" TITLE="学习指导" TYPE="Chapter">
      <fptr LogicalPageNum="255" PhysicalPageNum="255"/>
      <Paragraph CONTEXT="本章介绍了文件的常用的组织方式（顺序文件、索引顺序文件、直接存取文件、多重链表文件和倒排文件）的构造方法及文件操作在其上的实现。要求熟悉并掌握各类文件的特点、构造方法以及如何实现检索、插人和删除等操作。" ID="1">
        <fptr EndPN="00000255" StartPN="00000255"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="244" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="255" PhysicalPageNum="255"/>
      <Paragraph CONTEXT="／试比较顺序文件、索引文件以及索引顺序文件各有什么特点？10.1l0.2试叙述索引顺序文件与顺序文件相比较的优缺点，指出一种适用于索引顺序文件的外存设备。10.3试叙述文件有哪几种常用的组织方式？它们各有什么特点？10.4简单比较文件的多重链表和倒排表组织力式各有什么优缺点？试综述文件有哪几种常用的组织方式？10.5对于如图10.14所示的数据文件，用图示意其索引表及文件记录输人过程中建立的索引表。物理记录号学号姓名据贯" ID="1">
        <fptr EndPN="00000255" StartPN="00000255"/>
      </Paragraph>
      <Paragraph CONTEXT="1ol2s张林云南" ID="2">
        <fptr EndPN="00000255" StartPN="00000255"/>
      </Paragraph>
      <Paragraph CONTEXT="1os10504108宋田甘肃10902郑延文山东11236李玉英广东114" ID="3">
        <fptr EndPN="00000255" StartPN="00000255"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="245" TITLE="第11章 《数据结构》实验指导" TYPE="Chapter">
    <fptr LogicalPageNum="256" PhysicalPageNum="256"/>
      <div ORDERLABEL="247" TITLE="11.1 实验一线性表及其应用" TYPE="Chapter">
      <fptr LogicalPageNum="258" PhysicalPageNum="258"/>
        <div ORDERLABEL="247" TITLE="11.1.1 课程成绩管理" TYPE="Chapter">
        <fptr LogicalPageNum="258" PhysicalPageNum="258"/>
        <Paragraph CONTEXT="【实验目的】" ID="1">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="1)掌握顺序表的定义及操作的c语言实现方法；" ID="2">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="2)掌握单链表的实现方法。" ID="3">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="【问题描述】利用顺序表和单向链表分别完成一个班级学生课程某成绩的管理：能够增加、删除、修改学生的成绩记录。" ID="4">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="【实验要求】参照附录源程序一，在上机前写出全部源程序。" ID="5">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="247" TITLE="11.1.2 一元稀疏多项式简单计数器" TYPE="Chapter">
        <fptr LogicalPageNum="258" PhysicalPageNum="258"/>
        <Paragraph CONTEXT="【实验目的】掌握一元稀疏多项式的链式存储结构及其加法、减法运算的实现，进一步熟悉线性表在链式存储结构上的插人、删除操作。" ID="1">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="【问瓜描述】" ID="2">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="设计一个一元稀疏多项式简单计算器。" ID="3">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="【实验要求】一元稀疏多项式简单计算器的基本功能是：" ID="4">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="1)输人并建立多项式A(x7-3x+9x8+Sx" ID="5">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="2)输出多项式，输出序列为nci,elcZ,eZ…ce其中n是多项式的项数和e：分别是第i项的系数和指数，序列按指数降序排列；" ID="6">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="3)多项式A和B相加，建立多项式C=A十B，并输出相加的结果多项式C;" ID="7">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="4)多项式A和B相减，建立多项式D=A-B，并输出相减的结果多项式D,【方法说明】" ID="8">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="1)多项式的输人与存储用带表头结点的单链表存储多项式，多项式的项数n存放在头数据结构结点中。链表中的每个结点分别存储多项式各项的系数和指数，即每从键盘输人多项式的一对数（系数，指数），可对应建立链表的一个结点。每个结点的结构为：！coef’二pInextI输人上述多项式A&lt;xB(x)的系数和指数，需建立以下两个链表，其中Pa,Pb分别为它们的头指针：mtecp;structpoly*next}polytype" ID="9">
          <fptr EndPN="00000259" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="3)主要算法创建链表的算法，请参见教材。" ID="10">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="多项式相加的算法Add_Poly，可作参考.VoidAdd_Poly(Polytype*Pa,Polytype，Pb){P二Pa一＞next;q=Pb一仁＞next;P二pre一＞next;u=q;q=qee－－：＞next;" ID="11">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="free(u);" ID="12">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="｝else{" ID="13">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="u=q一＞next;q气＞next=p;" ID="14">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="pre～－：＞next=q;pre=q;q=u;" ID="15">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="ifqpre‘－－：＞next=q;" ID="16">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="【测试数据及结果】" ID="17">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="1)A&lt;x2x-F-5xe-3.lx“，B（x）＝7-5xe十11x9,C(x)=7+2x十11x9-3.1x&quot;2racx1十X+XY+X3十X‘十XS,B(X)＝一X3-X4，C(X）二1+x十XZ十X5" ID="18">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="3)A(x）二x十X3,B(X)＝一x-X3,C(X" ID="19">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="4)A(x）二X+XZ+X3,B(X0fC(XX+XZ'X3【选做内容】" ID="20">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="1)计算多项式在x处的值。" ID="21">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="2)多项式a和b相减，建立多项式a-b," ID="22">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="3)多项式a和b相乘，建立乘积多项式ab," ID="23">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="4)计算器的仿真界面。" ID="24">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在众多数据结构当中，线性表是最简单、也是最基本的一个。线性表按存储结构分，可分为顺序表和链表，它们各有特色。本次实验的主要目的在于帮助同学熟练掌握线性表的基本操作在两种存储结构上的实现，其中，以链表的操作和应用作为重点内容。链接表的优点是“按需分配”，且增删方便，缺点是不能随机访问。在实际当中，有许多应用是频繁变动，但并不要求随机访问，在这样的情况下，链表就大有用武之地。通过本实验，对链表基本操作及其组合应用的演练，加深对链表存储方法及其基本操作的理解，为以后进二步学习更复杂的数据结构打下基础。" ID="1">
        <fptr EndPN="00000258" StartPN="00000258"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="24" TITLE="11.2 实验二栈和队列及其应用" TYPE="Chapter">
      <fptr LogicalPageNum="260" PhysicalPageNum="260"/>
        <div ORDERLABEL="249" TITLE="11.2.1 停车场管理" TYPE="Chapter">
        <fptr LogicalPageNum="260" PhysicalPageNum="260"/>
        <Paragraph CONTEXT="【实验目的】" ID="1">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="1)深人了解栈和队列的特征，以便在实际背景下灵活运用它们；" ID="2">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="2)熟练掌握栈和队列的构造方法和基本运算。【问盈描述】设停车场是一个可停放n辆汽车的狭长通道，且只有一个大门可供汽车进出。汽车在停车场内按车辆到达时间的先后顺序，依次由北向南排列（大门在最南端，最先到达的第一辆车停放在车场的最北端），若车场内已停满n辆汽车，则后来的汽车只能在门外的便道上等候，一旦有车开走，则排在便道上的第一辆车即可开人；当停车场内某辆车要离开时，在它之后进人的车辆必须先退出车场为它让路，待该辆车开出大门外，其他车辆再按原次序进人车场，每辆停放再车场的车在它离开停车场时必须按它停留的时间长短交纳费用。试为停车场编制按上述要求进行管理的模拟程序。" ID="3">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="【实验要求】以栈模拟停车场，以队列模拟车场外的便道，按照从终端读人的输人数据序列进行模拟管理。每一组输人数据包括3个数据项：汽车“到达”或“离去”信息、汽车牌照号码以及到达或离去的时刻.对每一组输人数据进行操作后的输出信息为：若是车辆到达，则输出汽车在停车场内或便道上的停车位置；若是车辆离去，则输出汽车在停车场内停留的时间和应交纳的费用（在便道上停留的时间不收费）。栈以顺序结构实现，队列以链表结构实现。【方法说明】需另设一个栈，临时停放为给要离去的汽车让路而从停车场退出来的汽车，也用顺序存储结构实现。用以下示意图帮助理解题意。" ID="4">
          <fptr EndPN="00000260" StartPN="00000260"/>
        </Paragraph>
        <Paragraph CONTEXT="数据结构" ID="5">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="」匕" ID="6">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Picture URL="00000261\00000261_new\0003.jpg">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Picture>
        <Picture URL="00000261\00000261_new\0005.jpg">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Picture>
        <Paragraph CONTEXT="8)设停车场已停满n辆车（按时间先后顺序），" ID="7">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Picture URL="00000261\00000261_new\0008.jpg">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Picture>
        <Paragraph CONTEXT="h)假设车2要离开，车3到车n应退出停车场，暂时停在东边A4,25)A5,30)fD',2,35)D',4,40)E',0,0)其中，'A‘表示到达（Arrival)D‘表示离去（Departure)E‘表示输人结束（End),【选做内容】D两栈共享空间，思考应开辟数组的空间是多少？" ID="8">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="2)汽车可有不同种类，则它们的占地面积不同，收费标准也不同，如1辆客车和1.5辆小" ID="9">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="汽车的占地面积相同，1辆十轮卡车占地面积相当3辆小汽车的占地面积。" ID="10">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="251" TITLE="11.2.2 车厢调度" TYPE="Chapter">
        <fptr LogicalPageNum="262" PhysicalPageNum="262"/>
        <Paragraph CONTEXT="【实验目的】栈是一个结构简单，却非常有用的基本数据结构，在解决各种问题当中有着广泛的应用。本次实验的目的在于深人了解栈的特性，以便在实际问题背景下灵活应用它们；同时还会涉及递归算法的设计。" ID="1">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
        <Paragraph CONTEXT="【问题描述】假设停在铁路调度站（如教科书中图3,1(b)所示）人口出的车厢序列的编号依次1,2,…," ID="2">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
        <Paragraph CONTEXT="n。设计一个程序，求出所有可能由次输出的长度为n的车厢序列。【实验要求】输入车厢数n，若n＞0，则输出所有可能的序列，序列号之间用逗号分隔，每序列占一行；否则应给出相应的提示并重新输入数据或退出，最后给出总的序列数。【实现提示】－用递归法。因为，对于车站这个“栈”来说，在任何状态下都有两种可能的操作：“人”和“出”。每个状态下处理问题的方法都是相同的，这说明问题本身具有天然的递归特性，可以用递归算法实现。输人序列可以仅由一队整型变量表示，既给出序列头／尾编号。输出序列用栈实现。然后定义一个或打印操作，自底向顶顺序打印栈元素的值。r日之宁渔吮翻定1毛启金月日、" ID="3">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
        <Paragraph CONTEXT="total:5" ID="4">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="251" TITLE="11.2.3 汽车加油" TYPE="Chapter">
        <fptr LogicalPageNum="262" PhysicalPageNum="262"/>
        <Paragraph CONTEXT="【实验目的】与栈一样，队列也是一个结构简单而非常有用的基本数据结构。本次实验目的在于深人理解队列的操作以及被操作的元素序列的特点，学会通过深人分析队列的内部运作规律来确定外部输出特性；另外还涉及其他一些编程技巧的训练.【问厄描述】假设一条单行线公路边有一环形通道的加油站，如图所示，汽车经加油站时，可以进站加油，也可以不加油直接驶过。若进站加油，则须从指定的人、出口进出，不能超车。若对要从加油站经过的几辆车依次编号为1,2,…,n，请编程求出所有可能的输出序列。数据结构" ID="1">
          <fptr EndPN="00000263" StartPN="00000262"/>
        </Paragraph>
        <Paragraph CONTEXT="【实验要求】输人汽车数n，若n＞0，则输出所有可能的序列，序列号之间用逗号分隔，每序列占一行；否则应给出相应的提示并重新输人数据或退出。最后给出总的序列数。r目，劝.创且号井、可把汽车分成两种，一种曾进站加油，而另一种则未进站加油。这两种车在输出序列中分别构成两个队列，换言之，任何的合理输出序列均可划分为两个递升的序列。因此，可以对所得到的每一个序列进行验证。对所有长度为n的序列进行验证固然可以，但那样时间复杂度为n，所以，当产生长度为k(1k&lt;n)时就检证，只有合理时才以此来产生长度为k十1的序列的办法要好些。大象知道，递归程序既易编，又易读懂，请思考，本问题能否用递归法解决？为什么？" ID="2">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="【侧试数据及结果】" ID="3">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="total:5" ID="4">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="栈和队列是两种操作特殊的线性表，在实际中应用相当广泛。本实验的目的在于使学生深入了解栈和队列的特性，熟悉栈和队列的操作，以便在实际问题背景下灵活运用它们，同时巩固对这两种结构的构造方法和运行过程的掌握，开始接触较复杂问题的递归算法设计." ID="1">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="252" TITLE="11.3 实验三串及其应用--简单行编辑程序" TYPE="Chapter">
      <fptr LogicalPageNum="263" PhysicalPageNum="263"/>
      <Paragraph CONTEXT="简单行编辑程序" ID="1">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="【实验目的】串，在本质上是一种线性表，但是，由于串在实际当中有着广泛的应用，尤其是在文本编辑方面，而且，在应用中形成了一些结构所特有的基本运算，所以，它往往从线性表中独立出来，独树一帜，自成体系。本实验的目的就是通过训练，加深理解并把握串的基本运算的特点，使用技巧，以及串在文本编辑中的作用。" ID="2">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="【问皿描述】文本编辑程序是利用计算机进行文字加工的基本软件工具，实现对文本文件的插人、删除等修改操作。限制这些操作以行为单位进行的编辑程序称为行编辑程序。被编辑的文本文件可能很大，全部读人编辑程序的数据空间（内存）的作法既不经济，也不总能实现。一种解决方法是逐段地编辑。任何时刻只把待编辑文件的一段放在内存，称为活区。试按照这种方法实现一个简单的行编辑程序。设文件每行不超过320个字符，很少超过80个字符。" ID="3">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="·252" ID="4">
        <fptr EndPN="00000263" StartPN="00000263"/>
      </Paragraph>
      <Paragraph CONTEXT="【基本要求】" ID="5">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="实现以下4条基本编辑命令：ll行插人格式：i（行号》（回车）（文本》.＜回车》将（文本》插人活区中第（行号》行之后。" ID="6">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="2）行删除格式：d（行号1（空格》（行号2（回车》删除活区中第（行号1）行（到第（行号2）行）。例如：&quot;d10回车”和“d1014回车”。" ID="7">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="3)活区切换格式：n（回车》将活区写人输出文件，并从输人文件中读人下一段，作为新的活区。" ID="8">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="4)活区显示格式：P（回车）逐！地（每页20行）显示活区内容，每显示一页之后请用户决定是否继续显示以后各页（如果存在）。印出的每一行要前置行号和一个空格符，行号固定占4位，增量为1,各条命令中的行号均须在活区中各行行号范围之内，只有插人命令的行号可以等于活区第一行行号减1，表示插人当前屏幕中第一行之前，否则命令参数非法。【测试数据】" ID="9">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="自行设定，注意测试将活区删空等特殊情况." ID="10">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="【实现提示】" ID="11">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="1)设活区的大小用行数ActiveMaxLen（可设为100)来描述。考虑到文本文件行长通常为正态分布，且峰值在60到70之间，用320*ActiveMaxLen大小的字符数组实现存储将造成大量浪费。可以以标准行块为单位为各行分配存储，每个标准行块可含81个字符。这些行块可以组成一个数组，也可以利用动态链表连接起来.一行文字可能占多个行块。行尾可用一个特殊的ASCII子符（如（(012)8)标识.此外，还应记住活区起始行号.行插人将引起随后各行行号的顺序下推。" ID="12">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="2)初始化函数包括：请用户提供输人文件名（空串表示无输人文件）和输出文件名，两者不能相同。然后尽可能多地输人文件中读人各行，但不超过ActiveMaxLen-x,x的值可以自定，例如20" ID="13">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="3)在执行行插人命令的过程中，每接受到一行时都要检查活区大小是否已达ActiveMax-Len。如果是，则为了在插人这一行之后仍保持活区大小不超过ActiveMaxLen，应将插人点之前的活区部分中第一行输出到输出文件中；若插人点为第一行之前，则只得将新插人的一行输出。" ID="14">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="4)若翰人文件尚未读完，活区切换命令可将原活区中最后几行留在活区顶部，以保持阅读连续性；否则，它意味着结束编辑或开始编辑另一个文件。" ID="15">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="5)可令前3条命令执行后自动调用活区显示。" ID="16">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="【选作内容】" ID="17">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="1)对于命令格式非法等一切错误作严格检查和适当处理." ID="18">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="2）加人更复杂的编辑操作，如对某行进行行替换；在活区内进行模式匹配等，格式可以为s（行号）＠（串2)＜回车）和m（串》（回车）。" ID="19">
        <fptr EndPN="00000264" StartPN="00000264"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构" ID="20">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="254" TITLE="11.4 实验四树及其应用" TYPE="Chapter">
      <fptr LogicalPageNum="265" PhysicalPageNum="265"/>
        <div ORDERLABEL="254" TITLE="11.4.1 二叉树的中序遍历及线索化" TYPE="Chapter">
        <fptr LogicalPageNum="265" PhysicalPageNum="265"/>
        <Paragraph CONTEXT="【实脸目的】" ID="1">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="1)熟悉二叉树的二叉链表存储结构；" ID="2">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="2)掌握构造二叉树的方法；" ID="3">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="3）加深对二叉树的遍历及线索化的理解.【问厄描述】任意给出一裸二叉树，试设计一个程序，在计算机中构造该二叉树，并对它进行中序遍历及线索化。" ID="4">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="【基本要求】" ID="5">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="1)数据结构采用Itag和rtag标志域的二叉链表（线索链表）存储二叉树及线索。" ID="6">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="2)输人数据" ID="7">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="254" TITLE="11.4.2 重言式判别" TYPE="Chapter">
        <fptr LogicalPageNum="265" PhysicalPageNum="265"/>
        <Paragraph CONTEXT="【问厄描述】一个逻辑表达式，如果对于其变元的任一种取值都为真，则称为重言式；反之，如果对于其变元的任一种取值都为假，则称为矛盾式；既非重言式，也非矛盾式，则称可满足式。试写一个程序，通过真值表判别一个逻辑表达式属于上属哪一种。【实验要求】" ID="1">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="1)逻辑表达式从终端愉人。逻辑运算符号包括：非“一”、或“｝”和与“＆”，运算优先级递降，但可由圆括号”（”和”）”改变，即括号内的运算优先。逻辑变元为一个大写或小写字母。表达式中任何地字母间都可以含有多个空格符。" ID="2">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="2）若是重言式或矛盾式，只可显示“TRUEFOREVER”或“FALSEFOREVER&quot;，否则，显示“SATISFACTIBLE&quot;，以及变量名序列，与用户交互.若用户对表达式中变元取定一组值，程序就求出显示逻辑表达式的值。" ID="3">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="【方法说明】" ID="4">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="1)识别逻辑表达式的符号形式并建立二叉树，可以用以下策略：自底向上的运算符号优先法（参见教科书第3.2节），先序遍历建立二叉树的方法。" ID="5">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="2)可设表达式中逻辑变量数不超过20。真值表的产生：可在一个维数组上，一次产生一·254组真值，即一个真值指派，然后计算表达式的真值，看表达式的真值是否总是不变，以此来辨别其类型。用递归方法实现更简单。" ID="6">
          <fptr EndPN="00000266" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="【测试数据及结果】1Al-A)&amp;(B1-B)Tureforever;2A＆一A)&amp;CFulseforever;" ID="7">
          <fptr EndPN="00000266" StartPN="00000266"/>
        </Paragraph>
        <Paragraph CONTEXT="3)aibiciDiEi-aTureforever;" ID="8">
          <fptr EndPN="00000266" StartPN="00000266"/>
        </Paragraph>
        <Paragraph CONTEXT="4)aB&amp;c＆一BFulseforever;" ID="9">
          <fptr EndPN="00000266" StartPN="00000266"/>
        </Paragraph>
        <Paragraph CONTEXT="5)(AiB)&amp;(Ai-B)satisfactible;" ID="10">
          <fptr EndPN="00000266" StartPN="00000266"/>
        </Paragraph>
        <Paragraph CONTEXT="6)A＆一Bi-A8B;0,0;0,1;1,1;1,0,【选做内容】逻辑变元的标识符不限于一个字母，可以是任意长的字母数字串。还可根据用户的要求" ID="11">
          <fptr EndPN="00000266" StartPN="00000266"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="树结构在实际中有着广泛的应用，在《数据结构》这门课程中也是重点和难点，而二叉树则是其典型代表，故应着重训练。由于遍历是其他众多运算的基础，故本实验自然离不开遍历，希望能认真把握。另外，实验还涉及二叉树的建立以及其他一些编程技巧。本实验旨在通过这些训练，以达到熟悉树的存储结构特点，进一步理解树在解决实际问题中的应用，以达到应用树结构解决具体问题的目的。" ID="1">
        <fptr EndPN="00000265" StartPN="00000265"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="255" TITLE="11.5 实验五图及其应用--跳马将军" TYPE="Chapter">
      <fptr LogicalPageNum="266" PhysicalPageNum="266"/>
      <Paragraph CONTEXT="跳马将军【实验目的】图是一种很重要的数据结构，在很多大型系统中都要用到图结构。关于图，有许多存储表示方法，也有许多经典问题和解法。方法是死的，而应用环境和具体问题则是多变的，具备任何分析具体问题，恰当地应用所学的知识和方法来解决问题的能力才是最重要的。本实验的目的是加深对图的各种存储方法的特点的理解，并能根据应用需要，选择合适的存储方式，而且能够根据具体问题来选择或设计适当的算法。【问题描述】按照中国象棋的规则（规则从略），给你一个“马”，请编程求出此“马”能将到对方的“帅”的" ID="1">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="最短路程。【实验要求】输人“马”的起始位置（即二维坐标）及“帅”的位置，输出尽可能多的最短路程。要求给出每一步从某个位置可到达的最短路程上的若干个（至少一个）“下一位置”，如：" ID="2">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="step1:" ID="3">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="&lt;3,34,52,5&gt;&lt;1,32,5&gt;【实现提示】可以在搜索之前将棋盘上的位置按马步骤联成一个图，不这样也行，只是每走一步都要进行边界检查，十分麻烦。于是，问题就变成了在图中寻找最短路径的问题，剩下的问题就是如数据结构可能会选出多条最短路程，这时，要根据这些最短路程修改来确定的顶点的路程长度，并修改源点到这些顶点的路程，这时就要把所有的最短路程都进行包括进去，比如说，源点V,到V2有2条最短路程，V：到V,有3条最短路程，则V，经V：到V,就有2X3=6条最短路程，这是乘法原理，同时，V；到V：还可能不径过VZ，故，随桌路程长度的增长，最短路程数会呈指数急剧增长，所以，这种方法并不好。其二，就是用户广度优先搜索法（请思考，为什么不可能深度优先搜索法），每前进一步都把前一位置记下来，直到终点（“帅”）为止，然后再以终点（“帅”）为源点，沿“前一位置”消息搜索原来的源点（“马＂），并沿途作标记，找到“马”后，就可以再一次用广度优先搜索法在有标记的范围之内搜索“帅”，并可在前进之前把每一步的可选择的“下一步”都找到。" ID="4">
        <fptr EndPN="00000267" StartPN="00000266"/>
      </Paragraph>
      <Paragraph CONTEXT="【选做的内容】" ID="5">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="可同时加人其他棋子，这些棋子（攻方的与守方的）会挡住马的一些去路，若是守方的棋子，还会控制一些线路（即马不能从这些危险线路去试图将军），其他要求不变。" ID="6">
        <fptr EndPN="00000267" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT=".256妙猫笋‘叨湘职圈梦叨翻妙甩肾侧腆哪姻脚砂include&lt;stdio.h&gt;include&lt;malloc.h&gt;include&lt;conio.h&gt;defineERROR0defineOK1defineEQUAL1defineOVERFLOW-1defineLIST_INIT_SIZE100#defineLISTINCREMENT10structSTU{" ID="7">
        <fptr EndPN="00000268" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="charname[201;" ID="8">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="charstuno[101;" ID="9">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="intage;" ID="10">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="intscore;｝stu[501;structLNODE" ID="11">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="｛ElemTypedata;structLNODE关next;｝；typedefstructLNODELNode;数据结构typedefstructLNODE关LinkList;intinit(LinkListL)（L二（LNode*)malloc(sizeof(LNode)ifL)exit(ERROR(Lnext=NULL;returnOK;" ID="12">
        <fptr EndPN="00000269" StartPN="00000268"/>
      </Paragraph>
      <Paragraph CONTEXT="init，/intListLength(LinkListL)｛" ID="13">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="intj=0;while(L一＞next)｛" ID="14">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="L=L-Jnext;" ID="15">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="l十＋；" ID="16">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="17">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="returnJ;" ID="18">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="｝intGetElem(LinkListLinti,ElemType共e)｛LinkListp;intj;p=L&gt;next;j=1;while(pjGiP二P一＞next-j;｝if&lt;!pjlj&gt;1)returnERROR;*e=p一＞data;returnOK;" ID="19">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="｝intEqualList(ElemType*e1,ElemType*e2)if(strcmp(el&gt;name,e2一仁＞name)0)return1;else" ID="20">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="258" ID="21">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
      <Paragraph CONTEXT="return0;" ID="22">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="）intLess_EqualList(ElernType*el,ElemType二e2)｛if(strcmp&lt;el长＞name,e2一＞name0)return1;" ID="23">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="24">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="return0;" ID="25">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="｝intLocateElem(LinkListLa,ElemTypee,inttype)｛" ID="26">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="inti;" ID="27">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="LinkListp;" ID="28">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="p=La;" ID="29">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="switch(type)" ID="30">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="｛caseEQUAL;（" ID="31">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="P=P一＞next;" ID="32">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="return0;" ID="33">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="break;" ID="34">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="default:" ID="35">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="break;" ID="36">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="37">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="return0;" ID="38">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="39">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="voidMergeList(LinkListLa,LinkListLb,LinkList*Lc)｛LinkListpa,pb,pc;pa=La一仁＞next;pb=Lb一＞next;关Lc=pc=La;while(papb)｛·259" ID="40">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构if(Less_EqualListpa一＞data,pb一＞data（pc一＞next=pa;pc=papa=paes.＞next;｝" ID="41">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="42">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="｛pc一＞next=pb;pc=pb;pb=pb，－－：＞next;｝" ID="43">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="｝pc一＞next=pa?pa:pb;free(Lb" ID="44">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="｝intprintlist(LinkListL)｛" ID="45">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="mtl;" ID="46">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="LinkListp;" ID="47">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="P=L:printf&lt;&quot;namestunoagescore\n;while(p气＞next)（P今P一next;printf％一lOs%s\t°od\t°od\np一＞data,name,pdata.stuno,P甲&gt;data.age,p一＞data.score｝" ID="48">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="printfn;" ID="49">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="｝intListInsert(LinkListLinti,ElemTypee)｛" ID="50">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="LinkListp,s;" ID="51">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="intj;" ID="52">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="P=L;j=O;while(pj&lt;i-1)｛p=p一＞next;十＋J;" ID="53">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="｝ifPllj&gt;i-1)returnERROR;·260；_(LinkList)malloc(sizeof(LNode;；一仁＞data=e;；－艺＞next=p一＞next;P一）next=s;" ID="54">
        <fptr EndPN="00000272" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="returnOK;｝/*ListInsertBeforeimain()" ID="55">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="56">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="structSTUe;LinkListLa,Lb,Lc;clrscrO;printfn\n··ListDemoisrunning··°·，一、n\nprintfFirstisInsertListfunctionninit（＆La）；strcpy&lt;e.namestul;strcpy(e,stuno100001;" ID="57">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="e,age=80;" ID="58">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="e.score=1000;ListInsert(La,1,e);strcpy(e.namestu3strcpy(e.stuno100002" ID="59">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="e.age=80;" ID="60">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="e,score=1000;ListInsert(La,2,e);printlist(La);" ID="61">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="getch;strcpy(e.namestu5strcpy(e,stuno100003" ID="62">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="e,age=80;" ID="63">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="e.score=1000;ListInsert(La,3,e)玫据结构。rintlist(La);3etch;" ID="64">
        <fptr EndPN="00000273" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="initLb);strcpy(e.namestu2;strcpy(e.stuno100001" ID="65">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="e,age=80;" ID="66">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="e,score=1000;ListInsert(Lb,1,e);strcpy(e.namestu4;strcpy(e.stuno100002" ID="67">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="e.age=80;" ID="68">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="e.score=1000;Listlnsert(Lb,2,e);strcpy(e,namestubstrcpy(e.stuno00001" ID="69">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="e,age=80;" ID="70">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="e.score=1000;ListInsert(Lb,3,e);printlist(LbgetchO;MergeList(La,Lb,(PLC);printlist&lt;Lc);getchO;printfn\n\n\n\n\nWelcometohate!\n\n\n\n\n\n\n·262" ID="71">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="【实验目的】老鼠走迷宫的游戏不少人都已经知道了，甚至一些医学专家用老鼠在迷宫中的行为来进行实验心理学研究。今天，利用计算机来解迷宫问题的确是数据结构课程的一个很好的练习，它不仅有助于熟悉数组与堆栈的应用，而且还会对“回溯程序设计”方法增加一些感性认识。【问题描述】一个迷宫可以看作尸个M*N矩阵，其元素为1或0,1表示有障碍（用阴影表示）,0表示无障碍（用空白表示），并且指定一个人口单元和一个出口单元。通过迷宫就是要从人口开始，在每次移动中只能从一个无障碍的单元移到其周围的八个方向上任。无障碍的单元，直至移到出口单元为止。" ID="72">
        <fptr EndPN="00000274" StartPN="00000274"/>
      </Paragraph>
      <Picture URL="00000274\00000274_new\0016.jpg">
        <fptr EndPN="00000274" StartPN="00000274"/>
      </Picture>
      <Paragraph CONTEXT="【实验要求】解决迷宫的问题就是要寻找一条通过迷宫的路径，采用的是回溯技术，其基本思想是试探：只要有路可走就前进一步，无路可走时，退回一步，重新选择那些未走过的可走的路。如此继续，直至到达出口或返回人只处（无法通过迷宫）。为了保证在任何位置上都能沿原路退回，显然需要一个后进先出的结构来保存从人口到当前位置的路径。因此，在求迷宫通路的算法中应用“栈”也就是理所当然的事了。在进行算法设计时，设置一个栈保存已经过的多分支位置信息，注意，只有悦条路可经过的位置不必记录，在那里不存在重选的可能，这样可以加快回溯速度。" ID="73">
        <fptr EndPN="00000274" StartPN="00000274"/>
      </Paragraph>
      <Paragraph CONTEXT="【实现提示】在任意时刻，老鼠在迷宫中的位置可以用老鼠所在点的行下标和列下标（i,j）来表示，这样，老鼠在迷宫中的某点MAZE[i,j］时，其可能的运动方向有8个。图11.2中O表示某时刻老鼠所在的位置j)，相邻的8个位置分别标以N,NE.E,SE,S,SW.W.NW（分别代表O点的北、东北、东、东南、南、西南、西、西北方向）；同时，相对于（(i,j)，这8个相邻的位置的坐标都可以计算出来，如图11.2所示。" ID="74">
        <fptr EndPN="00000274" StartPN="00000274"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结构$Picture[00000275\00000275_new\0002.jpg]Picture$但是，并非迷宫中的每一个点都有8个方向可走，4个角上就只有3个方向可以选择，边上只有5个可供选择的方向。为了不在算法中每次都去检查这些边界条件，在迷宫外面套上一圈，其元素值均为1，这样，实际M*N的迷宫所使用的数组就变成了图11.11所示的有（M+2）行、(N-F2）列的矩阵MAZEM-2)N-f-2。该矩阵的人口位置是MAZE[1,11，而出口位置则是MAZE[M,N],为了简化算法，根据图3.10所示的位置（(i,j）与其相邻的8个位置的坐标关系，建立一个如图11.3所示的表，表中给出相对于位置（(i,j）的8个方向上的i,j的增量值。一科撇黝图11.3设计算法时，在每一个位置上，处理方法如下：如果当前位t已经是出口则成功，否则计算当前位置的出口数，已经走过的位置（如来路）应排除，将经过的位t值改为非0（假如程序结束前想恢复迷宫原貌，应置异于1的值）。如出口数为。则需要回溯，即取出栈顶元素作为当前位t信息，栈空表明此迷宫无解；如出口数为1则无可选择，直接推进；如出口数大于1，则将当前位置信息送人栈中。这里称的“当前位！信息”除行、列号外还包括一方向值，该方向值即为前面所说的。7这8个方向.约定找出路时总从0方向开始顺时针进行，在栈内保存了每个分支点上已经选过的方向最大值，这样回溯时就不必再从。开始选，避免了无效重复。这样表示迷宫中的一个位里，也就是栈中的一个元素的数据应有如下结构，它用代替前面" ID="75">
        <fptr EndPN="00000275" StartPN="00000275"/>
      </Paragraph>
      <Paragraph CONTEXT="链栈数据元家类型的定义语句：" ID="76">
        <fptr EndPN="00000275" StartPN="00000275"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstruct" ID="77">
        <fptr EndPN="00000275" StartPN="00000275"/>
      </Paragraph>
      <Paragraph CONTEXT="｛inti,j,dir;}Elem'I'ype;移动位！用两个一维数组movei,movej保存07方向上相应的行、列号增量。当前位置为（curi,curj),由于栈元素改为结构类型，栈操作实现模块中有几个函数也有相应改动，包括与栈有数据" ID="78">
        <fptr EndPN="00000275" StartPN="00000275"/>
      </Paragraph>
      <Paragraph CONTEXT="交换的进栈、出栈。这里采用链栈进行实现，其对应函数进行如下更改：linkstack*push(linkstacktop,datatypex)｛" ID="79">
        <fptr EndPN="00000276" StartPN="00000275"/>
      </Paragraph>
      <Paragraph CONTEXT="linkstack*q;q=(linkstack*)malloc(sizeof(linkstack;q一＞data.1，x.1；／，改动部分‘／q‘－－：＞data.j二x.j;/，改动部分‘／q一＞data,dir=x,dir;/，改动部分‘／q一＞next=top;" ID="80">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="top=q;" ID="81">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="return(top／，从栈中取出一结构型数据，／linkstack*1inkpop(top,datap)linkstack*top;" ID="82">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemType长datap;" ID="83">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="（" ID="84">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="linkstack*q;if(topNULLprintfunderflowreturnNULLelse{*datap,i=top一）data.i;/，改动部分，／*datap.j=top&gt;data.j;/，改动部分，／二datap.dir=top&gt;data.dir;/，改动部分‘／q=top;" ID="85">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="top=top&gt;next;" ID="86">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="free(q" ID="87">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="return(top" ID="88">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="89">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="}/*1inkpop，/" ID="90">
        <fptr EndPN="00000276" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="【测试数据及程序】用C语言编写的迷宫程序如下：include&quot;stdio.h&quot;$include&quot;linkstack.c&quot;#defineROWS8defineCOLUMNS11staticintmaze[ROWSCOLUMNS，迷宫，／{{1,1,1,1,1,1,1,1,1,1,1数据结构{1,0,1,0,0,0,1,1,0,0,1{1,1,0,0,0,1,1,0,1,1,1{l,o,l,l,o,o,o,o,l,l,l{1,1,1,0,1,1,1,1,0,1,1{1,1,1,0,1,0,0,1,0,0,1{1,0,0,1,1,1,0,1,1,0,1{1,1,1,1,1,1,1,1,1,1,1staticantmovei[81_（一1，一1,0,1,1,1,0，一1staticintmovej[810,1,1,1,0，一1，一1，一1linkstack*Is=NULL;datatype*a=NULL;intcuri二l,curj=l;/，人口位置，／intnexti,next];／二下一个位置的行、列坐标，／intnextd[21;所以将初始值直接设为2，从E方向开始试探，／" ID="91">
        <fptr EndPN="00000277" StartPN="00000276"/>
      </Paragraph>
      <Paragraph CONTEXT="main()" ID="92">
        <fptr EndPN="00000277" StartPN="00000277"/>
      </Paragraph>
      <Paragraph CONTEXT="｛stopmaze=FALSE:intoutnumO,backO,forkO;" ID="93">
        <fptr EndPN="00000277" StartPN="00000277"/>
      </Paragraph>
      <Paragraph CONTEXT="voidprint;" ID="94">
        <fptr EndPN="00000277" StartPN="00000277"/>
      </Paragraph>
      <Paragraph CONTEXT="is二linkstacknull(ls);" ID="95">
        <fptr EndPN="00000277" StartPN="00000277"/>
      </Paragraph>
      <Paragraph CONTEXT="while(!stopmaze)｛switch(outnum(curi,curj,d))｛break;／二出口位置则成功，／｝｝case1:curi=nexti;｝｝" ID="96">
        <fptr EndPN="00000278" StartPN="00000277"/>
      </Paragraph>
      <Paragraph CONTEXT="print;" ID="97">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="｝／，函数。utnum返回出口个数，／intoutnum(i,j,dd)" ID="98">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j,dd;" ID="99">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="100">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="intcount,k;fork=dd,count=0;(kG=7countG=1k｛if(i(ROWS-2j＝二（COLUMN-2if(maze[i-i-movei[kjmovej[k_=0)" ID="101">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="102">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="nextd[count-1=k;" ID="103">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="if(count1)" ID="104">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="圣" ID="105">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="106">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="107">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="returncount;｝／，函数back执行回溯操作，／back(ip,jp,dp)int*ip,*jp,*dp;（ElemType釜temp;if(empty(lsreturnERROR;pop(ls,temp*1P＝并temp,i;*］p=*temp.1;·267" ID="108">
        <fptr EndPN="00000278" StartPN="00000278"/>
      </Paragraph>
      <Paragraph CONTEXT="数据结林returnOK／，函数fork将分支点信息送人栈内，，fork(i,j,d;inti,j,d;" ID="109">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="110">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="ElemTypetemp;temp.i=i;temp.j=j;temp.d=d;return(linkpush(Is,temp);》／，函数print打印结果，／print()叹" ID="111">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="inti,j;" ID="112">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="printfin;for(i=O;iCROWS;i＋十）悦for(j=0;j&lt;CLOUMNS;j--f-)if(maze[ij]＝二）printf%c‘二‘）；" ID="113">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="elseprintf%dmaze[i][j;" ID="114">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="printfn;｝少" ID="115">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
      <Paragraph CONTEXT="268" ID="116">
        <fptr EndPN="00000279" StartPN="00000279"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="臼砚旅顺华涸梦恻脚妙摊睐咽多卿颐缈摊瞬涸笋侧锁妙棘饭阅多徽毓缈死数据结构是计算机专业的核心课程，训练同学进行复杂程序设计的技能和培养良好程序设计的习惯是本课程的教学要求之一。上机实验是《数据结构》教学中必不可少的环节，其重要程度不亚于知识的传授。通过上机编程实验，加深对课堂教学内容的消化理解，同时也是对同学的一种全面综合训练。" ID="1">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="«)实验步骤一个软件工作者应具备科学的工作方法和良好的工作作风，软件开发需要系统工程的思想。软件开发常用的方法是将软件开发过程分为需求分析、系统设计、编程实现和维护4个阶段。虽然数据结构的实验其难度远不如一个面向实际的“真正”的软件，然而我们应从课程实验训练中逐步培养好的思维方式和工作方法，以提高科学素养。" ID="2">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="1)需求分析首先需要充分分析和理解问题本身，明确问题的要求是什么，限制条件是什么，确定程序的各项功能、性能需求和设计约束，考虑基本数据特性、数据间的联系等.在问题分析阶段，不要急于想“怎么做”，而是强调“做什么”。对问题的描述应避开算法和所涉及的数据类型，而对所需完成的任务作明确的回答。" ID="3">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="2)系统设计系统设计分为逻辑设计和详细设计.逻辑设计是对问题描述中的操作对象定义相应的数据类型，以数据结构为中心划分功能模块，即写出每个抽象数据类型的定义（包括数据结构的描述和每个基本操作的规格说明）和各个主要模块的算法，并画出模块之间的调用关系图.详细设计是对数据结构和基本操作的规格说明做出进一步的求精，写出数据存储结构的类型定义，按照算法书写规范写出函数形式的算法框架。在求精过程中，应尽量避免陷人语言细节，不必过早进行辅助数据结构和局部变量的定义。" ID="4">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="3)编码实现编码是用一种程序设计语言把详细设计的结果进一步求精为能够上机运行的程序，编写的程序要符合该程序设计语言的语法规则。对于C语言编程很熟悉的同学，可将详细设计的算法直接在键盘上输人程序，而对不熟悉的同学，必须在上机前将程序在纸上写好，以节省上机调试的时间." ID="5">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="4)测试数据设计上机前除了准备好上机程序外，还必须准备好测试数据。测试数据包括以下几种可能的情况：" ID="6">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="①验证程序各种函数功能的基本数据；" ID="7">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="②验证函数与函数之间参数传递的数据；" ID="8">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="③验证各个函数边界条件的数据；" ID="9">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="④不满足边界条件的数据。" ID="10">
      <fptr EndPN="00000256" StartPN="00000256"/>
    </Paragraph>
    <Paragraph CONTEXT="数据结构" ID="11">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="5)上机准备和上机调试运行上机的准备工作有：①用每一组设计好的测试数据手工执行程序（通常应先分模块分函数检查），静态检查程序逻辑的正确性，发现程序中存在的问题，并为程序加上注解，以帮助理解程序，保证程序功能逻辑的正确性。②熟悉上机环境，包括操作系统、高级程序设计语言编辑编译的常用命令，掌握调试工具的使用，以便上机调试活动的顺利进行。上机步骤：源程序编辑一编译一连接一运行在调试过程中尽量借助调试工具，提高调试效率。" ID="12">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="6)总结和整理实验报告" ID="13">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="(2)实验报告规范" ID="14">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="实验报告内容包括：" ID="15">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="1)实验目的说明实验所验证的知识点。2&gt;需求分析以无歧义的陈述说明程序设计的任务、约束条件、输人输出要求、对功能的规定及模型。" ID="16">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="3)逻辑设计说明本程序中用到的所有抽象数据类型的定义、主程序的流程以及各程序模块之间的层次调用关系。" ID="17">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="4)详细设计’逻辑设计中定义的所有数据类型的实现，核心算法的设计描述、人机界面设计、函数之间调用关系的描述，主要功能的算法框架，测试数据设计." ID="18">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="5)测试分析测试结果的分析与讨论，测试过程中遇到的主要问题及采取的解决措施。" ID="19">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="6）心得软件设计与实现过程中的经验与体会，进一步改进的设想。" ID="20">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="7)程序清单‘源程序中应有足够的注释.如果提交源程序软盘，列出程序文件名。" ID="21">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="(3)如何提高上机效率为了提高上机的效率，真正达到实验目的，要求同学做好实验前的准备工作，写好实验预习报告，即实验报告规范中的1234)部分，编写好程序，并用一组测试数据手工执行程序静态检查程序是否有错，通过阅读、执行程序或给别人讲解自己的程序而深人全面地理解程序逻辑，提高程序的正确性。对C语言程序不熟悉的同学，上机时最好带上C语言程序设计的教材，以备查阅。调试" ID="22">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="迅速排除问题，加快调试速度。" ID="23">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
    <Paragraph CONTEXT="·246" ID="24">
      <fptr EndPN="00000257" StartPN="00000257"/>
    </Paragraph>
  </div>
  
</METS>
