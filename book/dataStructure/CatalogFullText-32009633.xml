<?xml version="1.0" encoding="utf-8" standalone="no"?>
<METS xmlns:METS="http://www.loc.gov/METS/" xmlns:gdm="http://sunsite.berkeley.edu/GDM/" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" TITLE="Zhejiang University.jdl.China-America digital library project" TYPE="Section" xsi:schemalocation="http://www.loc.gov/METS/http://www.loc.gov/standards/METS/METS.xsd">
  
    <div ORDERLABEL="00000014" TITLE="第一章  绪论" TYPE="Chapter">
    <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
      <div ORDERLABEL="00000014" TITLE="第一节  什么是数据结构" TYPE="Chapter">
      <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
        <div ORDERLABEL="00000014" TITLE="一、  发展史" TYPE="Chapter">
        <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
        <Paragraph CONTEXT="自194G年电子计算机问世以来，电子计算机的应用范围越来越广泛，计算机科学和软硬件技术发展迅速.计算机应用领域也从早期的科学和工程的计算发展到人类社会活动的一切领域。计算机的处理对象不仅是简单的纯数值型信息，而且是带有不同结构的各种数据和非数值型信息。现代计算机科学把计算机程序处理的一切数值和非数值型的信息统称为数据(data)，电子计算机是加工处理数据的工具。所以.要设计一个好的软件，不仅要求人们掌握计算机使用的语言，还要系统地研究计算机程序加工的对象，即研究数据的特性、数据之间存在的关系―数据结构。数据结构作为一门独立的课程在美国从1968年就开始设立了。60年代中期数据结构的前身叫表处理语言，但当时未成课程体系。19fi8年美国唐·欧·克努特教授开创了数据结构的最初体系，并系统地阐述了数据的逻辑结构和存储结构。在美国一些大学的计算机系，也开始把数据结构作为一门独立的课程。从so年代到70年代初，人们越来越重视数据结构,70年代中期到$o年代初，关于数据结构的书开始大量出现，我国各种关于什算机的学术研讨会确定数据结构为计算机专业的主要课程，而且也是非计算机专业的主要选修课程.这是因为在计算机科学中，数据不仅是一般程序设计（特别是非数值计算的程序设计）的基础，而且是设计和实现编译程序、操作系统、数据库系统及其它系统程序的重要基础.数据结构的发展并未终结，一方面是向各专门领域中特殊问题的数据结构的研究和发展，另一方面，从抽象数据类型的观点来讨论数据结构，已成为一种新趋势，越来越被人们重视。" ID="1">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000014" TITLE="二、  数据结构" TYPE="Chapter">
        <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
        <Paragraph CONTEXT="用计算机可以解决图书馆的书目检索自动化问题，多叉路口交通灯的管理间题及成绩排队间题等等，对这些问胭的解决要从具体问题抽象出一个恰当的数学模型，并设计一个较好的解决此数据模型的算法，最后编出程序、进行侧试，调整得到最终结论.从这里我们可以看出用计算机解决实际间题的主要步骤是寻求数据模型，而寻求数据模型的实质是分析间题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述.至于什么是数据结构，我们不妨先看下面的例子，然后再给出定义.例1.查询职工住址间题：假定有一个职工通信录，记录了某工厂全体职工的姓名和相应的住址，现要写一算法，要求给定任何一位职工的姓名.该算法能够查出该职工的住址。(1)首先抽象出一个适当的数学模型。对职工通信录进行适当组织，按职工所在车间来排列，并且再造一个索引表.由这张表构成的文件便是职工住址查找的数学模型，计算机的主要操作是：先从索引表中查到某个职工所在车间的职工姓名是从何处开始，然后，就从这开始查找，进行查询.而不藉要查找其他部分的姓名.这类数学模型中，什算机处理的对象之间通常存在着一种最简单的线性关系.这类数学模型称为线性的数据结构，此外描述非数值计算间题的数学模型还有树和图之类的数据结构。(2)设什一个解此数学模型的算法，计算机的算法与数据结构（数据模型）密切相关，数据结构直接关系到算法的选择和效率。此外，数据结构还需要给出每种结构类型所定义的各种运算的算法.还以职工通信录为例，当有职工进厂，浦要添上新职工的姓名和住址。还要求在已安排好的结构上进行插人（insert）和翻除（delete)。但是.如何实现擂人和剔除？擂人和姗除后对原有数据是否有影响，有什么样的影响？我们应事先考虑。如添加职工的姓名和住址具体应添在什么位t，职工调离，姗除其姓名住址.其它数据是否移动及怎样移动？为此，还猫定义一些运算，如擂人运算和姗除运算.另外，对于职工摄家间题还可以定义修改运算。计算机要完成这些运算，就要设计出相应的算法，为此数据结构需给出每种结构类型所定义的各种运算的算法.(3)最后，编出程序，进行侧试、调整，直至最终解决。因此，数据结构是研究数据元素（dataelement）之间抽象化的相应关系和这种关系在计算相应的算法.而且确保经过这些运算后所得到的新结构仍然是原来的结构类型." ID="1">
          <fptr EndPN="00000015" StartPN="00000014"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000015" TITLE="第二节  基本概念和术语" TYPE="Chapter">
      <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
      <Paragraph CONTEXT="在本节中，我们将对全书中最常用的一些概念和术语斌以确定含义，以便读者更好地理解.数据（data）是对客观事物的符号表示，在计算机科学中是指所有输人到计算机中并被计算机程序处理的符号。例如：一本书、一篇文章、一张图表、一个句子、一个算式、一个数值、一个字符等都是数据。因此，数据含义是很广泛的，所有能够被计算机加工的对象，能够被计算机翰人、存储、处理和翰出的一切信息都称为数据.数据元素(dataelement)是数据的基本单位，在计算机程序中通常作为一个事件进行考虑和处理。例如第一节中例1.1中的“表”被称为一个数据元家。一个数据元素可能由若干个数据项组成，例如，地址查询中姓名和住址为数据项.对于一个字符申而言，每个字符就是它的数据元1e数据和数据元家是相对而言的，如对于一个文件的每个记录而言，它相对于所在的文" ID="1">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="件是数据元素，而相对于记录中的各数据项（域），它又是完整的数据。数据对象（(dataobject)是性质相同的教据元紊的集合。是数据的一个子集.例如：宇符中的字母数据对象是集合C二｛‘AB’.…，‘2’｝e数据结构（datastructure）是相互之间存在一种或多种特定关系的数据元案的集合.数据类型(datatype）是和数据结构密切相关的一个概念，它最早出现在高级语言中，用以刻划程序中操作对象的特性，在用高级程序语言编写的程序中.每个变t、常t或表达式都有" ID="2">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="一个它所属的确定的数据类型。" ID="3">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="与数据结构密切相关的是定义在数据结构上的一组操作。操作的种类是没有限制的，可以根据需要而定义，基本的操作主要有以下几种：插人（(insert)：在数据结构中的指定集合上增添新的数据元素。" ID="4">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="侧除（delete}：姗去数据结构中某个指定的数据元素，查找（search)：在数据结构中寻找满足某个特定要求的数据元素的位置和值；排序（sort)（在线性结构中）重新安排数据元素之间的逻辑顺序关系，使之按值由小到大或由大到小的次序排列。算法（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作，此外，一个算法还具有以下五个主要特性：有穷性：一个算法必须总是（对任何合法的翰人值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。确定性：算法中每一条指令必须有确切的含义.读者理解时不会产生二义性，并且在任何条件下，算法只有唯一的一条执行路径，即对于相同的输人只能得出相同的翰出.可行性：一个算法是可执行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。摘人：一个算法有零个或多个的输人，这些输人来自于特定的对象的集合。输出：一个算法有一个或多个的输出.这些精出是同输人有某个特定关系的量." ID="5">
        <fptr EndPN="00000016" StartPN="00000015"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000016" TITLE="第三节  算法的描述和算法分析" TYPE="Chapter">
      <fptr LogicalPageNum="16" PhysicalPageNum="16"/>
        <div ORDERLABEL="00000016" TITLE="一、  算法的描述" TYPE="Chapter">
        <fptr LogicalPageNum="16" PhysicalPageNum="16"/>
        <Paragraph CONTEXT="关于描述算法的语言：研究数据结构的目的在于有效地进行程序设计，主要是非数值型的程序设计，所以，在讨论各种数据结构的基本运算时都将给出相应的算法。算法偏要用一种语言来描述，而描述算法的语言有多种，在计算机上运行的程序（算法）必须严格按照语法规定用机器语言或汇编语言或高级程序语言来编写，而一个读者阅读和交流的算法应该是具有描述简单、明确、一目了然和便于理解及掌握其思想和实质的算法，因此采用一种中间的形式―类Pascal语言做为描述工具.类Pascal语言是我们在标准Pascal语言基础上的修改，它忽略了标准Pascal语言中语法规则的一些细节，同时增加了一些功能较强的语句。由于本课程是Pas-cal语言的后继课程，所以本书中采用了十分接近于Pascal语育的类Pascal语官描述，这样做的目的将使得算法更具体、更易于在计算机上实现。" ID="1">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="有的算法以过程形式表示：" ID="2">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="procedure过程名（参量表），" ID="3">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="b祝in" ID="4">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="5（语句组）" ID="5">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="6">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="也有的算法以函数形式表示：" ID="7">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="function函数名（参盆表）：函数值类型；" ID="8">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="9">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="S（语句组）" ID="10">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="函数名：＝返回值，" ID="11">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="end;参量表可含有若干个参量，语句组由一个或一个以上的语句组成，两语句之间用“尸作分隔符，另外几个语句也可以写成一行。类Pascal语言的语句如下：" ID="12">
          <fptr EndPN="00000017" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="1.赎值语句变量名：＝表达式" ID="13">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="2.转向语句goto语句标号" ID="14">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="3.调用过程语句Ccall〕过程名（参量表）此处“c山”也可以省略." ID="15">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="4.退出循环语旬" ID="16">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="exit" ID="17">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="5.返回语句return结束并退出函数或算法过程。‘.出错语句error（宇符串）在算法中为了避免非法操作，进行出错处理时用该语句，它表示此算法的执行到此中止。该语句括号内的字符串用以说明出错的原因。" ID="18">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="7.条件语句，有两种形式，即if条件thenS1或if条件thenS1elseSp其中，Sl.SZ是任意的语句组。" ID="19">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="8.情况语句" ID="20">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="21">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="或case变量名of" ID="22">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="值I:S1:" ID="23">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="值2:52:" ID="24">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="值3:Sa3" ID="25">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="……" ID="26">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="值n:Sa;" ID="27">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="else:Sn+1“4" ID="28">
          <fptr EndPN="00000017" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="ends其中，SS(1《in+1）为任意的语句组.，.加r循环语旬fori=＝初值to终值doSQlfari,＝初值downta终值dflSQ其中，格式①初值应小于或等于终值，格式②的初值应大于或等于终值，否则不会执行其循环体。lU.w611e摘环语句" ID="29">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="while条件doS" ID="30">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="12.rapes扭循环语句" ID="31">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="爬peat" ID="32">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="Suntil条件其中S是一组语句，此循环语句含义是重复执行repeat与until之间的语句组，直到until之后的条件成立，才停止重复执行，而去执行后面的语句。12入场'read（变量表）或readln（变t表）〕" ID="33">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="向变量表中输人数据后不换行或换行，其中readln可省略变t表，此时只接收一个换行符。" ID="34">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="13.输出语句write（参量表）或writeln（参盆表）〕翰出各参t的值不换行或换行。其中，writeln可省略参t表，作用是只翰出一个换行符." ID="35">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="14.stop命令它命令过程停止执行巧.加奄加" ID="36">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="复合语句开始。复合语句是多个语句的组合.其语法地位相当于一个语句.l6.ead复合语句结束.另外，在算法中任何处均可插入用大括号“毛）”，括起来的中文表示注释，对于算法或某些步孩给予必要的有关算法分析的说明." ID="37">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000018" TITLE="二、  算法的分析" TYPE="Chapter">
        <fptr LogicalPageNum="18" PhysicalPageNum="18"/>
        <Paragraph CONTEXT="当解决同一个间题时，往往能够编写出不同的算法，如何选择一个好的算法及怎样评价算法的好坏，这些都是算法分析要讨论的问题一般从四个方面对算法进行评价，即正确性、运行要通过上机调试.还要从理论上证明其正确性.运行时间是指一个算法在计算机上运行所花费的时间。通常等于所有语句执行时间的总和，而每一语句的执行时间总和为该语句的执行次数与单次执行所需时间的乘积，而这有时又是很难精确计算的，只能对执行次数粗略估计后计算.不管一个算法是简单还是复杂，最终都被分解成简单操作来具体执行.一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间、算法的翰人拍出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。存储量需求指算法执行过程中所需要的最大存储空间。最简单和最直接的算法往往不是最有效的，即最节省时间和空间的。但算法的简单性使得证明其正确性比较容易，同时便于编写、阅读和调试，所以还是应当强调和不容忽视的，简单性有时比有效性更重要。在四个评价指标中，时间的减少和空间的缩小往往是矛盾的，通常用算法的执行时间作为算法好坏的主要衡盘指标，这是因为硬件发展较快，存储芯片价格不断下降，使存储空间花费不断下降。通俗地说，好的算法效率高，效率高指的是算法执行时间短.对于同一个问题如果有多个算法可以解决，执行时间最短的算法效率最高.一般情况下，算法中基本操作重复执行的次数是间题规模n的某个函数g(n)，算法的时间量度记作T(n)二O(g(n))，它表示随间题规模n的增大算法执行时间的增长率和g(n）的增长率相同，称作算法的时间复杂度.常见的0(g(n)）有0(10(logsnO(nO(n1ogsn0（nZ）、0（n，）、0（2，）（在这里，我们把O(1）称为常t阶，0(n）称为线性阶，0(lagsn）称为对数阶.O(nZ）称为平方阶，O(2z）称为指数阶），它们的级别一个比一个高，g(n}中的级别最高的项的级别就是g(n）的级别。例如：在g(n)=ins-4nlogsn-300中.3n，是O(ns）阶（级别）的，4nlogZn是O(n1agzn）阶的，100是0(1）阶的，所以g(n）是O(ns）阶的。从这个例子中可以看出，T(n)=0(nz）的含义是执行次数不超过ns的某个常数倍，其它阶依此类推.一般认为.随n的增大，T(n）增长较慢的算法为优。通常说来，时间复杂度为O(1）的算法不常见，一般我们尽可能选用多项式阶0(n)的算法，而不希望用指数阶O(2°）的算法，即尽纽选用时间复杂度" ID="1">
          <fptr EndPN="00000019" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="级别较低的算法。" ID="2">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="例1.2在下列三个程序段中." ID="3">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)xx十1" ID="4">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)fori1tondoxx十1;" ID="5">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="x:-x十1;" ID="6">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="每段的执行次数如下" ID="7">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="段号次数" ID="8">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="{1)1" ID="9">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="(2}nC3)nz注意，算法分析主要针对复杂的大题目，对于比较简单或n很小的问题，一般无分析的必" ID="10">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="要。" ID="11">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000020" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="20" PhysicalPageNum="20"/>
      <Paragraph CONTEXT="1.现要解决图书馆的书目检索自动化问题，用文字叙述相应算法。" ID="1">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="2.试确定下面两个程序段中各语句的执行次数。" ID="2">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)foriltandoforj：二1toido" ID="3">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="x：二x-1;" ID="4">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)i1;whileiC=ndvbegin" ID="5">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="xx+1;ii1" ID="6">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
      <Paragraph CONTEXT="ends" ID="7">
        <fptr EndPN="00000020" StartPN="00000020"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="00000021" TITLE="第二章  线性表" TYPE="Chapter">
    <fptr LogicalPageNum="21" PhysicalPageNum="21"/>
      <div ORDERLABEL="00000021" TITLE="第一节  线性表及其基本运算" TYPE="Chapter">
      <fptr LogicalPageNum="21" PhysicalPageNum="21"/>
      <Paragraph CONTEXT="我们先观察下列数据结构：" ID="1">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="(80,75,77,85,87,93)课程表（语文，数学，历史，外语，音乐，地理）" ID="2">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="例2.3某单位职工工资表：例2.3稍复杂些，其中每一个数据元素由若干个数据项组目日成，常称为一个记录，所有记录组成的工资表就是一个数据库.为…｝了与例“.Z、例“.2式上统一起采，例2.“的工资表也可以表" ID="3">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="示为图2.1的形式.像这种由几个数据元素按照一定的顺序组成的有限序列(al,as，····，aa）称为一个线性表。这好比用一根线穿起一串珍$Picture[00000021\00000021_new\0016.jpg]Picture$珠，一个数据元素为一倾珍珠，“顺序”为串珍珠的线。其中a,(i二圈L11t山上贡祝1，2,····n)可代表任愈的计算机程序处理的符号，如表Z.1中的数据元素鹉为数字，表2.2中的数据元素a‘为汉语词组，表2.4中的效据元家氏为记录.尽管如此，但同一线性表中的数据元素必定具有相同的特性，即为同一数据对象。元素与元素之间有先后顺序关系（即数据之间的逻辑关系），其中a；为线性表的第一个数据元素，a。是线性表的最后一个数据元素，数据元素a：在数据元素a之前并与a;相邻，数据元素氏+：在数据元素a;之后并与a;相邻。我们称数据元素H;一：为数据元素8。的直接前趋元素，数据元素aifl是数据元索a;的直接后继元素.在线性表（(a，，a2,····，aR）中数据元素氏（1＝2，……，n）有且仅有一个直接前趋元素ai-1；数据元素a；（i＝1，2，·“·，n-1)有且仅有一个直接后继元素a1。线性表中数据元素的个数n(n）0)称为线性表的长度。当n=。时称为空表.如例2.1中“80”是线性表的第一个数据元紊，它的直接后继是数据元素“75”，……，数据元素“93”是线性表的最后一个数据元素，它的直接前趋元素是“87&quot;，线性表的长度是6可见，线性表这种数据结构是通过数据元素在表中出现的先后顺序来体现元素间的逻辑" ID="4">
        <fptr EndPN="00000022" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="关系的." ID="5">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="我们可以用如下形式来描述线性表." ID="6">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="linear_1ist=(D,R)" ID="7">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="其中：Da,a;Edataobject,lGiCn,n&gt;0}R二（Ca‘一：，a｝a：一：.a;ED,2CiCn}通过上面的分析，我们对线性表这种数据结构有了一定的了解，下面介绍线性表的基" ID="8">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="本运算：" ID="9">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)置空表。etnull(1)：将线性表l里为一个空表." ID="10">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）求线性表的第i个数据元素get(1,i)：取得线侧" ID="11">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="1）：取得线性表1中第1个数据元索ai，（1成1镇length（1））。" ID="12">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）取某数据元素的直接前趋PriorO，执）：取得线性表1中数据元素ai的直接前趋元素a卜：（2《1成n）." ID="13">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）取某数据元素的直接后继next（l，a‘）：取得线性表1中数据元素ai的直接后继元素" ID="14">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="a、：（1《1（n-1）。" ID="15">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（6）在线性数据表中查找某个特定的值locate（l.x）：返回线性表1中元素值等于x的第一个数据元素a‘的序号1，若线性表1中不存在值为x的数据元素，则函数值为0." ID="16">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（7）在线性表1中第1个位置插人一个新的数据元素bi，rt（1，1，b）（1《1蕊n＋1）；在线数据元素b，得到一个长为n十1的新线性表（al，为，……，a卜J，b，即……‘）（al，a：，……，出一1，街＋1……，‘）利用以上八种幕本运算我们可以实现其它更复杂的运算，如线性表的合并、拆分、复制等。" ID="17">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000022" TITLE="第二节  线性表的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="22" PhysicalPageNum="22"/>
        <div ORDERLABEL="00000023" TITLE="一、  线性表的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="23" PhysicalPageNum="23"/>
        <Paragraph CONTEXT="我们把线性表（At.aZ，faa）中的数据元家按照它在线性表中出现的先后顺序依次放人存.地址内存状态元素序号一块地址由底到高的连续存储单元中。即用数据元素在什算机$Picture[00000023\00000023_new\0007.jpg]Picture$蓄邻的物理位置.因此，我们只要知道线性表中第一个数据元素的白存储地址，就能计算出其他数据元素所在的物理位置.例如假设田2.2dl，则线性表中第i个数据元素的存储位置为：ddtt-1)1.这样我们就可以任意的存放和读取线性表中的一个数据元素.我们知道在计算机程序语言中，所有的数组在计算机内均由连续的存储单元存储，最低地址对应于数组的第一个元素，最高地址对应于数组的最后一个元素。根据此存储特点正好符合" ID="1">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="线性表的顺序存储结构的存储要求，因此我们可以用数组来描述线性表的顺序存储结构。" ID="2">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="坛就：运忱9口《指示线性表的长度｝内存状态国，目用end;其中数据城elements存放线性表的所有-素，数据城last指示线性表中的最下面我们将讨论线性表在顺序存储结构时的按特定值查找、插人及侧除这三种基本运算。而其他的蓦本运算是容易实现的，请读者自己补充。" ID="3">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="1.奋找运茸L为了在级性表中查找值为x的元素，只要从线性表的第一个元素起遥个田2,3" ID="4">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="线性表的" ID="5">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="和x比较直到找到为止.机内表示" ID="6">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="function1ocate一阅list(varv:sequenlist;x:elementsintegera" ID="7">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="（在线性表，中查找值为x的效据元ta;.若存在.则返回函数值为i.若不存在.则返回函数值为。｝hegiai1{给箱坏控侧变fib初值｝" ID="8">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="whileiv.1astdo（开始查找，宜到找到或线性表结束》" ID="9">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="ifv.eletnenta[i＞xthen泪前扫描元索不是x}ii+1（级续查找｝else1ocat。一sglist：=i;{找到元萦ai.期返回它在线性表中的位兰i}locat。一sgliac：二。（找不到值为x的元索.月返回0}一个位置。即原来线性表中第n个数据元素娜到第ni个存储位里上.第n-1个数据元素娜到第n个存储位置上，··…，第i个数据元素娜放在第i十1个存储位置上，从而空出第i个存储位置放置待抽人线性表的数据元素，最后修改数据域h就.其算法如下：procedureinsert-sglist(varv：sequenlist，x:elementypeti:integer);｛在线性表v中第i个数据元索之前抽人x}" ID="10">
          <fptr EndPN="00000024" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifv.1astrnexlengththen{判断存储线性表的内存空间是否有空余｝erroroverflow')elseif(iCl)or(i&gt;v.1ast十1)then{J断擂人位t是否有效）else" ID="11">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="12">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="13">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="ends例2.4在线性表（(a,b,c,e,f,g）中第四个数据元素e之前擂目，人DAscDDrI'I空I空目闲目阅描人前n-6擂人后n=7人数据元素d，插人前后各数据元素在内存中物理位t的变化如图2.4所示。" ID="14">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="3.一除运算目兰塑侧除线性表中第i(1CiCn)个数据元家a。时，数据元素ai-t据元素a+：在机内物理位置上的相邻则需将第i+1至第n个（共" ID="15">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="n-i个）元素依次向前移动一个位里.即将原线性表中的数据元" ID="16">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="素+：移至第i个存储位置，”二，第n个数据元素au移至第n一.‘月" ID="17">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="口1" ID="18">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="线性表擂入前后的状况" ID="19">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="1个存储位置上.最后修改数据i1ast。其算法如下：" ID="20">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="proceduredelete-sglist(varv.二quenlistti,integer)" ID="21">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="｛侧除线性表v中第i个数据元素ni}beginifGCl)or(i&gt;v.last)th即（判断i是否有效｝errorwithout')《无效则抽出夕without'}" ID="22">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="23">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="beginforj:-i-1tov.1astdov,elementa[j-11：一v.elements[j]i（将第i+1至第n个（共n-i个）致据元索依次向前移动一个位t}" ID="24">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="v.1astr=v.1ast-l内存状态内存状态BB.气－‘空76州除前n-7后。°fi" ID="25">
          <fptr EndPN="00000025" StartPN="00000024"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000025" TITLE="二、  线性表的链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="25" PhysicalPageNum="25"/>
        <Paragraph CONTEXT="兰鲤拿线性表的顺序存储结构是将每个数据元素存储在一段连续的内存空间.我们也可以将线性表的各数据元素存储在地址不连续的内存单元中，这就是线性表的另一种存储结构：线性表的链$Picture[00000025\00000025_new\0004.jpg]Picture$式存储结构。例Z.‘线性链表（a,b,c,d,e,f)在机内表示为如图2.6所由图2.6可以看出，这种线存储地址性表的存储结构中逻辑上相邻的数据元素在机内并不一定保1存在相邻的物理位置上，而是通过在保存某一数据元素时同时4堡套皇竺皇竺厦竺元竺竺色竺坚份买吵臀塑整弊健头豁素的逻辑相邻关系。我们把线性表的这种机内表示称为线性巴」一吕表的链式存储结构。其中数据元素本身与它的直接后继的存15储位里组成一个节点，它包括两个城；存储数据元素信息的域ki;称为数据域，存储其直接后继存储位置的域称为指针域，指针表。即线性表的链式存储结构.也常称这种链表为线性单链表" ID="1">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="图z.s性表的链式存" ID="2">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="继，因而线性链表的最后一个节点的指针为“nil（空）”，在图中也常用表示.在实际应用中，我们通常关心的是线性链表的数据元素之间的逻辑顺序。因此我们就把链表画成如tl2.7示用箭头相链接的节点的序列。“巨日习丑J七工升国口兀亚于亚亚一”｝川：｝图2.7线性链表的逻辑状态我们常借助程序设计语言中“指针”数据类型来描述线性链表如下：" ID="3">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="begin1：二nil;｛初始化.建立一个空表｝fori：二ndawnto1do" ID="4">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="5">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="new(pp-datea[i｛生成一个新节点，使其数据城为a[i]}" ID="6">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="p&quot;.next==1;1p《将新节点擂人在链表的第一节点之前｝end" ID="7">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="end;当然建立一个链表还有其它方法，如将每个新的节点放在表的尾端，按上升次序排序逐个擂人新的节点等。有些时候我们可以在线性表的第一个节点之前附加一个节点，它的数据城可以存储任何信息一般倩况存储线性表的相关信息如线性表的长度等，指针域指向第一个节点的指针，称此节点为头节点，带头节点的链式表有利于有些运算的实施。如图2.8所示为带头节点的单链表。" ID="8">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="L礴班子毛t升2'口一·气anNILL斗扭NIL" ID="9">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="2。为挂农存储结构的loctte(l,Y)函数算法如下：function1ocate-klist(var1elinklist;xtelementypeinteger;｛在带头节点的单链表中查找值为x的数据元索a&lt;，如存在，则返回函数i，否则返回函数值为0}beginp1&quot;.next;i：二I;（初始化，P指向第一个数据元素节点》whilepnildo（若链表非空，开始查找｝ifp&quot;.dataC&gt;xthen｛若当前元索不是x，继续向后查找｝" ID="10">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="11">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="P：二p&quot;.next.i：二i十I《指针后指｝" ID="12">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="endelse且oc日te_ekliat：二i;{找到值为x的数据无tai.返回i的值｝locate_sklist0（若链表中不存在值为x的数据元t，月返回0}endr" ID="13">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="3，取出睡性链衰中第i个数据元案的het(l,i}函致算法如下：functionget-aklist(var1elinklist;i:integerelementype毛{1为带头节点的单链表的头指针且头节点数据城为线性表的长度.取出线性表中的第i个数据元素ai1" ID="14">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="beginp：=！一next,m：二1;｛初始化，P指向链表的第一个元索节点｝while(1'.data&gt;i)and(m&lt;i)dopp&quot;.next;mm+1｛开始查找，直至指针p指向第i个数据元萦节点｝“Z3endsifi&gt;1'.datathenerrorC'without{i＞表长.i值无效｝-1一。一1_”一‘一一户J1'fit白.!F：it、翻rGl习卜飞" ID="15">
          <fptr EndPN="00000027" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="e阮gct-skl诚：＝p户" ID="16">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="e血." ID="17">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="4，抽入运算我们要在线性表的数据元素a，b之间擂人一个数据元素x，如图2.9所示，首先要生成一个数据域为x的新节点，而新节点x的指针域指向数据域为b的节点.然后让数据域为a的节点的指针域指向新节点x，从而完成擂人运算。对于一般的insert（l，x，1）的算法如下：proc司ureln.ert一。klist（varl：hakl讯；1：integer；x，ele六垮nt，p吧）。《在单链表中第1个数据元素节点之菌或表尾播人元索x.1为指向带表头节点的单链表的头指针》卜牺幼，（幼。，一血ta：＝二，（生成数据城为x的新节点》p：二1om：＝0，（初始化，p指向头节点｝" ID="18">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="，hile（P声.next＜＞司）如d（m＜1-1〕do卜笔初p：＝p’.next.m：二m＋1｛在链表中查找第1个数据元素的直接前趋第1-1个数据元素】eud." ID="19">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="汪p＜＞曲then｛开始在桂表中插人数据城为x的新节点》反gin‘一nextl二p’.next犷p“，衅xtl＝，end" ID="20">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="e阮error（‘初thout，）《1＞表长十1，1值无效｝" ID="21">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="拍人曲摘人后图2.9在单桂表中擂人节点时指针变化状况" ID="22">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="5.日除运算要侧除线性表中数据元素b，只浦修改链表中数据域为b的直接前趋节点a的指针域，使…引石水｝b｝｝月·1斗～…，除前圈2.1。在单链表中侧除节点时指针变化状况" ID="23">
          <fptr EndPN="00000027" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="beginp1，二：=0（初始化，P指向头节点｝while(p-nextC&gt;nil)and(m&lt;i-1)dobeginpp&quot;.next;mm+1ends（寻找且令P指向第i个数据元t的直接前趋节点｝ifp&quot;.next=nilthenerrorwithout{i＞表长，i值无效｝elsebeginqp一。next.p一。nextp&quot;.next&quot;.next.dispose(q)end" ID="24">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="J.‘随卜植二洲卜月七山早；子刁卜王t招‘谙他医白洲卜扮恨畏安价占、end例2.7设有三个集合：全集I=(1,2,3，4,5,6.7,8,9}，集合A1.23,4}，集合B1,25,6,7｝试求：AUB,A,我们用li,la,lb分别存放全集I、集合A、集合B，将lb中各数据元素按集合求并的原则擂入to中，最后得到的is即为AUB，算法如下：procedureunion(var1a:Gnear-listI1b:linear-list）书（将16中所有不在la中的数据元盆擂人到la中去｝" ID="25">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="beginn：二length(la){取得线性表la的长度，用以确定擂人新元家的位t｝fori1toiength(lb)dobegin" ID="26">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="x：二get(lb,i)t{取得［lb中第i个鼓据元家｝" ID="27">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="k.=locate(la,x)《查找线性表la,！断la中是否具有元家x" ID="28">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="ifk=othen" ID="29">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="30">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="insert(1n十l,x)i{线性表la中不存在元索x,f擂人｝" ID="31">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="n：=n-1《修改线性表卜的长度｝endendends对于求集合A的补集则采取在全集I中侧除集合A中的元素，最后集合I中剩下的元素组成的集合即为集合A的补集，其算法如下：procedureresidu趁1(var1i:linear-listAla=linear-list)《在线性表!i中侧除线性表la中的数据元素）" ID="32">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="33">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="nlengthtli)｛取得线性表Ill的长度，用以确定捆人新元盆的位f}" ID="34">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="35">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="ends例2.8设计一个算法，将线性表eat,aZ‘一）逆里，即使e中数据元数排列次序颠倒过来，成为线性表el二（aa。一：a，，at)，要求用顺序存储和单链表两种方法表示." ID="36">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)顺序存储结构procedurerevereel(vara:sequealiat)（将线性表e中的数据元余依次翻侧｝begink:=e.1ast《将线性表e的长度斌予k}fori：二1toint(n/2}do" ID="37">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="映9恤" ID="38">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="e.elements[k-i+11：二x" ID="39">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="40">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="41">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）单链表由表头到表尾依次修改链表节点的指针域使其指针反向指示，从而实现线性表的逆置。procedurereverse2(var1:Gnkliat｛将线性表e中的数据元素依次颇倒，1为指向链表的指针｝" ID="42">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="43">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="P：一nil;" ID="44">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="wltile1nildo" ID="45">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="q&quot;.next-P.P。～q《便取下的节点的指针后指}ends1：二p{使1指向新的链表的表头｝ends例2.，试设计一个求两个一元多项式的和的算法。要求和多项式的存储空间砚盖两个一元多项式的存储空间。对于此题我们采用单链表存储结构。" ID="46">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="type1ink”一Hader" ID="47">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="node=record" ID="48">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="coef,rearr｛节点的数据城用于存放多项式的系数｝" ID="49">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="exp:integer{节点的数据城用于存放多项式的指()" ID="50">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="next:Gnk（节点的指针城｝" ID="51">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="end;polynom=linki设P和q分别指向两个一元多项式中的某一节点，然后比较节点中的指数项，若P-expCq&quot;.expP节点应是和多项式中的一项，令P指针向后移。若P一，exp＞q&quot;.exp，则4节点应是和多项式中的一项.将q节点插人在P节点之前，且q指针在原来的链表上后移，若P&quot;.exp=q&quot;.exp,则将两个节点中的系数相加.当和不为零时修改P节点中的系数域，令P.q指针后移并释放4节点；反之，和多项式中没有此项，则从P所指节点所在的链表中侧去P节点，同时释放P和q节点，并令P.q指针后移.算法描述如下：procedurepoly-nddLpa.pb:polynom;varpc:polyno二），{pa,Pb和P分别为表示两个一元多项式和他们的和的带表头的单桩表的头指针）拢蜘ps=pa&quot;.next;q：一Pb.二xt。{p和q分别指向两个一元多项式链表中第一节点》：：二paipc：二pa，{s指向P节点的直接前趋，以Pa所指链表作为和链表）while(pnil)and(gC&gt;nil)docasep-exp&lt;q&quot;.exp:{p所指节点的指数城小于q所指节点的指数城｝beginsplpP‘.nextend；{p指针后移｝p&quot;.exp=q&quot;·exP：{P所指节点的指数城等于9所指节点的指数城｝begin" ID="52">
          <fptr EndPN="00000030" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="x：二p&quot;.ccef十q&quot;.ccef｛求同类项的系数和｝" ID="53">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="ifxC&gt;0then" ID="54">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="begtnp-caef:=x;s：一pend《系数和不为零，修改P节点的事数城｝" ID="55">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="eke" ID="56">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="begins-next:=p一，next:di叩Dee(p)endo{系教和为零，川除P节点）" ID="57">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="pe'.next;uq;{p指针后移，u指向4节点｝" ID="58">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="q：二q&quot;.nextldispoee(u){q指针后移，侧除u节点｝end;P-exp&gt;q-exg:{P所指节点的指数域大于4所指节点的指数域｝悦9访uq-next;q'.next：二pl{q节点擂人P节点之前}s'.nextq，aq；qu{q指针后移｝end" ID="59">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="end;ifqC&gt;nilthene&quot;.next-q;{将q所指节点所在铸表中刹余节点抽人和多项式中｝dispaee(pb)｛释放q所指节点所在链表的头节点}end;现在我们来看一看线性表的顺序存储结构与链式存储结构的优缺点，线性表的顺序存储结构最大的优点是可通过一个简单的公式确定线性表中任意一个数据元索的存储位置，从而实现随机存取表中任意一个数据元索.它的主要缺点是线性表的容量不能随惫扩充.可能造成存储空间的浪费，以及在做插人、侧除运算时需移动大最的数据元素造成时间的浪费。而线性表的链式存储结构也具有自己的优越性，主要表现在：在做擂人或侧除运算时，只需通过改变相关数据元素的指针域，而不像线性表的顺序存储结构那样要移动大盆数据元素，能充分自由的利用存储空间；线性表的容盆可以随意扩充，只受内存空间大小限制。它的主要缺点是访问节点时，均需从头查找，而且要开销一部分内存空间存储节点地址.对于实际编程.要根据具体所涉及的数据及其须做的处理选择合适的存储结构。对于线性表的链式存储结构除了上述单链表之外，还有循环链表和双向链表，下面我们简单地对他们讨论如下：让单向链表的最后一个节点的指针域指向头节点，整个链表形成一个环，称之为单循环链表，如图2.11所示。对于一个循环链表而言既无表头又无表尾，只要知道链表中某一节点便可访问链表中任一节点.因此，循环链表的运算和单向链表基本一致，所不同的是在算法中的循环结束条件不是p或p‘.next是否为空，而是p&quot;.next是否等于初始地址。例2.10在长度大于1的单循环链表中.既无头节点.也无头指针，t为指向链表中某个节点的指针。在t所指节点与其直接前趋之间插人元素x的算法如下：procedureinsert-crust(vart:cYlinklist;x:elementype｛在t所指节点与其宜接前趋之间擂入元索x,t为指向单循环链表某节点的指针）beginnew(s)。一data.=x;《生成数据城为x的新节点｝pt;《初始化，P指向t所指节点｝whilep&quot;.nexttdopp&quot;.next;（寻找t指节点的直接前趋元l节点》：一nextp&quot;.next，p&quot;.next：二s（擂人数据城为x的新节点｝ends例Z.11侧除长度大于I的单循环链表（无头节点，也无头指针）中。所指向的单循环链表中的节点，其算法描述如下：proceduredelete-crust(vars=crlinklist1feg1APat{初始化，P指向s所指节点｝whilep-nextC&gt;sdap：二p&quot;.next;（寻找。所指节点的直接前趋元索节点}p'.next：二s-next;dispose(s{除，所指的节,}" ID="60">
          <fptr EndPN="00000031" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="spend;上面我们所讨论的链式存储结构为单链表，它有一个缺点，就是无法逆向操作.下面我们讨论另一种可逆向操作的链式存储结构―双向链表.点链接组成，其中第一个指针城指向该数据元田2.12双向健表素的直接前趋，第二个指针城指向该数据元素" ID="61">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="的直接后继元素，如图2.12所示." ID="62">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="节点的类型可描述如下。" ID="63">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="typedupointerdunodetype;dunodetype=recorddata:elementype《双向链表节点的数据城｝priou,next:dupointer《双向链表节点的指针城）" ID="64">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="end;dulinklist=dupointer;在双向循环链表中，length(1),get{l,i),locate(1,x)等运算只涉及一个方向指针，它们的算" ID="65">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="示。$Picture[00000032\00000032_new\0002.jpg]Picture$$Picture[00000032\00000032_new\0003.jpg]Picture$二士｝！｝一匕二二创＿｝！月二……例2.12在双向链表的第i个数据元素之前擂人元素x的算法描述如下：procedureinsert-dulist(vaxdl:dulinkliat;i:integer;x:elementype｛在双向链表dl中第i个节点之前播入元家x.dl为指向带表头节点的双向链表的头指针｝beginP：二dt;tn：二。，｛初始化，P指向双向链表的头节点｝while(p一。nextnil)and(m&lt;i}do｛开始查找第i个节点》beginpp&quot;.next;mm+1end;ifi＜二length(dl}then" ID="66">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="beginnew(se-date:=x｛生成一个教据域为x的新节点｝P-priou-next：二s;s-priou：二P-priou;{人数据城为x的新节点｝p'.prious;s&quot;.nextpend" ID="67">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="elseerrorwithaut')" ID="68">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="end;请读者想一想。在双向链表末端插人一个数据元素，该怎样修改上述算法？例2.13剐除双向链表的一个节点x的算法如下：proceduredelet。一dulist(vardl:dulinkliet;x:elementype｛幼除双向链表d[中数据城为x的节点，dl为指向带表头节点的双向链表的头指针｝beginpdl一，next;{初始化，P指向双向链表的头节点｝while(p&quot;.datax)and(p-nextniI)dop：二P-next;（查找双向桩表中数据域为x的节点｝if(p&quot;.data=x)and(p-nextnil)then如果数据城为x的节点不是尾节点｝beginP-priou&quot;.nextp-nextsp&quot;.next&quot;.priou：二p'.prioutdispose(p)｛侧除数据城为x的节点｝" ID="69">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="endelseif(p&quot;.data二x)and(p-next二nil)then{如果数据城为x的节点是尾节点}beglpP-priou一。next：二tulidtapose(p){除数据城为x的节点｝end" ID="70">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="elseerrorwithout')" ID="71">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="end;与单链的循环链表类似，双向链表也可以有循环链表，即双向循环链表，如图2.14所示。在双向循环链表中.抽人和侧除运算与双向链表类似。例2.14在双向循环链表中，数据城为R的节点之前播人一个数据域为Y的节点的算法描述如下：procedureinaertbefore-duliat(vardl;dul'mklist。x,y;eletnentype)t｛在双向循环链表dl中数据城为x的节点之前擂人一个数据城为Y的节点.dl为指向无头节点的双向循环链表某一节点的指针｝begin" ID="72">
          <fptr EndPN="00000033" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="p：一dl'.priouqwhileCpdUsnd(p-dataC&gt;x)dopp&quot;.priou;（如果此双向循环链表不是空表开始查找数据城为x的节点》ifp二dlthenerror(nofind)｛此双向循环链表中无数据城为x的节点｝else" ID="73">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="beginnew(a)。一data：二Y｛生成数据峨为Y的新节点｝，一priou;=p&quot;.priou" ID="74">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="p.pnouais'.priou&quot;.nexta=ss&quot;.next，二P" ID="75">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="76">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="ends在双向循环链表中插人一个节点时指针的变化状况如图2.15所示." ID="77">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="圈2.15在双向循环链表中擂人一个节点时指针的变化状况例2.15在带头节点的双向循环链表中别除节点x，算法描述如下：proceduredelete-dulist(vardl：dulinklist1x:elementype)《在带头节点的双向循环链表dl中侧除数据城为x的节点，dl为指向头节点的头指针｝beginpdl-next初始化，让P指向双向循环链表的第一个数据节点｝二，，矛.才‘，＿洲＿一＿＿，去从盏‘J，“儿“」刃，卫twhile(pC＞dand(p'ifp二dlthenerrornotfind徽表空或链表中无数据城为二的节点》e]助beginp'.priou-next:=p-next;p声.next&quot;.priou：二P-priou；diapoee(p)end" ID="78">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="erd,在双向循环链表中姗除一个节点时指针的变化状况如图2.16所示。例2.16试设计一个火车站的自动定票和退票系统的算法.要求链表以姓名为序。我们用一个双向循环链表来表示此系统，自动定票实质是向此链表插人一个节点；自动退票实质是侧除此链表的一个节点.其算法如下：c）自动定票procedureorder-tick(vardl,dulinklist.z:elementype){在双向循环链襄中抽人节点x,dl为指向头节点的头指针》beginp:=d1-next，{p指向链表第一个节点》new(q)3{产生一个新节点｝4-datax;｛新节点救据城为x}while(pdl)aad(x&gt;p-data)dap.二P-nextt｛查找新节点的抽人位皿｝4-priou:=p-prtou3q-nextpip-ptiou&quot;.nett:=q，P一。pnou：二q‘修改指针城，擂人新节点｝" ID="79">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="80">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）自动退票procedure二to-tick(vardl,dulinkliat，二：eiementype)｛在双向循环链表中川除数据城为x的节点，dl为指向头节点的头指针｝beginP：二dl-next，{P指向第一个节点}while(pdl)and(p&quot;.datax)dop：二P-next:（寻找数据域为x的节点}ifp=d1the:errornotfind（无此节点返回）else" ID="81">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="卜eginp&quot;.priou-next:=p&quot;.next。p-next-priou：=p-prtou.（侧除敬握城为x的节点}dispoee(p){释放数据城为x的节点｝end" ID="82">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="ends例2.17设有n个人围坐在一个圆桌周围，现从第1个人开始报数，数到第m的人出列，然后从出列的下一个人重新开始报数，数到第m的人又出列，”…，如此重复直到所有的人全部出列为止.试设计一个算法模拟此过程.procedurecircle{n，二，byte{n个人围成一圈从ljm报数｝beginforis=1tontio（通过拍环产生一个循环链表｝begin" ID="83">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="neve(r)《产生一个新节点r1ifi=1thenqr｛以q记录t先产生的节点｝r&quot;.data：二。十1-is‘倒着为每个节点的数据嗽值.先大后小）r&quot;.nextps｛新产生的节点指向上回产生的节点｝pr{记录这次产生的节点｝ends｛结束在链中添加第i个结束点的操作｝q&quot;.nextr;｛此时已经得到了以r为表头的链表.q指向r就得到循环链表｝jOs{j为报数用的记数变量，初值为0}" ID="84">
          <fptr EndPN="00000035" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="P，二4｛用p寻我要城除节点的上一个节点、repeat{开始转圈报数的循环）" ID="85">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="j：二j十is｛一个人报数.报数变量加1}" ID="86">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="ifj=mthen{判断是否报数的人该除}begin;如果报数人报的是m就要1除D" ID="87">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="qp&quot;.next:｛先用q记录翻除的节点｝" ID="88">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="p&quot;.next:=q&quot;.next‘将4从链中侧除}" ID="89">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="j1.{准备再从1开始报数｝" ID="90">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="write(q-data:4)S枯出彼f1者的号数｝ends;（除操作结束）p：二P-next（报数应该轮到链中下一个人）untilp&quot;.next=ps｛直到链中只有1个人才停止报数）writeln(pdata:4)｛把链中仅有的一个人号码辅出｝end甲对于双向链表来说，它比单链表多一些好处，第一是对链表可以任意方向查找，这样做不仅有利于排序，更重要的是在数据库中允许用户从两个方向扫描。第二个好处因为无论前向链还是后向链都可遍读整个表。这样，在一条链损坏时，仍可用另一条链将表重新修补好." ID="91">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="上一节我们学习了线性表中数据元素之间的逻辑结构，那么线性表这种数据结构在计算" ID="1">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000035" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="35" PhysicalPageNum="35"/>
      <Paragraph CONTEXT="1.试设计一个算法，将x插人到一个有序的线性表（顺序存储结构）的适当位置上，并保持线性表的有序性。" ID="1">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="2.设计产生一个有两个节点的链表的算法，且第一个节点中放数值x，第二个节点中放" ID="2">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="y,first为头指针." ID="3">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="3.设计一个算法求两个集合的交集，并尽可能的节省存储空间。" ID="4">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="4.设计一个统什选票的算法，并按得票数递减输出结果。（候选人编号依次为1,2,3,…." ID="5">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="n，共有m张选票，且每张选票选且只选一人）" ID="6">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="5.试设计在带头节点的链表上实现length(1）的算法，并将长度写入头节点的数据域中。" ID="7">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="6.设计一个求单链表中第i个数据元素的位置的算法。" ID="8">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="7.已知由单链表表示的线性表中含有三类字符的数据元素（如字母字符，数字字符和其他字符〕，设计构造在三个以循环链表表示的线性表的算法，并使每个表中只含同一类的字符，且利用原表中的节点空间作为这三个表的节点空间。" ID="9">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
      <Paragraph CONTEXT="8。设计一个算法，将一个用循环链表表示的稀疏多项式分解成两个多项式，使这两个多项式中各自仅含奇次项或偶次项，并要求利用原来链表中的节点空间来构成这两个链表。。22" ID="10">
        <fptr EndPN="00000035" StartPN="00000035"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="计算机程序处理的数据纷萦复杂，但对于某一个具休的程序所面对的数据元素又有着相同的特性，各数据元素之间存在着一定的逻辑关系.比如。一张学生成统单，它就是一组数据，每位同学的姓名及成绩组成一个数据元素，每个数据元素之间存在着以成绩递减为序的逻辑关系。由于数据元素间逻辑关系及其在计算机内的表示不同，就形成了不同类型的数据结构.本章讨论数据元素间具有线性关系的数据结构―线性表。" ID="1">
      <fptr EndPN="00000021" StartPN="00000021"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000036" TITLE="第三章  栈和队列" TYPE="Chapter">
    <fptr LogicalPageNum="36" PhysicalPageNum="36"/>
      <div ORDERLABEL="00000036" TITLE="第一节  栈" TYPE="Chapter">
      <fptr LogicalPageNum="36" PhysicalPageNum="36"/>
        <div ORDERLABEL="00000036" TITLE="一、  栈的定义及其基本运算" TYPE="Chapter">
        <fptr LogicalPageNum="36" PhysicalPageNum="36"/>
        <Paragraph CONTEXT="出的访问方法，如图3.1所示。这就像桌子上的一攘盘子，先放在桌子上滚尾）的盘子最后使用，而最后放到盘裸上的最先使用。表头叫作栈底，表尾叫" ID="1">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="作栈顶。图3.1栈。=(a：，az，一，a）中a：是栈底的数据元素，a二是栈顶；表头）的数据元素，各数据元家按a、，ap,·,a。的次序进栈（放人线性表），而出" ID="2">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="找（取出）的顺序正好相反为：氏.，a。一a。栈的应用非常广泛，大量图3.1栈地用于如编译程序和解释程序那样的系统软件。栈的基本运算：" ID="3">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)inistack(s)：初始化操作，设定一个空栈s" ID="4">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Picture URL="00000036\00000036_new\0010.jpg">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Picture>
        <Paragraph CONTEXT="(2)push(s,x)：在栈s的顶部插人元x，简称为人找." ID="5">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)pop(s删除并返回栈顶数据元素，简称为出钱。相当于线性表中翻除一个数据元素，该运算与push(s.x)为互逆运算。" ID="6">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)top(s)：取出栈顶元素，但不用除找顶元素。" ID="7">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="(5)setnull(a)：置s为一个空栈。" ID="8">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)empty(s)rf定5是否为空栈，若是则返回值为真，否则返回值为假。" ID="9">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000036" TITLE="二、  栈的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="36" PhysicalPageNum="36"/>
        <Paragraph CONTEXT="根据找的描述可知，栈是一个线性表，是一个只许在表的一端进行存取的线性表，可见它只是有特殊操作方式的线性表.因此找的存储结构仍然具有顺序存储结构和链式存储结构两种，下面分别加以讨论。当我们用数组来描述栈的顺序存储结构时，将线性表中指示最后一个数据元素位置的整数变量last改为top,tap称为栈顶指针，如图3.2所示。这里top记录的是找顶数据元素在找中相对位置.当t叩二0时，表示空图3.2找的顺序栈;top=1表示栈内有一个数据元素，[1I..top二i表示栈内共i个数据元存储结构素，栈顶数据元素为，[i]；当top=maxsize时。说明栈满。若此时有元素人栈，示意图则栈滋出，称为“上滋”。当top=0时，若此时出栈，就要发生“下滋下滋”常用作控制转移的条件.其结构描述如下：conatmaxaize=“，;{杭可能达到的最大容t}typesequstaclt=record" ID="1">
          <fptr EndPN="00000037" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="ends找的五种基本运算在栈的顺序存储结构中都易于实现，下面我们分别讨论top(s)push(s,x）与poPCs）的算法如下：" ID="2">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="1.取出柱顶数姗元安的勿p{s）运算functiontop-agatack(va,ra，aequatack),elementypei（取出栈。的栈顶元t并返回元素值｝" ID="3">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifs.top二0thenerrorwithout空.返回》已laetop-sgatack==s.elements[s.top]（取出栈。的栈顶元素s.elements〔二copend:" ID="4">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="去入找的pusb(e,x)运算procedurepush-agatack(vara。aequstack；二：。且ementype《在找：的砚郁擂人数据元素川" ID="5">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifs.top-maxaizethenerroroverflow{挽s潇)else" ID="6">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="begins.topa.top十1。s.ekmenta[s.top]：二xend" ID="7">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="《在栈顶抽人致据元;x，同时修改栈顶指针｝end;" ID="8">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="人栈前后栈的变化如图3.3所示。" ID="9">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="3.侧除钱顶橄据元，的pip(s)运算functionpop-agstack(vars:squatackelernentype;《侧除栈。的视顶数据元素，返回找顶数据元家值｝hegiraifa.top=4thenerrorwithout{空返回｝else" ID="10">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="11">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="a.tops.top-l{修改相顶指针，即月除权顶数据元" ID="12">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="PoP-sgstack：二s.elementa[s.top十11｛返回一除的栈顶数据元t值｝" ID="13">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="14">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="15">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="出栈前后栈的变化如图3.4所示.从上述出栈算法可见，着由于误操作侧除了枕顶元素，在未傲人找运算前此误操作是可以恢复的.只需恢复top值即可.即执行语句s.tops.top十1,例3.1设计求一个由终端擂人的表达式的值的算法。对于本题我们用两个钱optr,opnd分别寄存运算符、操作数或运算结果，首先topnd栈为空找，表达式起始符‘＃’为optr栈的校底元素.然后依次读人表达式中每个字符，若是操作.24$Picture[00000038\00000038_new\0001.jpg]Picture$$Picture[00000038\00000038_new\0002.jpg]Picture$锢唱飞人挽前人挽后出钱前图3.3人栈前后权的变化示意图图3.4出栈前后找的变化示意图数则进opnd栈，若是运算符，则和optr的栈顶运算符比较优先数后作相应操作直至整个表" ID="16">
          <fptr EndPN="00000038" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="达式求值完毕。functionexpression:reaulttype;｛计算由挂盘输人的表达式，以‘材’结尾，假设艳入的表达式无语法错误｝比9运iniatack(optr)，push(optriniatack(opnd);（初始化枕并在运算符伐的钱底压人表达式左端的盛设字符,optr设为运算特找,opnd设为" ID="17">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="操作数枕,op为运算符的集合》read(w《从终端接受一个字特）whilenotwand(top(optr)°do（如果表达式没有结束或栈不空｝ifwnotisop山en{断w是否为运算符}" ID="18">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="beginpush(opnd,wread(w){若不是运算符就进opnd数字栈再读，｝endend书" ID="19">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="expresaton：二top(gpnd)eadi算法中调用两个函数，precede是判定运算符栈的栈顶运算符与读人的运算符之间的优先关系.operate是计算atheta（目前所取运算符）b的运算结果。例3.2用计算机模拟“钻迷宫”游戏。在一个用二维数组二az[m,n〕表示的迷宫中，数据元素1表示死路，数据元素。代表通路，maz[1,1〕为迷宫的人口.tnaz[tn,n〕为迷宫的出口，试给出一个求迷宫的一条通路的算法，若有解。请将路径打印出来。用什算机解答迷宫问题时i把走步数字化，当地处某一位tk行1列时，可向八个方向走（除边界位里），即北，东北，东，东南，南，西南，西，西北，分别给八个方向编号，分别相当于k二$Picture[00000039\00000039_new\0002.jpg]Picture$素mov[2,k]代表k走步时i的修改童.k走步与数组元素" ID="20">
          <fptr EndPN="00000039" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="图3.5行走方向与走步对照圈mov[p,kp=1,2;k=1,2,3，一，8)取值如下表3.1," ID="21">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="图3.6改变前后的迷宫示t图衰3.1k走步与傲组元狡.v[p,k〕对皿衰$Picture[00000039\00000039_new\0013.jpg]Picture$$Picture[00000039\00000039_new\0014.jpg]Picture$黔导十州渭设！三个分别存放路径通过的点的位ti,j和走下一步的方向k的栈is,ja,ka，用ist记录" ID="22">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="走到某点的步数；用数组。ark[s,t〕记录走过的点.即当通路通过点1，1时，则数组元素mark" ID="23">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="[i1，否则为。。其算法如下：proceduremaszmov(vari小k,11,18t,g,b,IBto:integer)a｛求由maz[0I2,0二is〕表示的迷宫的通路｝varia,ja.ka:array[1二601ofintegers{存放点的位ti,j和走步方向k的杖；mov=array[I2,1二81ofinteger;《设t存放行列修改f的数组；" ID="24">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="二k:array[1二Ii,l151ofintegers（记录走过位里的数组｝" ID="25">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="mas:array[0二12.0161ofinteger;{表示迷宫的数组｝" ID="26">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="27">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="forj：二1to15dofori:=1to11doread（，aa口，j］）。f初始化，可随机粉人）fori：二arol2dobeginraaz[i,011saraz[i.1611end川数字化左右边界｝" ID="28">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Picture URL="00000040\00000040_new\0001.jpg">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Picture>
        <Paragraph CONTEXT="fariiz=1to60dobeginia[ii]：二O;ja[iiO;ka[ii0end;f初始化｝fori：二1to11do" ID="29">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="forj1to16domark[i,j]：二p;{初始化mark数组）i：二l;j1;k：二1;ist：=J;｛初始化｝mark[l,l]：二1;{在数组mark中标记走过人口）repeat（开始走迷宫｝is[ist1：二i;7a[ist=jtka[ist]、二k,｛目前位置及将走的方向人栈｝istisr+1｛记录步数｝l;gi十movk｛计算将到达的目&gt;F点所在的行｝" ID="30">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="hj十mov[2.k｛计算将到达的目标点所在的列｝" ID="31">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="if(maz[g.h〕二1)or(mark[g,h1)then（判断即将走的位1是否死路或已走过｝" ID="32">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="33">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="2:k十1;（遇到死路或巳走过的位值则换方向寻找另一位里｝" ID="34">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="ist:=ist-l;iiist一工；｛退回一步）" ID="35">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="iia[iijja[iikka[ii｛退回一步后所在位t及走步方向出找｝9俄。仑｛换方向寻找新的通路｝endendend;tnatk[g.h]1｛找到通路点并记录｝is=g;i。二h;k1｛初始化，继续前进】until(g=11)and(h=15)i‘直到走出迷宫｝增长，当整个共享存储空间被占用（即两个栈顶相碰）才发生“上滋”。这两个栈共享空间时的存储结构描述如下：conatm＝一，{al.a2两个桥共享空间的大小｝typedubiatack=record(qvCm其中topl,top2分别指示栈sl,s2的栈顶元家的位里，初（i，x）.pop（i）和toP（i）（其中1＝1或2，分别代表两个栈）算图3.7两个栈共享存储空间示意图法描述如卜." ID="36">
          <fptr EndPN="00000041" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="1。p助血（1，x）算法procedurePU：h-d喊ack（vary，dub阮aekox：e眨menty碑11：1.。2）；｛在栈1、栈2共享存偏空间时，数据元素x人1钱，1为权名｝阮苗niftopl＝topZ-lthener心（‘价.们。侧）；｛栈摘，不能人栈｝吐1二lth即比9玩taPI：＝toPI十1；v【topl］：＝xod《数据元索x进人栈1｝e胶旋gintDpZ：二topZ-1，v〔topZ〕：＝xend（数据元索x进人找2｝" ID="37">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="e沁，" ID="38">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="2.钟pQ）算法functionl明，一dustack（vary：dubl：tacko1：1二2）：elementyp吧，毛在钱1、钱2共享存储空间时.钱1出栈运算.1为权名｝" ID="39">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="阮ginifi二lthen甘t叩1＝Otben～（，ithaut）（权1空｝" ID="40">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="el加" ID="41">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="卜gin" ID="42">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="t叩1：＝topl-1，（栈1的栈顶元素出找｝pop-d睬ack.＝v示opl＋1］end乡el能iftopZ二饥＋lthenetror（without）｛栈2空）" ID="43">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="e凌" ID="44">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="加pZ：＝相pZ＋1，《校2的校顶元索出栈｝" ID="45">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="pop-d.taek：二。［帅2-1〕" ID="46">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="切de记；" ID="47">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="3，toP（朴算法f皿cdont叩一du拟k（vatv：duhl：tack，1：1二2）：element麻，" ID="48">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="（在栈1，袂2共享存储空间时，取出柱1的校顶数据元素，1为校名｝" ID="49">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="ifi=1theniftopl&gt;0thentop-duatack：=v[sop]1｛若栈1非空则取出栈1的栈顶数据元盆｝elseerrorC'without')（钱空，返回｝elseiftop2&lt;m+1thencop-duatackv[top21｛取出栈2的找顶数据元东｝elseerrorwithout')｛找空，返回｝end;对于一般的n个找共享空间的问题复杂一些，有兴趣的读者参考其他书目。本书不再介绍.下面讨论枚的另外一种存储结构栈的链式存储结构。栈的链式存储结构如图3.8所示。找的链式存储结构可描述如下：typepointer一。odetype；一习一IINILI#JtE" ID="50">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="nodetype=record" ID="51">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="图3.8链栈示意图" ID="52">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="next二ptnnter" ID="53">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="endlinkatack=painter显然，一个栈顶指针唯一确定一个栈。当栈顶指针为空时，则表示一个空栈.如果此时再做出栈运算到发生栈“下擞”。由栈的链式存储结构可知，栈的大小只受可用内存空间限制.所以只有当所有存储空间被占用时，人栈运算才发生栈“上滋”，因此在一个程序中若涉及多个栈则采用栈的链式存储结构，从而实现共享存储空间，对于栈的链式存储结构的push(s,x" ID="54">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="PoP(g）和tops）运算分别描述如下：" ID="55">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="1.puslt(s,x)7算prnoedurepush-latack(varis:linkatacklx;elementyge｛在链栈is的找顶擂人数据元素x,l。为指向栈顶的指针｝beginnew{p)ip&quot;.datax;｛生成一个数据城为x的新节点｝P-next，二ls;Isp‘在栈顶擂入数据域为x的新节点｝" ID="56">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="57">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="2.pops）运算functiontvp-latack(var1a:linkstark)：elementype;（链枚l：的栈顶数据元索出栈，肠为指向栈顶的指针｝beginif1a=nilthenerrorwithvut{空.返回）" ID="58">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="59">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="60">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="P-lai1e：一1，一next;S川除链找钱顶元;'}top-lstnck：二p八.data;diapoae(p)" ID="61">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="62">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="63">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="3.tops）运算functiontopstack(ls,linkatack):elementypeibeginifis=nilthenerrorwithout‘链栈空.返回）elsetop-lstack:=1：一daca{返回栈顶数据元紊值｝end;" ID="64">
          <fptr EndPN="00000043" StartPN="00000042"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000043" TITLE="第二节  队列" TYPE="Chapter">
      <fptr LogicalPageNum="43" PhysicalPageNum="43"/>
        <div ORDERLABEL="00000043" TITLE="一、  队列的定义及基本运算" TYPE="Chapter">
        <fptr LogicalPageNum="43" PhysicalPageNum="43"/>
        <Paragraph CONTEXT="队列是一种访问次序是先进先出的线性表，如图3.9所示。出队列一.alatA二、一人队列也就是说，置人队列中的第一个数据元索将是从队是读出的第二个数据元素，依此类推，这与现实生活中排图3.9队列示意图队购物类似。先到的先购物，先离开队列.在队列当中，允许插人数据元素的一端叫作队尾，允许删除数据元素的一端称为队头。如图3.9队列qaaz,,a二）中，a：是队头数据元家，a。是队尾数据元素为最先进人队列的数据元素，则最先出队列，而a。为最后进人的数据元素，且最后出队列。队列可以用于许多问题的求解，最常用的是模拟，另外的用途还有调度和I/O缓冲等。队列的基本运算如下：" ID="1">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)addqueue(q,x)：在队列q的队尾播人元素x，称为人队列。" ID="2">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）delqueue（q）：删除并返CR]队列q的队头元素，称为出队列。{3)frontque{q)：取得队列q的队头元素." ID="3">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)setnull(q):置q为一个空队列。C5)empty{q)：判断q是否为空队列，当q为空时，返回‘true否则“false&quot;" ID="4">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000043" TITLE="二、  队列的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="43" PhysicalPageNum="43"/>
        <Paragraph CONTEXT="同栈一样，队列也是一种操作受限的线性表。但它依然具有线性表的两种存储结构―顺序存储结构和链式存储结构。现分别讨论如下：队列的顺序存储结构如图3.IO所示.在用数组来描述队列的顺序存储结构时，将线性表的记录型的结构中除数据域后再加上两个整数变t域front,rear,rear域存储队列的队尾数据元素在数组中的相对位置称为尾指针。front存储队头数据元素的在数组中的相对位置的前一位里，称为头指针.在队列的顺序存储结构中，当头指针与尾指针相等时，则此队列为空队列。若此时出队列，则发生下滋.当尾指" ID="1">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="针等于maxsize时，人队列则发生上滋.显然空队列是程序设什中常用的一种控制转移的条front.rear:integerends" ID="2">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="队列的五种基本计算在顺序存储结构中均易于实现，现就addqueue(q,xdelqueue(q）和$Picture[00000044\00000044_new\0001.jpg]Picture$$Picture[00000044\00000044_new\0002.jpg]Picture$$Picture[00000044\00000044_new\0003.jpg]Picture$图3.10队列的顺序存储结构图3.11空队列及非空队列示意图" ID="3">
          <fptr EndPN="00000044" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="1.addqueue(q,x）运算procedureadd-squeue(varsq;Aequeue;x:elementype｛在队列sq的队尾摘人数据元家x)" ID="4">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifsq.rear二maxaizethenerroroverflowI队满，不能播人数据元素）else" ID="5">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="决目n" ID="6">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.rear：二，q.mar+1;aq.element，仁sq.rear]z=x{数据元紊：人队列｝end" ID="7">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="end冬" ID="8">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="2,delqueue(q）运算functiondel-squeue(varsq,sequeue):elementype;｛剐除并返回队列闪的队头数据元素｝beginifsq.front二sq.rearthenerrorwithout护）｛队列空，返回｝else" ID="9">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="拢咖" ID="10">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.front：二sq.front十1;《队头教据元素出队列｝" ID="11">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="del-squeue==sq.elements[sq:front]end" ID="12">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="13">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="3.frotttque(q)i&amp;算functionfro-squeue(varsq:sequeue):elementype｛从队列闪中取得但不剧除队头数据元素｝beginifsq.front=sq.rearthenerrorwithout{队列空。返回）elsefro-squeuesq.elementa[sq.front+l]｛取得队头教据元素｝end:按上述算法，则在图3.12所示的队列中作人队列运算，发生上滋，但事实上此队列物理空间并非真正占满。为了节省空间，我们可以将队列中数据元素移到队列前面，或者在队列中有数据元索出队列时，'移动队列中的数据元索，使队列中的数据元图3.12队列实例$Picture[00000044\00000044_new\0038.jpg]Picture$采用这种方法，而采用一种更有效的方法.当rear等于、X31，时让rear调回头重新指向队列$Picture[00000045\00000045_new\0003.jpg]Picture$图3.13循环队列示意图在循环队列中，当sq.rear+1&gt;maxsize-I时，我们可以令sq,rear=4使rear指向队列的始端，另一种使rear指向队列的始端的方法是设m;=maxsixe-" ID="14">
          <fptr EndPN="00000045" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="1，再借助数学中的.模运算”便可实现rear达到最大时回到队列的始端，即在作人队列运算时，让sq.rear：二（sq.rear+1)mod(m十1)。在实际中我们常使用后一种方法，省去判断sq,reax+1＞maxsize-1的这一步.在循环队列中.当sq.front=sq.rear时，可能为队列空，也可能为队列满，这是易于理解的，相当于队列中一个数据元素都没有（即空）时，有sq.front$Picture[00000045\00000045_new\0016.jpg]Picture$$Picture[00000045\00000045_new\0017.jpg]Picture$=sq.rear，也可能是sq.rear转一圈后追上sq.空队列满队列front，此时也有sq.front=sq,rear，这时队列J图3.14空队列和满队列满.如图3.14所示." ID="15">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="那么怎样判断队满和队空呢？通过上面分析可知：用sq.front=sq.rear不能判断出队列满和队列空，为了表示sq.rear追上sq.front，我们采用sq.rear十1二sq.front来表示队列满，而用sq,front=sq,rear来表示队列空。值得注意的是：循环队列的尾指针sq.rear恰好指向队尾数据元素，而头指针sq.front则指向队首数据元素的前一个位置." ID="16">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="循环队列的描述如下：" ID="17">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="typesequeue=record下面我们来讨论在循环队列中addqueue(q,xdelqueue(qfrontque(q）三种运算的算法如下：" ID="18">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="1.addq二（(q,x)运算procedureadd-aqueue(vars9;eeQueueax:elementype);（在循环队列aq中擂人数据元家x)" ID="19">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="beginif(®q.ream-1)mad(m-1）二aq.frontthenerroroverflow{返回）else" ID="20">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="21">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.elementa[sq.rear]：=x" ID="22">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="23">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="24">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="Z.delqueue(q)算functiondel-aqueue(varsq:sequeueelementype（在循环队列叫中侧除并返回队首数据元素｝beginifsq.frrmt二aq.rearthenerrorwithout队&quot;il;回｝else" ID="25">
          <fptr EndPN="00000046" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="26">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.frontaq.front+l}mad(m+I{翻除循环队列队首狱据元素｝del-squeueaq.elements[sq.front]｛保存侧除数据元索备用}" ID="27">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="28">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="29">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="3.frontque(q）运Xfunctionfro-squeue(sq:sequeueelementypea｛取出但不姗除循环队列Sq中队首数据元索｝beginifag.front=aq.rearthenerrorwithout{队空返回｝" ID="30">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="31">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="32">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="f：二（sq.front+l)mod(m+1)fro-squeuesq.elementa[f]‘取得循环队列中队首致据元t并返回其值｝" ID="33">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="end即山除了上述判断队列满、队列空的方法外，还可以采取设置标志位的办法，设标志位tag的初值为如果由于人队列运算使得rear=front时，置吨为“1”表示队列满，若由于出队列" ID="34">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="elements:anay[0二m]ofelementype;rear,front:integer;tag:01ends采取设里标志位的情况下addqueue(q,xdelqueue(q）算法描述如下：" ID="35">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="1.Addqueute(q.x)算procedureadd-squeue(varaq:eequeue;xoelementype)《在箱环队列叫中擂人数据元索x?" ID="36">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="37">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="iftag=lthenerraroverflow｛队满返回》" ID="38">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="39">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="beginsq.rear：二（sq.～十1)mod(m十1｛在循环队列中擂人数据元素x}" ID="40">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.elements[aq，二〕.=x;" ID="41">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="ifsq.rear=sq.fraatthentag1｛队浦使标志位为1}end{在循环队列sq中删除并返回队首数据元素｝beginiftag二0thenerrorwithout{队空返回}else" ID="42">
          <fptr EndPN="00000047" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="43">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.frant：二（sq.front十1)mod(m十1{fl除循环队列队首数据元素｝" ID="44">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="del-squeuesq.elements[sq.front{保存队首数据元素备用｝" ID="45">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="ifaq.rear二sq.frontthentag0{队空设置标志位为0}end" ID="46">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="end;比较上面两种方式，很明显前一种方法因队列中留有一个空额而损失一个存储空间，但较后一种方法节省时间，因为后一种方法在人队列与出队列运算时孺要判断标志而浪费一些时间。循环队列用得最普遍的场合可能要数操作系统。操作系统中滋盘文件和控制台的读出／写人信息都是存于循环队列中的。循环队列的另一个常见用途是实时程序，因为实时程序要在有缓冲Y/请求时不断进行信息处理，许多宇处理程序在进行段落重排或行调整时要进行这种缓冲操作。因为在其它进程正在执行时，键盘输人的字符并不能立刻显示而要等正在执行的进程结束之后才能取出处理，为了实现这一过程，应用程序需要在其他进程执行过程中持续地检查键盘输人，假如一个键被输人，则将它迅速置入队列，而后让正在执行的进程继续运行。一旦该进程运行结束，队列中的字符才移出队列处理。当然在几个队列同时存在时，也有共享内存空间的问题，由于其复杂性，因此在这种情况下常采用下面将讨论的队列的另一种存储结构―链式存储结构。" ID="47">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000047" TITLE="三、  队列的链式存储结构——链队列" TYPE="Chapter">
        <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <Paragraph CONTEXT="队尾称为尾指针.显然一个链队列由这两个拾针唯一确定。图3.15是一个带头节点的链队列，其头指针指向头节点，当q,front-q,rear图3.15列的链式存储结构·空raj大小限制or,¢队列pJ描述如卜：type1inkqueue=recordfront.rear:pointerend;" ID="1">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="下面讨论链队列的addqueue(y,xdelqueue(q）和frontque(q）运算如下：" ID="2">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="1.xddqueue(cf,x）运算procedureadd-lkqueue(varq:1inkqueue;x=elementype);" ID="3">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="子在链队列q中擂人数据元素幻" ID="4">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="q.rear&quot;.data：二x:｛给新节点狱值｝" ID="5">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="q.rear‘.next：二nil{队尾节点的指针域为空｝end:" ID="6">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="2.delqueue(q)i算functiondelltqueue(varq;linkqueueelementypes｛链队列q中的出队列运算，并返回队头元家｝beginifempty(y)thenerrorwithoutd队空返回1else" ID="7">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT=".begin" ID="8">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="sq.front'.next;" ID="9">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="q.front&quot;.ne二ts&quot;.next修改头指针｝" ID="10">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="if，一。next=nilthenq.rear：二q.front:｛队列为空｝" ID="11">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="del-lkqueues&quot;.data:dispose(s)｛返回副除数据元素，释放无用节点｝end" ID="12">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="13">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="3.frontquetq算functionfro-lkqueue(varq;1inkqueue),elementypc:（取出链队列q中队头数据元素、" ID="14">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifq.rear二q.frontthenerrarwithout')（队空返回｝elsefro-lkqueueq.front&quot;.next&quot;.data{返回队头数据元紊｝end:" ID="15">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000048" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="48" PhysicalPageNum="48"/>
      <Paragraph CONTEXT="1.编一个算法，让使用者可以通过上、下、左、右四个方向键指挥屏幕上的显示目标向相应的方向移动（如果将要超出屏幕范围I9不移动），按backspace键可退回一步（如果以后退到了最初的出发点就不退），按Esc结束此算法." ID="1">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="2.编一个算法检验字符串参数，中的｛、｝、仁、］、（、）等括号字符是否满足算术中的包含关系（这里允许大括号直接套小括号）。" ID="2">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="3.本章例题中解决了算术表达式中包含＋、一、X）的问题，现请编一个类似的算法.能够计算包含＋、一、X‘的算式。可以不考虑括号，还可假定运算数都是一位数字。" ID="3">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="4.在屏幕的第一行建立一个字符队列，当从键盘输人字母或数字符时就在队列右边进行插人（尾追加）。第一行已满时播人无效。如果按delete键则在队列的左边进行1除，除非队列中没有字符。要求队列的左边第一个字符总显示于第一行左边第一个位置上。" ID="4">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="5.把数组a中从a[1」到。[n〕的n个元素顺序存人一条新建的链中，表头通过变参r返回。" ID="5">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="6.新建一个链表，把从键盘输人的n个数据按与愉人顺序相反的顺序存入链表当中（即最后输人的是表头节点的数据）。n为值参，表头r为变参." ID="6">
        <fptr EndPN="00000048" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="7.有13张扑克牌扣着攘成一抓，从下面抽出第一张翻开放在一旁，抽出第二张不翻移到此摇牌的最上面，再从下面抽第三张翻开放在一旁，抽出第四张不翻移到上面，·…，直到13张牌全被翻开，发现翻开的顺序恰好为A.2.3.4.5.6.7.8,9.10.J.Q,K，求原来这些牌的从下到＿L的摆放顺序。" ID="7">
        <fptr EndPN="00000049" StartPN="00000048"/>
      </Paragraph>
      <Paragraph CONTEXT="8.把已建好的以r为表头节点的单链改成循环链表。" ID="8">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="9.把第一题所用的栈改用链式找来完成。。36" ID="9">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="前面我们讨论了一般线性表的存储结构及其运算的实现。本章将介绍两种特殊的线性表―找和队列.从逻辑结构上看.栈和队列仍是线性表，其特殊性主要是其基本运算有着严格的规定。由于栈和队列在程序设计中应用广泛，因此本章对它们单独进行讨论。" ID="1">
      <fptr EndPN="00000036" StartPN="00000036"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000050" TITLE="第四章  串和数组" TYPE="Chapter">
    <fptr LogicalPageNum="50" PhysicalPageNum="50"/>
      <div ORDERLABEL="00000050" TITLE="第一节  串的运算" TYPE="Chapter">
      <fptr LogicalPageNum="50" PhysicalPageNum="50"/>
        <div ORDERLABEL="00000050" TITLE="一、  字符串的概念" TYPE="Chapter">
        <fptr LogicalPageNum="50" PhysicalPageNum="50"/>
        <Paragraph CONTEXT="字符申（string）是一种简单的数据结构，它是由一个给定语言的字符集―又称字母表中A二‘a-a'(n）0)其中单引号作为字符串的起止定界符号，不属于字符串本身的字符，用单引号括起来的字符序列是串的值，A是串的名宇；alCiCn,O（nC255）表示字符申中的第i个字符，可以是字母、数字或其它符号，n表示字符串中字符的个数，即字符串的长度；如果n二0，表示一个空串.即串中不含任何字符，则A的长度为。；当n二1时，表示只含一个字符的串。" ID="1">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="例A二‘’" ID="2">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="B" ID="3">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="C=`s'" ID="4">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="D二‘datastructure'E二‘a+b二25'其中A是空串（以后用“甲”来表示空串），E3是空格申（其长度n=1)。这五个字符串中，其长度分别为。,1,1,14，和6从字符串的定义看，字符串属于数据类型为字符的一种线性表，对线性表的一切运算对字符申都可以进行；从字符串的表示来看，它是字符的紧密排列，能用它来描述事物的基本属性。字符串本身具有简单数据、数组和线性表三方面的特点，并且宇符申是数据处理领域最重要的数据类型之一，所以在本章重点讨论。为了区分申变量和其它变量，以后在串变量名的后面加一个符号“＄”，例如AB" ID="5">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000050" TITLE="二、  字符串的运算" TYPE="Chapter">
        <fptr LogicalPageNum="50" PhysicalPageNum="50"/>
        <Paragraph CONTEXT="由于字符串具有多种数据类型的特点，它的运算也有多种，本节只对宇符申的连接和有关" ID="1">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="子串的七种基本运算讨论。" ID="2">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="1.连接（connection)个新串，用符号“｝｝”表示1" ID="3">
          <fptr EndPN="00000051" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="设A＄二‘Bei'$＄二‘jing'" ID="4">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="则A$IlB$Beijing" ID="5">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="B$IIA＄二‘jingBei'可以看出A$IIB$拼B$IIA$，这表明：串的连接运算不满足交换律，但符合结合律。即（A＄｝｝B＄川｝C＄＝A＄｝｝（B＄”C＄），读者可以自己去验证。" ID="6">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="z.z于一（substring)一个串的子串就是串中的一个连续的子序列。即从该申中的第i个字符开始，取出连续J个字符组成的子串。用sub(A$,i,j）来表示求A＄的一个子串。例如：ubBeijing4,3)jin'" ID="7">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="subBeijing3,1`i'3甲的长度（1ength)串的长度就是串中含有的字符个数，用len(A$）来表示。例如lenC`Beijing=7" ID="8">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="len}=0显然len(A$IIB1en(A1en(B$)4求子串在串中的序号（position)又叫串的模式匹配（运算），求子申在串中的位置，用position(A$,B$）来表示B＄在A$中第一次出现的首字符的位置（序号），结果为非负数.若pasition(A$,B$）二0，表示B＄不是A＄的子申。注意B＄不能是空串。例如pasitian(`Beijing`jing'）二4" ID="9">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="positionBei'jing=0" ID="10">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="5·g#¢tCreplacement)把串中的子串用另一个申来替换。用repl(A$,B$,C$）来表示，其含义是：如果B＄是A＄的子串，用C＄去取代原来A＄中所有的B$，如果B＄不是A＄的子串，则repl(A$,B$,C$）二A$。注意B＄不能是空串。例如repl(`BBABBABBA`AB`C'）二‘SBCBCBA'" ID="11">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="reel(`BBABBABBA`E`C_`BBABBABBA'" ID="12">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="6·illh除子串(delete)从申中删除从第i个字符开始的长度为l的一个子串，用deI(A$,i,j）来表示。例如del(eijing4,3`jin'i'意:0&lt;j&lt;len(A）一i-1" ID="13">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="7入（insert)在申的第i个字符之前插人B$，用ins(A$,i,B$）来表示。j如ins(`Beijing3KS_`BeiKSing'庄意，lCiClen(A1下面给出几种运算的算法描述：.连接算法，roreduremncat(rl.r2atring:VARR:string在字符申rl的后面连接字符串r2.连接的结果通过字符串R返回。｝38" ID="14">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifrl.ien+r2.len&gt;thenerroroverflow（假如字符申rl,r2的长度之和大于最大允许的长度时，则进行“滋出”处理。｝faris=1torl.1endo" ID="15">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="R.val[i=rl.val[i｛将字符串rl传送给字符串R}fori1tor2.Iendo" ID="16">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="R.val[rl.1en+i]r2.val[i｛将字符串r2传送给字符申R}" ID="17">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="R.lenr1.1en+r2.1en｛置R的长度为rl和r2的长度之和｝end;" ID="18">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="2。取子串算法proceduresubstring(rl:string;i,j:integer;VARR:stnng);｛从字符串：1的第i个字符开始连续取j个宇符，合成字符串，通过宇符串R返回。}beginifi+j-1&gt;rl.ienthenerroroutofrange;《如果条件成立.则表明i和」的值超出所允许的范围.应进行“超出范围”错误处理.｝forkz=1tojdo" ID="19">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="R.val[k]rl.val[i+k-11;｛将rl中指定的子串传送给宇符串R}" ID="20">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="R.1en:=j（把子串长度斌给R的长度域｝end;" ID="21">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="3。求子串位位t的算法functionposition(rl,r2atringinteger书｛求子串r2在字符串rl中第一次出现的首字符的位里｝" ID="22">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="23">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="1：二1;{i作为扫描rl的指针｝j：二1;{j作为扫描子串r2的指针｝while(i＜二rl.len)and(jr2.len)do" ID="24">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="ifrl.val[i］二r2.val[j1thenbeginis=i+1;j：一j十1end（继续使指针分别指向下一个字符｝" ID="25">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="elsebeginis=i-j+2;j1end;使指针i回溯，指针j重新指向r2的第一个字符。｝ifj&gt;r2.lenthenpositioni-r2.1en{如果rl中存在r2，返回r2在rl中第一次出现的首字符的位置｝elseposition0｛如果rl中不存在r2.返回。值｝" ID="26">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000052" TITLE="第二节  串的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="52" PhysicalPageNum="52"/>
        <div ORDERLABEL="00000052" TITLE="一、  串的顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="52" PhysicalPageNum="52"/>
        <Picture URL="00000053\00000053_new\0003.jpg">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Picture>
        <Paragraph CONTEXT="图4.I紧t方式节，则长度为n的串需要m-n/k飞(rn/k1代表不刁‘于n/k的最小整存储示例数）个存储单元。紧凑方式存储把字符串数组的n个分量紧凑到一个字存储单元里。例如n=15,k=4，则m=X15/41二4，则需要4个存储单元。用这种方式存储A＄二‘datastructures'，如图4.1所示。非紧凑方式以存储单元为单位存放字符，即一个字符占一个存储单元。当计算机采用字编址结构时，数组的每一个分量至少占用一个字符存储单元。如果字符串的长度为n。则需要n个存储单元.用非.紧凑方式存储上例中的A$，则得到的存储结构如图4.2所示.对照图4.1、图4.2，不难理解紧凑方式和非紧凑方式各有优缺点.紧凑方式对存储空间的利用率高，但对单个字符的处理困难。与紧凑方式相反，非紧凑方式空间利用率低，即浪费存储空间，但处理单个字符比较方便。就二者而言，紧凑方式优点较显著，所以一般计算机都是用紧凑方式存储字符串的.$Picture[00000053\00000053_new\0021.jpg]Picture$此外，对于按字节编址的计算机，采用单字节字符申方式存放申值，这种方式节省空间，处理单个字符比较方便。如图4.3所示。串的顺序存储表示，从串名可以直接访问到串值，访间串中的子串运算是很方便的，而对于插人和删除运算稍为困难。对于紧凑方式存储和非紧凑方式存储，还有两种处理字符串长度图4.2非紧凑方式的方法：采用固定长度、设置长度指针。存储示例" ID="1">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="1.固定长度不考虑字符串的实际长度，按照计算机内部事先规定的长度存储.设n为计算机内部规定的长度，当字符申的实际长度小于n时，则从第一个单元开始存储，对后面空余的单元用空格宇符补满，当字符串的实际长度大于n时，把后面超长的宇符舍去.例如A$datastructure'" ID="2">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="B$8213456'" ID="3">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="n-13" ID="4">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="len(A$）二14,1en(B7" ID="5">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="则它们的存储结构如图4.4所示。" ID="6">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="2.设盆长度指针设字符申所能达到最大长度为n(l^255之间的整数，由用户给定）这种字符串类aL的每个变量开辟了n-1个字节的存储空间（一个宇节为一个存储单元）.每个存储单元放一个字“40S$181211’!3卜15161III｛11图4.4采用固定长度方式处理字符申长度" ID="7">
          <fptr EndPN="00000054" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="符。设编号为。,1,…,n，其中第。号存储单元专门存储字符串的实lid长度。" ID="8">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="例如设n二17" ID="9">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="A＄二‘Y：二2X十3B＄二‘M：二EXP(X)，CC)S(X)则它们的存储结构如图4.5所示。A$｝二lYl二IIX！一＿｝｛川IIIII0123‘567891011121314151617S$｝16’1M`1EIXlPI&lt;IXI）卜｝CIoISI(IX卜｛｝】图4.5采用设里长度指针方式处理字符申长度" ID="10">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="作插人或删除运算时.第。号单元的当前长度也随之改变。比较采用固定长度方法存储字符串和采用设置长度指针方法存储字符串适用范围，前者仅适用字符串作为简单数据和数组使用的情况，后者不仅适用字符串作为简单数据和数组使用的情况.而且适用线性表使用的情况。" ID="11">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000054" TITLE="二、  串的链接存储" TYPE="Chapter">
        <fptr LogicalPageNum="54" PhysicalPageNum="54"/>
        <Paragraph CONTEXT="类似于线性表的链式存储结构，串的链接存储结构是把可用存储空间分成大小相同的节" ID="1">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="点，逻辑上相邻的字符物理上是通过指针来链接的。链表的每个节点有两个域：值域(data域）data域可以存放一个或多个字符，如图4.6和4.7是节点大小为3（即每个节点data域中s叮IJ＿！1111111.…一州.rllS.ITI寸～｝R+I,I.N｝寸一！G！二｝4,”,图4.6节点大小为3的链表三区日一区日一侄日一区压卜区日一区日一区国图4.，节点大小为1的链表" ID="2">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000055" TITLE="三、  两种存储方式的比较" TYPE="Chapter">
        <fptr LogicalPageNum="55" PhysicalPageNum="55"/>
        <Paragraph CONTEXT="串的顺序存储和链式存储即有联系，又有区别，在其中进行的插人和删除运算见表4.1,$Picture[00000055\00000055_new\0002.jpg]Picture$比较顺序存储和链式存储，顺序存储对访问子串运算较为方便，而且节省空间，而对插人和剐除运算较为困难，而链式存储插人和姗除运算方便.但是可能浪费存储空间。" ID="1">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT=".43" ID="2">
          <fptr EndPN="00000055" StartPN="00000055"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="申在程序语言中和许多非数值处理的程序中不仅作为输入输出的常量，也是操作的对象，作为变盘而出现，有串变量名和串值，串值的存储分配有两种类型。顺序存储，链式存储，而每" ID="1">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
      <Paragraph CONTEXT="一种存储各有优缺点。" ID="2">
        <fptr EndPN="00000052" StartPN="00000052"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000056" TITLE="第三节  数组" TYPE="Chapter">
      <fptr LogicalPageNum="56" PhysicalPageNum="56"/>
        <div ORDERLABEL="00000056" TITLE="一、  有关数组(array)的一些概念" TYPE="Chapter">
        <fptr LogicalPageNum="56" PhysicalPageNum="56"/>
        <Paragraph CONTEXT="我们大家都知道，数组不仅是一种常用的数据结构，也是一种比较复杂的数据结构。不同于线性结构中的数据元素，元素的值是可以分解的。这里要说明一点，数组中数据元素必定属于同一数据类型，数组元素的值和其下标是一一对应关系，而且数组下标具有上界和下界.我们可以把数组看成是线性表或向量的推广。为了研究问题方便，我们先向读者介绍几个概念：" ID="1">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="1.向妞向量指某一特定数域上由n个数组成的有序数组（(a1，a2,····art)，其中a1&lt;iCn)称为向最的分量." ID="2">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="2.矩阵矩阵形如下列形式，A二、：矩阵有m行n列，可以看成一个二维数组：aAmu。二amt此二维数组中含有mn个数据元素.每个数据元素都a和下标i,j一一对应，其中1CiC" ID="3">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="m,1CjCn。二维数组的每个数据元素都受两个关系：行关系和列关系的约束，一般情况下每个元素g有两个前驱元素；a&lt;一：，;和a;，十还有两个后继元素a(it1)1和&amp;c;十第一行和第一列元素一般只有一个前驱元素，其中无前驱。第m行和第n列元素一般只有一个前驱元素，其中a二无后继。" ID="4">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000057" TITLE="二、  数组存储的排列顺序" TYPE="Chapter">
        <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <Paragraph CONTEXT="若按一定规则，访间数组中每一个数据元素，并且按照访问的顺序元家重新排列。这里用向量作为存储结构来存储数组。对于二维数组A二，。来讲，则有两种顺序排列：即“行主序”和主序”。行主序：就是将数组中元素按行向量排列，第i十1行向量紧排在第i行向量后.rl2341" ID="1">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="以A,r,一｝5678｝为例，便得到如下的排列方式：" ID="2">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="L9101112J“列主序”。1,2.3.4,5,6,7,8,9,10,11,12" ID="3">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="‘一一，厂－～曰、一一叫丫一～一一、尸" ID="4">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="第一行第二行第三行" ID="5">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="列主序：就是将数组中元素按列向量排列，第j-1个列向量紧接在第i个列向量之后.如" ID="6">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="A,x；排列方式如下：1,5,9,2,6,10,3,7,I1,4.8.12、一、.－‘、－－一～铲－户一～一、～－～曰‘一、产－一曰第一列第二列第三列第四列" ID="7">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000057" TITLE="三、  数组的运算" TYPE="Chapter">
        <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <Paragraph CONTEXT="由于数组中所包含的元素是不变的，所以数组不同于线性表，没有插人和别除运算。但是给定一组下标的值，可以存人相应数据元素，也可以修改相应数据元素的值。" ID="1">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000057" TITLE="四、  数组的顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <Paragraph CONTEXT="如果要检索某个元素，首先知道决定元素在内存中的存储地址的因素：数组元素下标。数" ID="1">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="组在计算机中的存储结构（一个存储单元存储元素的个数）；数组的首元素在计算机中的存储" ID="2">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="loc(all}+(i-1)Xnj-1)。如二维数组A,x。中，loc（a32）＝10。（al，）＋（3-1)X4C2-1loc(als8+1=1oc(ai9我们还可以将此方法推广到三维数组：loc（ai＊）＝loc（a〕、）＋（1-1}XmXnj-1)Xn-(k-1)" ID="3">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000057" TITLE="第四节  稀疏矩阵" TYPE="Chapter">
      <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <div ORDERLABEL="00000057" TITLE="一、  稀疏矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <Paragraph CONTEXT="在许多数学问题中，我们经常以矩阵为研究对象.特殊矩阵有很多种，我们在此将要讨论一种特殊类型的矩阵―稀疏矩阵.那么究竟什么是稀疏矩阵呢？人们无法给出稀疏阵的明确" ID="1">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="1a-zoaofr”“。。’”、！“2-2”““｝M一｝’“。“““｝｝00O0D0｝＿‘00D00-1／5x62-2000。“““｝N一｝6言石。。。。。｝＿｝1。。。八凡八八，尹SX6kn六六内0D00图4.9稀疏矩阵M和N" ID="2">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="各种等效运算。为了节省时间、空间，我们要研究稀琉矩阵的压缩存储形式." ID="3">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="我们知道，在计算机编制各种程序时，可以用二维数组来存储矩阵元素。对于矩阵的每个" ID="4">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="非零元素，可以用一个三元组来表示。即非零元素值和它所在行号和列号来表示，即（i，j，aij），" ID="5">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="则每个稀疏矩阵可由表示非零元的三元组及其行列数唯一确定。如果把稀疏矩阵每个非零元" ID="6">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="素用三元组来表示，并把每个三元组按照行主序或列主序排列起来，则得到一个三元组序列。" ID="7">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="例如稀疏矩阵M的三元组序列为｛（1，1，3），（1，5，1），（2，2，2），（2，3，一2），（3，1，1），（5，6，" ID="8">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="-1）｝。若设一个稀疏矩阵有m行n列，非零元素个数为t的三元组为（m，n，0.和三元组序列构成一个三元组表。例如稀疏矩阵M为5行6列，非零元素的个数为6，则它的三元组表如下（其中（5，6，6）表示矩阵M为5行6列有6个非零元素）：（5，6，6）（1，1，3）（1，5，1）" ID="9">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000058" TITLE="二、  稀疏矩阵的存储" TYPE="Chapter">
        <fptr LogicalPageNum="58" PhysicalPageNum="58"/>
        <Paragraph CONTEXT="稀疏矩阵化三元组的算法如下：procedurepress(m,n,A;varB)（求m行n列稀疏矩阵A的三元组矩阵B}begin" ID="1">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="so准备用s记录非0元素个数）foris=1tomdo{逐行检查矩阵A的非6元;}forj:=1tondo《在A的第i行逐列检查非0元素｝" ID="2">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="ifA［i.扫＜＞。then（如果A[i,j〕不是。就要存人一个三元组｝" ID="3">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="4">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="B2］：＝j；‘将非0元素列下标存人B}" ID="5">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="B[s.31：二ACi.j]｛将非。元素存人B'rends" ID="6">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="B1］：＝m；硬记录稀疏矩阵的行数｝B[0,21：二n;{记录稀硫矩阵的列数｝B[0,31：二。｛记录稀疏矩阵非零元素的个数｝ends" ID="7">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="2，链接存储" ID="8">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="行号相同的三元组节点按照列数从小到大的顺序用指针连接成一个单链表，为第i条链建立一个链头指针H;，这样做需要使用指针型数组H[0二m]，其中H。指向（(5,6,G)。如图4.12所$Picture[00000059\00000059_new\0022.jpg]Picture$不。图4.12带行指针的链式表示法" ID="9">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000059" TITLE="三、  稀疏矩阵的运算" TYPE="Chapter">
        <fptr LogicalPageNum="59" PhysicalPageNum="59"/>
        <Paragraph CONTEXT="利用三元组表表示稀疏矩阵时.进行矩阵有关运算很方便，下面以矩阵的转置运算为例，体现用三元组表示稀疏矩阵的处理方法.矩阵的转置就是把矩阵中的第i行第J列元素a换到第，行第i列的位置上，得到的新矩阵叫作原来矩阵的转置矩阵。一个mXn阶矩阵的转置矩阵为nXm阶矩阵。例如本节中矩阵1V就是矩阵M的转置矩阵，反过来M也是N的转置矩阵，二者互为转置矩阵，记作：矩阵If=M（即矩阵N是矩阵M的转置矩阵）。显然一个稀疏矩阵的转置矩阵仍是一个稀疏矩阵。(2〕按照行主序重排三元组之间的顺序，以便实现矩阵的转置。如图4.13所示。说明一点，三列二维数组B是矩阵M中非零元素按列序进行转置，由于矩阵M中的每一个非零元素在数组A中按照行主序排列，所以只有对数组C按行主序重新排列得到的数组B才是矩阵M的转置矩阵N:N中非零元素按照行主序依次排列表示（这个问题的算法做为习题请同学自己思考）。例4.1已知矩阵M，求M的转置矩阵N（具体算法描述如下）。方法1：若矩阵M用数组A（三元组序列）表示，矩阵N用数组B表示，对数组A进行n轮扫描（。为M的列数，亦即N的行数），第一轮扫描把列号为1所在的三元组（即对应N中第一行非零元索所构成的三元组）按照从上到下（即按数组M的行号从小到大）的顺序写人到数组B中，第二轮扫描把列号为2所在的三元组（即对应N中第二行非零元素所构成的三元组）按照从上到下的顺序写人到数组B中，依次类推。矩阵M中的非零元素在数组A中是以行序存放的，这样得到的元素顺序将是它们在B中应有的顺序。具体算法描述如下：proceduretranamat(A，VARB{A和B分别代表稀疏矩阵M和N,N是lul的转里矩阵，现由AFBbegin" ID="1">
          <fptr EndPN="00000060" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="二，＝AFo，1〕；n：＝A［0，2二A[0.31;" ID="2">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="B［0，1］，＝n；B〔0.2］：＝moB〔0.3］：二t;{序中二代表矩阵M的行数（N的列数）,n代表M的列数（N的行t代表M和N中非零元紊的个数。）ift＜二0thenreturn;｛如果非零元东个数小于0,则退出此过程｝q1:｛用q指示B数组的行下标，初值为1}forcol：二1tondo｛用。of指示待扫描矩阵M的列号（N的行号）｝forp：二ltotdo《用P指示数组A中待扫描的行号｝" ID="3">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="ifA[p,2］二colthen{1断当前非零元是否在短阵N的第col行｝" ID="4">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="5">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="end" ID="6">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="end书此算法的运行时间主要取决于双重for循环，算法时间复杂度为O(nXt)，即同m的列与非零元素的个数的乘积成正比。方法2：对数组A进行两次扫描.按照数组A中行的顺序进行转换.但转换后的元素不连续存放，而是直接放到数组I3中应有的位置上，可以避免元素移动。第一次扫描统计出I;1中每一列（即对N中每一行）非零元素的个数，由此求出每一列的第一个非零元素（即对应N中每一行的第一个非零元素）在数组B中应有的位置，第二次扫描将数组A中的每一个三元组写人到数组B中确定的位t上。设。of表示f中的列号，ntun[1二n〕和pos[1n〕为两个一维数组，分别存放矩阵M中每一列的非零元素个数和每一列的第一个非零元素在数组B中的应有位里。procedurefaattrans(A:VARB{A表示转里前的三元组序列.B表示转t后的三元组序列｝beginm：二A[0.11，n：二A印，幻；t：＝A3〕。｛读出转置前的稀疏矩阵行朔数及非。元个数｝B［0.1〕：＝n；B〔0，2〕：二二，B［0.3〕：＝t，老求转里后三元组序列的行列致和非。元素数｝ifx二0thenreturn｛如果三元组序列空就不必求转T)farcol：二1tondonum[col]：二0｛对nurn向量中的每个分t斌初值0}foris=1totdonum[A[i.21num[A[i,211;" ID="7">
          <fptr EndPN="00000061" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="{上面是第一次扫描数组A.统计出M中每一列（即N中每一行）非0元紊的个数｝" ID="8">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="侧”【1」：＝1。" ID="9">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="forcoi2tondopos[colpos[col-11tnum[col-11i" ID="10">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="（上面是求出M中每列（即N中每行）的第1个非0元素在数组B中的行下标｝foriltotdo｛对数组A进行第2次扫描，求转置｝" ID="11">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="悦9运col：=A[i,21:q：=pos[col]（将数组A中第i个三元组的列号赎给co将该三元组在数组B中对应的行下标斌给q}B[q.l]：二A[i,21；B[q.21：二A仁1.1〕。B［q，3］：二A[i,31;P坦[11：二paa[co1｛使poa[col」指向第。of列的下一个非。元众在数组B中对应的行号｝end" ID="12">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="13">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="此算法的运行时间主要取决于4个并列的for循环，时间复杂度为Cn+t这种算法的" ID="14">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="时间复杂度要比算法1好得多。利用稀疏矩阵的三元组表示法求转置，除了算法i和算法2以外，可利用下面的方法：先把各三元组中的行与列交换，此时所得到的各个三元组均可表示转置矩阵中的非零元素，但" ID="15">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="可能不符合行优先的存储顺序。对这个交换过行列下标的B数组再进行行优先的顺序便可得" ID="16">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="到转置后的三元组矩阵$aprocedureconvert(B}i（求三元组序列B表示的稀疏矩阵的转置，仍用B表示｝beginforj：二1＋ItoB〔0，3〕do走依次比较行列值，按行优先的顺序存储三元组）" ID="17">
          <fptr EndPN="00000062" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="ifB[i,l]#w-B[i,21&gt;B[j,l]*w+B[j.21then{判断转t后哪＋三元组位里在前}" ID="18">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="begin（如果第i行的元索应排在第j行的元索之后，则交换这两行元素｝" ID="19">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="tB[i,21，B[i,21：二B口，2〕。B口，2〕.＝t。艰交换这两行的第2个元素｝" ID="20">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="t：二B[i,31:B[i,31：二B［i，3〕，B［j，3］，！t｛交换这两行的第3个元索｝end;" ID="21">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000062" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="62" PhysicalPageNum="62"/>
      <Paragraph CONTEXT="1.已知三维数组是A[1二m,l二n,l二t]，数组的每个元素占用1个存储单元，当数组的13300000-600" ID="1">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="A二" ID="2">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="00000000000280Q0" ID="3">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="3.空格申与空申有何区别？字符申中的空格符号有何意义？" ID="4">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="4.设A＄二’仪以dcabca阮，" ID="5">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="B＄二‘abc，求（1）len（A＄），len（B＄）。" ID="6">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）判断B＄是否是A＄的子串.如果是其子串，说明起始点是A＄的第几个字符." ID="7">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="5.写出执行以下过程的翰出结果。" ID="8">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="Pr仪eduredents。" ID="9">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="吨in5＄：二‘Th认招A且刀kl；r印1（5＄，：ub（5＄，3，？），rESEARE‘）；" ID="10">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="计算机不仅能够处理数值对象，而且能够处理非数值对象，字符串数据的处理就在非数值处理中占有重要的地位.宇符串简称为串，如汇编语言的编译、文字编辑、信息检索系统、自然语言翻译系统及音乐分析程序等等，都是以字符串数据作为处理对象。为了有效地处理字符串，必须根据具体情况使用合适的存储结构。本章将对申的存储结构进行研究。" ID="1">
      <fptr EndPN="00000050" StartPN="00000050"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000063" TITLE="第五章  树" TYPE="Chapter">
    <fptr LogicalPageNum="63" PhysicalPageNum="63"/>
      <div ORDERLABEL="00000063" TITLE="第一节  树的定义和运算" TYPE="Chapter">
      <fptr LogicalPageNum="63" PhysicalPageNum="63"/>
        <div ORDERLABEL="00000063" TITLE="一、  树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="63" PhysicalPageNum="63"/>
        <Paragraph CONTEXT="树是树形结构的一个重要类型，下面我们给出树的定义.定义：树是n(n&gt;0)个节点组成的有限集合T。其中，当n=0时，即不含节点的树是一棵空树。当n,l时，即至少含有一个节点的树是一棵非空树。在一棵非空树中，满足（”有且只有一个特定的称为根（(root)的节点。" ID="1">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)除根节点外，其余节点被分成m(m妻0)个互不相交的集合，而这些集合中的每一个集合本身又是一裸树，我们称T1CiCtn）为根的子树（subtree在这里，需要说明一点子树也是树，用树来定义树，这显然是一个递归定义，这为以后进行树的各种运算提供了方便。自然界中的树有树根，树枝（子树）和树叶。我们下面给出树的画法与自然界中的树生长方向正好相反，采用倒置的树的形式，例如图5.1(a)是一棵只有一个根节点的树（只由根组成），图5.1(b〕是一棵有13个节点的树T，根节点为A，其余节点分成三个互不相交的有限集合：TB,E,F,K,L，TC,GT9b,H,I,1,MTTZ,T：都是根A的子树，而它们本-50身也是一裸树（分别对应如图5.1(c)例如在T,中。其根节点为B，其余节点分成两个互不相文的有限集合：T二｛E，K，L｝；Tl：＝丈F｝。TI：和Tiz是S的两裸子树（分别对应如图5.lCf(g。在T,、中，E是根，{1{｝和｛{1.｝是其两棵互不相交的子树K｝和{1-｝本身又是一个只有一个根节点的树.在每一裸树中，我们这样定义节点的前驱和后继，即树的每个节点都可以看作其每个子树的根节点的前驱，而它的每个子树的根节点，又可看作它的后继.从这里我们知道.在一裸非空树中，只有树根这个节点没有前驱，而其余的每个节点有且仅有一个前驱节点。树中除最外层节点（叶子节点）外，树里每个节点（包括根节点在内）有若干个后继。例如：在图5.1(b)中，A节点无前驱节点，其余每个节点有且仅有一个前！节点，在所有节点中;A,D节点分别有三个后继节点，C,H节点分别有一个后继节点，B,E节点分别有两个后继节点，其余节点无后继节点。" ID="2">
          <fptr EndPN="00000064" StartPN="00000063"/>
        </Paragraph>
        <Paragraph CONTEXT="树结构在客观世界中应用广泛，如人类杜会的" ID="3">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="族谱和各种社会组织机构等都可用树来形象表示。" ID="4">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="例如：爷爷A有两个儿子B,C,B有3个孩子D,E," ID="5">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="F,C有两个孩子G和H.一本书的结构也可以看作" ID="6">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="一裸树，树中的节点为书、章、节的名称及相关信$Picture[00000064\00000064_new\0017.jpg]Picture$息，树中的关系为包含关系。例如：一本书A可以分图5.2文氏图表示法为两章S,C,B章又分三节D,E,F,C章为两节G" ID="7">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="和H,树的表示方法有多种，有树形表示法（图5.1)；还有文氏图表示法；凹人表示法和嵌套括号表示法。我们用文氏图表示法即集合的包含关系来表示上段的两个例子，如图5.2," ID="8">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000064" TITLE="二、  树的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="64" PhysicalPageNum="64"/>
        <Paragraph CONTEXT="I.节点的度和树的度每个节点具有的子树的个数为节点的度（degree)，例1(b)中，A,D的度为3,B,E的度均为2,C,H的度为1，其余节点的度均为。。所有节点的度的最大值称为该树的度.因为节点的最大度为3，所以树T的度为3," ID="1">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="2.分支节点，叶子节点" ID="2">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="度大于零的节点称作分支节点，又叫非终端节点." ID="3">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="度等于零的节点称作叶子节点，又叫终端节点.例如图5.1(b)中节点A,B,C,D,E,H为分支节点，其余为叶子节点，" ID="4">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="3.欲子、双亲、兄弟节点每个节点的子树的根称为该节点的孩子（child)，相应地.该节点被称为孩子的双亲（par-ent)。我们也称后继为孩子，称前驱为双亲。例如：图5.1Cb）中B,C,D是A的子树的根节点，则S,C,D是A的孩于，而A是B,C,的双亲。具有同一双亲的孩子称为兄弟（brother)，如B,C,D互为兄弟.每个节点的所有子树中的节点被看作该节点的子孙。从根节点到达某一节点的路径上经过的所有节点称为该节点的祖先。例如：K的祖先为A,S,E，而B的子孙为E,K,L,F," ID="5">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="a.节点的层数和树的深度根节点的层数为1，其它节点的层数等于它父母节点的层数加1。树中节点的最大层数为树的深度或高度（depth)。例如图5.1(b〕中，树T的深度为4.5.有序树若树T中节点的各子树是按照一定次序从左向右排列的，则称树T为有序树，否则称为无序树。如图5.1(b）是一棵有序树。" ID="6">
          <fptr EndPN="00000065" StartPN="00000064"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000065" TITLE="三、  树的基本运算" TYPE="Chapter">
        <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <Paragraph CONTEXT="1.求根节点（rtwt(T〕或root(x" ID="1">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="求树T的根节点或求节点所在的子树的根节点.如果T是空树或x不在任何一裸树上，则root(T）或root(x)值为“空”。" ID="2">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="2.求双亲节点（parent(T,x" ID="3">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="求树T中的节点x的双亲节点.若节点x是树T的根节点或x不在树T中，则parent(T,x）的值为空." ID="4">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="3·求左兄弟节点“eft-sibling(T,x))" ID="5">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="求树T中节点x左边的兄弟。" ID="6">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="此外，还有擂人，删除，迫历运算。" ID="7">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000065" TITLE="第二节  二叉树的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <div ORDERLABEL="00000065" TITLE="一、  二叉树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <Paragraph CONTEXT="二叉树（binarytree）是一种最简单、最重要的树形结构。它的特点是：树中每个节点最多只有两棵子树.即二叉树中任何节点的度数都小于或等于2，那么二叉树或者是一棵空树，或者是一棵由一个根节点和至多两棵互不相交的子二叉树组成的，这两裸子二叉树分别称为左子树和右子树。二叉树的五种基本形态如下图5.3所示。" ID="1">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="了飞根据二叉树定义，我们可以看到二叉树可以是一裸空树‘树和二叉树的最大区别是二叉树的子树有且一定有左、右次序之分，而树不必区分次序。" ID="2">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000065" TITLE="二、  二叉树的遍历" TYPE="Chapter">
        <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <Paragraph CONTEXT="二叉树的遍历是二叉树中所有其它运算的基础.所谓遍历二叉树就是按照一定次序访问树中每个节点，使每个节点都被访问一次，且仅被访问一次。如何访间才能得到二叉树各节点的一种线性顺序，才能使访问迅速且方便？我们知道，二叉树是一种非线性结构，每个节点都可能有左子树和右子树，可以先访间左子树，也可以先访问右子树，因而必须事先规定一种规则，·52-$Picture[00000065\00000065_new\0006.jpg]Picture$按照这种规则访问，从而使二叉树上的各节点按线性顺序来排列，使谊历方便。二叉树是由根节点，左子树。右子树三个基本单元组成，用L,D,R分别表示。我们规定：按先左后右的规则（即在遍历子树时先遍历左子树再迫历右子树）退历二叉树，共有三种可能性；DLR.LER,LRD按照先左后右的规则。先访问根节点再遍历左右子树，这种遍历叫先根遍历（也叫先序遍历），即DLR；若访问根节点在遍历左子树和右子树之间，这种遇历方案叫中根遍历（也叫中序.历），即LDR；若访问根节点在遍历左、右子树之后，这种遍历方案叫后根遏历（也叫后序追历）。即LRD。我们知道，二叉树是递归定义的，即i历左、右子树实际上也是遴历二叉树.下面给出三种遍历方法：" ID="1">
          <fptr EndPN="00000066" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="l.先根追历X法（DLR}procedurepreorder(t（按先根次序遏历二又树t.t的每个节点有三个城：lchild、data,rchild}beginiftnilthen" ID="2">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="3">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="write(t-data（访间根节点｝" ID="4">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="preorder(t&quot;.lchild递归先根遍历t的左子树）preorder(t'.rchild)｛递归先根迫历t的右子树｝" ID="5">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="endend;" ID="6">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="2.中根遥历算法（LDR)procedureinorder(t｛按中根次序追ri7二叉树t.t的每个节点有三个域：lchild,data,rchild}beginift&lt;＞nilthen" ID="7">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="8">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="inorder(t'.lchild" ID="9">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="write(t'.datainorder(t-rchild)" ID="10">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="endend;" ID="11">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="3.后根追历算法（LRD)procedurepostorder(t｛后根遏历二叉树t.t的节点有三个城：lchild,data,rchild}beginift&lt;＞nilthen" ID="12">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="13">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="ppstarder(t-lchild)" ID="14">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="postarder(t一。rchild)write(t&quot;.data)" ID="15">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="endends$Picture[00000067\00000067_new\0004.jpg]Picture$图5.4i历二叉树示例杂度均为U(n包括参数、局部变量、返回地址和其它内部工作状态，而且都占用系统堆栈区，如果改用非递归算法描述，只保存用户所孺的变量或参数值.有时能节省存储空间，还能突破系统堆栈区的容t限制，避免堆找滋出的错误。下面以中根遍历二叉树的非递归算法为例给出算法。例5.1中根遍历二叉树的非递归算法.proceduremid(i｛对以t为恨节点的二又树进行中序班历｝begini：二0;{i处理左子树或根节点或右子树的标志｝z1;{名是记录根节点的栈指针｝" ID="16">
          <fptr EndPN="00000067" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="repeat{开始重复访问各个树和子树｝is=i十1;｛在左子树、根节点、右子树中处理完一个后处理下一个｝caseiof｛对上述三种悄况分别处理｝I;ift-1&lt;inilthen第1种情况处理左子树，先1断有没有左子树｝begin《如果有鱿要先访问左子树｝a[z]：二t;《在找中记录根节点}名：二z+1;{栈指针上移一位｝t：二t&quot;.1;当前节点变为左子节点｝i：一a（指示器清。，准备在访问一个新树（左子树〕时从第1步开始｝end;1种情况处理完｝" ID="17">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="2ibegin{第2种情况处理根节点》write(t-data:4｛此处仅以打印代表一般的处理》ift-rC＞nilthen{判断此节点有没有右子树｝begin{如果有右子树就要访问它｝t：二t‘.r;｛以右子节点代替（当前）根节点｝is=0｛准备访间新树（右子树）时从第1步开始进行｝end{右子树非空处理结束｝·" ID="18">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="end书｛根节点处理结束）3.6gin《第三种悄况是处理完根节点有没有右子树｝z:：一1;（以t为根的子树访问完，准备从找中找出它的根节点》t：二：压〕；（从栈顶取出上一层根节点｝i：二1{要处理根节点将从访问树的第z步进行｝end{第3种情况处理结束｝" ID="19">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="end｛分情况处理结束）untilz二Q{直tf最后一个根节点处理完才结束i历｝ends" ID="20">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="·54" ID="21">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000068" TITLE="第三节  二叉排序树" TYPE="Chapter">
      <fptr LogicalPageNum="68" PhysicalPageNum="68"/>
        <div ORDERLABEL="00000068" TITLE="一、  二叉排序树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="68" PhysicalPageNum="68"/>
        <Paragraph CONTEXT="二叉排序树又称二叉查找树，它或者是一裸空树，或者是一棵具有下列特性的非空二叉树.(i)若它的左子树非空，则左子树上所有节点的值都小于根节点的值。" ID="1">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)若它的右子树非空，则右子树上所有节点的值都不小于根节点的值。" ID="2">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)左、右子树本身又各是一裸二叉排序树。如图5。5是一棵二叉排序树，树中每个节点的值都大于它的左子树中所有节点的值而不大$Picture[00000068\00000068_new\0007.jpg]Picture$于它的右子树中所有节点的值，根据二叉排序树的定义，对此树进行中根遍历便得到节点的有序序列为3,12,24,37,45,53,100," ID="3">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000068" TITLE="二、  二叉排序树的插入、生成和删除" TYPE="Chapter">
        <fptr LogicalPageNum="68" PhysicalPageNum="68"/>
        <Paragraph CONTEXT="二又排序树的插人运算较简单，插人时满足树中不存在与给定值相等的节点（不允许有相同值的节点的存在），且在二叉排序树中插入新节点后，还应该是二叉排序树.插人的原则：若二叉排序树为空，则®5.5二叉排序树擂人节点为新的根节点，若插人节点值小于根节点值，则插人左子树，若插人节点值大于根节点值，则插人右子树。在子树里又与子树根比较，如此进行下去。直到把新节点插人到二叉树里作为一个叶子节点。具休算法如下：例5.2二叉排序树的擂入算法。procedureinstree（吕;vart（把s所指节点抽到以t为根的二叉排序树中｝begin" ID="1">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="ift=nilthent：二selseifs&quot;.data&lt;t&quot;.datatheninstree(s,t&quot;.lchiid)end;例5.3利用有m个节点的数组r建二叉排序树。procedureaorttree(m;vart｛构造一个有。个节点r[i」的二叉排序树.1《iCm,t指向根节点）" ID="2">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="3">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="t：=nil;《初始化》" ID="4">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="foris=1tomdo" ID="5">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="P-rchild：二niI;" ID="6">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="instree(p.t)" ID="7">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="end;利用二叉排序树的插人算法，可以生成一裸二叉排序树，具体算法只播对上述算法稍加改动。例如在图5.6中48,38,26,fi2,94,73,5,36)可以生成一裸二叉排序树，每插入一个节点得到一裸二叉排序树，生成过程如下。$Picture[00000069\00000069_new\0007.jpg]Picture$$Picture[00000069\00000069_new\0008.jpg]Picture$$Picture[00000069\00000069_new\0013.jpg]Picture$$Picture[00000069\00000069_new\0014.jpg]Picture$$Picture[00000069\00000069_new\0015.jpg]Picture$二叉排序树的剐除算法比插人算法复杂.无论姗除二叉树中的哪个节点，都还应满足排序二叉树的定义.下面分三种情况来说明剧除的过程（如图5.7)" ID="8">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="1.侧除叶子节点这种别除实现很简单，因其既无左孩子又无右孩子，所以直接栩除该节点即可." ID="9">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="2.侧除单分支节点即翻除一个只有左孩子（或右孩子）的节点。若姗除一个只有左孩子的单分支节点，则用它的左孩子取代被翻除的节点，原来左于树内各节点之间关系不变，若川除一个只有右孩子的单分支节点，情况类似." ID="10">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="3.侧除双分支节点这种翻除是删除既有左孩子又有右孩子的节点。删除方法有两种，或者用左子树中最大的节点来取代被姗除的节点，或者用右子树中最小的节点来取代被删除的节点。二叉排序树的插人和姗除都不难实现，擂人一个节点，不必遗历全树，只要添一个叶子节点即可，删除一个节点，也不必移动所有节点，只需移动少t节点即可.而二叉排序树的播人算法的运行时间和侧除算法的运行时间基本一样，插人算法的主要操作在查找插人位置。而删除算法的主要操作除了查找待侧除节点以外，还要洗出代替该节点的节点.·56$Picture[00000070\00000070_new\0001.jpg]Picture$$Picture[00000070\00000070_new\0002.jpg]Picture$a)川除③$Picture[00000070\00000070_new\0005.jpg]Picture$$Picture[00000070\00000070_new\0006.jpg]Picture$.种种叫.卜$Picture[00000070\00000070_new\0009.jpg]Picture$$Picture[00000070\00000070_new\0010.jpg]Picture$(c)翻除③" ID="11">
          <fptr EndPN="00000070" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="－弓.，" ID="12">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Picture URL="00000070\00000070_new\0013.jpg">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Picture>
        <Picture URL="00000070\00000070_new\0014.jpg">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Picture>
        <Paragraph CONTEXT="二i&lt;d）创膝⑤$Picture[00000070\00000070_new\0017.jpg]Picture$图5.7二又排序树的翻除示例" ID="13">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000070" TITLE="第四节  哈夫曼树" TYPE="Chapter">
      <fptr LogicalPageNum="70" PhysicalPageNum="70"/>
        <div ORDERLABEL="00000071" TITLE="一、  基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="71" PhysicalPageNum="71"/>
        <Paragraph CONTEXT="1.路径长度从树中一个节点到它祖先的某个节点之间的分支构成这两个节点之间的路径.路径上的分支数目称作路径长度。路径长度等于路径上的节点数减1," ID="1">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="2.树的路径长度" ID="2">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="从树根到每一节点的路径长度之和." ID="3">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="3.节点的权和带权路径长度我们把树中的节点斌上一个有特殊意义的实数，这个实数称为该节点的权。节点的带权路径长度为该节点到树根之间的路径长度与节点上权的乘积。" ID="4">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="4.树的带权路径长度n树中所有叶子节点的带权路径长度之和就是树的带权路径长度.记作WPL一习W,L,。其上tl中w;为每个叶子节点的权值（i＝1，…，n）.我们前面提到的哈夫受树就是指带权路径长度WPL最小的二叉树。例如：有四个叶子节点，分别带权7,5,2,4，由它们构成的三裸不同的二叉树（还有其他可" ID="5">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="能）如图5.8所示，则图中三棵二叉树的加权路径长度分别为：" ID="6">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)WPL二2X2十4X2十5X2十7X2=3fi(a)(b)(e)图5.日三裸不同的二叉树" ID="7">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="在上例所有的树中，(3)树的WPL最小，此树就是哈夫受树。从上例可以看出，在哈夫曼树中.权值越大的节点.离根节点越近。" ID="8">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000071" TITLE="二、  构造哈夫曼树" TYPE="Chapter">
        <fptr LogicalPageNum="71" PhysicalPageNum="71"/>
        <Paragraph CONTEXT="如何构造哈夫曼树呢？哈夫曼最一早给出了带有一般规律性的算法。俗称哈夫曼算法，现将哈夫曼的思想概述如下：(I)由n个给定权值w1,wE+…,n的节点构成含n裸二叉树的集合FT1,Ts" ID="1">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="T。}，其中每棵二叉树T;(1&lt;iGn〕都只有一个权值为W‘的根节点，其左、右子树均为空." ID="2">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）在F中选出两裸根节点的权值最小的树作为一棵新二叉树的左、右子树，且置新二又树的根节点权值为其左、右子树的根节点的权值之和。(3〕在F中l除这两裸树，同时新树加人F中。" ID="3">
          <fptr EndPN="00000071" StartPN="00000071"/>
        </Paragraph>
        <Paragraph CONTEXT="是哈夫曼树的生成过程。" ID="4">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000072" TITLE="三、  哈夫曼树的应用" TYPE="Chapter">
        <fptr LogicalPageNum="72" PhysicalPageNum="72"/>
        <Picture URL="00000072\00000072_new\0001.jpg">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Picture>
        <Picture URL="00000072\00000072_new\0002.jpg">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Picture>
        <Paragraph CONTEXT="哈夫曼树的应用很广，哈夫曼编码就是其中的一种应用.在远距离电报通讯中，电文是以二进制的0,1宇符组成的字符申。为传送这些字符串，需要对字符串进行编码，最简单的二进制编码方式是等长编码。例如：电文中有A,B,C,D四种字符进行等长编码.若用这四个字符作为四个叶子节点，让该二叉树中每个分支节点的左、右分支分别用0和t编码，对应的编码二叉树如图5.10所示.采用二位二进制字符.编码依次为00,01,10,11,为了缩短传送电文的总长度，节省传送时间，常采用不等长编码。但是要设计长短不等的编码，则要求字符集中任一字符的编码都不能是其®s.ia等长编码示例它字符编码的前级，这种编码方式称作前缀编码。这样可以避免译码时有多种译法。比如：设计A,B,C,D的编码分别为0、00,1和O1，当翻译编码001时，可以译为‘BC，或‘AD，等，则产生了多义性.而前面提到的前级编码可以使字符集中每个宇符都作为叶子节点而生成一棵编码二叉树，解决译码时的多义性问题。下面讨论怎样得到电文总长最短的二进制前，编码.电文总长为L-MVP“一荟W;L，其中w。为字符在电文中出现的次数，L;为编码长度，n为电文中字符种数.为了得到传送电文的最短长度，将w‘作为字符节点的权.L;作为从根到叶子的路径长度.则习w,L。为二叉树上带权路径长度，若求出了此树的最小带权路径长度，也就求出了传送电文的最短长度.因此，设计电文总长最短的二进制前级编码间题等价于以字符集中所有宇符作为叶子节点，由n种字符出现的频率做权产生的哈夫曼树，所以称二进制前级编码为哈夫曼编码。例5.4求哈夫曼编码的算法." ID="1">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="fori:_1tomdo" ID="2">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="beginht[iparent0;ht[iI.lch0;ht[iI.rch0（初始化｝end;foris=1tondaht[iI.weight：二w[i（初始化｝forin十ltomdo" ID="3">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="begin" ID="4">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="select(i-l,sl,s21在ht[k1&lt;kCi-1)中选择两个其双亲域为零而权值最小的节点，它们在ht中的序号分别为sl,s2}ht[slI.parent：=i;ht[s2I.parenti;ht[iI.1ch：=a1obt仁iI.rch:=s2i" ID="5">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="+ht[s2I.weight" ID="6">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="end;" ID="7">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="fori：二1tondobegincd.start==n:3cd为codetype型变f)" ID="8">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="。：二i;fht[cI.parent;" ID="9">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="whilef0do" ID="10">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="begip" ID="11">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="ifht[fI.1ch=cthencd.hits[cd.start]，二0" ID="12">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="elseed.6its[cd.start]：二licd.start==cd.start-1;cf;fht[fI.parent" ID="13">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="end:" ID="14">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="hcd[i]：二cd" ID="15">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="end$Picture[00000073\00000073_new\0031.jpg]Picture$图中A,B,C,D编码依次为0,01,11,110,111,L二WPL二图5.11哈夫受树白＿＿‘一一～LW:L10X1十5X2十2X2+4X3=38e而在前面图5.10中，等长编码得到的L=iW;L2X(10-5十2十442,可以看到，哈夫曼编码所得的传送长度比等长编码所得到的传送长度要小.：在此例中，C的编码是这样得到的，从2到6的编码是0，从6到11的编码是1，从11到21的编码是1&gt;反序收集的结果就是C的编码110。我们以此编码为下列代码序列译码，ABCDAABD的编码应的字符序列是ABCDAABD，译码过程结束.已知字符串5是一个。,1序列，R是一个哈夫燕拉圣汉.创日沈r±～‘.面石奋rrasuvc二业昌Xudfr甘+tt,7.Fc.xk歼#tJk.不7i38fi9r;usict京件Crf" ID="16">
          <fptr EndPN="00000074" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="type" ID="17">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="jd=&quot;node:" ID="18">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="node=record" ID="19">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="data;real;" ID="20">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="ch:char;" ID="21">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="l,r:jd" ID="22">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="end;例5.5利用哈夫曼树解码。proceduredecodes:string;r:jd利用根节点为r的哈夫受树对O,I序列，解码}begin：：＝。八建立扫描字符的指针幻repeat｛一次次地重复沿二叉树从根到叶的解码过程｝tr;｛每解码一个字符都是从根开始的，故先设树的当前节点为r}white(tnil)and(z&lt;length(sdo｛当代码序列没扫描完且P没有进到叶子节点时｝" ID="23">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="begin｛当前节点将向下走一层｝" ID="24">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="zi=z+I;{代码序列的扫描指针加1" ID="25">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="p：=ts{P记住上一次的t}" ID="26">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="ifs[z0thent：二t&quot;.l{当前这位代码如果是。则当前节点变为其左孩子）elset：二t-r;｛否.（此位代码为1)，当前节点变为其右孩子）end}{结束对一个字符的扫描过程｝ift二nilthenwrite(p&quot;.ch)｛若存在解码字符就把它打印出来1untilz-length(s{直到代码序列扫描完毕就结束解码过程｝" ID="27">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="writeln（物出换行》" ID="28">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="哈夫曼树，又称最优二叉树，是带权路径长度最短的二叉树·57" ID="1">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000074" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="74" PhysicalPageNum="74"/>
      <Paragraph CONTEXT="1.试写出如图5.12所示二叉树的终端节点，非终端节点以及每个节点的层次，树的度数，节点C的双亲、祖先、孩子、兄弟。" ID="1">
        <fptr EndPN="00000074" StartPN="00000074"/>
      </Paragraph>
      <Paragraph CONTEXT="3.给定一些仅由五个字母A,B,C,D,E组成的字，在这些字中，五个字母的使用频率依次为23,2,16,18,16，试用二进制串为每个宇母编码，要求每个二进制串能唯一解码，且编码" ID="2">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="所需的二进制申的平均长度应尽可能短。" ID="3">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
      <Paragraph CONTEXT="4。试写出先根次序、后根次序遍历二叉树的非递归算法。" ID="4">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="树形结构不同于以往的线性数据结构，它能反映节点之间有分支的、层次结构，是一种重要的非线性数据结构，很类似于自然界中的树。在计算机领域中，树形结构的应用很广泛.它不仅是计算机中常出现的数据，而且在实现各种算法时，树形结构也起着很重要的作用。" ID="1">
      <fptr EndPN="00000063" StartPN="00000063"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000076" TITLE="第六章  查找" TYPE="Chapter">
    <fptr LogicalPageNum="76" PhysicalPageNum="76"/>
      <div ORDERLABEL="00000076" TITLE="第一节  顺序查找" TYPE="Chapter">
      <fptr LogicalPageNum="76" PhysicalPageNum="76"/>
      <Paragraph CONTEXT="顺序查找是一种针对线性表进行的最容易想到、最容易描述的查找方法。它的具体查找步孩是先查找线性表的第一个元家，每查找完一个元素后接着查找它的后继元素，直到查完整个线性表或查到所豁元素就结束查找。当然在可能反向依次查找的线性结构（例如顺序存储的线性表或双向链表等）中，从后向前的查找也属于顺序查找的方法，无箱更多的解释和说明，很容易理解这种算法对所有数据的查询是不重不漏的。顺序查找既可以查找关健字、取某个特定值的一个或多个记录，查找的也可以是与某一元素之间符合某种特定关系的元素或是查找符合某个特定条件的元素对，还可以根据表中某一特定位置查询该位兰的数据或是根据综合条件进行比较复杂的查询等。例‘.1在链式存储的线性表中查找一个数据a,procedureczlink(h,avarb)s（在以h为链头的链表中查找一个数据为a的节点b}" ID="1">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="2">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="b：二hs{b从链头向后顺序移动进行查找卜" ID="3">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="while(bnil)and(b&quot;.dataC&gt;a)dob：=b&quot;.next（只要没有找到数据a并且后面还有节点就让b沿，链向后移动｝ends此过程通过变参b返回的节点可能是链中数据为a的第一个节点.也可能是空节点，返回空节点时说明链中不存在数据为a的节点。这只是在链结构的线性表中查找第1个待查数据的例子，方向是从前向后，顺序查找也可以在连续存储的线性表中进行，查我也可以是面向多个符合条件的数据，就连查找方向都可以是从后向前的.下面就是一个这样的例子.例‘.2按存储位登的序号从大到小打印出顺序线性表b中所有数据为a的数据序号." ID="4">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="procedureczaxb(b,n,a)（在n项数据的顺序线性表b中套找a}beginfori：二ndownto1do（按从后向前的顺序查找数据8}ifb[iI.data二athenwriteln(i)｛只要此项数据的值是，就打印它的序号｝ends顺序查找可以包含更复杂的查找条件.例如在下一章中，我们将多次利用顺序查找的方例‘.3在不少于两项数据的线性表中查找第2（或并列第1)大的数据。functionsec(a,ndatatype;｛在数组a的n个数据中找第2（或并列第1）大的数据｝begin｛以下过程要在J中求第2大的值｝ifn＞二2then{只有当n不小于2时才可能求得结果｝begin｛开始求数组中第二大的值｝ifa[11&gt;a[21then{J断数组中前两项哪个大）" ID="5">
        <fptr EndPN="00000077" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="beginia[11;j：二a[21end{若aCi〕大就用i记a[11,j记a[幻｝" ID="6">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="elsebeginj：二a[11，ia[21ends{若a[2］大就用i记a[2j记a[11}" ID="7">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="begin《下面的过程中将把最大数存放于i，第2大的存放于j}ifa[k1&gt;ithen{判断此数是否大于当前最大数｝begin《如果此效！最大数还大）" ID="8">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="1:片b｛原最大数当做第2大的数二" ID="9">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="is=a[k]{此数当做最大数｝end{结束改变最大值的处理》elseifa[kjthen｛否则看此数是否大于当前第2大的值｝ja[k]{如果大于当前第2大的值就将此数作为第2大的值｝end《结束顺序查找｝secj{用j作为求出的结果返回原阅用处｝ens;顺序查找是线性表中最容易描述的算法，也是最容易想到和最容易理解的算法，只要沿着线性结构从头到尾（或从尾到头）地查找，一定能够不重不漏地查找完所有数据.顺序查找对线性表不要求任何前提条件，从这个意义上说，它也是适用面最广的线性表查找算法.当然，与这么多优点同时存在的是一个显而易见的缺点，那就是比较次数最多，达到n次." ID="10">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000077" TITLE="第二节  折半查找" TYPE="Chapter">
      <fptr LogicalPageNum="77" PhysicalPageNum="77"/>
      <Paragraph CONTEXT="折半查找也是面向线性表的一种查找方法，它的突出优点是查找次数少。但此种方法要求" ID="1">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="线性表是有序的而且能进行随机查找。此外，这种方法的查找目标是符合条件的一项数据，不适合查找符合条件的多项数据.由于要求能随机访问存储结构中的数据，所以这种查找方法只能用于顺序存储的线性表，不能适用于链式结构。" ID="2">
        <fptr EndPN="00000077" StartPN="00000077"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="3">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="k，二Oa《以k为标志准备枪查数组a的n个数据是否已按降序排列｝fori：二1ton-1do（从a[11到a[n]都要检查｝ife[i]Ca[i+11thenk1;｛如果有反序就把k改变为1yif(k二0)and(n&gt;1)then{断是否符合折半查找的前提条件｝begin（如果符合条件就开始折半查找的过程｝" ID="4">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="1.二1｛用k记录待查范国的最小下标｝" ID="5">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="rn，{用r记录待查范围的最大下标｝" ID="6">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat{反复进行一轮轮地比较和查找｝，：＝（r＋l）divZ，厦先求出待查范围中间位t的下标m}ifx=a[m]thenJ断是否已经找到所需数据｝" ID="7">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="1：二r+1｛如果已找到就让.小下标为最大下标加1以结束查找｝elseifx&gt;a[m]then{否则要把待查范围编小一半继续查找｝" ID="8">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="else1：二m+1{中间元素大于二时保留右半个范围》until1＞rt《直到待查范围中没有数据｝ifx-A[m」then{断是否因查找到而结束上述过程｝writeln(a[m])｛如果查到了数据就打印此数据｝elsewriteln(xnotfound')（没有查到就输出”未查到”的fJ息；end｛结束可以折半查找的过程?" ID="9">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="ends从上面过程中的else的情况中体现出尽快缩小查找范围的目的，当x大于a[m〕时，下标m后面肯定不会出现x，去掉这些数据就可以使待查范围缩小一半，反之，当x小于a[m」时又可以去掉下标小于m的所有元素，无论怎样都可以使待查范围编小一半。这样一半一半地缩小下去，很快就能完成查找，总的查找次数只是O(logZn)。某次查找到要找的数据时，把I置为r+1，让待查范围最小下标比最大下标还大就意味着待查范围中已经没有数据了，此举意在结束查找过程.当然，查找结束后有相应的判断来区别处理因找到而结束查找和因待查范围没有数据而结束查找。表6.1以9,8,7,fi,5r4,3,2,1这9个数中查2为例给出各轮比较的情况，其中a[m］用圆圈圈出。表6.1折半全找Z的过程｛，来”“，‘三432，一几＿＿‘一，！一，｝Im一，9876C793212Cai5｛一，’一6r一，｝" ID="10">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000079" TITLE="第三节  分段查找" TYPE="Chapter">
      <fptr LogicalPageNum="79" PhysicalPageNum="79"/>
      <Paragraph CONTEXT="在线性表的查找方法中，第一节介绍的顺序查找不要求任何前提条件就可以实行，但查找的计算盆一般较大，而第二节介绍的折半查找虽然计算量很小，但又需要满足能随机访问和数据有序的条件.本节要讨论的分段查找就是介于二者之间的查找方法，它对要查找的线性表的要求没有折半查找那么高，而查找的计算量也没有顺序查找那么大.要进行分段查找首先必须能对存储数据的线性表分段，即把拱个表分成若于互不相交的子表，这些子表内部的数据并不要求有序，但子表间的排列必须是有序的（即段间有序）。具休地说，我们把下标最小的子表叫子表1，接下去的叫子表2,····，最大下标的子表叫子表k，那么要求子表1中所有的关键字都大于子表2中关键字的最大值，子表2中所有的关键字都大于子表3中关键字的最大值，··…，子表k-1中所有的关键字都必须大于子表k的最大关键字.还要为每个子表（即每段）建立一个索引项，索引项中存该段的最大关键字（称为索引值）和此段的位置信息（例如顺序存储的线性表中此段的最小下标）。把每个索引项都按索引值从大到小的顺序存放就得到一个索引表，在索引表中最后一项后可以人为地填上一个“监视哨”，它的索引值应小于第k个表中的最小值，它的位置信息应是整个线性表的最后一个元素的位置（例如在顺序存储的线性表中就是下标n分段查找x的过程是先用x在索引表中顺序查到相应的子表，然后再对该子表顺序查找" ID="1">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="x。具体地说，先用x从较小的索引项开始顺序查找，一旦发现某索引项中的值大于或等于x,有序，所以不裕要在索引项中记录每段的结尾位置.因为下一段的开始就可以表明这一段的结束。为了标志最后一段的结束.在图6.1分段查找示t图索引表的最后添加一个索引项，它的数据应该小于所有数据，而它所指的位t则是线性表的尾部.特别要注意的是，索引项中存的数据虽然是该段的最大值，$Picture[00000079\00000079_new\0026.jpg]Picture$但是它指明的位置却不一定是此最大值的位置而是该段的起始位里.例6.5编写分段查找算法，对n个数据的数组a查找x，可利用m项的索引表b和c，其中b存每段的最大数据，c存每段的起始下标.procedurefdcz(h,c,m.a,x｛在a中分段查找x，可利用m项的索引表6和c)begin" ID="2">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="if(x&gt;b[01)or(xb[mthen{到断要查的数据二是否在存储结构中｝" ID="3">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="writelnnotfound{如果不在就翰出查找不到的信息）" ID="4">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="elsebegin｛如果x没有超出数据范围就开始进行分段查找｝" ID="5">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="km（从最小的索引项找起｝" ID="6">
        <fptr EndPN="00000079" StartPN="00000079"/>
      </Paragraph>
      <Paragraph CONTEXT="ends" ID="7">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000080" TITLE="第四节  树形结构的查找" TYPE="Chapter">
      <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
        <div ORDERLABEL="00000080" TITLE="一、  汉字内码的查找" TYPE="Chapter">
        <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
        <Paragraph CONTEXT="利用键盘输人汉字一般是输人外码（即输入码，例如拼音、五笔字形等），但计算机必须根据抬人的外码迅速地查找到此汉字的内码（例如GB2312国标码）和字形信息（输人码即字库中的字棋）.借助树形的索引结构是很容易实现这种查找的.这个树形结构应该由这种外码的输人程序来完成。在帮助查找的索引k叉树中，除根节点外每个节点记录着一个字母及此节点对应的汉字信息‘还有指向子节点的指针。例如某代码是以a开头的，则根节点的子节点中必有一个字母是a的节点，如果代码中a后面是b，则a的子节点中必有一个节点的字母是b,汉字输人程序在没有拍人时以根节点为当前节点，从键盘接收到a时就找到子节点。并以a为当前节点.再接收到b时又找到子节点b并以b为当前节点，.，.，当码长已满或接收到空格键及数字键的输入时就会把此节点对应的汉字信息分不同情况输入到指定存储区，没有重码时输人的是此节点对应的唯一汉宇，有重码时若按的是空格键就输人第I个汉字，若按数字键则根据数宇选重码。这个索引树形结构还能及时应付各种查找失败，例如在汉语拼音中卜后面不能是c，反映到相应的索引树中，b节点的子节点中就不会含字母c，当b为当前节点时，如果使用者错打了。键，那么从当前节点查找。子节点的操作就会失败，输人程序立即做出“置之不理”或“响喇叭”等出错处理.利用树形结构帮助查找的好处是显而易见的。在成千上万的汉字代码中查找，如果方法选择不当会增加许多操作，浪费宝贵的时间，从而失去实用性.使用了树形结构索引后，即使在当前节点中顺序查找某个字母的节点，总的查找次数也不超过几十次，借助下节中“数据与地址对应”的方法，由外码查找内码仅需几次即可完成。直接使用这样的树形结构在空间占用方面是不很理想的，因为树中使用了大量的指针空间。为减少指针所占用的空间，可利用二叉树来表示k叉的树，在这个二叉树中，某个节点的“左孩子”表示的仍然是此节点在k叉树中的一个子节点，而“右孩子”则是与此节点在k叉树中有相同双亲节点的“兄弟”，也可以把向右指的指针看成是链指针，链中全都是同一个节点下面的子节点。图6.L中的：节点原有3个一子节点b,c,d.转化为二叉树（见图6.3)后.b仍然是a的子节点，而。则变成了b的右子节点，d变成了。的右子节点。用这种办法就可以把一般的树形结构转化为二叉树的结构，优点除了节省许多指针所占用的存储空间外，提供了用同一种方法处理多种多样树形结构的途径，缺点是查找某个节点的子节点只能用顺序查找的办法，在满足速度要求的前提下，多花一点点时间换来存储空间的节省有时还是可行的。" ID="1">
          <fptr EndPN="00000081" StartPN="00000080"/>
        </Paragraph>
        <Paragraph CONTEXT="／｝、＼bcddC图6.2三叉树图6.3图6.2对应的二叉树" ID="2">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000081" TITLE="二、  利用二叉排序树查找" TYPE="Chapter">
        <fptr LogicalPageNum="81" PhysicalPageNum="81"/>
        <Paragraph CONTEXT="在线性结构的查找中最快的方法是折半查找，在树形结构中也有一种类似的查找法即二叉树查找.关于二叉排序树的定义及建树方法在前面已经讨论过了，下面直接讨论在树中查找的问题。" ID="1">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="例6.‘在！为树根节点的二叉排序树中查找给定关键字x的一个节点。" ID="2">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="fu配tionfind（r，x）。谧在：为根节点的二叉排序树中查找关健字x｝" ID="3">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="beginifr＝nilthen｛判断r节点是否空｝find：二nil｛如果无数据就返回空节点，查找失败｝" ID="4">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="elseifr-data＝xthen厦不空就判断是否找到了x）" ID="5">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="find：二r若如果发现r的关健字就是x则返回结果r｝" ID="6">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="e映ifr-data＞二then（关链宇不是x，再看是否大于x｝诬ind：～find（r‘.rchild，x）｛大于x向右找｝elsefind：二find（r-1山己d，x）（小于x向左找｝end‘这里省略了检验此树是否为二叉排序树的过程。函数fi记显然是递归算法，当查找成功时返回关键字是x的节点，查找失败时返回空节点。由于二叉树查找的对象存储于有序的结构中，所以也具有与线性结构查找中的折半查找相类似的优点。我们先对一个整齐的二叉树―完全二叉树来讨论查找过程。在2，一1（n＝1，2.3…）个节点的完全二叉树中，如果根节点的关健字不是x，下一步只需要找某一边的子树就行了，x大于根节点数据就找右子树，否则找左子树，这样一来查找范围编小了一半还多，与折半查挽很相似，总的查找次数为105：n，计算复杂性很低。上面的分析是对于完全二叉树进行的，怎样保证二叉排序树就那么整齐呢？我们先给出一个衡量二叉树均匀、整齐的标准―二叉平衡树。所谓二叉平衡树要么是一个空二叉树.要么" ID="7">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="它的左右子树深度差不超过1且它的所有子树也满足这个条件。二叉平衡树显然是数据分布" ID="8">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="前面三节我们讨论的都是在线性存储结构中的查找方法，这一节我们将了解树形结构给查找带来的好处.先了解一般k叉树在查找中的作用，再分析排序二叉树加快查找的原理及保证二叉树查找高效的条件，B树和B十树也是有利于查找的重要结构，但它超出本教材的范围，暂不讨论。" ID="1">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000082" TITLE="第五节  哈希表的查找" TYPE="Chapter">
      <fptr LogicalPageNum="82" PhysicalPageNum="82"/>
        <div ORDERLABEL="00000082" TITLE="一、  哈希查找的有关概念" TYPE="Chapter">
        <fptr LogicalPageNum="82" PhysicalPageNum="82"/>
        <Paragraph CONTEXT="存储在存储器中的数据都有确定的存储位置（即地址），例如内存地址或下标等，如果建立了一种数据与其存储地址间的对应关系，那么由待查的数据直接就能找到存储它的位置，从而达到查找的目的。这种对应关系通常称为函数，我们称之为哈希函数.哈希函数的建立既决定了数据的存储方式又决定了数据的查找方式，更具体地说，存储数据时就是根据数据关键字的‘值，通过哈希函数得到存储位置的，而查找时还是通过这个哈希函数.由待查的关键字去找到存储位置，这种用哈希函数来分配存储存储空间的存储结构叫哈希表。根据设定的哈希函数hCkey)和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键宇在地址集中的“像’，做为记录在表中的存储位里，这种表便称为哈希表，这一映像过程就称为哈希造表或散列，所得存储位置称哈希地址或散列地址。设数据记录个数为n，地址从0至m-1共m个.m&gt;n。如果构造出的哈希函数能保证不同的关键字对应不同的地址，这个哈希函数就已经解决了不同关键字的存储和查找问题，这是一种最为理想的情况。但是，关键字相同的数据怎样存储和查找呢？另外，如果得不到那样理想的哈希函数而使得不同关键字对应了相同的地址又怎么办呢？这就涉及到“怎样构造冲突尽" ID="1">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="可能少的哈希函数？”和“碰到地址冲突怎样解决？”这两个问题，下面分别讨论。" ID="2">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000082" TITLE="二、  构造哈希函数的常用方法" TYPE="Chapter">
        <fptr LogicalPageNum="82" PhysicalPageNum="82"/>
        <Paragraph CONTEXT="1，线性地址法所谓线性地址法就是构造一个数据关键字到地址空间的线性（一次）函数作为哈希函数，这种函数往往能避免地址冲突，而且映射出的地址往往可以连续，有利于节省存储空间.例6.7某班学生的学号从s91a1到99145。编写存储和查找45个学生数据的算法（以学" ID="1">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="号为关键字）" ID="2">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="首先要决定用什么哈希函数的问题，设x代表学号，则hash(x）二x-99101所得到的结果就可以作为记录的下标（地址）。这个函数也就是我们要得到的线性哈希函数。" ID="3">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="procedure1incarmem(a,b,n｛在数组a中存储学号从b开始的n个学生的数据；" ID="4">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="begin开始存'n个学生数据的过程}" ID="5">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="end结束这名学生的输人和存储s" ID="6">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="end:：结束n名学生的翰人和存储!prrxcdure1inearsrCh(a.b,n.lt){｛在a数组的n名学生中进行哈希查找｝br;in{开始查找学号为h的学生，第1个学号是bt" ID="7">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="if1h＞二：b)and(h&lt;n+b)and(a[h-b＞nnll)then" ID="8">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="：判断此号是否能对应有效地址及此地址是否空）" ID="9">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="begin{如果对应有效下标就开始查找｝" ID="10">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="end｛结束能查找的处理｝" ID="11">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="elsewritelnnotfound')｛否叫输出查找不到的信息tend;｛结束对h学生的哈希查找｝上面两个算法中n二45,b=99工O1.两个算法中关键字都是学号，由学号对应下标地址的函数也都是同一个哈希函数。哈希查找也可能失败，用待查数据通过哈希函数的映射得哈希函数也都是同一个哈希函数。到的下标地址若不在地址空间中说明在地址空间的范围内不会存储该数据，即查找失败。另外，如果待查数据映射到的地址是空的即没有存储过任何数据，查找也是失败的。" ID="12">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="2，数字分析法线性地址法虽然优点突出，但许多实际问题很难构造出这种线性哈希函数，如果我们能够见到数据的关键宇，我们可以对关键字的各个组成部分（例如数值的各个数位等）进行分析，找出其中尽可能不重复的部分直接作为该数据的存储或对此部分构造线性（一次）的哈希函数得到映射地址：例如下面是某车间42名职工的身高数据，单位是毫米，以此为关键字怎样对应存储地址呢？1597,1784,1762,1640,1$14,1794,1746,1667,1831,1609,1747,1628,1772,16631735,1679,1573.1742,1820,1791,1704,1675.1754,1785.1864,1671,1748,17441849,1670,1738,1490,Ifi60,1759.1883,1739,1787,1636,1'T82,1688,1833,1810分析上面的数据，千位显然都是重复的，百位重复机会也太多，而十位和个位同时重复难得出现，就以关键字的最低两位作为地址即得到可行的哈希函数：h(xxmod100线性地址法要求数据分布整齐、紧凑，而数字分析法则要求事先知道所有数据的关键字，这两个方法对数据的要求偏高，下面将介绍适用性更广的几个方法。" ID="13">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="3.平方取中法所谓平方取中就是把数据关键宇先进行平方运算，然后从平方结果中取出若干位作为地址。对于数据聚集紧密的情况，这样构造哈希函数有利于让存储地址在地址空间中分散一些，这对“同义词”的处理会带来便利（这里所说的同义词是指经过哈希函数的映射能得到相同地" ID="14">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="址的数据）。" ID="15">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="4.除留余数法设数据空间从。到m-i有m个地址.所谓除留余数法就是用关键字的整数部分除以m,用除得的余数作为地址.这样做可以把原本分布过于分散的数据聚拢到地址空间来。由于哈希映射的地址空间往往是连续的，如果数据在此空间内的存储过于分散，必然造成存储空间的浪费，因此在哈希函数的构造过程中，有时需要这种“聚拢”的效果。例如车间某小组6名工人的年龄分别为" ID="16">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="473358243542" ID="17">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="地址空间从0到7共8个地址。则哈希P数可以用" ID="18">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="h(xxmod8在此函数映射下，上面6个关键字分别对应地址如下：" ID="19">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="47、T33-158224，035-342-2这里出现了同义词58和42，即出现了地址冲突，这当然会影响哈希查找和存储，此问题将在本节的后面部分解决。" ID="20">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="3.折.法当关键字的位数远多于m时，可适当选择k值，把关键字按k位一段地分为若干段（最后一段的位数允许少于k），用这些段之和去掉进位后的k位作为地址，这就是折且法的哈希映射。例如用学生期中、期末考试总分（每个总分都是三位数）连接而成的六位关键字有563486;431418等共‘80个，所给地址空间m=100，可取k二2使用折叠法；563486-7fi431418-X75可以看出，折叠法也起到“聚拢”的作用，在关键字取值范围很大及关键字位数很多时，这种“收缩”地址的方法可帮助我们完成从较大的数据范围向较小的地址空间的映射." ID="21">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000084" TITLE="三、  处理地址冲突的常用方法" TYPE="Chapter">
        <fptr LogicalPageNum="84" PhysicalPageNum="84"/>
        <Paragraph CONTEXT="在实际间题中，数据的范围及其分布是多种多样的甚至是错综复杂的，因此，直接构造出由不同数据对应不同地址的哈希函数是困难的，更何况数据的关键字未必能保证互不相等，所以在使用哈希法处理数据的存储和查找时，必须处理好同义词的问题，即必须找到地址冲突时要采取的对策。需要指出，当地址冲突后，采用某种方法得到一个新的地址也仍然存在着冲突的可能.因此，解决地址冲突的各种方法都可能包含着一系列的步骤。" ID="1">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="1.开放定址法" ID="2">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="开放定址法总的思路是选择一个数列：" ID="3">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="a[11,a[21a[k]，一" ID="4">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="当第k次发现地址冲突时用(h(xa[kmodm的映射什算出第k十1个地址。在解决存储问颐时，当这个地址未存储数据时就以此为哈希地址.解决查找问题时，如果此地址数据的关键宇为所求则查找成功，此地址没有数据则查找失败，如果不是这两种情况则地址仍然冲突，把a[k］换成a[k+1〕再继续用开放定址法求下一项" ID="5">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="地址.公式中。[k〕序列有不同的选取方法：" ID="6">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）a［k］＝k。序列为：1,2,3,·一，此时称为线性探测再散列。" ID="7">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="1，一1,4，一4,9，一9,，此时称为二次探测再散列。" ID="8">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)伪随机数序列" ID="9">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="还可根据数据及地址空间的具体情况选择其它适用的a[k］序列。" ID="10">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="2.再哈希法所谓再哈希法就是构造一序列由数据x到地址空间的映射：hl(xh2(x)、，当哈希函数映射所得的地址h(x)发生冲突时就用hl(x）映射得地址，如果再冲突就用下一个函数" ID="11">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="h2(x）映射地址，直到成功或失败。" ID="12">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="3.链地址法把所有地址冲突的数据按关键字的升序连接成一条链也是有利于查找的，此时常用数组存储各个链的表头.这时的哈希函数值就是各个链的表头节点下标.采用这种方法对数据进行存储就是在相应的链表中插人，而进行哈希查找时分为两步：首先根据要查找的关键字x和唯一的哈希函数得到对应的表头地址h(x}，然后对此链顺序查找x，由于链是有序的，所有平均" ID="13">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="查找长度也得到了控制，还由于n个数据是分散在许多条链中。所有每条链的长度不会大，查找远优于顺序查找。" ID="14">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="4.建立滋出表上面的第Z类和第2类方法实质上增加了许多辅助的函数解决地址冲突，而第3类则仅使用唯一的哈希函数映射出地址，简化了地址映射方面的问题，只使用唯一的哈希函数能否有另外的方法解决地址冲突呢？答案是肯定的。当发生地址冲突时可以专门建立一块存储空间" ID="15">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="（称为溢出表），无论是存储还是查找时，只要地址冲突就到滋出表中去顺序查找。虽然顺序查找会增加总的查找次数，但在冲突不多的情况下，滋出表也不会大，所以对查找速度的影响也不会大。" ID="16">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000085" TITLE="四、  哈希查找算法的评价" TYPE="Chapter">
        <fptr LogicalPageNum="85" PhysicalPageNum="85"/>
        <Paragraph CONTEXT="从理论上说，最理想的哈希函数是不重不漏的，不重是指任何两项数据都不对应相同的地址，而不漏则是指地址空间的任何一个地址都有数据对应（即数据量n等于地址空间的规模m)，不重就使得存储和查找都只通过哈希函数算一遴地址就一步到位地解决了问助。而不漏则使地址空间充分被利用，有利于节省存储空间。但是这样的要求除了线性地址法以外抓难于做到，即使是用线性地址法，当数据的关键宇相同时也无法避免地址冲突." ID="1">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="当地址冲突不可避免时，一方面我们希望减少地址的重复率以简化查找，节省则间.另一方面我们又希望提高存储空间的利用率以节省空r.我们用n/rn作为衡量地址空间占满程度" ID="2">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="tJ='fr储空问，但往往给减少地址冲突增大难度，为了解决地址冲突，往往增加了查找的" ID="3">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="时间，是用“时间换空间”还是用“空间换时间”，在构造哈希函数时要根据时间和空间的分配原" ID="4">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="本章前面介绍的几种查找方法主要是依靠对存储结构中的数据进行比较来完成的，第一节的顺序查找比较的是与待查数据是否相等，而第二节和第四节除了要比较与待查数据是否相等，在不相等时还要区别是“大于”还是“小于”的关系，以决定接下去的查找方向。第三节包含着上述两种比较过程。由于都需要多次的比较，所以不同程度地影响了查找效率。本节要讨论的哈希查找算法用另外一种思路，力求通过数据的关键字与其存储地址的对应关系直截了当地由待查数据找到该数据的存储位置从而完成查找操作。下面分别就哈希杳找的有关概念" ID="1">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
      <Paragraph CONTEXT="常用的哈希函数构造方法、解决地址冲突的常用手段等问题分别加以介绍。" ID="2">
        <fptr EndPN="00000082" StartPN="00000082"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000085" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="85" PhysicalPageNum="85"/>
      <Paragraph CONTEXT="2.编一个分段查找的算法，对索引表采用折半查找.对分段数据仍然采用顺序查找。" ID="1">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="3.写出在71,42,73,24,I5,36,87,98,69,3a这1o个数中查找sa的过程，直到查找失败。" ID="2">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="4.下面12个汉字的编码分别是：计as算ab机ac编ba码66索be引ca结cb构cc三a叉b树c建立这些编码的索引三叉树." ID="3">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="5.对排序二叉树编一个统计查找次数的算法.函数的返回值是查找x成功或失败的次数（提示：编写递归函数）。" ID="4">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="6.dos文件的扩展名最多可包含3个字符，如果只考虑包含英文字母的扩展名，地址空间为。到19999，请解答下列问题：" ID="5">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)建立一个从只包含字符的扩展名到地址空间的哈希映射." ID="6">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）此映射有没有地址冲突？" ID="7">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）计算出装填因子。" ID="8">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="如今人类已经开始进入信息时代，成指数增长的信息给人类带来了巨大的好处，但是如何在信息的海洋中尽快地查找到自己关心和需要的信息呢？这成为利用和处理信息的一个重要环节。本章所研究的就是在各种存储结构中查询信息的有关问题，我们将针对不同的数据存储结构讨论不同的查找算法，特别是对于线性结构这种最常见的结构要多讨论几种算法。" ID="1">
      <fptr EndPN="00000076" StartPN="00000076"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000087" TITLE="第七章  排序" TYPE="Chapter">
    <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
      <div ORDERLABEL="00000087" TITLE="第一节  排序的有关概念和术语" TYPE="Chapter">
      <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
      <Paragraph CONTEXT="排序又叫作分类（sorting)，排序是把一批数据按其关健字的先后顺序排列的过程.例如象加高考的每名考生的数据可以是一个记录，其中可包.含姓名、性别，考号、各科成绩及总分瞥数据域，在存取时可能需要根据其总分进行从高到低的排列，这就是一个排序过程.排序关铆字是总分。按关键字从低到高的排序称为升序排序，反之.按关键字从高到低的排序则称为阵序排序。上面的例子是降序排序.排序的含义虽不难理解.但由于排序的算法种类繁多、丰富多采，为了区别和评价各个算法方方面面的优劣，人们从不同的倒面提出了评价标准。除了对于一般算法都有的正确性、结构化和易读性等标准外，主要还关心运行算法所占用的时间资源和内存资源.影响运行时间的主要因素是计算复杂性，而计算复杂性又取决于排序过程中比较的沙敬动的次数。这里移动次数主要是指将一个变量的数据赋值给另一个变童。在许多排序算" ID="1">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
      <Paragraph CONTEXT="和移动的次数。次移动完成的。对于移动次数更细致的划分是最少移动次数、最多移动次图7.1银转斌值数和平均移动次数，前两项分别表示在排序过程中移动次数可能到达的$Picture[00000087\00000087_new\0019.jpg]Picture$下限或上限，平均移动次数是前两者的平均值。比较次数也可以细分为最少、最多和平均甘协次数三项指标。显然，比较次数和移动次数越少计算复杂性就越低，就越有利于提高速度和节省时间。排序需要使用的存储空间也是评价排序算法的重要指标，内存无疑是计算机的重要资源，少占内存的算法可以对更多的数据排序，在一些多任务的系统中。少用内存就有可能避免使用或减少使用虚拟内存。从而大大提高速度.内存占用量一般是一个与排序数据tn有关的函数。由于被排序的数据本身就占用了n个该类J的变量，所以n是最小的占用量。由于n个存放数据的变量和n个存放指针的变量所占的存储空间可能差异很大，所以需要细分时也可以分别估计数据空间和指针空间的大小。排序过程中与n的大小无关、为数不多的简单变t一般是不去计较的。上面介绍的这两个重要因素间有一种奇妙的关系.在一个算法中减少内存占用量常常引起比较次数或者移动次数的增加，反之，要减少比较次数或者交换次数又往往要增加若干的存储量，因此。人们寻求既省时间又省空间的的排序方法就变得更具有挑战性和实用性。评价排序特点的还有稳定性这个指标.一种排序方法如果对于关键字相同的数据可以保证排序后不改变原来的先后顺序（原来在前面的排序后还在前面）就称其为稳定的排序方法，否则就是不稳定的。如不特别说明，本章中的排序算法都以降序为默认的排列顺序。在降序排列的a数组中，尸二口irg，盆-r：一l.厂石1,3/l/h:lrfk.金云:r去n田7岁r:i:ur门.尹尹r:r,r石分r:.厂门当1＜j时必然有a［1］）成j」这个结论，为反序，特别当1＋1＝j时这对反序又称为相邻反序.从某种意义上说，排序的过程就是消灭反序的过程.用数学中的反证法不难证明：有反序必然有相邻反序，也就是说，消灭了相邻反序就不会有反序了，当然这就排好序了。某些排序算法正是从这点出发完成整个排序过程的。这一章的排序与上一章的查找有着相辅相成的关系，查找是许多排序算法中必不可少的步骤。有的算法要顺序查找反序，有的要查找相邻反序，还有的要查找插人位置，甚至在这些查找中涉及到了多种查找方法，例如顺序查找、折半查找、二叉树查找等。反过来说，排好序的数据才更有利于查找，例如折半查找就要求在连续存储的有序线性表中进行，二叉树查找又要求在排序二叉树上进行（这个树可以看作是排好序的数据结构）。这都体现了二者互相促进、互为基础甚至是相互依存的关系。排序技术不仅有广泛的实际应用价值，它还是程序设计基础训练的好素材.我们可以从中体验如何建立数学模型，如何确立数据结构；如何顺畅地描述所选择的算法；还可以学习算法的评价及若干编程技巧.排序的算法和存储结构涉及面很广，有递归算法，也有非递归算法，有线性结构，也有非线性结构，就是在线性结构中也是既有顺序存储的类型又有链式存储的类" ID="2">
        <fptr EndPN="00000088" StartPN="00000087"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000088" TITLE="第二节  选择排序" TYPE="Chapter">
      <fptr LogicalPageNum="88" PhysicalPageNum="88"/>
      <Paragraph CONTEXT="选择排序的过程是这样的，最初将所有n个数据作为“待选择序列”，同时建立起一个空的“选择结果序列”，第1轮在待选序列中选出一个关键字最大的数据.将它追加到结果序列中（在尾部插入）.并将它从待选序列中用除。再进行第2轮选择，从待选序列的n-1个数据中找到最大关键字的数据（在n个数据中这是第2大的），再追加到结果序列中并从待选序列中将其侧除，··一，直到第n-1轮在2个数据的待选序列中选出最大的，然后追加并删除，剩余的1项数据直接追加到结果序列中排序就完成了。这时结果序列有n个按关键字从大到小排列的数据，而待选择序列却己经是空的了。上面所说的两个序列当然可以用两个线性表，但考虑到两个线性表中的有效数据元素的个数总和总是n，如果使用顺序存储的一维数组，那么两个序列完全可以共用一个长度为n的数组，例如在数组的前一部分存结果序列，后一部分存待选序列，两个序列中间有个动态的分界线.可用一个指针（变量）来表示，这个指针的变化正反映了两个序列之间此消彼长的关系‘" ID="1">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="例7.1直接交换数据的选择排序。" ID="2">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="proccdureselect（n，a）；f对n个数据的a效组进行选择排序｝" ID="3">
        <fptr EndPN="00000088" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="吨in比gint：”a［1〕，a吕］：＝a［j〕；a〔j］：二tend外层的i循环每取一个i值就是一轮选择，第i轮选择中j还要取遍i后面的每个下标依次查找与第i个关键字的反序。一旦找到某个a[j］与a[i]构成反序就把它们交换，交换后就消除了这个反序，也可以说是让a[门又保持住了待选序列中最大的地位，这样边查边交换进行完一轮，a仁i]中一定保留了待选序列中的最大值.随着循环变量i自动增值，既完成了向结果序列的追加，也完成了从待选序列中的删除，i取得了新值就意味着将开始新一轮的选择.以n=8为例，用这个算法对5.2,7,4,1,3,8,6这些数据排序的第1轮过程如表7.i所不.$Picture[00000089\00000089_new\0008.jpg]Picture$这里带有圆圈的是a[i]，而带下划线的是a，每次比较就是在这两个变量间进行的，如果是反序还要交换二者的位置。为节省篇幅此处仅给出第I轮的过程，当1变成2时，第1轮的选择已经结束，最大数8进人a[11中，这便是结果序列中追加的第1个数据，而i变成2表明从下标2往后都是待选序列，也表示此轮要将a[21到a[8」中的最大值换入aC21中。请你按上面第1轮的格式写出第2轮选择的过程。上面这个算法的描述的确很简短，但计算复杂性却不低。第1轮比较n-1次，第2轮比较n-2次，…，最后一轮比较1次，不难计算出总的比较次数是n(n-12,n的最高指数是2，我" ID="4">
        <fptr EndPN="00000089" StartPN="00000088"/>
      </Paragraph>
      <Paragraph CONTEXT="们称其计算量为U(n2)级别。移动次数最少是0（每次比较都不交换〕，最多是3n(n-12，平" ID="5">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="均移动次数3n(n-14，也是O(n2）级的。能不能把移动次数降低呢？" ID="6">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="例，.2降低移动次数的选择排序." ID="7">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="procedureselect(n.e):{对n个数据的数组。进行选择排序}" ID="8">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="9">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="ifa[ma[j]thenmj｛哪个值比a[m〕还大就让它的下1变f1当m}" ID="10">
        <fptr EndPN="00000089" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="ta[i]ia[i]：一。[ms[m]：一：{在结束第i轮前将最大数a[m〕换人。}end｛结束第i轮选择}end书这个算法的比较次数与前一个算法是一样的，但移动次数却降低到3n以下。这是因为前当前找到的最大值与a[i］交换，而是暂时记住当前最大值的下标，直到一轮选择比较完，最大值下标确定无疑时，才把这个认准了的最大值a[rn」与a[i]交换，省略了许多可能没有必要的移动，所以将移动次数降为n的级别。下面的表7.2给出用此算法对上面那8个数排序的过程。这里每行的i值都对应的是该轮比较未开始时的情况，带有圆圈的数据是结果序列，没有圆圈的则是待选序列。在一轮当中（即1循环执行过程中）所有数据都不会发生变化，但在每轮$Picture[00000090\00000090_new\0007.jpg]Picture$的比较过程中m和J是在变化的，请你把i等于i时每个j对应的m值一一列举出来。对于在数据元素无序的待选序列中p找与a[i]的反序，最可行的也就是顺序查找了，由上一章的学习我们知道，查找过程的比较次数是很难降低了。而降低移动次数还可以采用另外一种思路，考虑到待选序列和结果序列是两个线性表，而算法中对这两个表分别要进行插人和删除的操作.前面学习过的链这种线性结构中进行这两个操作都是很容易的，因此可以把链作为选择排序的存储结构。例7.3要使用链式存储结构首先定义链中节点的数据类型：type" ID="11">
        <fptr EndPN="00000090" StartPN="00000089"/>
      </Paragraph>
      <Paragraph CONTEXT="idil+" ID="12">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="jl=record" ID="13">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="data;byte;" ID="14">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="next;jd" ID="15">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="end;既然是使用动态链式存储结构，所以把待选序列和结果序列分别存成两个链表也不会浪费更多的存储空间，所以下面的过程是一个不断在待选链表中选择和姗除同时不断在结果链丰由泊俪的名d.扭procedureselect{vnrh)‘对h为链头指针的链进行选择排序｝beginnew(pp'.nexth;hp;｛在待选链头前擂A一个虚（无数据）的链头节点｝new(ab：二A｛建立a为链头的结果链，开始仅一个l节点b,b也是此链尾指针）repeat｛开始选择过程｝ph;qp&quot;.nextl{p在前q在后沿着链查找最大数据｝" ID="16">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="rnh;nm&quot;.next;{n准备记最大关娜字的节点.rn是n的上一个节点（指向n" ID="17">
        <fptr EndPN="00000090" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="whileqnildabegin《如果4的数据比n的数据大就要记录4和P:" ID="18">
        <fptr EndPN="00000091" StartPN="00000090"/>
      </Paragraph>
      <Paragraph CONTEXT="mp;n：二q{m换成p.n换成q}" ID="19">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="end;" ID="20">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="pq‘qq’.next`P和q着链再走一个节点下" ID="21">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="end;《一轮选择结束下b'.next：二n;S结果链的尾指针指向本轮选择的最大数据节点｝bn;｛尾指针6指向新的结果链尾｝m&quot;.next：二n'.next{在待选链中侧除最大数据的节点n}untilh'.next=nil;（直到待选链头的！节点后面没有节点（链空）就结束选择》dispose(h);｛释放待选链的虚链头节点｝ha'.next;｛把返回参数的链指针指向结果链的实际链头｝dispose(s)《释放结果链临时使用的虚链头节点｝end;算法中使用的两个链都使用了链头的虚节点，虚节点是为查找方便和追加方便而临时占用的，如果在待选链中没有这个虚节点，那么最大数据的节点是否出现在链头就要分开处理，如果结果链没有这个虚节点，那么追加的节点也要区别处理，所以暂时借用虚节点可以简化算法的描述。虚节点中无有效数据，排序结束后把虚节点释放掉就可以了.这个算法的比较次数与上面两个算法相同，由于利用了链表中删除和擂人简单的特点，它的移动次数仅为n的级别。比第一个算法的移动量大大减少。本节的算法所占用的存储空间都不大，仅占用n个数据单元.除第一个算法不具有稳定性" ID="22">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000091" TITLE="第三节  堆排序" TYPE="Chapter">
      <fptr LogicalPageNum="91" PhysicalPageNum="91"/>
      <Paragraph CONTEXT="定排得满这一层。树中的父节点和子节点的相互关系非常简单，不必使用多重链表结构.设i&lt;n且2i＜二n,yPfa[2i〕就是图7.2堆阵示例点，反之，如果idiv2＞0rJa[idiv2〕就是a[i]的父节点.需要指出，并不是任何排成上面形式的一维数组都是堆.必须满足任何父节点不大于子节点的条件才是堆.结合着上一节的选择排序算法可以看出，得到一个堆就意味着完成了一轮选择，得到的最小值就是aC11，那么怎样得到一个堆呢？按从上到下，每层内从左到右，依次用每个子节点与$Picture[00000091\00000091_new\0014.jpg]Picture$其父节点比较，以查找反序，一旦发现反序就交换父、子节点的值，接着仍以原子节点（现已上升一层）为子节点与其父节点比较·，直到与父节点不是反序再回到第一次文换前的位置，换下一个子节点继续查找反序。" ID="1">
        <fptr EndPN="00000091" StartPN="00000091"/>
      </Paragraph>
      <Paragraph CONTEXT="轮正在比较的子节点。$Picture[00000092\00000092_new\0002.jpg]Picture$$Picture[00000092\00000092_new\0003.jpg]Picture$$Picture[00000092\00000092_new\0004.jpg]Picture$$Picture[00000092\00000092_new\0005.jpg]Picture$$Picture[00000092\00000092_new\0006.jpg]Picture$$Picture[00000092\00000092_new\0007.jpg]Picture$$Picture[00000092\00000092_new\0008.jpg]Picture$$Picture[00000092\00000092_new\0009.jpg]Picture$$Picture[00000092\00000092_new\0010.jpg]Picture$$Picture[00000092\00000092_new\0011.jpg]Picture$$Picture[00000092\00000092_new\0012.jpg]Picture$$Picture[00000092\00000092_new\0013.jpg]Picture$图7.3中只有最后一个三角阵列才符合堆的定义，其余的三角阵列都体现了某一数据元素的比较或交换过程，其中有的不用交换，有的交换一次就行了，而有的则需连续交换，最后得到的就是一个堆。得到这个堆就完成了第一轮的选择，那么删除掉最小元素a[1］后怎样建立下一个堆从而得到下一轮的选择结果呢？将a[1］后面的a[21…a[n]搬移到aClIa-17,再重复上面的初始建堆过程是可以得到下一个堆的，但这并不是最好的办法.随着堆中被选出的元素一个个被删除，堆的规模会越来越小，可以使用一个尾指针来记录当前堆尾位置。每次需要删除选出的a「i]时就把它与堆尾元素交换，然后将尾指针前移就行了，这样做能够完成姗除，但留下来的就不一定是堆了，但在此基础上调整出一个新堆并不是难事.以刚换到aC月的原堆尾元素为比较对象，用它与其两个子节点中数据较小的一个比较，如果是反序就交换两个变量的值，换到新位置的比较对象继续与数据较小的子节点比较，直到不反序或没有子节点就得到了新的堆。这个过程显然比初始建堆过程要简单得多，可以大大降低计算复杂性。下面仍以图7.3中的8个数为例，给出第1次交换a[11和堆尾后的调整过程（如图7.45fi7S①①①图7.4第1次调堆按这个调堆过程进行下去，堆尾将不断前移.堆将越来越小，同时堆后面排好序的数据自$Picture[00000093\00000093_new\0018.jpg]Picture$$Picture[00000093\00000093_new\0019.jpg]Picture$然是越来越多，直到全部排好序.特别值得注意的是，选择过程每轮选的都是最小的，而最后得到的排序数据却是降序的，因为每次所选的最小数据又被换到了堆尾.例，.4堆排序算法。procedurestack(n,a)，{对。个元素的a数组进行堆排序｝" ID="2">
        <fptr EndPN="00000093" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="3">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="fori2tondo｛依次用每个子节点向上层比较.初始建堆过程开始}悦才nji.记住要比较的子节点的下标｝" ID="4">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="mjdiv2。3m为其父节点下标}" ID="5">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="while(a[ma[jand{m&gt;0)do｛当父节点存在且与子节点是反序时执行｝begin" ID="6">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="t：=a[m]ya[m]：二a［j］；。口］：＝t。｛交换父子节点1jmom：二trunc(m2)（子节点位置上升一层｝end{结束找到反序的处理｝ends{结束初始建堆过程}fori：二ndownto2do开始调堆过程.i是尾指针从n变到21begint==aC1J;aCtJaGaCiJ：二t,｛先交换堆尾和已选出的aC11}" ID="7">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="m1,{以1为最初的父节点下标｝" ID="8">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="while2，m&lt;ido{当m的子节点没超出堆尾时重复执行下面过程｝" ID="9">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="beginis‘二2«mi{先让i记a[m」左子节点下标｝" ID="10">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="end{m的子节点未出堆的处理结束）end｛结束调堆过程}end;这个算法的调堆过程中最值得关注的是m和J两个变量，l要指向数据较小的子节点.但首先不妨让它指向左子节点，只有当右子节点没出堆而且其值比左子节点更小的情况下才将它改指向右子节点，这里面还有一层意思，就是当右子节点不在堆内（超出堆尾）时，左子节点就是最小节点.a[m〕就是原来堆尾的元家，它先被换到了a[11，后来又不断地与数据较小的子节点比较或交换，当不需要再交换时令m=i，目的是为了结束与子节点的比较，因为m取i值就惫味着a[m〕已经出堆，那么它的子节点当然就更不在堆中了.为了估算计算复杂性，我们先来看n个数据的堆分为几层，由于每层的数据个数都是上一层数据个数的2倍，所以层数应该是EogZn+1，那么a[1］下面的层数当然不超过2为底n的对数log,n。初始建堆过程时，每个数据向上比较的次数不会超过login，那么n-1个数据初始建堆的总比较次数一定小于nlogZn，而移动次数当然也就小于此数的3倍。调堆的过程中，先要比较出数据较小的子节点，再用父节点与这个数据较小的子节点比较，所以a[m〕每下降1层要比较2次，由于把每个a[11下调时都不超过logZn层，所以总的比较次数不超过2nlog2n，移动次数同初始建堆.综上所述，此算法的比较次数和移动次数之和不超过nlogEn的某一个确定的倍数，我们说此算法的计算复杂性是nlogxn级的.它远比O(nP)此算法计算复杂性低，所占用的存储空间也是很少的，因为除了待排序数据所占用的n个单元外没有用到其它的辅助存储空间。但由于使用了堆头、堆尾的大范围交换，所以破坏了稳定性。" ID="11">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000094" TITLE="第四节  起泡排序" TYPE="Chapter">
      <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
      <Paragraph CONTEXT="回顾上一节的初始建堆过程，较小的数据不断上升，就好像水中的气泡一样。而调堆的过程中先把堆尾较大的数据换到堆顶a[11，再把它下调到应放的位置，就好像石头在水中向下沉去。这启发我们把一个线性表的一端当做水底而把另一端想象成水面，不断把较小的数据移向一端或把较大的数据移向另一端，最终就可以得到排好序的线性表。这就是“起抱”排序的由来。具体实施的步孰是这样的.每轮从a[1］到a[n-11查找哪个a[i〕比a[i+1〕小，如果找到" ID="1">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="了这样的相邻反序就交换这两个变量（这就好比一个气泡向上升了一步），一轮完成并不能说" ID="2">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="排序已经完成，一轮轮地比较下去，直到某轮没有发现反序，所有的相邻反序就消灭完了。利" ID="3">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="4">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="抢详歌｛一轮接一轮地查找并处理相邻反序）" ID="5">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="m：二。。{m为是否在一轮中发现反序的标志，先令m二U表示2有发现相邻反序t" ID="6">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="foriton-1do｛每轮让,从1变到n-1，在整个线性表中查找相邻反序｝endi{结束反序处理t" ID="7">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="unfitrn=0｛直到本轮未发现过反序就结束查找争end;仍以x,2,7,4,1,3,8,6这8个数为例，表7.3是利用此算法进行第1轮查找和处理的过程，其中带圆圈的数为a[i]，将对它与其右边一个数比较。n个数具有n-1对相邻关系。在最理想的情况下，所有数据没有反序，比一轮就可以了，$Picture[00000095\00000095_new\0015.jpg]Picture$即这个算法最少比较次数是n-I，而在最不理想的情况下，所有的相邻关系都是反序，需要比较n轮，即最多比较次数是n{n-Z)，这个算法的平均比较次数不能简单地求最多和最少比较次数的平均值。n个数据的任何一个固定的排列用此算法排序都对应着一个固定的总比较次数，把n个数据的所有排列所对应的总比较次数求和再除以排列的种数就能求得这个平均比较次数，不难验证，对于n＞3的情况，平均比较次数都大于n2f2，是O(n=）级的。交换次数最少是0，最多是3n(n-12，平均3n(n-14，也是O(n2）级的。观察上面具体数据的第1轮起泡过程不难发现，第1轮比较结束时，最小的数就像一个气泡胃出水面一样已经被放到了a仁n〕当中，从另一个角度看这也是完成了选择排序中的一轮选" ID="8">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="择，那么在除掉a[n〕的部分再进行一轮选择（起泡）必定能将n个数中第2小的数换人。[n-" ID="9">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="j〕，这样分析，等待比较相邻反序的数据就一轮比一轮少，甚至反序存在标志也可以不必处理和判断了，下面就是据此写的算法：例7，‘不带反序标志的起泡排序。" ID="10">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="0刁二～ro、.!v+。木7!b!K8crJlErAlaa琳r*ae,i1ax;" ID="11">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="foxi：二1tondo（开始进行n-1轮相邻关系的比较，" ID="12">
        <fptr EndPN="00000095" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="ends这个算法第i轮比较次数n-1，第2轮比较次数n-2,，总共比较次数是一个确定值n(n-12.交换次数与例7.5是一样的。对比这两个算法的差异，它们的比较次数明显不同，对于反序不多，只有少盆数据偏离了应有的位里的序列来说，例7.5的算法比较次数可以很小，这一特点是任何一个其它排序算法所不及的.但当反序很多时，按例7.5的处理过程，比较次数又是非常多的，在这种情况下它又不及大多数的其它排序算法.而例7.6的比较次数是恒定的，反序少时它不如例7.5，但反序多时它又强于例7.5。能否有一个算法对任何的排序数列的比较次数总不超过两个算法中较少的比较次数呢？这当然不难，只需在例7.5中的until前面插人nn-1即可。下一步要设计一个起泡排序的过程，它的比较次数不仅要保证对任何数据排序的比较次数都不超过例7.5和例7.6，而且还要尽可能地比它们少.要想让此过程对反序少的情况能减少比较次数，作为标志的变量是有必要的，如果我们让这个变盆不仅记录是否有反序，还记住上一轮发现的最后一个反序的位置，对下一轮的比较是很有益的，就以这个位置当下一轮比较的循环终值是一种更优的考虑。如果有相邻反序，那么它出现的位置至少比上一轮靠前1个位置，所以起泡循环终值的递减速度不会低于例7.6，在许多情况下它的递减速度还不只是每轮匆心，J寺云华刀七仪.翻甘习口苗日们余菌住书峡，分二卜＿亩6，越冬1当.从务功月后坦匕田，妇山」匕J盆了户男卜节胃期鉴劝1哈r扛至，翻】月书鑫井减1志变量记录上轮最后的反序位里是一种比较巧妙的思路，我们可以通过检查循环变量在循环" ID="13">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="结束后的取值与标志变t闻的关系，来判断此轮是否发现了相邻的反序从而决定排序是否可" ID="14">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="以结束。" ID="15">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="例，.起泡排序的改进算法.proceduregp(n,a（对n个数据的数组a进行起泡排序｝begin" ID="16">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="mn;{m记录上一轮最后一个相邻反序的位t，先设它为n}t：＝a［1〕.a［1〕一魏[i+11ra[i+1〕一t｛交换｝m:-i（记录相邻反序中较小的下比｝end{结束相邻反序的处理｝until(m＞i)or(m=1)｛宜到本抢投找到反序或没有可比的相邻元索}end;要检验m的值在本轮中是否发生过变化，最容易想到的就是再用一个变量记录m在上轮的值，循环结束后把m与原来记录的值比较一下就行了.而这里给出的算法却利用了循环变量i来体现循环前m的信息，因为在循环进行过程中改变m的值已经不会影响循环的终值了。由于i只变化到m-1，所以一旦m被改变过就会变小，当然也就不会大于i了。另一方面，$Picture[00000097\00000097_new\0001.jpg]Picture$每轮比较次数不断递减，而且可能比每次减1的递减速度还要快，这使得比较次数比前两种起泡法都少。上面这8个数只比了13次，而用例5的算法要比21次，用例6要比28次.三种方法的移动次数都较多。起泡排序占用的存储空间只是n个数据的存储最而无藉占用其它的辅助空间，所以是一种很节省空间的排序方法。起泡排序都是沿着一端向另一端依次推进的，所以都可以保证排序的稳定性。" ID="17">
        <fptr EndPN="00000097" StartPN="00000096"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000097" TITLE="第五节  插入排序的一般方法" TYPE="Chapter">
      <fptr LogicalPageNum="97" PhysicalPageNum="97"/>
      <Paragraph CONTEXT="插人排序的完整过程是由一轮轮的插人构成的.每轮插人都是先用待插人数据在一个原已有序的表中查找插人位置（在此位置插入后，表仍保持有序），然后再将此数据擂人到找到的位置，这样作无疑得到多了一个数据的有序表.耐人寻味的是我们的目的就是要排序，可又要先得到原来就有序的表，那么第1个有序的表从何而来呢？明确地说，a[11就是一个有序的表，因为此表中只包含一个元家，所以没任何反序.我们先把：〔幻向表中插入，再把：[3〕向表中插入，…，直到把a[n］也插入到表中，这个表就已经是排序结果了。表7.5中仍然以5,2,7,4,1,3,8,6'aS8个数为例给出插人排序的一般过程，其中带圈圈的数代表待播人的数，它左边的部分就是有序表。" ID="1">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="·84这里只是粗略地按每轮一行给出了简单过程，每行中的带圈数据都是即将要向左边的有序列插人的数据，而它右边是无序的、等待一个个被插向左边的数据.随着插人过程一轮轮地进行，这个带圈的位里逐步右移，有序的部分越来越长，无序的部分越来越短，直至整个要排序的序列都变成有序的就排好了序。至于每轮具体是怎样查找到插人位置的，又怎样实施插人的，这正是各种风格各异的插人排序过程要探素和尝试的。本节和下面两节我们将着重围绕这两方面寻求尽可能满意的算法。" ID="2">
        <fptr EndPN="00000098" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="例7.8直接交换的插人法排序." ID="3">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="procedurepc(n,a｛对n个数据的数组e进行抽人法排序｝" ID="4">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="5">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="fori;=2tondo｛让被擂人的元素从a[2］变到a[n" ID="6">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="begin｛开始查找和交换过程｝" ID="7">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="i：二i-1《被插元素位里的记录变t向前跟一步｝" ID="8">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="end｛查找和擂人结束｝end（循环结束｝end;这个算法中似乎投有看到哪个指令表示插入操作，实际上插人体现在若干次交换中，什么时侯不需要再文换了就是插人到了相应的位置，也可以说此算法是边查找插人位里边把应排在待插元素后面的元素向后搬移（交换），由于是在一个有序表中从小到大查找，一旦发现不小于待插元素的数据就没有必要再向前查找和交换了，此时待插元素刚好处在它应播人的位置，此轮插人结束.从这个算法边查找相邻反序边交换的形式来看似乎很像上一节的起泡排序，只不过起泡的比较范围是越来越小的，而这个算法的比较范围却是越来越大的。事实上，二者的差别远不只于此，起泡排序中对查找范围的数据没有任何要求，而插人法却要求查找范围有序，正是由于这个区别，起泡排序的比较必须在整个查找范围内彻底进行，而此插人法的查找在找不到反序时就可以结束了，这显然更合理、更有利于降低计算复杂性。这个插人排序的比较次数最少是n-1，最多不过n(n-12，平均约nz/4，移动次数是相图中在各次移动线上标明的号码是该操作的顺序号。此顺序绝不是任意的，但也不是唯一的，例如将所有移动反向同时将操作顺序彻底反序排列也是可以的.例，.，利用循环交换方式的插人法排序。procedurepc(n,a｛对。个数据的数组。进行擂人排序｝begin" ID="9">
        <fptr EndPN="00000099" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="fori,-2tondoh待擂元t从a[2〕到a[n" ID="10">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="begin（循环进行各轮的查找和擂人｝" ID="11">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="j1;＜用i查找描人位t，i先从1查起逐步增大｝" ID="12">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="whilea[i]Ca[j]dojj-1;当。Cif小于a[j〕时就把j所指位t后移｝" ID="13">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="t一：[i]《找到擂人位tj后准备擂人，先把a[i]移人tyform：二idowntoj+ldoa[m二a[m-11;《成片向后徽移有序列中j后的元索）：0〕：＝州将原来的。0〕擂人到第j个位tf" ID="14">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="end｛结束对a[i]的查找和插人｝" ID="15">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="end;这个算法层次分明，wtite循环及前一行is°1的指令是查找部分，下面涉及t的两个指令及中间的for循环是擂人部分，可以明显看出擂人部分体现的就是图7.5的过程。它的移动次数明显可以降低，而关键宇的比较次数并没有降低，但仔细观察插人位里查找的过程可以发现整个查找过程的总比较次数缩减了一半。对比例7.8的查找过程的查找顺序和比较条件，例而是从a［1］开始向后查找，也正是由于这一改变，在查找的比较条件中就可以大胆地去掉了判断j是否超出比较范围的条件而不至于导致死循环，因为j是趋向1变化的，即使1前面的所有j都满足、仁1］＜alj〕”的条件，当j＝1时此条件也必定被破坏了，a〔门成为查找范围的天然界限，起了一个“监视哨”的作用。原来在查找时每比一次关键字也要判断一次是否超出有序表的范围，从这个意义上说，监视哨的使用减少了一半的比较次数，减少的虽不是关键宇的比较次数，但毕竟是排序的比较次数，因此也能提高算法的运行效率。按下标从小到大的顺序查找插入位置的作法很自然地引人了监视哨，但又破坏了例7。8的稳定性，其实反过来查找也可以使用监视哨，而且为了简化过程的表述，查找的循环和成片握移的循环写在一起。就是下面的样子.Procedurepe（n，a）；《对n个元众的数组a进行擂人排序｝映廖。" ID="16">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="。［0」：＝255，｛以a为监视喃，以1字节数据的排序为例不会超过255》" ID="17">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="fori：二Zton面行从2到n变化，将第1个元索擂人到有序表中｝映gin｛开始对：［i〕进行查找和插人｝" ID="18">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="j：＝1；《查找位t从1-1开始｝悦gina［j］：＝a口一1］1《aD-1］后移1位》" ID="19">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="j：，j-1不查找位t前移｝" ID="20">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="end;这个算法的监视哨是在下标较小的一端加人的，因为查找是从下标较大的一端开始的，但这里并不是借用a[i」自身哲时作为监视哨，而设立了一个“专职”监视哨在a[a]中，这个a[o当然不是原来要排序的数据，不可混为一谈.付出一个变量的代价减少了多次比较，这当然是值得的。此算法突出的特点是边查找擂人位置边移动有序表中的元素，相当于是把原来整休进行的成片雄移拆开进行了，当查挽的循环结束时，最后移出元素的位置就是已经空出的插人位置，直接插入即可。例7.9的这两个算法比较关键字的次数最少是n-1，最多n(n-12，平均比较次数大约为n4，是0(nz）级的，但它不藉要判断查找范围，比例7.8的查找过程减少了多次判断。移动次数比例7.8减少大约2/3.后一个算法是稳定的。三个算法占用的存储空间都是n,例7.9比例7.8的比较次数和移动次数都明显减少，还能不能进一步减少这两种次数呢？如果我们能把n个数据的序列分为m个较大的和m个较小的（m=n/2)，即使还用例7.9的算法分别对两个部分排序再合成一整个有序列，总的比较和移动次数也将明显减少，因为m个数据的比较次数不大于m(m-12，那么总的比较次数上限是：2m(m-12=m(m-i）二（n/2n/2-Zn{n-24&lt;n(n-12=c(n)这里。（的代表对n个数用此算法完成排序的比较次数上限。从理论上说，把整个序列平分成两个长度减半的序列排序，总比较次数的上限也减少了一半，用同样的办法可以得到平均总比较次数也将降低一半.同样的计算还可以证明平均移动次数和最高移动次数也将降低到一半。下面我们将利用这个思路根据例fi.9的后一个算法编写这种“两路排序”的算法.具体实施时，先尽可能地找一个排序数据的分界数，再建立与排序数据空间等长的结果空间，烦序检查每一个待排序的数据，如果小于分界数就在结果空间的后半段进行从尾端开始的查找和插人，否则" ID="21">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="用此数据在结果空间的前半段进行从头开始的查找和插人，最后一个数据擂人结果空间时，结" ID="22">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="果空间刚好被擂满，因而得到n个数据的完整排序序列。" ID="23">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="例，.10两路插入法排序。procedureins2(n,a（对n个数据的数组a进行二路擂人排序｝lx8mm(mex十min}div2i（把m作为分界值，max和min分别代表数据的上限和下限｝" ID="24">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="b[o]：二maxi{在结果空间b数组的前面设，监视哨｝" ID="25">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="b[n十1〕：＝min，丈在结果空间b数组后面设f视峭》" ID="26">
        <fptr EndPN="00000100" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="ifa[i]＞mthenfe=1{如果效拓大于分界数描人前半段，否川插向后半段｝z[f]：二：[f」十f｛插人位里指针相应移动｝" ID="27">
        <fptr EndPN="00000101" StartPN="00000100"/>
      </Paragraph>
      <Paragraph CONTEXT="ends｛查找和擂人结束）foriltondoa[i]：二b[i]‘将结果空间依次移人原数据空间｝end;算法中f和：tf〕的使用使得在前半段插人的程序段与在后半段插人的程序段合成了一段，该段反映的正是例7.9的后一个算法的查找策略，即边查边移。算法中分界数的确定是假设数据按均匀分布，所以由数据最大值max和最小值min的平均值来求得.一般情况下，这个值很难精确求得，精确计算它的算法并不简单，常根据数据的分布或已知的其它数据特性来估算这个分界值，稍有些误差也不至于完全抵消二路插人的优越性。此算法的计算复杂性前面巳经分析过，比前三个算法明显降低.但它不具有稳定性，使用的空间也是很多的，达到2n，虽然排序完成后可以返还给系统，但同一时刻所占用过的空间曾达到2n," ID="28">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000101" TITLE="第六节  移动最少和比较最少的插入排序" TYPE="Chapter">
      <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
        <div ORDERLABEL="00000101" TITLE="一、  链表插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
        <Paragraph CONTEXT="减少比较次数和移动次数是优化排序、提高效率的主要方向.具休到擂人排序法就是要寻求尽可能快捷的查找和尽可能简单的擂人方法。先考虑擂人环节的简化，在上一节的所有擂人算法中，移动次数都很多，都是O(n'）级的，而这所有的移动都是为了空出一个擂人位t给待擂数据元素。为了一个数据元素的移动而牵动许多数据都要移动大大增加了擂人移动次数。如果使用链表这种线性结构来存储待排序数据，插人的操作一定会简单得多，只需要在待播序列中姗除当前的待插节点而把它插人到有序列中就行了." ID="1">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="例7.11利用链表进行插人排序的算法." ID="2">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="procedureinsert(varh}｛对h为链头的链表进行擂人排序｝" ID="3">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="悦9认" ID="4">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="ifhnilthen{断链是否空｝" ID="5">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="begin｛如果链非空就进行排序｝" ID="6">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="new{anew(b)s（产生有序子链的链头和链尾｝" ID="7">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="b-data：二min门在链尾设Z视哨｝a&quot;.next：=bs｛链中只有一个链头J节点a。它指向链尾b}repeat{开始重发进行查找和插人牛n：二卜。｛把链头第一个节点作为侍擂人的节点n}Ps=as{P应指向抽人位t的上一节点，先指向有序链的链头｝q：二e&quot;.next;{g应指向擂人位t的下一节点.先指向P的下一节点）" ID="8">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="whifen-data&lt;q-datado《如果没查翔擂人位里就继续往下查｝beginp：二q;q：Tq&quot;hn&quot;.next;（将待播人的节点n从待擂数据链的桩头翻除｝A-next：二qsP-next，二n（将n在P后q前插人到有序链中｝untilh二nifs｛直到待擂人数据的链空才停止查找和插人的过程｝" ID="9">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="h,（妇f将原来待排序数据链的链头指针指向最后排好序的链头｝mh；（准备沿着有序链从头去找尾｝whilem&quot;.next6dom：二m&quot;.next;{n没到链尾监视哨就继续向后移｝m`.next：二nil（在链尾把监视哨前一节点指向空.作为新链尾）" ID="10">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="dispose(s);dispose(b)《释放借用的宜链头和监视峭｝" ID="11">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="end结束非空链的排序》" ID="12">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="end;算法中借用一个虚链头a是为了让查找和插入过程的叙述统一和简化，否则查找和插人的两段都要分处理链头和非链头两种情况。临时使用的监视哨b仍然是为了查找时省略链尾判断.这两个临时借用的节点最后当然要释放。算法中出现的min代表数据的下限。" ID="13">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000102" TITLE="二、  折半插入" TYPE="Chapter">
        <fptr LogicalPageNum="102" PhysicalPageNum="102"/>
        <Paragraph CONTEXT="显然每个数据的插人只是靠移动两个指针来完成的.可以认为是两次移动.n个数据也只是2n次移动，只是n的级别。就插人而言已经是最简化的方法了。但比较次数仍然是O(nz）级的。这个算法和上一节的所有算法为什么都是O(nz）级的呢？原因在于这些算法在查找时使用的都是顺序查找，为了减少比较次数就必须改进查找的方法，回顾上一章对线性表的查找方法中还有折半查找和分段查找，其中当然是折半查找效率更高.当然它对查找范围的要求也更高，要求查找范围有序，而这个要求在插人法排序中恰恰是能够满足的，下面我们就利用折半查找的方法代替顺序查拢的方法来查找插人位置，进而实现插入排序.例，.12折半插人排序。procedureinse(n,a｛对n个数据的数组。进行析半查找的擂人排序｝" ID="1">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="beginfari：二2tondo（让i从2到n}" ID="2">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="begin｛描人第i个元家到，ElIe[i-I]的有序列中｝" ID="3">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="te[i]｛把待擂元素先取人t中｝" ID="4">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="m(1十r)div2;｛求出左右边界下标的平均值m（折半）｝" ID="5">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="iftCs[m]then｛用待擂致据与范围中点元t比较｝" ID="6">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="l：二rn十1（如果小于中间位笼的元素就以中间位f的下标加1作为查找范围左边界｝" ID="7">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="elser：二m《否则以中间位t的下标作为右边界下标}" ID="8">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="untilr二l;（直到左右边界下标重合就可以结束查找｝" ID="9">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="for1idownto1+1do（让j从i到1丰1变化｝a[j]：二，G-1J《把：G-1J移到。G］当中｝aCl]：二t{将待擂的元;擂人到查到的位t上）end{结束播人aG」的过程｝end;算法中的1最终是要指明擂人位置的。为查找到一个插人位置.repeat循环要重复的次数是2为底i的对数lOgzi，因此n-Z个元素的总比较次数一定小于nlogzn，这是所有排序算法中比较次数上限最小的.但是这个算法在播人时又采用了“成片搬”的方法以空出擂人位！，虽然是使用循环交换，但移动次数仍然是O(nz）级的.能不能像起泡排序时那样把两个算法的就是说直接把折半查找和指针播人结合在一起是办不到的。" ID="10">
          <fptr EndPN="00000103" StartPN="00000102"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000103" TITLE="三、  希尔分类" TYPE="Chapter">
        <fptr LogicalPageNum="103" PhysicalPageNum="103"/>
        <Paragraph CONTEXT="我们力求找一种查找和插人次数都很少的插人法，希尔分类就是这样一种计算复杂性很低的插人算法。它是多次利用例7.8算法逐步合并若干有序的部分序列来完成。回顾例8的算法.当反序比较少的时侯比较次数接近n，怎样得到反序比较少的待排序数据呢？怎样有效降低比较和移动的次数呢？下面我们就从两个方面来加以分析。设下面两个序列已经是有序列：" ID="1">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="a[ls[21,a［二］b[11,b[21,b[m]aClb[xa[zb[z,a仁mb[m]分析这个合并完的序列，虽然还不是完全有序的，但可得知反序已经受到限制和削减。首先，如果一个元素（例如b[k]）如果在这轮排序（合并）中如果没有向前交换，那么其后面的一个元素（b[k]）在插人时最多向前交换一次，其次，如果某一元素（例如a[k]）在插人时向前交换了位置，那么它的下一元素（{b[k]）在播人时肯定不会交换，还有，即使序列中的第m个元素在擂入时需要交换，其次数也不会超过m的一半，这三点都说明此序列的反序已受到限制和削减，不断合并下去，反序将越来越少。也就是说用例7.8处理时比较次数将趋于n而不是nZ另一方面，刚开始对多个序列分别排序时虽然离消灭反序的目标还很远.但由于分的序列比较多，所以对每个序列来说n都很小，又由于nz减小的速度比n的减小速度快得多，即使按nZ的级别来估什比较次数也不会多.从上述两方面的分析可以了解到，希尔分类利用例7.8对多个子序列不断进行插人排序（即合并）的总次数也是很低的。为了程序描述方便，我们不用多个数组表示多个序列。为了让每次排好序的子序列自然处" ID="2">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="在交错排列的位置上而不再需要额外的移动，各子序列中数据的下标是以一定的步长间隔排列的，例如a数组中如果包含4个子序列时，那么它们分别是：aClaL5J,a[91，二。，a〔4k＋1］.…这时的步长间隔恰好是4，与序列的个数一样多。把步长减半变成2，就把4个序列合并成两个序列：$Picture[00000103\00000103_new\0028.jpg]Picture$a[11,a[31,a[51,a[2k+11.a[21,a[41,a[61a[2k" ID="3">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="合井有序子列的过程正是通过步长减半之后再用例7.8处理来实现的。当步长从2m减" ID="4">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="……,16,8.4,2,1的规律缩减，那么这个步长的初值定为2m,(m=login)，每轮让步长减半，也可以将步长的初值定为n/2，每轮缩减为原步长的0.618.当间隔步长不是严格按每轮减半的规律变化时，插人与合并的过程复杂一些，由于此问题已超出本教材要求，就不再详细讨论了。例，.13希尔分类算法。" ID="5">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="procedureina(n,s《对n个数据的数组。进行希尔分类｝" ID="6">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="beginm：二n;{m是各轮中序列间隔的步长制，由于它每次减半，所以先设为n}repeat｛开始一轮轮的排序合并｝" ID="7">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="m：二mdiv2｛步长减半｝" ID="8">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="forim1tondo｛让i从所有序列中第1个待插元索变到最后1个待擂元t的下标｝" ID="9">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="a[j]：二t{在查找到的擂人位zaG〕插入侍插人元素tl" ID="10">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="end{结束一轮擂人）until。二i｛直到间隔步长是i的擂人合并完成才结束整个分类）end;算法中t的引人是把原算法中直接文换改成了循环交换，这样做可以减少移动次数。由于开始排序时子序列比较多，所以此处没有加人监视哨。算法中各序列内部的下标间隔从n/2开始，每轮减半，按这样的规律变化，下标m变吨少轮就可以结束了.而每轮比较和移动的次数越来越接近n，平均总移动次数和比较次数都比O(nz级要小得多，这在线性表的插人排序算法中无疑是很优秀的.可以看出，最后一轮的播人就是完整地执行了一次例$的过程，也就是说在执行例7.8之前又添加了许多操作，这会不会增加例7.8直接排序的计算复杂性呢？由于增加的这些操作都是在较远的距离上消灭反序，比起泡法的近距离消灭反序就更直截了当（这也是希尔分类比起泡排序平均效率高得多的重要原因），随着比较元素在数组中距离的不断缩小，最后一步未" ID="11">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Picture URL="00000105\00000105_new\0001.jpg">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Picture>
        <Paragraph CONTEXT="本节的三个算法所占用的存储空间都只是n，很节省内存.前两个算法都是稳定的算法，但此处没有给出稳定性的描述形式，而希尔分类不具有稳定性." ID="12">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000105" TITLE="第七节  利用二叉树进行插入排序" TYPE="Chapter">
      <fptr LogicalPageNum="105" PhysicalPageNum="105"/>
      <Paragraph CONTEXT="寻求查找最简单并且擂人也最简单的排序算法是一个十分诱人的目标，但在线性表的结构框架内是难以实现的.在非线性结构中的二又树上插入叶子节点是很容易的，如果是平衡二叉树，那么擂人的比较次数大约是login，这两个特点正是我们在擂人排序中所追求的。我们可以利用待排序的数据建立二叉排序树，当然，这个建树的过程就是在一个有序结构上进行查找和插人的过程，当一个二叉排序树完全建好的时侯就已经有了排序结构，因为对树中的任惫两个节点，无舫知道其数据，只通过两个节点的位里关系就可以知道它们的大小关系。如果要转" ID="1">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="化为人们最熟悉的线性表形式的排序结果.只需要对树进行中序谊历就行了。礴要强调下面两点，一是为与本章的降序排序一致，我们定义的二叉排序树与上一章的顺序刚好相反，即对任意节点，如果存在非空左子树，那么左子树的每个节点数据都大于该节点数据，如果存在非空右子树，那么上面的每个节点数据都不大于该节点数据.二是由于对二叉排序树进行平衡处理的算法超出本教材范围，所以此处建立二叉排序树的过程将省略平衡算" ID="2">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="法的处理。建立排序二叉树的过程是这样的，从这个树的根节点（刚开始此节点为空）开始，用待插节点和树上的一些节点依次比较，以查找到其在树上的擂人位置.我们称正在与待插节点比较的节点为当前节点.如果待插节点的数据大于当前节点的数据就用当前节点的左子节点代替当前节点进行下一次比较，否则用其右子节点代替当前节点进行下一次从比较，每比一次，当前节点就会走到下面一层，直到某次当前节点为空时，就把待插节点插入到当前空节点的位置上，即让原指向当前空节点的指针指向待插节点.这次插人就完成了.由此可见.这里的插人操作只需要改一次指针，比在链上插入还容易。例，.14建立n个待排序数据的二叉排序树的算法。由于要用到树形结构，所以应该定义如下类型的节点：type" ID="3">
        <fptr EndPN="00000106" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="沁＝一lx;" ID="4">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="lx=record" ID="5">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="data:byte:" ID="6">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="l,r=jd" ID="7">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="end;建树算法中还包含了插人一个节点的子过程ins，整个建树过程如下：proceduresettree(k):{建立k个数据的二叉徘序树》procedurein(d;vart｛将节点d擂人到以t为很的树上｝比9加《开始擂人一个节点d}" ID="8">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="ift=nilthen{断当前节点t是否为空｝td（如果当前节点空就在当前节点的位里擂人｝elseifd&quot;.data＞t&quot;.datathen{如果当前节点非空就比较待抽节点和当前节点数据｝" ID="9">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="in：（d，t‘.1）（如果当前节点小就向其左子树插人｝" ID="10">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="elseins(d,t&quot;.r)《如果当前节点不小就向其右子树播人｝end;{结束抽人节点d的过程}begin《产生k个节点并一一擂人的过程开始李rniii（以r为二又排序树的根节点，开始没有任何致据，定为空}fori：二ltokdo｛循环k次、" ID="11">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="begin｛产生并且擂人一个节点全" ID="12">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="new(p（先产生一个新节点｝" ID="13">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="read(p&quot;.data)〔抽人此节点中的待擂人数据；" ID="14">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="P-1：二nit;p&quot;.rs=nil门此节点没有左右子节点，清空两个指针｝" ID="15">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="汤抓p,z)f将断节点擂人到二叉排序树中卜.d‘结束k次的循环）" ID="16">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="e刀d,{结束整个建立树的过程}这个算法的关健在It]B过程中，这是一个递归过程，它的功能是在t为根的树中擂人d.但当t非空时，还要根据比较结果用t的左或右子节点代替t再次调用这个过程本身，实质上就是在一个更小的树上继续查找，由上一章的学习我们已经知道，这样做平均会使查找范围缩小一半，因此大约查找{og,a次就能查到。平均比较次数是很低的.过程中t空的处理也很巧妙，不论t代表的是左还是右子节点的指针或是根指针.只要将t指向d就完成了插人.因为t是个变参，对它的操作就是对其代表的指针的操作.利用上面的算法对5,24,2,38,6这8个数建树过程见图7.6,仍然是对这8个树建二叉排序数.只是将数据顺序变为4,6,5,2,8,1,7,3，所建的树却变" ID="17">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
      <Paragraph CONTEXT="57P" ID="18">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="‘／5$Picture[00000107\00000107_new\0010.jpg]Picture$／＼，2／＼$Picture[00000107\00000107_new\0014.jpg]Picture$415／＼7t" ID="19">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="／＼41＼，＿／、＿了、～一77.一72" ID="20">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="图76建材过程" ID="21">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="虽然树的形状不同，但是所对应的有序数列都是同一个，要想把这个有" ID="22">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="／＼" ID="23">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="62" ID="24">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="八八日531＼7序结构中的顺序转变为线性结构愉出，只需要对这个树进行中序遥历。因为要将任何一个节点装人线性结构（或将它抽出）前，都要把大于它的所有左子树节点访问一遍，接着访问完它本身之后再访问右子树，这种按“左子树一根节点一右子树”顺序访间二叉树的方法正是中序遇历。例，.15中序遍历，输出二叉排序树的数据，即物出建二叉排序树的排数据顺序序结果." ID="25">
        <fptr EndPN="00000107" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="图7.7i0；{i是处理左子树或根节点或右子树的标志f：：二1；{：是记录根节点的栈指针｝" ID="26">
        <fptr EndPN="00000108" StartPN="00000107"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat（开始重复访间各个树和子树｝iilt（在左子树、根节点.右子树中处理完一个后处理下一个｝caseiof｛对上述三种悄况分别处理｝l:ift&quot;.1nilthen｛第1种情况处理左子树，先荆断有没有左子树｝" ID="27">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="k。蔽.J翔1』且创旨白份卫吐生精曰七了姗、" ID="28">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="，［；］：二t;｛在栈中记录根节点、zz+1:{栈指针上移一位｝t：二t-1（当前节点变为左子节点｝i0（指示器清。，准备在访间一个新树（左子树）时从第1步开始｝" ID="29">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="end;｛第1种情况处理完｝" ID="30">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="2:begin{第2种情况处理根节点｝" ID="31">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="write(t-data:4｛此处仅以打印代表一般的处理｝" ID="32">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="ift'.rnilthen｛判断此节点有没有右子树｝" ID="33">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="i4｛准备访间新树（右子树）时从第1步开始进行｝" ID="34">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="end（右子树非空处理结束｝ends《很节点处理结束｝3：旋苗n（第三种情况是左子树迫历完，即将访间上一层根节点｝SL-Ii（以t为根的子树访间完，准备从栈中找出它的根节点｝ti=a［Z｛从找琪取出上一层根节点｝Z：二1要处理根节点将从访问树的第2步进行｝" ID="35">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="end｛第3种情况处理结束｝end（分情况处理结束｝untilz=0｛直到.后一个根节点处理完才结束追历）end书用i指示应该做何处理，i的控制就成为整个过程的关键，三种情况都要设置i以指明i值以控制过程的走向，但是所设的i值都比要去方向的i值少1，因为每次处理时都首先将i增加" ID="36">
        <fptr EndPN="00000108" StartPN="00000108"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000108" TITLE="第八节  快速分类" TYPE="Chapter">
      <fptr LogicalPageNum="108" PhysicalPageNum="108"/>
      <Paragraph CONTEXT="在本章第五节的原理分析中我们已经知道，如果能将n个数据排序的问题分解为两个子序列的排序问题对降低计算复杂性是很有好处的，两个序列的数据量越接近就越有利于比较次数和移动次数的降低。快速分类正是基于这个特点.它第一步的目标是得到一个序列和，其中包含这样一个元素aCy]，对于任何j&lt;y肯定都有。Ci：仁y]，而对于任何k&gt;y都有a[Y]ya[k](1CyCn)，有了这样一个中间结果，第二步就可以分别对y两边的序列排序，排序的策在一个序列中查找a[y〕的方法并不千篇一律，这里我们着重介绍一种比较区域缩进法，操作过程是这样的：先选定序列中的一个元素（例如第一次就选a[工孙作为这一次分割的“比较对象”，序列中其它元素作为.比较区域”，每次都用比较对象与比较区域最远端的元素比较，如果是反序就交换两个元素的位置，交换后的比较对象处在一个新的位置，此时比较区域“远端”的含义和交换前恰好左右相反.无论被比较的远端元素是否与比较对象交换了位置，比较后它就从比较范围内被侧除，即每比一次都会使比较区域缩小，这样一次次比下去比较区域总会缩小到没有元素，此时比较对象就处在我们要找的叮y」当中（即完成了一轮分割）。表7.7仍以5,2,7,4,1,3,8,6为例，给出第一轮分割的比较过程，在整个这轮比较过程中都是以原来的a[1」二5作为比较对象的，用圆圈标出，另一个用画圈标出的就是比较区域的远端元索。它$Picture[00000109\00000109_new\0010.jpg]Picture$外面就不是比较区域了.接下来就可以分别对“6,8,7&quot;和“1,3,4,2&quot;再分别使用上面的处理过程继续分割，直分到" ID="1">
        <fptr EndPN="00000109" StartPN="00000108"/>
      </Paragraph>
      <Paragraph CONTEXT="小区域不必再分已经有序时便排好序了。由于对分割所得的区域进行的还是原来形式的" ID="2">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="每个小区域不必再分已经有序时便排好序了" ID="3">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="分割过程.所以排序过程是递归进行的，为了突出每段程序的功能，下面用几个过程来描述这" ID="4">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="一算法." ID="5">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="例T.17快速分类算法.procedurejh(vara.b)（交换a.b两个变量）begiata;abib：二t{借中闻盆t交换a和b中的值｝" ID="6">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="end;（结束交换过程}" ID="7">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="begin$Picture[00000109\00000109_new\0025.jpg]Picture$f：一li{开始时比较对象在左（最左边一个元素列" ID="8">
        <fptr EndPN="00000109" StartPN="00000109"/>
      </Paragraph>
      <Paragraph CONTEXT="ends《分创过程结束｝procedurepx(l.r)i《对下标从1到r的一段数组元素排序｝悦颐nifL&lt;rthen{9j断此段区城中元家是否多于1个｝begin｛如票多于1个元素就还需要排序｝" ID="9">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="c：二ry（先传递此段最大下标r在c中）" ID="10">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="fd(l,c)y｛对整个要排序的区城实施分i，分点下标通过。传回｝" ID="11">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="px,。一1)《递归调用过程本身对左边序列排序｝" ID="12">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="px(c十l.r)《调用自身对右边分出的序列排序｝end｛元索多于1个的处理结束s" ID="13">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="ends最后这个过程中的c是局部变量，用它代替r去作最大下标是因为它不仅担负着向分割过程传递参数的任务.而且担负着返回分点下标的任务，如不引用。而直接用r作为参数将破坏整个排序区域的最大下标数据，此数据在递归时还要用到。如果此算法各次返回的分点都比较接近原区域的中间位置，此算法的比较次数和移动次数就都是nlog2n的级别，最坏的情况是对整个反序排列的数据使用此算法，此时的比较次数和移动次数就都是0(n'）级的了。为减少这种极端的情况对计算复杂性的影响，分例的策略可以稍做改变，例如使用两个固定扫描方向的变量i和1，都以中间某个元素为比较对象.若同时与比较对象是反序则交换a[i]和aCi]，下面就是体现这种方法的过程：例7.1$快速分类算法二。" ID="14">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="proceduresort(l,r《对下标从1到r的一段排序｝" ID="15">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="16">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="i1a{i是从左向右变的下标指针｝" ID="17">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="j：二Yy{j是从右向左变的下标指针｝x口1＋r）山vZx是原中间位t上变f的值｝代peat（开始重复进行一轮比较和交换｝whilea[ixdoi：二i+l；{从左往右查找与x的反序｝whilex&gt;s[j]doj：二j-la（从右向左查找与x的反序）ifijthen{判断i和J两个指针的左右位t是否已经交情｝" ID="18">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="begin《如果没有交错就交换两个元紊位盆｝" ID="19">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="Y：二。［1〕；e［1〕：二a口］，aD〕：＝y；｛交换。[i〕和aD" ID="20">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="i：二i+lyis=i-1{i和J各移i位1" ID="21">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
      <Paragraph CONTEXT="end{没有交错的处理完毕｝untili&gt;jy{直到i和j左右错位才结束查找与交换｝if1Cjthensart(l,j)y{如果j不是此排序段最小下标就对小于1的一段再排序｝i!iCrthenwrt(i,r){如果i不是此排序段最大下标就对大于i的一段再排序｝end;由于查找过程不是按同一方向进行，快速分类不具有排序稳定性.表面上看，似乎没有引人新的辅助存储空间，但递归调用时的最小和最大下标在系统堆栈存储区中都是要保存的，而递归调用的最多层数平均是login.所以这份空间的消耗是要计算在内的." ID="22">
        <fptr EndPN="00000110" StartPN="00000110"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000111" TITLE="第九节  合并排序与外部排序" TYPE="Chapter">
      <fptr LogicalPageNum="111" PhysicalPageNum="111"/>
        <div ORDERLABEL="00000111" TITLE="一、  合并排序" TYPE="Chapter">
        <fptr LogicalPageNum="111" PhysicalPageNum="111"/>
        <Paragraph CONTEXT="上一节的快速分类是不断对待排序列进行一分为二的处理.直分到每个序列最多只有1个数据时就不需再排序了.反过来思考，我们也可以认为整个待排序列中的每个数据都是一个已经有序的序列（在插人排序时我们就曾经这样考虑过），我们要做的只是将这些已经有序的序列两两合并为若千个所含数据更多的有序列（这种思路我们在希尔分类中也是熟悉的），每轮合并将使有序列的个数大约减少一半，而每个有序列的数据个数大约增加一倍.直合并到只有一个有序列时排序自然就完成了。这就是合并排序的总体过程.将两个有序列合并起来的具体步骤与希尔分类的合并有所不同，希尔分类所采用的是例金念rIrdh州七‘A七fCriA75'I欠gII习导aB刁石.9.R17甘心侄J之卜生ts且赛日！ba侧旨.尧a.r一月卜才卜」上奎七上庄叹盆7sliXP14:不断比较两个等待合并队列的队头元素，哪个大就将它从所在队列中删除并擂人（追加）到结果队列的尾部，直到两个待合并队列中的一个已经被侧空就把另一个非空的待合并队列全部追加到结果队列的尾部，这次合并就完成了。而所谓“一轮”合并就是由若干次这样的合并组成。仍以5,2,7,4,1,3,8,6这8个数据为例，经过3轮合并就可以得到排序结果.见表8,具体每轮中每次的比较、剐除和插入的具体步骤就不详细给出了，只把最后由第2轮结果合并得到第3轮结果的过程表示在表7.9中。由8个数合并3轮可以想到n个数据合并的轮数不会超过logxn+1.由8个数据合并的比较次数不超过7也可以想象到一轮中合并每对有序列的比较和移动次数都不会超过被合并" ID="1">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="移动次数都限制在这个水平的排序是非常难得的。" ID="2">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="例，.1，合并排序算法.待合并的有序列占据了一份存储空间，合并结果还要占一份同样大小的存储空间，而且为了减少移动次数，不必把每轮合并结果的有序列回移到原待合并序列的空间中来，而是在下轮合并时把这轮作为合并结果的两个有序列当作代合井序列，而把新的合并结果存回上轮待合并有序列所占的空间中，因此至少需要使用2n的存储空间。为了表述方便和操作简便，可定义两份存储空间都是数组类型的指针。" ID="3">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="type" ID="4">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="az=array[byte]ofbyte;" ID="5">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="里昌二朋." ID="6">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="varg,b,cszz为简单起见，设被排序的数据及其下标都是一个字节的数据类型byte.每次合并专门用一个过程来表述，此过程的参数中应当说明由哪个数组合并到哪个数组，还要分别说明数组中等待合并的有序列的最小下标和最大下标.procedurejoin(cl.dl,c2,d2;varf,t:za《从f所指数组合并到t所指l9t组）旋才n{开始要将f中下标从cl到dl的一段与c2到d2的一段合并至t中cI到d2的一段｝zcl《定a为t中控翻追加的尾指针，先从cl的位t开始｝repeat{盆复进行一次次的比较和追加｝iff&quot;[cl1&gt;f一［Cc21then{1断序列1和序列2的队头元索肠个大｝" ID="7">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="begint&quot;faf‘仁clcl.二cl十Iend{序列1头元索大。月将它侧除井移至t尾｝elsebegint一〔习：产f‘［e2］心：二c2十1ends{序列i头元t不大，翔将序列2头元素姗除并移至t尾）" ID="8">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="z：二z+1｛结果队尾指针后移一位｝" ID="9">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="until{cl&gt;dl)or(c2&gt;d2)t{直到两个待合并有序列中的一个变为空）ifcl&gt;dlthen{4I断是否是队1空）begin（如果队1空就要将队2追加到t尾｝cl：二c2id1：二d2（把队1的头和尾指针分别指队2当前的头和尾｝ends£ori：二cltodldo｛用循环过程将f中cl到c2的一段报到t后面｝begin{撅移开始｝t一［二f&quot;[i]，z：二：fl{f一［i］在t尾进队，尾指针后移｝end{报移结束}end;上面的过程是具体实施两个有序列合并为一个有序列的步获。但它还孺要一个专门用来控制的过程，即每次调用它时指明合并哪个数组到哪个数组及具体的下标起点和下标终点：procedurectrl(n)，{对n个致据的数组进行合并排序）" ID="10">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="begin，：二1:{开始时合并只包含1个元素的有序列，由m指明｝new(c)i（产生除数据空间以外的另一个同样大小的效组及其指针日" ID="11">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="i：二1十1《待合并序列1的头指针i应比上一次合并时队列2尾指针l多1}" ID="12">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="k：二i+m;【队2头指针应比队1头指针多m}" ID="13">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="j:-k-1s｛队1尾指针应比队2头指针少1)" ID="14">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="1：二j+m;（队2尾指针应比队1尾指针多m}" ID="15">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="if1&gt;nthenI：二n;｛如果队2尾出界就调整尾指针为n}" ID="16">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="ifj&lt;nthenjoin(i,j,k,l,b,c)｛若队2非空就根据两队按4个指针从b合并到c}" ID="17">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="else{如果队2空则需要将队1直接迫加到结果队尾｝" ID="18">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="fork：二itondoc'[k]：二b一〔k]｛如果7是n就把队Z直接追加到结果队尾｝until1=ns（直到1二n就完成了一轮的合并｝a：二二bsb一。交换b和。所指数组，待合并数组与合并·果数组交换指针｝m：二m«2｛下一轮要合并的有序列中元素个数比这一轮多一倍｝" ID="19">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="unrifm&gt;～n（直到要合并序列元素达到或超过n就不必再合并下一轮了｝" ID="20">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="dispose(c)《释放排序的擂助空间（其中存着最后一轮待合并的数据）｝" ID="21">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="end;｛结束合并控制过程｝过程中开始设1二0是为了在一轮中第一次调用合并过程时得到队1头指针是1，计算4个指针使用的是周而复始的循环盈代，所有计算都是基于4个指针未超出n进行的，接着就是对指针的修正，其中包含了比较复杂的逻辑关系，1超n时l是否可能超n呢？不管7是否超n就直接把1修改为n是否稳妥？接下去的,断就把住了调用合并过程的关，调用只有在队2非空的情况下才会发生。没有调用合并过程就说明队2空，此时队1没有可合并的对象，只得直接搬进结果队尾.关于a,b,c三个指针也要说明如下，a是全程数组指针，它带来了要排序的数据，而b和。都是局部变量.因为只产生了一份辅助空间（由new(c)所产生的数组）.所以在排序后要释放c所指的辅助空间.虽然合井过程是把b当中的数据合并到。中，但释放时已经经过了一次指针b和c的交换，所以此时b指的才是最终排序的结果，由于交换时中间变里a指向的就是b，所以a带回的数组就是排序结果.此外，交换b和。只是交换了两个指针，移动量是极小的，这也" ID="22">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="正是使用数组类型指针的用心所在." ID="23">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000113" TITLE="二、  外部排序" TYPE="Chapter">
        <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <Paragraph CONTEXT="计算机的内存资源是宝贵而有限的.除了此处的讨论，本章中我们所讨论的排序方法都是在内存中进行的，即使你用最节省存储空间的排序方法，能在内存中排序的数据量也是有限的，如果需要排序的数据最超过这个限制，排序的过程就不能一次完成于内存中了，而需要使用借助外存的排序即外部排序.排序的步辣是先选择一个内部排序方法，根据内存所能容纳的数据t和此内部排序的空间占用情况估算出一次能在内存中排序的最大数据量.编写算法，打开待排序的数据支件（此文件的数据当然超过一次能排序的数据童），先按估算出的数据量读人第一批数据，用选择的内部排序法对此批数据排完序后写人排序中间结果的文件1，再从待排序的文件中读人下一批数据，排完序后写人中间结果文件2，一，直到待排序的数据文件中所有数据被分批处理完就得到了若干个有序的数据文件。此时关闭所有打开的文件。最后将这些各自有序的中间结果文件两两合并就能得到所有数据的排序文件。合并两个有序文件时，先打开两个待合并的文件和一个合并结果文件（此文件当然是新创建的），利用两不是写人结果队尾，而是追加到结果文件的尾部，其中一个文件读完最后一个数据时把另一个文件的刹余部分全部追加到结果文件的尾部就完成了此次合并。然后关闭两个被排序的文件。这样合并下去，有序的文件越来越长，直到所有中间结果的排序文件都被合并到一个文件中，整个外部排序就完成了." ID="1">
          <fptr EndPN="00000114" StartPN="00000113"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000114" TITLE="第十节  多关键字排序" TYPE="Chapter">
      <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <div ORDERLABEL="00000114" TITLE="一、  低关键字优先排序" TYPE="Chapter">
        <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <Paragraph CONTEXT="所谓低关键宇优先排序又叫作基数排序。它先按最低位的关键字（即排序关健字的最低位，例如对自然数而言是个位）分成若干个线性表，然后按从大到小的顺序将这些按最低关键字分类的线性表收集到一个统一的线性表中，虽然每个分类得到的表内并没有顺序，但收集这个表时也要依此表当时的排列次序进行。第二轮再按次低位的关键字的不同依数据在统一的线性表中的排列姗序把数据又分成若干类。每类还是一个线性表，仍然按上面的收集方法收集到统一的线性表中，…，直到按最高位的关键字也进行完了这样的分类和收集，所得到的线性表就是排序的结果。以102,21,201,111,12,210,202,120这8个数为例，下面各线性表的插人和侧除都是在大希人认称月araac,众上七卜右奋八自月门以＿口么肠曰习砂山石后担；入才书左七翻行＿玉毕石茄.、夕乌心‘节山玉帐d匕甘为由拍分摊，“七‘所以这种排序又被称为“捅排序”，装人的数据就好像是从“桶”底向上“堆”起来的。上述这八个数据未排序之前是：" ID="1">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="1022120111112210202120" ID="2">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="第1轮按个位分类：" ID="3">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="0:120210" ID="4">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="1:111241212,2021z1Oz第1次收集结果：" ID="5">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="1021220221201111214120" ID="6">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="第2轮按十位分类：" ID="7">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="0;201202102" ID="8">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="1:210111122:12021第2次收集结果：" ID="9">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="2I12012111210102202201" ID="10">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="第3次按百位：" ID="11">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="2:201202210" ID="12">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="第3次收集的结果：2102022011201111022112每次按某位关健字分到各个表中再收集回来的过程实际上就是按这个关键字对所有数据排序（只是对这一位关键宇排序）的过程，好在这样的排序是稳定的算法，所有前面对更低的关键字所进行排序的结果都会被保留下来。例如上面例子中对百位排序时，每个百位相同的表内部数据的十位和个位已经是有序的了，收集起来后整个数据的排列就是完全有序的了.这种算法排序并没有进行真正的比较，从这个惫义上说比较次数是最少的，它的计算复杂性主要与移动次数有关，而移动次数与数据的位数是成正比的，还与数据t眼分类数（几进制就要分成几类）之和成正比.例，.20基数排序算法.除数据自身要占用的数据空间（收集用的“大桶”）外，还要用到若干（例如十进制用10个）个“小捅”，在最特殊的情况下分类时会出现所有数据都进人某一“小桶”的情况，所以“小桶”可能并不小，如果为各个“桶”都预备固定的存储空间.此算法所占用的空间将是非常大的，我们应该采用链式存储结构灵活地组织各“桶”中的数据，这样就不必使用更多的存储空间，而只需为每个“桶”安排首尾指针就行了。把一个数据从“大捅”分人某个‘小桶”时，为了巷免判断，可采用数组来存储各“捅”的指针，把用来分类的当前位的值作为下标直接追加到此下标指针的链中就行了，不仅分配过程被简化了，而且收集过程也不用一项项地进行了，依次让各个“桶”的末尾数据指向前一个.桶”的头元素就可得到收集起来的数据链.先定义数据的指针类型：" ID="13">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="ty哪" ID="14">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="川二‘坛。" ID="15">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="坛二recard" ID="16">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="datarword" ID="17">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="a:array[1二51of0二9s" ID="18">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="next:jdend;下面的算法中以。到65535的两字节整数（word类型）为例，可看成5位关键字，为减少每次分配时一系列取数位的操作。在数据愉人时就将分离的各个数位分别存于记录的数组域中。proceduresort(vsrh)s｛对以h为链头的链表进行基数排序}begint［1＝h。化数组是各“捕”的“桶底”指针，b[l0〕作为“大福”的“极底，指针｝new(q)i｛产生节点4，准备在收集各关链宇类时当b[l0〕便用的盛节点｝fori：二Otogdonew（bD〕）；｛每个关链字的链头产生一个虎节点｝" ID="19">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="fori：二lto5do｛分5轮进行分配和收集（本例中以1至65535的整数为例）i" ID="20">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="forj：二。to9do｛每轮分配前要进行IO个指针的初始化｝" ID="21">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="begin《开始对第J个链的指针进行初始化｝whilet[101nilda｛只要公共链中还有数据就要向各分'中分配｝begin｛开始分配）" ID="22">
          <fptr EndPN="00000116" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="pt[101:｛将待分数据交由P指｝" ID="23">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="t[161t[101&quot;.next;{分配的数据从公共链中州除｝c：二p&quot;.a[i]i‘将此数据当前轮考虑的关键字（位〕送。》tC〕一next：二P;‘将P追加到c号链的·尾｝，几〕。＝nr且粗针翻放如【拓的枯民、end;（此数据分配完毕｝t［Io〕：＝q。。（先将收集数据用的公共链的尾指针指向此链仅存的盛节点）" ID="24">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="c10.{c指14是为了从.大关键字9的链开始收集｝" ID="25">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="ifb[j]&quot;.nextnilthen{1断第l条链是否空｝" ID="26">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="场抢肠《如果非空就要收集此链｝t[c〕一。nextb[j.next;{c：＝j｛上一次收集过的链换为j号链｝" ID="27">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="end，｛连接结束｝t［c〕‘.nex’t：＝nil；‘将最后收集过的。号链的最后一个元素且为链尾），rl八门‘＝。‘”.，f才守卜从业桩的胜车增向。氏而谊一木右扮肠握、.next《让公共链的链头指向q后面第一个有效数据）end，（分配和收集完毕）disp以蛇（q），｛释放借用的盛节点q｝forj：＝otolododi：卯犯（bD〕）；｛释放分配用到的盛链头｝h：＝tllo〕‘把结果桩的链头返回给原来的数据链头指针｝end‘作为分配目标的10个链都借用了链头的虚节点，这样做的目的是使分配的过程都可以用在链尾挂接的方式来表示.而所有数据共同链头所借用的虚节点q则可以使收集过程都可以表示为前链尾接后链首的操作.当然最后这些虚链的节点都要释放。收集数据并没有一项项地进行，只是通过分配所得的各条链依次首尾连接来完成." ID="28">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000116" TITLE="二、  高关键字优先排序" TYPE="Chapter">
        <fptr LogicalPageNum="116" PhysicalPageNum="116"/>
        <Paragraph CONTEXT="在桶排序的过程中，分类和收集是从低关键字即最低的位开始的.而这里我们要讨论的方法则是先从高关键字即数据的最高位开始考虑，先根据各数据的最高位或最高的几位分类，同时在各类中采用某种排序算法对其余的低关镇字进行排序，当所有数据都被分配到其高关键字的类中并排序后.再将各个高关键字类的排序结果按高关健字的顺序依次收集就得到了所有数据的排序结果.在每个高关键字类内部具体使用的排序算法可以灵活选择，但不论采用脚种算法对低关键字排序，都将比直接用此算法对所有数据进行排序的计算复杂性要低得多。因为前面我们曾例7.2I一根据高关键宇分成多个序列分别排序的算法.下面以。到255的数据类型（byte)为例，以数据的百位和十位合起来作高关健字分26个链分别排序，链头指针用数组a，类型定义为：type" ID="1">
          <fptr EndPN="00000117" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="jd二‘]xi" ID="2">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="lx二record" ID="3">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="data二byte" ID="4">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="next:jdi" ID="5">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="end;下面的过程在对高关键字（十位和百位）相同的数据排序时使用的是链表形式的插人排序，由于每条链使用了“监视哨，所以先定义它的值min;canstmin二Oaprocedureaart(varh｝对以h为链头的数据进行高关抽字优先的多链排序}决矛。" ID="6">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="forisz0to25dobegin{从0125为每个链的指针初始化1ne，（a［1］），new（p）。｛分别产生链头节点和链尾1视哨｝p&quot;.data:片min;p-next：二nil;‘监视峭的数据最小，尾指针指空；a[i〕一，xt=～p{链头先指向健尾监视峭｝end;｛初始化完毕｝whileheildo（只'待排序的数据链还有数据｝晚启玩｛将数据分配到它对应的镜中进行排序》q-h，（将待分配（抽人）的节点送q｝h;t&quot;.next;｛数据桂头指针后移，侧{已分配的节点｝:：一q-datadiv10;{将要分配的数据高关键字取到i中｝P：=BCi]，{P取得对应链的头（血）节点，准备在此链中插入｝whileq'.deta&lt;p&quot;.next&quot;.datado{q与P后的数据进行比较，查找描人位g}pp'.next;【如果q数据小就让P沿链后移一位}9-next：二P-nextip&quot;.next;=q《找到擂人位盆后就把9插在P后面｝ends｛结束分配和抽人｝newCh)s{产生收集所有数据的虎链头川q：＝h.甸用来记录收集数据的链当前的尾节点，开始应指虚链头争fori：=25dowato0do｛按从大到小的艘序连接（收集）每条排好序的铸}iegin（开始收集第i条链}P：二a[i.next{｛取出此链链头盛节点后的节点人Pyifp-nextnilthen{断此链是否空）" ID="7">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="决匆力者如果不空就要连接｝" ID="8">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="q&quot;.nextpi｛将此链第一个节点接在原链最后节点之后｝" ID="9">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="repeat{q沿着链后移，寻找新的链尾巴（不包括监视啃）｝" ID="10">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="untilp-next=nil｛直到P巳经是监视哨）" ID="11">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="闷。万性亩‘舀韭z§ac,卜翻、" ID="12">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="13">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="q-next：二nil;｛将最后排序结果链的尾节点的后继t空｝" ID="14">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="qh;hh-next;dispose(q)｛返回排序结果链头指针，释放崖链头}end;说明两点，在插人4时没有专门比较数据的低关键字而是直接比较了整个数据，只是为化查找过程的描述.另外在连接各个链时，不管链是否空，最后都要释放借用的节点，P和" ID="15">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="了简化查找过程的描述。9的控制必须照顾到这一点。本节两个算法的共同特点是把每个排序关健字都看作多个关键宇分别处理，还有它们都能大大降低计算复杂性，它们都具有稳定性（多链擂入存在具有稳定性的算法描述，例7.21未采用），附加的排序空间也只是少量的指针。但它们理论上不能对实数排序（因为实数没有确定的位数），它们排序的数据最好是比较整齐的，在多链插人的算法中还要适当控制链的数量，否" ID="16">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="我们所讨论的排序一般是根据数据的某一个关健字进行排序，在本章中使用指针类型的数据中都用data域，不用指针类型的算法中就直接对存有关键字的数组进行排序；这一节的算法中我们将排序关键字的各个数位分别看成关锌字，通过对这许多关键字的处理来完成排序工作。" ID="1">
        <fptr EndPN="00000114" StartPN="00000114"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000118" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="118" PhysicalPageNum="118"/>
      <Paragraph CONTEXT="1.根据下面各项要求分别写出873,210,fi09,9$7.47,707,7,214,490,412的排序过程." ID="1">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）进行9轮选择排序，写出每轮得到的数据排列（最后一排就是最终结果）." ID="2">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）进行起泡排序第1轮的比较和交换过程。" ID="3">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）用例7.8进行9轮插入时每轮所得到的数据排列." ID="4">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）折半插人最后一轮的比较过程." ID="5">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）希尔分类排这10个数据的全过程." ID="6">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(6）快速分类第1轮的比较和交换过程（利用例7.17)0" ID="7">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="c7）利用合并排序的全过程。" ID="8">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="cs)基数排序3轮分配和收集过程." ID="9">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="2。" ID="10">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）用上题10个数据构造堆." ID="11">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）对构造出的堆进行9次询整，得到最后的排序结果.C3）构堆的过程可以用监视哨吗？怎样做？" ID="12">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="3。" ID="13">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)利用第一题10个数据构造排序二叉树。" ID="14">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)对排序二叉树进行中序遥历." ID="15">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)构造排序二叉树的非递归算法。" ID="16">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
      <Paragraph CONTEXT="4.编一个选择排序的算法，其中每轮选择最大数采用锦标赛争冠军的办法，n个数两两比较，留下大的n/2个，继续两两比较得到n/4个较大的，…，直比到1个数就是所选出的最大" ID="17">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="00000119" TITLE="第八章  图" TYPE="Chapter">
    <fptr LogicalPageNum="119" PhysicalPageNum="119"/>
      <div ORDERLABEL="00000119" TITLE="第一节  图的概念及术语" TYPE="Chapter">
      <fptr LogicalPageNum="119" PhysicalPageNum="119"/>
      <Paragraph CONTEXT="图是一种数据结构，它的形式化定义是：" ID="1">
        <fptr EndPN="00000119" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="G=(V,R)这里G表示一个图，V是表示各个数据对象的顶点集合，R是V中若干顶点对的集合，若有某两顶点的点对属于R,9在图G中存在这两点间的直接通路.可见，图是由点的集合与点对的集合共同构成的。设x和Y都是V中的顶点，x和Y的点对属于R，如果这是个有序点对就表示为＜x,Y&gt;它所代表的是从x到Y的有方向的直接通路，x称为出点，Y称为人点。这种有方向的直接通路也称为弧.弧的集合又可表示为A，这种由顶点集合与弧的集合构成的图称为有向图.在图G二（V,A）中，如果对A中任意的＜x,Y＞都有＜y,x＞也属于A,则称G为无向图，此时有序点对＜x,y＞和＜y,x＞可用一个无序点对（{x,y）来表示，{x,y）称为边，z和Y都称为此边的端点。边的集合又可以用E来表示。本书中将顶点也简称为点.若＜x,y&gt;属于A,I称点x邻接点Y，点x在G中邻接的所有点的集合称为x的出邻域，邻接x的所有点的集合称为x点的人邻域,x的出邻城的点数称为x的出度，x的人邻域的点数称为x的人度.在无向图中，点的出邻城等于人邻域，称为邻域.点的出度等于人度，称为点的度。如果图G的每个点的度数都是k,则称G为k正则图。边（(x,Y)与x和Y的关系都叫作关联，所以某点的度又可理解为与它关联的边数。一个图中除了顶点表示数据对象外，弧或边也可以有自己的数据，这些数据叫作权，例如两点间的距离、从一点到邻接点的某项费用等都可以作为弧或边的权，这种弧或边带有数据的加权图称为网。设图G1V1,R1)，如果V1是V的子集，且R1是R的子集，则称图G1是GV,R)的子图.如果图G中的任意两点x,y，都存在一条直接或间接的通路p{x,y}，则称G为连通图。如果连通图中的任意两点x和Y之间都至少有k条互不相交的路径（除x和Y没有相同点的路径），这个图可称为k连通图.在连通图中有一类图，从上面随便一点出发，都可以走谊每个点而不重复，并且还能回到出发点，这类图称为H图（在某些书中又称为哈密尔顿图）。一个图即使不是连通图，也可能包含若干连通子图.如果图G中任意点都没有连接自己的边或弧，而且不存在通向同一点的两条弧或边，3iG称为简单图，否l是多重图。设图GV,E）是简单图，如果任意两点在图中都相邻，则称此图为完全图.在许多实际间翅中，可以利用图来建立数学棋型.下面是用图8.1来表示的5个飞机场的海拔高度和机场间飞行距离的例子。有些问题表面上着，似乎与图没有什么联系，但采用某种方法建立的数学模型也许就是一个图.例如在计算机中输人一个计算表达式.式中各类字符之间就应满足一定的逻辑关系。具.106体地说，哪类字符能做开头？哪类字符能做结尾？在左括号“（”、右括号与”、数字符和运算符中，哪类后面能接着哪类？这些关系$Picture[00000120\00000120_new\0003.jpg]Picture$是可以用图来表示的.例如" ID="2">
        <fptr EndPN="00000120" StartPN="00000119"/>
      </Paragraph>
      <Paragraph CONTEXT="31一（(283-65)&quot;2就是一个字符之间关系正确的表达式，而下面的表达式)3-2，/100一＠图8.1无fA]加权图示例$Picture[00000120\00000120_new\0015.jpg]Picture$图8.2有向图示例节点连接着自身。这个图又是个有向图，因为图所表示的因为各条弧表示的都是前后邻接关系，没有什么特别的“权”。" ID="3">
        <fptr EndPN="00000120" StartPN="00000120"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000120" TITLE="第二节  图的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="120" PhysicalPageNum="120"/>
        <div ORDERLABEL="00000120" TITLE="一、  多重表" TYPE="Chapter">
        <fptr LogicalPageNum="120" PhysicalPageNum="120"/>
        <Paragraph CONTEXT="这是一种简单而直接的表示方法.首先为每个顶点确定，一种数据类型：type" ID="1">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="id1za" ID="2">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="阮＝八改”川" ID="3">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="d:dara" ID="4">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="11.12id" ID="5">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="亡叼岁每个顶点都用包含多个指针的节点来表示，每个指针都可指向一个邻接点.而每个节点本身也是一个指针类型的记录，记录中祖类型的指针个数依图中点的最大度数而定。如果点的度数差异较大，那么度数较小的点必然有不少指针要空指，造成浪费.它比较适合于正则图、完全图等特殊类型的图的存储.建立一个完整的多重表还必须包括一个表头指针，它专门指向多重表的一个节点，通过它能进人这个图和访问这个图。还耍注意，在节点中不指向任何节点的措针必须指向空。" ID="6">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000120" TITLE="二、  邻接矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="120" PhysicalPageNum="120"/>
        <Paragraph CONTEXT="把图的n个点的数据用一维数组存储，而用另一个nXn的二维数组表示每一条弧或边。设二维数组是r，具体的方法是用r(i,j)=1表示一条从i到l存在一条弧，反之，如果这条弧不存在。则r(i）二4。若表示一个网，可适当改变这两个特征值的用法，如让对应邻接的数组元索等于该条弧或边上的权，而让对应不邻接的数组元素取某个不代表权数的特定值.这个二维由邻接矩阵的特点和无向图的特点可以看出：在无向图中，r(i,j）一定等于r(j,i所以这时的矩阵是关于主对角线（{r(i,i)卜二1,2，一，n}）对称的.以上一节5个机场的图为例，用邻接矩阵的方法可以这样表示；" ID="1">
          <fptr EndPN="00000121" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="cYpe" ID="2">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="user二array[1二51ofreal;" ID="3">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="east=array[1二5,1二51ofreal;" ID="4">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="const" ID="5">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="d:vast795.384.986.3fi4,800" ID="6">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="e:east0,2.3.0,0,0可以看出，这里的一维数组d表示的是点集V（即要处理的数据对象），而二维数组E则表示的是边集E（即点与点的邻接关系）。这种方法对图的表现力比较强，它既可以表示简单图，b俄习±奈之勺r3右't阅干白团固鲍撅万r川田气:志,Y!c垂更幽IIi9'rr7石水占具苏故垃时＿田又能表示多重图，有向图、无向图、网等都可以用它表示出来。这个矩阵是很方便的。但当弧或边较少时，存储量也不会相应减少，这不利于节省存储空间.上面两个数组的下标都对应着点在图中的某种编号顺序，改变编号顺序当然会改变数组中数据的分布，但图中的数据及其相互关系并没有改变。可见，不同的邻接矩阵可能表示实质相同的图.所以对点的编号随意确定一种顺序就行了。点的编号不同导致的邻接矩阵不同，并" ID="7">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="不会阻碍我们得到正确的结果。" ID="8">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000121" TITLE="三、  关联矩阵" TYPE="Chapter">
        <fptr LogicalPageNum="121" PhysicalPageNum="121"/>
        <Paragraph CONTEXT="如果说邻接矩阵是着眼于点与点的关系来表示一个图，那么关联矩阵则是着眼于点与边的关系来表示图.这种方法仍然保留邻接矩阵表示法中的一维数组存放点的信息，此外也要再用一个二维数组i(n,m）来表示图中点与边的关系。这里的n代表v的点数，m代表1中的边数.矩阵中的i(i,j1表示i点与l边关联，即i点是l边的一个端点，由于」边应有两个端点，所以必定存在k，使得i(k,j）二1。对于简单图来说，关联矩阵的每一列都有且仅有两个元素是" ID="1">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="I，这两个1所在的行数就是此条边两个端点的点号。这种矩阵中的两个特征值Z,0可根据所表示的图的特点适当改变，例如在有向图中再增加一个特征值以区别弧的人点和出点，在网中用权值代替邻接的特征值等。仍然以上一节5个飞机场的图为例，由于它的一维数组与邻接矩阵表示法中一样，下面只给出它的关联矩阵：" ID="2">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="type" ID="3">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="gl=array[1二n,l二m]Ofreal;" ID="4">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="亡onat" ID="5">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="1：91＝（（2.3，0.0.0，0，0）." ID="6">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="(2.3,3.5,1.7,3.8,0,0" ID="7">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="(0,3.5,0,0,2.5.O" ID="8">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="(0,0,1.7,0,0,2(0,0.0.3.6.2.5.2这种方法对每条边都编了号，所以对边的研究和区分比较有利，特别是在两个节点间允许出现两条边而又需要加以区别时是很有帮助的.但是当图的点数比较多时.由于每列中仅有两" ID="9">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="个非4值，所以浪费比较大。" ID="10">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000122" TITLE="四、  邻接表" TYPE="Chapter">
        <fptr LogicalPageNum="122" PhysicalPageNum="122"/>
        <Paragraph CONTEXT="邻接表中既包含了点的信息，也包含了弧或边的信息。具体的做法是为每个节点建立一个链表，每个以此点为出点的弧在此链中都占有一个节点，节点中可以包含三个域：" ID="1">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)存放有关此弧信息的域。" ID="2">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)存放人点位里信息（例如点号）的域。" ID="3">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）指向同链中下个弧节点的指针域。n个链表的表头可用记录类型的数组表示.每个表头的下标对应一个点号，某下标的记录内有该点号的数据区和指向以它为出点的弧的链表的表头指针.具体可这样定义：type" ID="4">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="node二’rs" ID="5">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="r二record" ID="6">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="7">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="fst二record" ID="8">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="ends" ID="9">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="head=array[1二n]offst以上的定义中，head为顶点数据和表头指针的数据类;z，而node则是弧节点的数据类型，弧节点中的intp域存放此条弧的人点号。使用这种存储结构，我们能沿着第i条链很容易地找到i号顶点能通过哪些弧到达哪些点.反过来想，要想找到哪些点通过哪些弧能到达第i号点，使用这种存储结构就很不方便了.要想解决这个问题，可以反过来构造链表，即第i条链存放以i为人点（而不是出点）的弧，在每个节点内存放该弧的出点（而不是人点），这样的n条链连同它们的表头节点（这些表头节点中可以同时存放相应的顶点信息）共同构成图的逆邻接表。邻接表和逆邻接表更适合于表示有向图，例如在a条弧的图中仅需要a个弧节点就行了，但在e条边的无向图中，却需要2e个节点才能构造出全表。在无向图中，出点和人点是没有区别的，所以邻接表和逆邻接表也是没有区别的.下面仍以上一节5个飞机场的图8.1为例，给出它的邻接表（图8.3如果G不是网或者无需关注弧的信息，这时节点中关于弧的数据域可以省略，若再省略掉指针，就单留下了人点，除了5个链头，图8.3所示的邻接表被简化成了表8.1的简单形式：$Picture[00000123\00000123_new\0002.jpg]Picture$如果G是个正则图或图中各顶点的度数差别不大，这种简化的邻接表各行的点就是相同或差不多相同的，此时这种简化的表就可以用一个二维数组来表示，顶点的信息仍采用邻接矩阵和关联矩阵的那种一维救组表示。我们称这种简化的表示为邻接表的二维教组表示法.在此二维数组中不代表点的元素一定要标注空的标记。在这个数组中，行下标是点的编号。列下标没有实质性的含义，它只是此点关联的弧的一个随意的编号。图中点的度数差比较大时，使用这种二维数组会空出许多元素，导致浪费。这时可采用一雄址份童甘俪＿撼月毕己！肠州的人仑七川。由占肠.蛋球扮＿西刁卜洲盼扭的空口毛＿" ID="10">
          <fptr EndPN="00000123" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="ty" ID="11">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="arc=array[la]of1ni" ID="12">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="index=array[1二n]of1a;" ID="13">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="把表8.1的邻接表用一维数组表示，两个数组分别是：" ID="14">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="conat" ID="15">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="h:arc=(2.1,3,4,5.2.5.2,5.2.3.4s:index二（1.28.10这里，h数组连续存放了上面二维数组中的非空元素，自然会节省存储空间.而。[的值指明了i点邻城在h数组中的起始位置，有了它的索引，在顺序存储的节点序列中就能容易地查到某点的邻接点，显然，一维数组h的存储是很紧凑的，节省了存储空间.连向存放顶点的一维数组，这个方法共用三个一维数组存储一个图，我们称它为邻接表的一维数组表示法。无论是邻接表的一维数组还是二维数组表示法，都具有“直观”这一最大优势。从对一个图的直接观察中最容易获取这种形式的数据，即使我们要用其它的存储结梅来表示一个图，也可以利用这种形式的数据，而由邻接表的数组表示法转换到所需要的存储形式则可由算法完成." ID="16">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000123" TITLE="五、  十字链表" TYPE="Chapter">
        <fptr LogicalPageNum="123" PhysicalPageNum="123"/>
        <Paragraph CONTEXT="这种链表是将邻接表和逆邻接表结合而成的，因此它具有这两种链表的优点。整个链表连接非常紧密，其中包含顶点和弧两种节点。顶点节点中有数据城和两个指针域，一个指向以此点为出点的弧连接成的链的第一节点，另一个指向以此点为人点的链的第一节点.弧的节点中可以有关于弧的数据城和指针域，指针域有4个，一个是其在相同出点的弧的链中指向下一节点的指针，一个是其在相同人点的弧的链中指向下一节点的指针，另两个分别指向此弧的出点" ID="1">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="访问和处理。两种节点的数据类及建立十字链表的算法见例8.10例1建立十宇链表的算法ptrocedu。二t-grp(varga《以ga为圈的节点数据建立十字桩表｝begin" ID="2">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="read(n,e‘读人点数n和边数e}" ID="3">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="fori：二ltondo（循环物人每个点}" ID="4">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="begin{抽人1个点的信息）" ID="5">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="read(ga[iI.data)t｛摘人此点中的数据｝" ID="6">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="ga[iI.firstin-nil（以此点为头节点的链指针t空，&amp;a[iI.fi二out：二nil｛以此点为尾节点的铸指针t空｝" ID="7">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="endt{结束1个点的艳人｝" ID="8">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="fark：二lcoeda{循环e次}" ID="9">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="begin《开始箱人每个边节点｝" ID="10">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="read(vt,vh)t｛分别.人此边的尾和头节点｝" ID="11">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="i：二k℃ve代cx（ga。vt）；（尾节点在，数组中的下标存于i)" ID="12">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="j;=1orvertex(ga.vh)t（头节点在，数组中的下标存于j}" ID="13">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="new(p‘产生斯节点P存储1条边｝" ID="14">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="P-tailvex：二i（此边尾节点指针指向它的尾节点i}p&quot;.headve，一j;{此边头节点指针指向它的头节点j}" ID="15">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="·p&quot;.blink：一ga{jI.firstin.{将此边播人到同头边的链上｝" ID="16">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="ga[jI.firatin：二pt{把刚插人的这条边当做链头｝" ID="17">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="p&quot;.Clinkga[iI.firstout:｛将此边擂人到同尾边的链头｝" ID="18">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="ga[iI.fimtout：二P{同尾边的链头指向此边｝" ID="19">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="end{结束这条边的翰人｝" ID="20">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000124" TITLE="第三节  图的深度优先搜索" TYPE="Chapter">
      <fptr LogicalPageNum="124" PhysicalPageNum="124"/>
      <Paragraph CONTEXT="有了图的存储结构，我们就可以从图中的某一点出发，去查询需要的一个或多个点，也可以去寻找某条路径.由于这些搜素可能要找遏全图，所以也叫边历.图的遍历按其主要搜索策略的不同分为深度优先和广度优先，这一节先学习深度优先的算法.所谓深度优先的过程是这样进行的，从某点向前走时，按邻接点的某种顺序先走向邻城中的某点，若这点的邻域不空就还按上述原则向前走，直到这点的邻域域空或者经过这点的路已经走完再退出这一点，退回到上一点后在回到的这点的邻域中把刚退出的点换成它的下一个点再去向前走，哪个点的邻城已被走完就再后退，直到把出发点也退掉了，从这点出发的所有可能的走法就都已经被走过了.在深度优先的算法中，每走出一个新点后，仍然优先考虑继续向前走，直到无路可走或路已走完才考虑后退.但每后退到一点还要考虑换个方向再向前走的问题。这种策略也被概括为“有路就走，碰壁回头”。从算法特点分析，所走的路径是需要存储的.不然后退时就不知回到哪构显然应该是栈。每当向前走了一个点，就要进栈操作，每当后退一个点就要进行退栈操作.无论是进栈还是退栈操作后，都要考虑再向前走一个点的问题，所不同的是，进了一个点后要从邻域中的第一个点开始考虑，而退了一个点后要从邻域中（刚退出点的）下一个点开始考虑.邻域中点的顺序是任意确定的，但确定后不应被改变，例如在图中各点编过号时，我们习惯上就按编号的顺序考虑。使用栈这种存储结构遍历一个图时，起止条件是十分重要的.开始深度优先搜索时，首先$Picture[00000125\00000125_new\0009.jpg]Picture$图8.4例8.2图类型的二维数组g及一个作为栈的一维数组a,type" ID="1">
        <fptr EndPN="00000125" StartPN="00000124"/>
      </Paragraph>
      <Paragraph CONTEXT="gr=array[1二9,191of0二1;" ID="2">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="const" ID="3">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="S:gr二（(0,1,1,0,0,O,O,a,O" ID="4">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(1,0.1,1.1,0.0,0.0" ID="5">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(1.1,O,O,a,1,0,0.0" ID="6">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(0,1,0.0,1,0,1.0,0" ID="7">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(a,l,a,l,a,l,a,l,a" ID="8">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(0,0,1,0,1,0,0.1,0" ID="9">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(a,o,a,l,a,o,a,l,l" ID="10">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(a,o,a,o,l.l.l,o.l" ID="11">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="(0,0,o,o,a,o,l.l,a" ID="12">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="var" ID="13">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="a,b:array[0二101ofl二9这里与栈a一同定义的数组b用来记某个点是否走过.在深度优先搜索中为避免点被重复走，可以采用某种存储结构来登记走过的点，也可以在找中进行顺序查找，后者虽然能够节省用来登记的存储空间，但当栈的深度较大时，大全的查找操作会造成时间的浪费。在下面的算法中，b[x9代表x点没走过，而b[xi则代表x点已走过。procedurefnd(x,y,z:byce)｛从x点走向Y点，从出发点算起是要走第：步}varfa1二9a{局部变tf是x点邻域中的点的顺序号｝beginforf:=1to9do{在9个点中顺序查找x点的邻接点｝if(g[x,f〕二1)and(b[f〕二9)thenbegin｛如果f点与x点邻接并且没有走过｝。今］：＝f；‘f点进栈｝" ID="14">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="b[f1;记录f点已被走过｝" ID="15">
        <fptr EndPN="00000125" StartPN="00000125"/>
      </Paragraph>
      <Paragraph CONTEXT="ends这是个递归算法，使用它时在主程序中一定要先把出发点c存人a[11（进栈），将9存人b[c]（记录。点已经走过），并将b的其它元素设置为9，如果以d表示目标点，则在主程序中可用fnd(c,d,2）的语句调用子程序.在此算法中可明显看到前进时的进栈操作，但后退时似乎没有看到退栈的操作。要理解这个问题首先来分析栈指针！的变化规律，由于！是此过程的参数，而在递归调用自身时传递过去的是z十1，也就是说下次调用自身前进一个点时栈指针比这次多1，所以在进栈的句子前后没有看到栈指针上移的操作，同样的道理，由于后退体现在过程结束退回到上一级主调的子程序中，这是栈指针当然就恢复成了上一次的2，即栈指针自动减了1，由于栈中数据的最大下标被；指明，所以z的这种减少已使它所指位置上面的数据失效了，可以说，这种过程结束的操作中就隐含了退找。类似地另一个问题是，当循环变量f代表的点可走时，到了f点后又开始了一次新的f循环.那么原来的f还保存着吗？如果没有保存，那么返回到原来那一级子程序时，f的下一个点又如何确定呢？在上面的算法中，破例（一般的算法都省略局部变量的定义）强调了f是个局部变量，在结构化的编程语言中，调用子程序时局部变量是会自动得到保存的，当返回到这一级子程序时，系统会恢复原来的局部变量，可以说，系统在执行这一算法时所保留的一系列f为此深度优先过程保存了宝贵的信息而不必让程序设计者再去费心.通过对此递归过程中参数和局部变量的分析，深度优先的递归算法向我们展现了它的优点，那就是可以利用系统的自动保存机制轻松地记录栈指针和每步走的点.使这个算法既直观又简单.当然，深度优先也可以表现为非递归算法，请看下面的例子." ID="16">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="一稠戛" ID="17">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="4行8列的方格组成（见图8.5)。请编一个算法，找到一条从" ID="18">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="左下角跳马到右上角的路径，每一步只允许向右边跳.上下的" ID="19">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="方向不限制。深度优先的算法既然可以搜索到任意两点间的所有路径，那么搜索两个特定点找一条路径当然是可行的。由于此图图8.5中国象棋棋盘（半幅〕中的点太多，为避免统一编号增加复杂性，我们可以直接用点的坐标来标注图中的点，这里把左下角的出发点记为（(a,o)，则右上角的目标点就应记为（(a,4完成了点的表示还要解决图的表示问题。如果仍用上题那种邻接矩阵的存储结构，仅二维数组就需要两千多个数据，即使用上一节的其它存储结构，数据量也是很大的。能否用简单方法表示这个图呢？" ID="20">
        <fptr EndPN="00000126" StartPN="00000126"/>
      </Paragraph>
      <Paragraph CONTEXT="(x十l,y-2），（x＋2，v-1" ID="21">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="(x十2,y+1(x+l,y+2)当然，这些点中超出象棋盘范围的就不再属于（(x,y)的邻域了.因此可以说象棋盘上（(x,Y)点的邻域可以在上述4点中找.如果我们把这4个点对应的跳法想象成4个方向，那么在图中的每点上，我们都能找到要走的方向，可以说，这个图已经被用一种比较开放和简炼的方式表达出来了.如果一定储要用上一节的某一存储结构固定下来，通过这种邻接法则表示的图也能使那种存储结构的构建更为简单，许多情况下，这种邻接法则表示的图是可以直接应用的。由于限制了马只能向右边跳，所以本题是个有向图，而且按这种限制是不会有点被重复跳的，所以上面那个例题的深度优先算法中的b数组可以不用。后退时应该换下一个方向再向，那么怎样得到刚退出的点是哪个方向呢公一种办法是通过计算，由退出的点与退到的点的坐标差就可以算出退出点的方向，另一种就是在进栈时多保存个方向信息，我们采用后一种方法.是记方向的栈，而a和b两个数组则是记录路径中的点，这里a记横坐标.b记纵坐标。退掉一个点时，取出它的方向信息，就可以找到下一个方向了.三个数组都是一维的，具体定义为：" ID="22">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="type" ID="23">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="art一。tray[1二81of-z二8," ID="24">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="const" ID="25">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="x:arr二（1,2,2,1.a.0.o,a" ID="26">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="ysarr=（一z，一l,l.z,a.o,o.o" ID="27">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="vat" ID="28">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="a,b.f:arr这里定义的常t数组x和y就是用来说明方向的，数组的下标可看作4个方向的方向号，x[i]1y[i〕分别是第i个方向在水平方向上和竖直方向上的坐标偏移里，用它们分别加上点" ID="29">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="的横纵坐标就可以得到新点（如果这点没出界）的坐标。下面是算法：procedurejumpsbegin1：＝1；k，＝0，fi是权指针，出发点进校，故k二l.k是方向号，搜索前tp}" ID="30">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT=".C17o,bCl7s=o;（将出发点的坐标存人机中｝" ID="31">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat" ID="32">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="aa,《把方向清0，从新点继续向前走将从第一个方向开始考虑y" ID="33">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="a[i=cib[i]：二d{坐标进栈）" ID="34">
        <fptr EndPN="00000127" StartPN="00000127"/>
      </Paragraph>
      <Paragraph CONTEXT="until(iCl)ar(c=8)and(d=4)i（直到找出目标点或无路可走｝" ID="35">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="ifi＞0then｛如果是找到了目标点就要考虑打印路径、" ID="36">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="end;这个算法也是深度优先搜索一个图，但对比例8.2可以看出两个算法各自的不同特点：" ID="37">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)例8.2采用递归算法，而例8.3采用的则是非递归算法。后者中可看到对栈指针i的操作，它实际上代表了从出发点开始已经走了多少步，算法中对1的控制是关键的环节，i的增加或减少直接反应了马的进退。而前者的找指针z却是通过过程的调用与返回自动实现的，这里递归算法的实质是将从x到Y的间题转化为先从x到xl，再调用从x1到Y的过程，而从xl到Y的过程也许还要转化为先从xl到x2.再调用从x2到Y的过程等等，其实这一系列的过程都是同一个过程，故此形成了所调的递归算法。事实上，前者的算法已经让系统记录了每一个走过的点f（一系列的局部变量f被记录在系统的栈中），只是为了输出方便才又使用了a数组作为存储结构路径的钱.后者只是把整个问题当做一个整体来解决." ID="38">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）例8.2使用了图的一种确定的存储结构―邻接矩阵法，而例8.3则没有用任何一种图的存储结构，直接利用此图的规律，通过邻接法则就完成了对整个图的搜索，采用这种方法描述一些有某种规律的图常常能使问题简单化，即便一定要转化为一种固定的存储结构，也可以把这些法则体现在转化的算法中，由计算机自动去生成那种存储结构。" ID="39">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）例8.2中使用了b数组专门用来记录某点是否被走过，在深度优先的过程中，一般不允许点被重复走，即使少数情况下允许某种重复，也是有严格限制条件的，否则对一个图的搜索可能会陷入一个无穷无尽的过程。例8.3虽然也要求在一条路径中不能出现重复点，但它却没有使用b数组作为标记.这是因为利用了这个特殊有向图的特点，只允许马向右边跳的情况下是不会跳出重复点的。" ID="40">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）例8.3中专门使用了f数组来保存某点的跳入方向，而例8.2就没有专门用数组来记录方向。这是因为在例8.2中，栈中存的点号本身就可以看作是方向号，特别是在递归算法中，后退一步体现为最后这级子程序的返回，回到的这级子程序的局部变量中会保留着刚返回的这个方向的信息，上述两个理由中占一条就可以省略专门记录方向的数组，而此算法两条都占，当然无需这个数组。前进方向的记录对于深度优先搜索是很有必要的，因为深度优先的算法在’‘碰壁”时要.回头”，而回头后又要换下个方向，所以方向的信息是不能缺少的，如果不记录这个重要信息就只能通过什算等手段来得到，这样做当然会增加算法的难度和复杂性。在有些算法中，可根据题目特点，把记录方向的存储结构和记录此点是否走过的结构巧妙地统一起来.节省出宝贵的内存资源。" ID="41">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）例8.2搜索的是两点间的所有路径，而例8.3只搜索两个特定点间的一条路径.这需要控制过程的结束条件。由于栈的规模是可以预先估算的，所以可以保证栈一般不会滋出，但是无论深度优先算法要找的点或路径是否存在，结束条件中一定要有栈空的处理，这更能够保证算法的完备性。" ID="42">
        <fptr EndPN="00000128" StartPN="00000128"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000129" TITLE="第四节  图的广度优先搜索" TYPE="Chapter">
      <fptr LogicalPageNum="129" PhysicalPageNum="129"/>
      <Paragraph CONTEXT="上一节的深度优先搜索总是沿着一条路径向前扩充新点。而广度优先则不同.它从一点向外走。要按某种顺序（当然这个顺序也是随意确定的，但必须确定）走完邻域中的每一个还未曾走过的点.如果把包含出发点这一个点的集合称为集合0，按广度优先的顺序搜索集合0中各点（即出发点）的邻域集合，把这些邻域集合的并集称为集合1，然后搜索集合1中的所有点的4'9tiCtc止七xtfieh3f山f+匕唯匕bn4n唯七/sIetideh.KGGcfTEr招胜ACdr'1，口佑2、，刁巨七困摘；禧卜2、0中所有点的邻域。在这些邻域的并集中除去集合0、集合" ID="1">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="1、集合2中的点得到集合3，一，直到得到集合n，而集合n已不再有邻域为止。显然，这种广度优先的搜索并不基于一条特定的路径，而是一层层向外扩充的，第一步扩充出的集合1中的所有点与出发点的距离都是I（只经过1条弧就可到达），集合2中的每一点都是与出发点距离为2的点，二，集合n中的点与出发点的距离都是n。，这里。从x到y至少需经过的弧的数目称为x到y的距离。在广度优先的遍历中，搜索过的点也需要记录下来，虽然这一轮中它是被扩充出来的新点，但在下一轮中，还要从它向外扩充别的点。使用什么样的存储结构来记录这些点呢？由于巢合。、集合1、集合2、…、集合n是按顺序扩充出来的，而在每个集合内部，点的存储顺序也可以按搜索顺序排列，所以在总的顺序中，先被搜索（并被记录）过的点也将先被用来向外继续扩充，这种“先进先出”的存储顺序决定了所使用的数据结构应该是队列.进行广度优先搜索前，首先应把出发点进队作为队头，因为只有1项数据在队，当然它也是队尾，每次都是用队头指针所指的点向外扩充，把它邻域中的点依次（例如按点号从小到大）插人到队尾，当它的邻城全扩充完后将它从队头删除.直到队头指针超过队尾指针时，就说明" ID="2">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="无法再向外扩充了，也就是说，广度优先搜索的结束条件一般是队空。" ID="3">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="例8.4利用广度优先算法对图8。4编一个过程.对任意输人的点分别搜索出1步能到" ID="4">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="达哪些点？2步能到达哪些点？" ID="5">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="首先还是先定义图和队列等存储结构：" ID="6">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="ty伴" ID="7">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="（0，0，D，1，D，0，0，1，1），" ID="8">
        <fptr EndPN="00000129" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="（0。0，D。0，1，1，1，0，1）.（0，0，D，0，0，0，1，1，0））；Var索过的点的数组，上面的b数组就起这个作用。仍然以b[i9表示i点没在队列，以bCi7=1表示i点己在队列。proceduretwoatep(d:byte｛以d点为出发点向外走两步｝beginforiIto9dob[i]：二9;｛初始化.队列中没有任何一个点｝a[I]：二d出发点进队｝" ID="9">
        <fptr EndPN="00000130" StartPN="00000129"/>
      </Paragraph>
      <Paragraph CONTEXT="b[d1;｛记录d点已经搜索过｝" ID="10">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="t。二1:I队头指针指向刚进队的出11队头指针指向刚进队的出发点｝w：91，｛队尾指针指向刚进队的出发点争k：＝1，｛每轮将以k为最大下标为k以内各点扩充邻城）。：二1；｛。记录即将搜索的点与出发点的距离｝" ID="11">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="re卯at｛开始沿着队列进行反复扩充｝j：＝a〔t］。哥将队头取入j中》fori：二ltogd。｛按点号顺序搜寻j点邻域中的点｝" ID="12">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="if（9已，1〕一1）and（b［1〕一9）t玩n｛如果1属于j的邻域并且1点还没有搜索过｝" ID="13">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="write（i：3）｛显示新进队的元素》end。毛从j点扩充邻域的过程结束｝t：二t十1；｛从队中侧除j号点.队头指针后移｝ift＞kthen《如果队头已经超过本轮搜索点的界限就应结束这轮扩充｝" ID="14">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="begin望结束这轮搜索，准备开始下一轮搜索｝" ID="15">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="二itdn，｛结束本行的愉出，换到下一行｝" ID="16">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="k：＝w。｛为下一抢搜索确定新的最大下标｝c：二c＋1（搜索的点距离增加1｝end叨til（c二3）or（t＞w）｛直到距离超出或无法再向下搜索就结束队列的抽人和侧除｝end；在上面的搜索中，c＝1时所进行的搜索，进队的都是集合1中的点，。＝n时搜素得到的都是集合n中的点，而。的变化又是随着k的变化而变化，实际上，k每次指明的就是某个集合的最后一个元素，因此队头超过它时就意味着对一个集合中各点扩充邻域的过程已经结束。二叉树的遇历我们已经学习过多种，例如先序遍历、中序遗历、后序遗历等.由于它也是一，当然也可以深度优先或广度优先遍历。用本章第二节的分类.二叉树采用的一般是多重种图，当然也可以深度优先或广度优先遍历。表的存储结构。下面就以这种存储结构为基础，对二叉树进行广度优先的谊历。" ID="17">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="例8.5节点的类型定义及队列的变量定义是：" ID="18">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="ty伴" ID="19">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="jd巴‘lx。" ID="20">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="lx二record" ID="21">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="data：byte，" ID="22">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
      <Paragraph CONTEXT="节吕r" ID="23">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="a,nrray[1二1001ofjd这里a数组就是在广度优先中要使用的队列，数据的元素都是一些指针，所指的就是二叉树中的节点。下面是从根节点开始。按广度优先遍历二叉树的算法：procedu二，tep(r;jd)l｛对以r为根节点的二叉树进行广度优先遥历｝begin" ID="24">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="a[11r;｛树根进队7" ID="25">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="七：二11队头指针初拍化）" ID="26">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="w1a{队尾指针初始化：." ID="27">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat《开始一次次反复搜索｝" ID="28">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="write(e[t.data:4｛访问队头元索｝" ID="29">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="ifa[t1C＞ni1then（如果队头的左孩子不空就把左孩子擂人队尾｝" ID="30">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="beginww+1sa[w=a[t〕一1end;" ID="31">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="玩ginw：＝w＋1。a［，］：＝a［t」‘.rend，" ID="32">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="t：二t十1吸翻除队头元索，头指针后移｝" ID="33">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="untilt＞w｛直到队空就结束整个搜索｝end番这个算法很简捷，它将会把所给的树按第1层、第2层、一、第n层的顺序访间一退.此例中我们暂以打印代替一般性的访问。每层中都是按从左到右的顺序访问的，但是打印的结束没有按层分行，怎样作才能使打印按层分行呢？请参考上一个算法将输出格式改变为按层分行的形式。对比深度优先与广度优先遭历的几个例子，可以看出它们在搜索的优先顺序、搜索过程使用的存储结构、计算复杂性及适用范围等方面，各自呈现出不同的特点，分别对比总结如下：（l）从当前点向外的搜索策略不同.深度优先每次从当前点沿某一方向走向一个邻接的新点，然后以新点为当前点继续进行这种搜索，直到某一方向没有可走的邻接点才会在邻域内找下一个方向有没有邻接点。体现了一种优先向纵深发展的搜索顺序。而广度优先中，即使从当前点走出一个新点，也只是先把此新点排在队尾，暂时不去管新点能否走下去的间题，而是再从当前点的邻域中去找下一个邻接点，休现的是广泛性优先的搜索顺序.当前点的邻域搜索完后将它（在队中〕的下一个点作为当前点继续这种搜索。以例8，2和例8.4的图为例.都以1为出发点，两种搜索的前9点为：" ID="34">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="深度优先123654789广度优先’123456789（幻所使用的数据结构不同。深度优先使用的是栈，进栈体现了“有路就走”，退栈则体现的是“碰壁回头”，这个方向没有路就换下个方向试试。广度优先使用的是队列的存储结构，队头的移动体现了“逐层推进”，而队尾的移动则体现了“步步为营”的策略。" ID="35">
        <fptr EndPN="00000131" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）计算复杂性不同.在广度优先的搜索中，每个点只进队一次，n个点的图至多有n次插人和n次删除。而深度优先搜索时，一个点可能被多次走过，因此它进找也可能是很频繁的.由于深度优先要搜索到每条路径，所以经过某点的不同路径越多，该点进栈的次数也就越多，有的点甚至进扮次数比n还多得多，可见，深度优先的计算量远比广度优先要多得多。确切地描述一个图使用两种搜索的计算复杂性，是比较复杂的数学什算过程.而且还涉及图的许多参数。这里暂举一个整齐而简单的例子，从中可看出两种搜索计算里的差别之大。设G是n个点的k正则连通图，深度优先搜索时，从每个点向k走都要考虑k种可能，所以需要搜索k，次，而在广度优先搜索中，队头指针在队列中至多扫过n个点，每个点考虑k种可能，所以搜索次数是nk。当n变大时，二者会有惊人的差距，因为前者是指数级别的.而后者只是多项式级别的。" ID="36">
        <fptr EndPN="00000132" StartPN="00000131"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）搜索的侧重面不同。广度优先以点为关注对象，即使增加一些辅助的存储变量也只能为每点记录一条路径。而深度优先关注的主要是路径，路径中的多个点中，随便换掉一个就是另一条不同的路径.可能需要重新搜索一退才能得到.当然，既然所有的路径都能被遍历。那么这些路径所经过的所有点自然就都被访间到了。同样的问题，如果既能用深度优先又能用广度优先，当然是广度优先更快捷.例如判断两个点之间是否有通路？距离是多少？这样的问题用深度优先是可以解决的，例8.3的马是否跳得过去？怎样跳？都是用深度优先来解决的（在那个过程中如果跳不通将不输出任何路径），我们不妨再用广度优先的方法来解决一个类似的问题.例a.‘设GR是n个点的无向图。已采用邻接矩阵8存储，编一个算法什算点d和点e的距离，如果不存在两点间的路径则距离为0Function1en(n,d.e:hytebyte;beginfori：一1tondob[i]：二9;a[11：二d，b〔d］：＝1。t：二1;wl;k1;c：二1;£：一0;" ID="37">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat" ID="38">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="j；二aCt" ID="39">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="fori：=1tondo" ID="40">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="if(g[j.i1)and(b[i〕一9)then" ID="41">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="i(i二ethen1：二c" ID="42">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="cnd;" ID="43">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="t,二t十1:" ID="44">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="ift&gt;kthen" ID="45">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="46">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="kw" ID="47">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="cc+1" ID="48">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="end" ID="49">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="untilU&gt;0)ar(t&gt;w）书" ID="50">
        <fptr EndPN="00000132" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="fen1end;虽然这个算法是以函数的形式给出的，但它的主要程序结构与例8.4相同，所以算法的注释就省略了，只把新变量及作用简述如下：新变母l用来侧t两点间的距离，repeat-until循没搜索到，循环结束后1还是a，最后把它就作为函数值返回.三个参数中，n是图的点数。d和e就是两个点。为体现连通与不连通两种情况，调试时可让图8.4中都与9分离（(9就成为a度点了）。二维数组9的定义便改为：type" ID="51">
        <fptr EndPN="00000133" StartPN="00000132"/>
      </Paragraph>
      <Paragraph CONTEXT="gr二array[1二9,1二，]of0二1:" ID="52">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="conat" ID="53">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="g:gr=4,1,1.0,0,0,0,4,0" ID="54">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(1,0,1,1,1,4,0.4,0" ID="55">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(l.l,o,o,o,l.o,o,o" ID="56">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(o.l,o,o,l,o.l,a,a" ID="57">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(0.1,o,1,a,l,o,l,o" ID="58">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,o,l,o,l.0,4,1,0" ID="59">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,o,o,l,a,o,a,l,a" ID="60">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,o,o,a,l,l.l,o,o" ID="61">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,a,o,4,0,4.0,0.0n是9，先把d和e分别用1和9代替.将返回距离。，说明已经没有1和9之间的路径，再把d和e分别用1和8代替，得到的返回值是3，说明这两个点之间不但有路径能走通，而且两点间的最短路径经过3条边." ID="62">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000133" TITLE="第五节  图的连通性" TYPE="Chapter">
      <fptr LogicalPageNum="133" PhysicalPageNum="133"/>
      <Paragraph CONTEXT="第三节最后的例题和第四节最后的例题中，我们巳经解决了两个点是否连通的问题。这一节我们先来解决一个无向图是否是连通图的问题.在一个无向连通图上任意选择一个初始点，那么图中的每一点到这个初始点的距离都大于0，仍延用上节那一系列集合的定义，设某点与初始点的距离是1，则在第1轮搜索时，定会将此点进队（即此点属于集合f)，也就是说，从随意确定的初始点出发能在广度优先的搜索中找到任何一点，最后得到一条n个点的满队列.这就为我们找到了一个检测连通图的试金石，广度优先搜索完成后，如果队不满则搜索的就不是一个连通图.例S.7设G是n个点的无向图，它的邻接矩阵用二维数组8表示，请编一个算法判断G是否为连通图。procedureconnect&lt;n,byteg：gr)‘{对n个点并且邻接矩阵是8的图到断连通性）比9认fari:=2tondob[i]：=9tf定义每个点都还没有走过）a[111f以1为出发点）btl]r=1，{记录1号点己经定过）t1，{队列的头指针初值为1)w：二1;｛队列的尾指针初值也为1}" ID="1">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="repeatis=a[t{队头点取人j}" ID="2">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="foriitondo《在n个点中顺序寻找邻接点》" ID="3">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="if(g[j,i〕二1)and(b[i9)then｛如果i与j相邻接并且1点投走过就可让i进队｝" ID="4">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="6epin（开始进队f" ID="5">
        <fptr EndPN="00000133" StartPN="00000133"/>
      </Paragraph>
      <Paragraph CONTEXT="t：二t十1'j点的邻城搜索完后删除7点（头指针后移））" ID="6">
        <fptr EndPN="00000134" StartPN="00000134"/>
      </Paragraph>
      <Paragraph CONTEXT="untiltaw;｛直到能连通的所有点都走完｝" ID="7">
        <fptr EndPN="00000134" StartPN="00000134"/>
      </Paragraph>
      <Paragraph CONTEXT="ifw=nthenwritelnconnect')" ID="8">
        <fptr EndPN="00000134" StartPN="00000134"/>
      </Paragraph>
      <Paragraph CONTEXT="（如果能通到的点数就是n，说明整个图是个连通图，并输出“连通勺" ID="9">
        <fptr EndPN="00000134" StartPN="00000134"/>
      </Paragraph>
      <Paragraph CONTEXT="elsewritelndisconnect')｛不是连通图就愉出“不连通”｝end;如果G是个连通图，那么不论以哪个点作为出发点都能走到图中的任何一个点，也就是说连通性与选择哪个点作为出发点是没有关系的，所以上面的算法中把出发点固定为1号点。如果搜索结束时进过队的点数还不到n，说明什么呢？首先说明图中存在着由出发点无法走到的点，其次，队中的所有点构成了一个连通子图，而且是一个点数无法再扩充的连通子图.可见这个算法同时也为我们提供了从一点出发，得到此点所在的连通子图的方法。设x和Y是图G中的两个点，如果G是连通图，从x是可以通向Y的。但换个角度来思考，从x走出的许多条路径中还存在着许多条不到达和不通过Y点的路径.可以说要想从x准确地通向y还甜要正确地引导，就好比说在一个现代化的城市中.交通是四通八达的，但如果你记错了路或得到了错误的指引，你也无法到达预定的地点.要走出一条路径辞要一系列的引导信息，就如同行进在街道上，每遇到一个路口就需要得到一次方向指引，在图上每走到一点也需要得到“下一步向哪点走”的引导信息，我们把这些引导信息称为“引导指令序列”.在一个本来走得通的图中，按某一引导指令序列却走不通，就可以证明这个指令序列是错误的.需要说明.从x到Y的路径可能并不唯一，所以相应的引导指令序列也可以有多个，而且这些序列都是正确的。作为一个有代表性的应用，我们可以通过图8.2的字符类j逻辑关系图.把表示算式的字" ID="10">
        <fptr EndPN="00000134" StartPN="00000134"/>
      </Paragraph>
      <Paragraph CONTEXT="符串作为引导指令序列来检验，考察输人的字符串能否引导.开始”顶点走向“结束”顶点。例如检验下面这个字符串：3&quot;4一（1一（12十3因为“开始”点邻接数字符3，数字符邻接运算符运算符‘一”邻接数字符4，数字符4邻接运算“一”，运算符“一”邻接左括号，左括号邻接数字符1，数字符1邻接运算符“一”，运算符“一”邻接左括号，左括号邻接数字符1，数宇符1邻接数字符2，数字符2邻接运算符“十”.运算符“＋”邻接数字符3,数字符3邻接右括号，右括号邻接右括号，右括号邻接“结束”点。所以得出结论：此算式各字符间的逻辑关系是正确的。特别需要强调，这里并没检验括号匹配的逻辑关系和和运算数的合法性等，只检验了字符串中每个字符与其前趋和后继的关系.对照图8.2，可以找到下面这个字符串中存在着许多错误，在此就不一一列举了./3a一，)4(例8.8编一个算法，检验字符申中的算式，如果此算式的开头、结尾和字符间的逻辑关系附合图8.2的要求就擂出yes，否则输出no," ID="11">
        <fptr EndPN="00000134" StartPN="00000134"/>
      </Paragraph>
      <Paragraph CONTEXT="gr二array[17.1二了]of0二1," ID="12">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="COn欧" ID="13">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="g:gr0,1,1,0,0.0.4)," ID="14">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="(0.1,1.0,0,0.0" ID="15">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="(0.0,1,1.1,1.0" ID="16">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,l,l,o,o,a,o" ID="17">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,a,o,1,1,1,0" ID="18">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="(o,o,o,o,o,a.o" ID="19">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="ro,o,a,a,o,o.o从这个二维数组的定义可以看出，这个逻辑关系图不是简单图，它所限制的字符间的逻辑关系只适合于正整数的允许带括号的算式。从数组的定义中还可以看出，代表“其它宇符”的7号点的邻域是空集，而且它也不属于任何点的邻域，这说明如果在字符中出现既非括号又非数字符且非运算符的字符，那它对应的点在图上既走不进又走不出，不通就意味着错误。下面是算法，它试图从“开始”走进字符申，以字符串为引导指令序列在图上走下去，再从最后一个字符走向‘结束井。procedurecheckatr(s,atrieg)，{字符申，中字符间的逻辑关系}begink：二length(s);《将算式中的字符个数存人k}is=1,{i存前一宇符的类型号（即在圈中对应的顶点号），检验前应为“开始”点号1}fori：二ltokdo{要对字符串从头到尾（即i从1变到k）扫描｝begin开始扫描｝cases[i]of（首先要根据第i个字符S[1〕确定它的类型（即在图中的点）号num}':num：=2;i左括号对应p}'012'34567S9nu二：=3i{（字符3iY't3}，＋一‘,.'：num4;｛运算符对应4}'：num：二5;｛右括号的类型号5}elsenum：二7{其它字符对应7}end;（结束宇符分类）ifg[j,num1tien{判断前一宇符类壑的点在图上是否能通向这一字符类型的点）" ID="20">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="1、一num《如果能走通就让i跟进到当前字符的类型｝else‘走不通执行下面两行｝" ID="21">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="begin" ID="22">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="num：二以类型号为。作为走不通的信号｝" ID="23">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="i.二k七把扫描的点号移到最后，不必再扫描其它字符了｝end" ID="24">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="cnd;if(num&gt;0)and(g[j,S〕二1)then判断是否宇7`间关系都正确且最后一个字符通“结束”｝wtitelnyes')（上述二条件都成立就打印yes}elsewritelnno')（否则打印na}" ID="25">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="亡nd利用引导指令序列从图中的一个点通向另一个点成为我们检验引导指令序列正确与否的重要手段，它把在图上能走得通作为前提，关注的却是引导指令序列的正确性.下面我们还是来关注一种特殊的连通图―H图。" ID="26">
        <fptr EndPN="00000135" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="X122从本章第一节H图的定义可直接推理而知，H图一定是2连通图.因为H图上至少存在一条经过图中所有点的路径且此路径的首尾还互相邻接.我们称这条路径和连接首、尾点的边所构成的包含图中所有点的回路为H圈。而图中任何两点x和y之间至少存在两条不经过相同点的路径，它们当然都在H圈上，在圈上沿着一个方向可以走出第1条x到Y的路径，而沿着另一个方向就可以走出两点间的第2条路径。而且除x和Y以外，两条路没有相同的点。这已经说明H图必然是2连通图。H图必为2连通图，而2连通图当然肯定是连通的了。从这个意义上说，从连通图到2连通图再到H图，连通性是越来越强，在图中搜索也会越来越自由。而引起国内外专家的广泛关注，在H图的理论研究方面取得了许多重要成果。例S.，编一个算法判断G是否为H图，如果是H图就打印出其中的一个H圈。这里就不再给出数据类型和存储结构的定义了。但图仍然用邻接矩阵来表示。procedureh-circle(n,g);｛对n个点井以“为邻接矩阵的圈找H圈；卜犯访fari.二工tondabq〕.＝9；之将所有n个点都设t为未走过｝a[11.二1;{1号点进找｝b[11：二Z;｛记录Z号点已经走过｝i：二l;{钱指针设t为1}" ID="27">
        <fptr EndPN="00000136" StartPN="00000135"/>
      </Paragraph>
      <Paragraph CONTEXT="i，=0+{准备从1号点（的方向）开始搜索｝" ID="28">
        <fptr EndPN="00000136" StartPN="00000136"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat" ID="29">
        <fptr EndPN="00000136" StartPN="00000136"/>
      </Paragraph>
      <Paragraph CONTEXT="j:」十li‘换下一个点（的方向）搜索｝begin如果条件摘足就走向1点）" ID="30">
        <fptr EndPN="00000136" StartPN="00000136"/>
      </Paragraph>
      <Paragraph CONTEXT="isxi+1;{指针后移）aCiis{i点进找｝bCi]：二l｛记录i号点已经走过｝i：二o{继续向前走还将从it号点开始考虑；end（进钱过程结束｝end（点存在的处理结束｝" ID="31">
        <fptr EndPN="00000136" StartPN="00000136"/>
      </Paragraph>
      <Paragraph CONTEXT="else（如果i点不存在就后退｝" ID="32">
        <fptr EndPN="00000136" StartPN="00000136"/>
      </Paragraph>
      <Picture URL="00000136\00000136_new\0034.jpg">
        <fptr EndPN="00000136" StartPN="00000136"/>
      </Picture>
    </div>
      <div ORDERLABEL="00000137" TITLE="第六节  最短路问题" TYPE="Chapter">
      <fptr LogicalPageNum="137" PhysicalPageNum="137"/>
      <Paragraph CONTEXT="在连通图上的两个点之间一定是走得通（即存在路径）的，有时同时存在着多条路径，为了走捷径.提高效率，人们常关心“哪条路径最短？”的问题，这的确是很实用的问题。本节中我们将根据图的不同性质和具休间题的不同特点分别讨论解决的具体对策。如果每条边没有长度的区别（即图不是网），我们可采用广度优先的算法，用此方法不仅有效，而且效率高，什算复杂性低。在前面几节的学习中我们已经知道。如果x与Y的距离是i，那么从x点开始广度优先搜索，在第1层（即集合1）一定能搜索到点Y。问题是在广度优先搜索中直接得到的结果是点，而没有一条现成的最短路径。要想得一条路径就要在搜索过的点中再单独建立某种联系.集合I中的一个点肯定是集合（1-1)中某点的邻接点，而这两个点之间的边也许就是最短路中的一条边，虽然在搜索过程中无法预先知道哪条边属于最短路，但每个1以内集合中都包含一条最短路中的边。里面一层的集合中的点可能有一个或多个邻接点在外面一层的集合中，也可能一个都没有，要由里层的点记外层的点需要多重指针，增加了不确定性，而外层的点肯定可由内层的一个确定点来邻接，事实上，外层点在队尾进队时的队头就是邻接它的确定点。由上面的分析可以看出.在广度优先搜索时.可以为每个进队的点增加一个指针来指明它里面一层的邻接点.这样一来，当我们找到目标点y后就可以沿着指针的引导，恢复出一条最短路的轨迹。当然.由于出发点x并不是哪个点走出来的.所以它无需指向什么点，但为了恢复一条逆向指针的链，出发点的这个指针应该设置为链尾标志，能使这条逆向链的翰出方便些。在队列的基础上使用了这些指针，实际上是在数据间建立了另外一种逻辑联系，沿着指针的方向看好象是一条条的链，但由于可能有多个外面一层的点指向同一个里面一层的点，所以逆着指针的方向看是一棵树，在树中采用的是子节点指向父节点的方式。每个叶子节点对应唯一一条链。使用广度优先搜索到目标点Y所在的一层就可以结束搜索了，所以目标点就是一个叶子节点，它对应的链逆过来就是最短路径。逆向访问一条链可以附加一个数组，沿着链的方向把点一个个存入数组，再反向输出这个数组中的点。还可以直接用递归算法。例8.10为n个点的图编一个从x到Y寻找最短路的算法，若找得到就输出这条最短路径。下面给出的算法利用了一个递归输出的子过程链指针，并没有单独使用另外的存储空间，而是利用了记录点进队的数组b，因为己经指向父节点的点肯定是进过队的，恰好也可用来判断该点是否进队.而出发点没有父节点，所以它的指针项设盖为n-I，表示链尾。此例中b[i〕表示i号点的父节点在队中的下标." ID="1">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="procedureahort(n,x,q.g)｛在有n个点且以g为邻接矩阵的图中找x到Y的最短路｝" ID="2">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="proceduredisp(d.n}“在n个点的图中逆向输出以点d为链头的健I" ID="3">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="ifb[dn+1then{q断d点是否是链尾｝" ID="4">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="disP‘a【b［dn）：｛则先自我调用.逆向愉出以前一节点为头的链}" ID="5">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="end" ID="6">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="end;i物出过程结束）" ID="7">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="begin（找x到5最短路的过程开始：fori：二itondob[i30:：所有点的链指针（也是进队标志）置。｝a[11x:｛出发点进队f" ID="8">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="b[xj：二“n十1:i设置总链尾标志；" ID="9">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="t1;w：二lc;队头和队尾指针都置为" ID="10">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat｛开始广度优先搜索）" ID="11">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="l：二At］i；先将队头点取到1中、forj1tondoSj在1到n的范围内搜索i的邻接点i" ID="12">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="if(g[i.j.i二1)andib[j〕二，0)then判断是否i邻接j且7点没走过！" ID="13">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="begin：如果满足条件｝" ID="14">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="万点指向1点〔的下标tj，" ID="15">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="c.nd：｛条件成立结束争t：二tJ－1｛1点的邻城搜索完后将它删除，队头指针后移、。ntil（t＞w）or（b〔y〕＞0）；｛直到队空或目标点y被找到、汀b［月＞othend匈（y，9）｛如果y点已进队就去逆向输出以y为链头的链｝end；广度优先的过程在：ePeat-untd循环中被简捷地体现出来，就不再加以分析了。用来逆向愉出反链的子过程简单分析如下。在此子过程中，逆向输出1号点为头的链一般被分为两个步熟，先逆向输出1点后面的那部分链，再输出1点本身.除非1点已经是链尾，若1是链尾，逆向输出链的工作就十分简单了，只需要直接打印1点就行了。两个过程中用到的指针也很值得一提，为同时记录点是否进过队，改变了前面几个算法用9作为没走过点的标志而以0代之，同时利用n＋1作出发点的标志，这样一来，不仅区别了走过与没走过的点，也区别了链尾与非链尾。这都有利于算法的描述。由于b数组兼作进队标志，所以它的下标是点号，而它的值当然应该指明下一个节点的存储位置，所以它的值是下一个点在队中的下标.这与通常由位盖得位置的习惯是不一样的，读递归调用的部分时要特别注意这一点。上面的算法得到的不仅是从x到y的这一条最短路.当我们把搜索结束条件中的j二y去掉后，所有的点都将被搜索到，这时对任意的一点1都已经找到了从x到1的最短路径，di，p（i，n）的子过程就可以看到结果。下面研究在网上寻求最短路径的问题，在许多实际问题中这是很有意义的。例如图中的点代表一些不同地点时，图中的边可以是连结这些地点的交通路线，由于在不同的路线上，距离、时间、花费等都可能不同，以这些数据作为各边的权，人们很自然地要关心“从x到y哪条路径的花费最少？”这样的问题。由于加了权之后，包含边数最少的路径其加权和并不一定最少，所以用广度优先的方法直接寻求边数最少的路径就得不到结果了，而深度优先的方法可以找遍从x到y的所有路径，那么在其中比较出一条加权和最少的路径问题就可以得到解决。为了比较加权和最小的路径，在搜索的过程中当然要计算路径的长度.当前进一步时在路径长度中增加这条边的权数，而后退一步时又要减去这条边的长度。还要像上一章的选择排序（当然也许还是上一次的最小长度），不断地搜索和比较，当前路径最小长度按单调减少的趋势变化，最后就得到了加权意义上的最小长度。在长度最小值的比较过程中，应该随时记录该最小长度所对应的那条路径，每次更新最小长度时也更新这条路径.最后在得到最小长度时也就得到了最短路径.当前最短路的最小长度值可以先用一个比较大的值为初值，而不应设得过刁、。例S.11编写算法，在n个点的网中求x到Y的最短路径。procedureshort(n.x,y.g【在n个点的网上求x到Y的最短路径.关联矩阵是gprocedurefd(x.y,z{递归子过程，从x到Y，总步数z}" ID="16">
        <fptr EndPN="00000139" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="varf=byte;{f为子过程局部变全｝" ID="17">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="begin‘开始递归子过程）forf:=1tondo｛让f从1到n寻找邻接点｝" ID="18">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="if(g[x.f0)and(b[f］一0)then｛判断是否f点在x邻城并且f点没走过}" ID="19">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT=".rr。一r,口福.r占aan鑫4ti" ID="20">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="forj1tokdoc[j]：二a[i]｛依次更换当前最短路径中的每个点｝" ID="21">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="ends{衷更薪}" ID="22">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="11-g[x,f｛退掉f点.先在当前路径长度中减去退出的一条边长｝" ID="23">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="b[f]：二0｛把f点恢复为没有走过》end{结束x邻城的搜索｝end;{结束递归调用的子过程》begin《开始对有。个点的图找从x到Y的最短路径的过程｝min.二max《先把当前最短路径的长度设t一个比较大的数）" ID="24">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="fori-ltondob[i]：二设图中每个点为没有走过｝" ID="25">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="a[11：二x;｛出发点进找）b压〕：＝1.f记录出发点已经走过｝t0;{没有向外走时当前路径长度为。｝" ID="26">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="fd（x，y，2）。七在x到Y的路上走第2点以后的路径｝" ID="27">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="fori：二1tokdowrite(c[i]：3{抽出最短路径》writefn(min:5粉出最短路径的长度；end;这里的深度优先搜索主要体现在递归子过程fd当中，而这个子过程中的关键部分又主要包含在f循环中。为什么在循环中进到f点后又要从这点退出呢？事实上，进到f点后又要调用自身（除非己经走到目标点）去寻找新的f点“是局部变童.前后用到的f是不同的〕，所以从下一级调用返回时，上面走过的一段路径经过当前f点再走下去的所有走法已被遏历完了，以在不增加什算量的前提下得到X通向每个点的最短路.当然，这需要为每个点都设当前长度和当前最短长度两个变量和一个记录最短路的线性表，这当然要付出相当的存储空间。在本节的最后，我们还要研究一个寻求路径最短的问题―“中国邮路”问题.这个问题早在1958年就由我国学者最先提出，所以被各国数学家称为“中国邮路”间题，它有着非常明显的实际意义.问题是这样的，在某邮局的邮递区域中。把邮局所在地和邮递线路上的所有叉路口及死胡同的尽头都作为图中的点，而把这些点之间的街巷作为边就形成了一个图，一个邮递员从邮局出发，要经过每条邮递线路又回到邮局，怎么走才能使经过的距离最短？在图上看，就是从一个特定点出发，走遍每条边回到这个特定点，怎样走最短？这里的每条边既可以是加权的也可以是不加权的。投递线路上的死胡同尽头和三叉路口、五叉路口等都对应着图上度数为奇数的点，它们被·奇点。理论上的分析和推理可以证明，一个无向图中如果有奇点，其数目一定是偶数.没称为奇点。有奇点的情况对中国邮路是最理想的情况，此时一定存在从出发点走出，经过所有边后回到出发点的路径而且每条边只被走一次，显然，这就是符合要求的最短路径。当奇点存在时，即使是满足要求的最短路径存在，也必定存在被重复走过的边，当然每条边被走的次数总共不会超过两次.求出中国邮路间题的最佳解有很专门的算法，它可以保证计算复杂性很低。而此处我们暂时仅围绕学过的算法来寻求解决的方案。例S.12在n点的图中从c点出发寻求经过每条边后回到c点的最短路径。上一个算法比较从x到Y的所有路径从而得到最短路的方法可以借鉴，只是这里出发点x和目标点y都是同一个点。。搜索的策略仍然是深度优先，但不能对点进栈（走过）的次数加.以限制，因为点和边都有可能被重复走，但要限制每条边被走的次数不能超过两次.由于要求的路径必须经过每条边，可以设什一个函数来什数没有走过的边数。procedureshort{n.c.g)t｛在有n个点无向图中.以c为出发点搜索最短路径，B是邻接矩阵｝" ID="28">
        <fptr EndPN="00000140" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="functionalleige(n:g)si&quot;先自定义一个函数，计算8中没有走过的边数｝" ID="29">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="begin｛函数开始}" ID="30">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="s：二。。｛。清。，将以，计数没有走过的边数｝" ID="31">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="forx:”1tondo‘行变量从I到n}" ID="32">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="fory;=1tondo{J变f从］到n}" ID="33">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="ifg[x.y0thenss±g[x.y]t（计数尚未走过的边数1slleigest｛将什数结果作为函数返回值}ends（函数结束｝" ID="34">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="begin｛搜索最短路径的过程开始）min：二max:{当1！最短路的长度先设置为一个比较大的数｝1at｛没有搜索之前，当前路径长度是。卜a[I]：二c:{出发点进槐}" ID="35">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="i1;{找指针的初值是1}" ID="36">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="j。;{j代表即将搜索的点号，设为a，将从1开.考愈}" ID="37">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="rg;（复制一个邻接矩阵r以记住每条边走过的次数｝" ID="38">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="repeat‘开始深度优先搜索｝" ID="39">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="j；二：Ci7:（先取出要退掉的点送j｝" ID="40">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="is=i-t,｛退出最后一点.栈指针回缩｝" ID="41">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="ifi&gt;6then3I断是否已后退掉出发点乡" ID="42">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="begin｛如果役退完）ka[i]i｛将后退到的点取到k中）1：二1-gCk.i（在当前路径长度中去掉退出的边长1r[k,j]：二r压，j〕＋9〔k.j二；｛恢复边的一个方向（弧）｝" ID="43">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="r自.kr口，k」＋只自，k皿不恢复此边的另一个方向（弧）tcndendel二if（r［k，j〕＞＝一9压.j］）and‘j对应图中点时判断这点是否走过两次｝(1+g[k,jmin)and(g[j,k0)then{f断当前点与这点是否相邻及当前路是否超长}begin{相邻且未走过两次且当前路径长度未超过当前最短路长度时则开始｝" ID="44">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="r[k.j]：二r[k,j〕一g[k.j【记录此边已被走过｝" ID="45">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="r肠，k〕：二r口，k」一K[j.k]r{此边的另一个方向同时也应记走过一次｝" ID="46">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="11+gCk.i7:｛走过的路径长度增加新边的长度｝" ID="47">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="i：二1十is;指针后移，准备将r点进栈｝" ID="48">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="aCi=i新点，进人栈顶｝if(j=c)and(alleige(n.r）二o)then{1断是否回到c点且走过所有边1begin{条件满足就更新最短路径及其长度｝" ID="49">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="wins=1s{更新最短路径的长度｝" ID="50">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="z：二i｛更新当前最短路径的点数｝" ID="51">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="fork:=1tozdo｛更新最短路径中的每一个点｝" ID="52">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="b[k]：二a[k]｛新点换旧点｝end结束更新过程｝je=4{将j$0.进新点后将再从第1个点开始搜索｝enda{结束进栈｝untili二。。｛直到栈已退完.就结束深度优先搜索｝fork：二1tozdowritc(b[k2i输出最短路径！writeln(mins5)ends" ID="53">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
      <Paragraph CONTEXT="减到两次时：中的相应元素就是8中相应元素的相反数了。判断两点是否邻接时还是以S数组为准.关子进栈时的条件为什么多了一个“是否长度已经超过”，这是为了尽可能地减少无用的搜索次数.因为点进栈的次数不受限制.边也允许重复走，增加了搜索的次数，提前判断路径" ID="54">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000141" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="141" PhysicalPageNum="141"/>
      <Paragraph CONTEXT="(2〕以1得到的二维数组为参数.编写算法由它得到邻接表的一维数组表示。" ID="1">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）编写算法，由工的二维数组产生邻接矩阵。" ID="2">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）编写算法，由1的二维数组产生关联矩阵。" ID="3">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="2。编写算法，在图8.5的中国象棋盘上求出马从左下角跳到右上角的最短跳法，只允许马从左向右跳。（提示：用广度优先搜索）" ID="4">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="3.有7级台阶，每步允许迈1级、2级或3级台阶，上完这7级台阶共有多少种不同的方法？是哪些兮" ID="5">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
      <Paragraph CONTEXT="4.有三个可以装米的桶，三个捅的容量分别是3千克，5千克和8千克，起初3千克和5千克的桶都装满了米，8千克的桶空着，怎样通过各桶之间倒来倒去把米平分为两个4千克分别装在5千克和8千克的两个桶中？共有多少种方法？是哪些？其中哪种方法步骤最少？" ID="6">
        <fptr EndPN="00000142" StartPN="00000142"/>
      </Paragraph>
    </div>
    </div>
  
</METS>
