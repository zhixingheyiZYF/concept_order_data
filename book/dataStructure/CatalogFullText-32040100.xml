<?xml version="1.0" encoding="utf-8" standalone="no"?>
<METS xmlns:METS="http://www.loc.gov/METS/" xmlns:gdm="http://sunsite.berkeley.edu/GDM/" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" TITLE="Zhejiang University.jdl.China-America digital library project" TYPE="Section" xsi:schemalocation="http://www.loc.gov/METS/http://www.loc.gov/standards/METS/METS.xsd">
  
    <div ORDERLABEL="00000011" TITLE="第一章  绪论" TYPE="Chapter">
    <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
      <div ORDERLABEL="00000011" TITLE="1.1  什么是数据结构" TYPE="Chapter">
      <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
        <div ORDERLABEL="00000012" TITLE="1.1.1  数据结构相关事例" TYPE="Chapter">
        <fptr LogicalPageNum="12" PhysicalPageNum="12"/>
        <Paragraph CONTEXT="为了说明什么是数据结构，我们先讨论现实生活中的几个例子。间题一：电话号码簿的使用及字典的使用。当用户拿起一本厚厚的电话号码簿，查找自己需要的单位或个人的电话号码时，一定是从电话号码簿的分类目录开始渣找相应的大类别然后根据所查找到的大类别后面指定的页码，翻到大类别的起始页，再从特定的大类别中查找小类别，从检索到的，fJ别下面顺序地找到用$Picture[00000012\00000012_new\0006.jpg]Picture$户所要的单位或个人的电话号码（如图l.l.l大、小类别可以看做电话号码簿的目录或索引。如果电话号码搏缺少类别索引，而是按照电话安装先后的顺序进行排列或毫无规律地排列，用户会使用这样的电话号码薄吗？如果电话号码簿只记载着一个部门的十几部或几十部电话，还需要分类吗？" ID="1">
          <fptr EndPN="00000012" StartPN="00000012"/>
        </Paragraph>
        <Paragraph CONTEXT="问题就是数据量的多少。少量数据的查找无需考虑数据的组织形式，而大量数据如果没" ID="2">
          <fptr EndPN="00000012" StartPN="00000012"/>
        </Paragraph>
        <Paragraph CONTEXT="有合理的组织形式，查找过程就只蒯须序地进行，从而导致用户无法接受；在合理的数据组织有若干个发往同一方向不同城市的货车车皮以随机的次序到达货站的进车道，如图1.1.2听示，整个货站由三部分构成：进车道、出车遣和调度道（中间多条车道）}o应雀5,1©4,3,24,2,5,1,7,67.5,S,4.3.2.1图1.1.2车皮调度间题由于货车的车皮从当前货站发往不同目的地.所以，货车发出本站时，列车的尾部所挂接的车皮应该是发往距本货站最近的车皮，这样可以保证到达某车站时从尾部“甩下”若干到站的车皮。可问题是不同的货运委托用户的车皮是以随机的次序到达货站的进车道，为了便于说明，我们假设发往较远站点的车皮的编号比发往较近站点的车皮的编号要小，从图中可以看到进调整为小编号在前、大编号在后的排列次序，即出车道上的次序。为实现调整过程，货运站需要借助调度车道完成，调度车道由若干条备用车道组成，调度过程可描述为：将备用车道上第一个到达的车皮（编号为6的车皮）任选一备用车道进人；运算过程（以后再讨论）是一定的。" ID="3">
          <fptr EndPN="00000014" StartPN="00000012"/>
        </Paragraph>
        <Picture URL="00000014\00000014_new\0002.jpg">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Picture>
        <Picture URL="00000014\00000014_new\0003.jpg">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Picture>
        <Paragraph CONTEXT="对上述三个间题进行归纳可以发现：" ID="4">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="第一个问题中，数据可以看做由三个表存放，表与表之间的关系是由每个表项中的页码关联的；每个表中的数据之间的关系是由前后存放的次序进行关联的；检索时，前两个表之间利用页码指向跳跃查找，在第三张表中则顺序查找。这个间题涉及大妞数据，所以在处理中要合理刹咧数据。" ID="5">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="第二个问题中，数据在进车道是按照先来排在前、后来排在后、不允许中间擂入的原则形成一个队列；在调度过程中，将进车道中的队列分散到不同的备用车道，每个备用车道又是一个有序的子队列；最后，再形成一个有序的完整队列进人出车道。每个队列中元素以进人的先位二水旧顺中粉樱具由而个生会妇吩“丽占”生吞山左访首丽占左旋“角妇“边”集合中存放着边的长度和边所关联的是哪两个顶点，两个集合中的数据可以是无序的；运算过程是找出较小的边，且保证保留的边使所有顶点间‘.连通’，但不形成环形路。这个问题的数据存放为两个集合。从上面的三个问题可以看出，这些问题的模型都无法用数学的公式或方程或函数来解决，它们都是“非数值计算的问题”。" ID="6">
          <fptr EndPN="00000014" StartPN="00000014"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000014" TITLE="1.1.2  数据结构的定义" TYPE="Chapter">
        <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
        <Paragraph CONTEXT="综上所述，我们可以这样给数据结构这门学科下个定义：数据结构就是研究让算机中大量数据存储的组织形式，并定义且实硕妞寸数据的相应的运算，以提高计算机的数据处理能力的一“运算”或“操作”是数据结构讨论内容的一个筷合间题。不同实际问题具有不同的处理要求，所有的处理要求要进行事先定义.并用计算机的某种语言给予描述，这就是“算法设计’。算法不仅要实现向题的要求，而且应该是高效地完成。低效的算法无法满足用户的需求程度地满足用户处理要求，而一个低效的处理算法设计的程序即使运用高速运算的计算机也不能满足用户的处理要求。" ID="1">
          <fptr EndPN="00000015" StartPN="00000014"/>
        </Paragraph>
        <Paragraph CONTEXT="对实际问题的处理能力不仅取决于计算机硬件本身的处理能力，而且更多地取决于对数据结构的合理组织以及相应处理算法的优劣，" ID="2">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000015" TITLE="1.2  数据结构的相关概念" TYPE="Chapter">
      <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <div ORDERLABEL="00000015" TITLE="1.2.1  数据和信息" TYPE="Chapter">
        <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <Paragraph CONTEXT="在计算机中，数据这个名词的含义异常广泛，可以认为它是描述客观事物的数字、字符，以及所有能输人到计算机中并能为计算机所接受的符号集合的总称。成语言。数据是信息以某一类特定符号表示的形式，是计算机程序加工的对象。随着汗技术的发" ID="1">
          <fptr EndPN="00000015" StartPN="00000015"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000015" TITLE="1.2.2  数据元素" TYPE="Chapter">
        <fptr LogicalPageNum="15" PhysicalPageNum="15"/>
        <Paragraph CONTEXT="关键码，反之称为次关键码或次码。「.d:nr1厂蕊东甲1/I:PSCF.一n:netc！’川‘卜，！L" ID="1">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Picture URL="00000016\00000016_new\0008.jpg">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Picture>
      </div>
        <div ORDERLABEL="00000016" TITLE="1.2.3  结构类型" TYPE="Chapter">
        <fptr LogicalPageNum="16" PhysicalPageNum="16"/>
        <Paragraph CONTEXT="数据结构中讨论的结构类型分为两个层面，一是逻辑层面的数据结构。简称逻辑结构；另一个是物理层面的数据结构，简称物理结构。" ID="1">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="t.逻择结构逻辑结构描述数据元素与数据元素之间的关联方式，简称为关系，表示的是事物本身的内在联系。逻辑结构又可以分为：线性结构和非线性结构两大类。线性结构的特点表现为，数据元素之间存在前后次序，排在某个数据元索b前面的数据元素a称为b的直接前驱元素，而数据元素b则称为数据元素a的直接后继元素。对于某个数据元素，如果存在直接前驱元素或直接后继元素，则都是惟一的《如，队列结构〕。线性结构中数据元素之间的正逆关系都是“尹对一”的。线性结构又可再分为：线性表、堆栈、队列等。非线性结构的特点表现为：数据元素不一定存在确定的前后次序.甚至是无序的，数据元素之间存在从属或互为从属的关系或离散关系。非线性结构又可再分为树形结构、图状或网状结构、纯集合结构。在树型结构中，数据元索之间存在着“一对多”的关系。某个数据元素a（结点）可能有多个分枝，每个分枝所联接的数据元素从属于数据元素a（多个数据元素从属于～个数据元在图或网状结构中，数据元素之间存在着“多对多.的关系。如城市间的公路间题，每个城市数据元家与多个城市数据元素相邻接，这些邻接数据元家相互之间不存在从属关系或理解为相互从属。在纯集合结构中，数据元素具有“同属于一个集合1，的关系。" ID="2">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="纯集合结构和集合结构是不同的，纯集合结构中只有数据元素本身，而不存在数据元素之" ID="3">
          <fptr EndPN="00000016" StartPN="00000016"/>
        </Paragraph>
        <Paragraph CONTEXT="2.物理结构物理结构也称为存储结构，是逻辑结构的数据元素在计算机的物理存储空间上地映象，映象不仅包含数据元素本身，而且包含着数据元素之间的关联方式，即关系的映象。映象表现为两种方式：顺序映象和非顺序映象。（1}顺序映象。顺序映象是指数据元家连续地在一块物理存储空间上存储，物理存储空间只用于存放数据元素本身，数据元素之间的关联以两个数据元素存储的相邻关系来表示或通过某个函数来表示。或者说，利用数据元素在存储空间上的相对位置来表示数据元素之间通过某个函数来表示。如一组成绩信息，每个数据由姓名和成绩两个数据项构成：｛｛彭亮，97｝,（王明，9s1,李智，90｝,f刘丹，ss1,！肖象，s数据元素是按成绩从高至低的顺序祠咧，即按成绩从高至低关联，在物理存储空间上的存I'ao0onl5LGHI10顺序映象的最大优点就是空间的利用率最高，但一旦要在中间插人数据元素或形除中间数据元素，就必须移动大最数据元素，这种运算在计算机中是相当耗时的。{2)非顺序映象。非顺序映象是指数据元素在物理存储空间上非连续地存储，物理存储" ID="4">
          <fptr EndPN="00000018" StartPN="00000017"/>
        </Paragraph>
        <Paragraph CONTEXT="空间不仅存放数据元素本身，而且为实现数据元素之间的关联，在每个数据元素存储的相邻空" ID="5">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="间中存储该数据元素关联的另一个或多个数据元素的起始地址。也可以说数据元素之间的关成绩信息的物理映象如图1.2.4所示。平杏" ID="6">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="在非顺序映象存储结构中.数据元素的逻辑结构一般在物理空间上不是以物理空间的相" ID="7">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="。邻来表孤而航针数据元素本身所占用空间的相邻空间侧，，决／）" ID="8">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="物理存储空间上的映象如图1.2.6所示。这裸树在物理存储空间上的映象是离散的，物理空间上除存储每个数据元素本身外，还利" ID="9">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="指向空地址。" ID="10">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="树的起点地扯" ID="11">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="今今＋卒" ID="12">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="3‘数据域和链接域(1}数据域。数据域是物理存储空间中存储数据元素中数据值的空间，如成绩数据间题" ID="13">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="中，存储姓名和成绩两个数据项，所占用的空间大小（字节数）依实际应用的数据元素中包含的信息量的大小而定。" ID="14">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)链接域。链接域又称指针域，是非顺序存储映象时表示数据元素之间关系的地址存" ID="15">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="储空间，是额外的空间付出。一般地，在特定的计算机中，存放存储单元的地址所占用的空间" ID="16">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="士ihf节断、撼一宁赫＿众丽良左按她势沙如由雄体倩且丈方＊份粉提二害今偷羊罗曰大小（字节数）是一定的。以物理存储的邻接方式隐含表示的。" ID="17">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000019" TITLE="1.2.4  静态存储空间分配和动态存储空间分配" TYPE="Chapter">
        <fptr LogicalPageNum="19" PhysicalPageNum="19"/>
        <Paragraph CONTEXT="我们对数据结构的逻辑结构和物理结构已做了较详细的讨论，但未涉及物理存储空间的" ID="1">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="存储管理。存储管理不是研究某种数据结构，而是为满足各种数据结构对存储的不同要求，研究数据元素的空间分配、回收的方法和机制。" ID="2">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="计算机的物理存储空间是有限的宝贵资源，对于每个空间的使用都要保证有效、合理。计算机中的物理存储空间的使用包括两个方面：分配和回收，即数据元素对空间的使用（分配）和数据元素使用过的空间的回收。这就如同把计算机的所有物理存储空间看成饭店中的床位，某旅客人住时.只要饭店还有床位，就可以向管理饭店的管理员申请床位（分配），当旅客离开饭店时，就要到管理饭店的管理员处办理退床位（回收）手续。对于一个团队在申请住房时，如果团队本身要求按相同性别及相同或相邻年龄逻辑顺序" ID="3">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="z.动态存储空间分配如果饭店保证按性别及年龄逻辑顺序逐个地具体安排某个人的床位，这时，饭店可能有连续的床位进行安排，也可能没有连续的床位进行安排（分散安排），但要保证相同性别、相邻年" ID="4">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="中途离开或集体离开，该饭店管理员将为每个顾客逐个地办理退床位手续。键的是逐个地申请床位，逐个地退掉每个床位。如果团队中有人这种方法中最关" ID="5">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="在计算机中如果按逐个地申请数据元素空间，逐个地回收数据元素空间的模式完成空间的分配或回收，我们将这种方式称为动态存储空间分配。在动态存储空间分配模式下，数据元" ID="6">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="素的物理映象是非顺序映象，因为逐个获取的数据元素空间在物理上不一定是连续的。这种逐个地获取或回收反映了“动态性”。实际中，如果某用户使用c语言进行程序设计，程序中需要若干个变量空间，在c语言中" ID="7">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="利用mai】。(）函数或new申请变量空间（动态空间申请），如果某变量空间不再使用，则利用free(}函数或delete释放变量空间（动态空间释放）)o即C语言负贵逐个空间的分配及逐个空" ID="8">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="间的回收。" ID="9">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="可见动态存储空间分配模式下，数据元素的存储过程是一步完成的，即获取单个物理存储空间的同时完成数据元素在物理空间上的映象。" ID="10">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="对上面1寸沦的两种获取物理空间的模式分析后，我们引人一个存储池的概念，在计算机中将所有的物理存储空间称为存储池。对于操作系统而言，整个内存和外存都是存储池；C语言" ID="11">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="在计算机系统中，操作系统擞据结构、编译原理、高级语言等都涉及物理存储空间的分配，为存储管理。不同的是，每个学科的侧重点不同，概括地说，计算机系统中的存储管理分统称为存储管理。" ID="12">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="为了更好地描述数据结构的内容，我们将用到许多术语。对相关的术语，我们在本节中给出确切的含义，以便在今后的学习中能有统一的概念。" ID="1">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000020" TITLE="1.3  数据类型、抽象数据类型和数据结构" TYPE="Chapter">
      <fptr LogicalPageNum="20" PhysicalPageNum="20"/>
      <Paragraph CONTEXT="机，运算器和控制器的作用是相同的，只是徽型计算机中的运算器、控制器在制作时被集成在一个芯片上。事实上，一个系统是由多个对象构成的，往往存在多个具有共同特性的对象，表示为：oi,伍，…，0。，…等对象都具有特性Pi,ps，p，则具有特性p1,P2，p的对象便是O：,Ox,，二，氏，一等对象的一个抽象。在计算机语言中，这样的抽象称之为“类”或“数据类型”。换言之，" ID="1">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="类或数据类型刻画了一组具有共同特性的对象。数据类型具体含义是，它描述了一组数据和在这组数据上的操作或运算及其操作或运算的接口。" ID="2">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="一组数据是具有相同特性的数据集，例如.整数构成一个数据集，字符构成另一个数据集。" ID="3">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="数据集的个体可以是由单数据项组成，也可以由多数据项组成‘而又临隋相同特性的数据的操作或运算具有限制性。例如，而又临隋相同特性的数据的操作或运算具有限制性。例如，整数可以进行加、减、乘、除、乘方运算；字符可以进行联接、求子字符串、求子字符申在主串中的位置序号。操作或运算的接口是约定在该数据类型上定义的一组运算或操作的各个运算名称，明确" ID="4">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="各个运算分别要有多少个参数及其参数的含义和顺序。在对象式语言的程序中，程序中有一个或多个数据类型组成，在程序运行时，视需要创建该数据类l的各个对象，即具体实例。如在C语言中用数据类型int定义整±J变ta并赋值，a就是一个对象。因此，数据类型是静态的概念，所创建的该数据类型的各个对象是动态的概念。" ID="5">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="2.抽象数据类型{abstractdatatypoA.D')是抽象数据类型在对象式程序设计语言中的具体实现。可以说，抽象数据类型是数据类型概念的引伸和发展。使用抽象数据类型将给算法和程序设计带来很多优越性：顶层算法或主程序的设计与底层算法或子程序的设计被隔开，使得在进行顶层设计时不必考虑它所用到的数据和运算具体表示和实现；反之，在进行底层数据表示和运算实现时，只要按照抽象数据类型定义的结构（名称和参数疾现.不必考虑它什么时候被引用。这样做，算法和程序设计的复杂性降低了，有利" ID="6">
        <fptr EndPN="00000022" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="于迅速开发出程序的原型，减少在开发过程中的差错。编出来的程序自然地呈现模块化，而且，抽象的数据类型的表示和实现都可以封装起来，便于移植和重用，为自顶向下逐步求精和模块化设计提供一种有效的方法和工具。" ID="7">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="3.数据结构、数据类型和抽象数据类型数据类型和抽象数据类型.我们已经在前面较详细地讨论过.对于它们的相似性和相异性以及联系有了了解。那么它们与数据结构是什么关系呢？数据结构作为计算机科学与技术领域的一门学科来讲，前面我们已经定义了，从狭义的理解，它用来反映一个数据的内部构成，即一个数据由哪些成分数据构成。数据是按照数据结构分类的，具有相同数据结构的数据属同一类。数据是按照数据结构分类的，具有相同数据结构的数据属同一类。同一类数据的全体称为一个数据类型，数据类型用来说明一个数据在数据分类中的归属，这个归属限定了该数据的变化范围和运算。不仅如此，数据结构还定义数据的逻辑结构和物理存储结构及其相应的物" ID="8">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="理存储映象。" ID="9">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="简单数据类型对应于简单的数据结构；构造数据类型对应于复杂的数据结构；在复杂的数的结构，因而允许属于不同的数据类型。可见，数据结构是一个或多个数据类型的结构体，抽象数据类型的含义又可理解为数据结构的进一步抽象。即把数据结构和数据结构上的运算或操作捆在一起，进行“封装”。对于抽" ID="10">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="象数据类型的描述，除了必须描述它的数据结构外，还必须描述定义在它上面的运算或操作" ID="11">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（过程或函数）)o" ID="12">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="4.抽象数据类型的三元组表示" ID="13">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="抽象数据类型可以形式化地定义为三元组：" ID="14">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="ADT=(Dset,Rset,OPset)" ID="15">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="其中，DSGt表示数据元素集，RsCt表示数据元素的关系集，OPSet表示对数据元素的基本操作" ID="16">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="集。以后为了全书的一致，约定以下面的格式描述各种抽象数据类型：" ID="17">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="ADT抽象数据类型名｛set:【数据元紊集描述】Rset：数据元素如果不空，则被分为根结点、左子树、右子树，每个子树仍是一个二叉树OPaet:" ID="18">
        <fptr EndPN="00000023" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="实现时，可能只讨论其中部分典型运算或操作。" ID="19">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000023" TITLE="1.4  算法及算法分析、算法描述" TYPE="Chapter">
      <fptr LogicalPageNum="23" PhysicalPageNum="23"/>
        <div ORDERLABEL="00000023" TITLE="1.4.1  算法和程序" TYPE="Chapter">
        <fptr LogicalPageNum="23" PhysicalPageNum="23"/>
        <Paragraph CONTEXT="t.算法算法是指解决问题的一种方法或一个过程。算法可以理解为函数的另一种表述，所以，一个给定的算法解决一个特定的问题。算法也可以描述为：算法（魂州山扭）影乍空的、有限的指令序列，遵循它就可以完成某一确定的任务。它有五大特征：" ID="1">
          <fptr EndPN="00000023" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）有穷性：一个算法在执行有限步骤之后必须终止。输人影响的特定工作。输出说明的是，算法至少有一个输出，且要求算法给出的输出是所期望的结果。" ID="2">
          <fptr EndPN="00000024" StartPN="00000023"/>
        </Paragraph>
        <Paragraph CONTEXT="2.算法与程序程序是使用某种程序设计语言对一个算法或多个算法的具体实现。同一个算法，由同一个算法，由于使用不同的设计语言实现，所以可能有许多程序对应于同一算法。算法必须提供足够的细节才能转化为程序，算法是可终止的，但程序不一定，程序可在无外来干涉情况下一直执行下去，可以既无输人又无输出信息。操作系统是一个程序，而不是一个算法，它可以在不发出停止命令的情况下无限地运行下去。但操作系统所完成的每一个功能就是要解决的一个问题，每一个问题由操作系统程序的一部分（即算法）来实现，且必须在有限步骤、有限时间内结束.并得到输出结果。" ID="3">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000024" TITLE="1.4.2  程序性能和算法效率" TYPE="Chapter">
        <fptr LogicalPageNum="24" PhysicalPageNum="24"/>
        <Paragraph CONTEXT="所谓程序性能，是指运行一个程序所需的时间和空间大小。侧量程序性能的方法可以通过直接执行程序，即实验法。另一种方法是分析法，分析程序编码的优劣。在编制程序时，首先应该根据要解决的问题和数据性质选择一个恰当的数据组织结构和针对该组织结构的好的算法。在相同数据组织结构下，对同一间题的不同算法首先要求具有" ID="1">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="实际中.有些程序不能完全满足用户的全部要求，如有些用户限定程序运行时间的上限，程序运行一旦达到上限，就被强制结束，即运行时间过长；有些程序需求空间太大，系统资源无法满足，或随着运行过程，对空间的需求不断增大，结果最终导致空何被耗尽。可见.程序是由算法组成的，程序的好坏是由算法的优劣所决定的。衡量程序的性能就是从空间复杂性和时间复杂性两方面衡量算法的性能。" ID="2">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="那么，如何衡量一个算法的好坏呢？从根本上讲从根本上讲，就是算法要有效利用钊娜机的资源。具体说，首先应确保算法满足上述五个性质，此外，通常还要考虑以下三个方面。" ID="3">
          <fptr EndPN="00000024" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)依据算法所编制的程序在计算机中运行时占有内存容量的大小（也要考虑占辅存容量的多少）.即空间特性。用一定的存储字节，程序中还定义了整型变量k，用于循环控制，则系统需也要为k变盈分配一定存储字节。Facboial(n-2}.Pactorial(1}" ID="4">
          <fptr EndPN="00000025" StartPN="00000024"/>
        </Paragraph>
        <Paragraph CONTEXT="Faaorial(4)" ID="5">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="2.时间复杂性一个程序在计算机上运算所消耗的时间主要取决于下述因家：" ID="6">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)程序运行时所需要输人的数据总量消耗时间。" ID="7">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）对源程序进行编译所需要的时间。" ID="8">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）计算机执行每条指令所需要的时间。" ID="9">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）计算机关键指令重复执行的次数。在上面四个因素中，前两个取决于问题本身数据量多少，第三个因索取决于计算机的硬、系统的客观条件。因此，一般把第四个因素作为分析算法时间效率的重点来讨论。软件系统的客观条件。分析第四个因素主要可从两个方面估算：(找出一个或多个关键操作，确定这些关键操作所需要的执行时间；" ID="10">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）确定程序执行步骤的次数，尤其是执行关键操作的次数。程序执行过程中，数据的比较、变盈的赋值（数据移动）、过程或函数的调用都是程序的关键性步骤，尤其是变量的赋值（数据移动）、过程或函数的调用步骤对程序时间复杂性影响较" ID="11">
          <fptr EndPN="00000025" StartPN="00000025"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000025" TITLE="1.4.3  算法分析" TYPE="Chapter">
        <fptr LogicalPageNum="25" PhysicalPageNum="25"/>
        <Paragraph CONTEXT="为此，我们引人语句频度的概念（frequencycount)。所谓语句频度即为“操作步骤”或“语算法中处理数据对象的数量或间题的规模的度量，如一算法时间复杂性是：T(n}2n3n2叶I当n足够大时有T（”卜2n3或者g(nr2n3。因为,n足够大时Zn3的复杂度大大超过3n+2n+1,或者说，T臼）数量级与矛数量级相同。所以，当n足够大时，可以忽略复杂性函数中复杂性较低的部分，而只用复杂度高的部分表示。为此.我们进而引人渐进符号“d&quot;，用大写O字母表示函数T(n)的上限函数，即当n足够大时的函数，记为：0{g(nO(n勺o下面给出1i仲典型的复杂性函数的表示（a,b,c为已知数）：线性函数：a(g(n拭(a*n+b)式(n)" ID="1">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="平方函数：以助）卜以色.nz化.n）试Xn勺" ID="2">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="指数1数：0以n）卜以犷化＊矿妇，n卜以们常数函数：O(g(n9+120(1)对数函数：O(g(n)kQa*n*logrn+b*n0(n*IogZn}常数函数是指算法的复杂性与算法中处理数据对象的数量无关，比如，" ID="3">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="T(n卜IS，川01众n：。川臼j＝cl，1臼1＋a【lllkl＊b［kl臼1；" ID="4">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="5">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="其中，每一语句的频度如上述算法右列所示。整个算法中所有语句的频度之和可约定作" ID="6">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="叹n二3+3nZ+2rt+I" ID="7">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="显然，它是矩阵阶n的函数，并且当n足够大时，则有T(n}（量级a户）p" ID="8">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="fx二又+1，其执行时间是一个常数，因此，其时间复杂性是常量级，即also在（b）中，同一语句：二z+1执行了n次.其频度为n，其时间复杂性依赖于m，所以，时间复杂性为O(n在（。）中，语句：=a+1执行了n*n次，频度为nx，其时间复杂性依赖于。z，因此，时间复杂性为。(nz}a由于频度的不同，算法执行的时间也会有很大的差异。f厂／派’一区麦笙士三二一a-oiswn图1.4.1各种数量级的T(n)一个算法的时间复杂性是反应算法性能的重要指标。对于某一问题而言，如果算法时间或1万倍，我们来分析一下上面这S个算法所能处理的输人量的大小有何变化。表1.4.2说明了由于计算机速度的提高给每个算法所带来的处理能力的改变情况。算法Al和A2在计算机的速度提高10倍或1万倍后，同一时间里所能处理的输人量几乎也增加10倍或I万倍；而算法A3和A4就差一些，最令人沮丧的算法A5，即使计算机的速度提高1万倍，算法AS在某一时间内所能处理的输人量不过比原来增加13个左右，真是寥寥无几。表IA.2计算机速度提离10倍和1万倍的效果淞时雌，麟鲍少梦邺呼处理提高to'r竺etll“速”曳互竺竺黔艺“内能" ID="9">
          <fptr EndPN="00000028" StartPN="00000027"/>
        </Paragraph>
        <Paragraph CONTEXT="兀州外’～的且大抽人f理的最大佑入最处理的最大钧人t人Insll0Sll加叹151”、。52对大的52接当’竖呀竺翌钾时，＿一＿，－－－－－·，－－·－－一一’一超过，。扣52幻n2533.1‘5310053幻n2533.1‘5310053A4n］斗2.皇55421＿，454舫户5555＋33255＋13.32对于表1.4.2不难推出这样的结果：对于算法AS而言，一台高速计算机在1分钟内所能处理完的输人量只不过是一台速度为它万分之一的低速计算机1分钟内所能处理完的输人量的两倍。由以上例子可以看出，随着计算机应用的发展和要求处理的信息量越来越大，设计出高效的算法是十分重要的。程序运行所占的存储量，同时也是问题规模的函数，它和时间复杂性类似，我们将以空间复杂性作为它的度量。法。然而，实际上不可能做得十全十美，时间性和空间性往往是一对矛盾。许多程序中数据经过压缩节省了存储空间，而运行时解压缩的过程又需要额外的时间；再如，物理上顺序映象可" ID="10">
          <fptr EndPN="00000028" StartPN="00000028"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000028" TITLE="1.4.4  算法描述" TYPE="Chapter">
        <fptr LogicalPageNum="28" PhysicalPageNum="28"/>
        <Paragraph CONTEXT="C什风格C风格ERRQit二O;禅def刀。ERROR0;eoumtool{TRUE,FALSE}enumStatus}OIERROR}" ID="1">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="2.数据元素结构的表示用类型定义" ID="2">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstirruct" ID="3">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="｛DaraTpedata:II数据元素其他数据项定义；da扭：" ID="4">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="3.算法函数的描迷（函数类型）＜函数名＞〔函数形式参数表）】函数形式参数表中，以＆开头的参数即为引用参数，引用参数能被函数本身更新参数值，可以作为输出数据的“管道”。" ID="5">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="4.内存空间的动态分配和释放" ID="6">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="C升风格C风格分配空间：指针变量二即数据类型；分配空间：指针变最月川山“（数据类型大小）：释放空间：del.指针变觉；释放空间：仓二（指针变里）；" ID="7">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="5.检入输出语句C＋＋风格C风格翰人：。1公州交量1＞＞…》变盘。‘输人：翻，口f（应变盆）；-J出：c鲤坚烤世达些＜.泛多终和；＿＿＿＿＿＿＿一鱼鱼兰卫鱼丝工鱼达式玉―一一" ID="8">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="计算机本身是人们进行信息处理的工具，解决什么间题、如何解决是人们提出问题并利用从数学的角度而言，可以把解决间题看做定义函数，并利用定义的函数完成刘薄。函数是输人和输出之间的一种映射关系，函数的输人就是计算机程序中的参数，可以是一个值或多个值.这些值经过函数式的计算，将产生相应的物出。不同的输人可以产生不同的输出，但对于同样的输人，函数的计算输出一定是相同的。" ID="1">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="同一个问题的解决函数可能不止一种，对同一个问题利用不同的函数运算就是对相同的愉入经过不同的运算方法进行处理，但不同函数的运算结果应该是相同的。" ID="2">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000029" TITLE="习题一" TYPE="Chapter">
      <fptr LogicalPageNum="29" PhysicalPageNum="29"/>
      <Paragraph CONTEXT="12一什么数据类型?" ID="1">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="13.什么是抽象数据类型？i4.数据类型和抽象数据类型的关系是什么？巧.什么是算法和程序？算法和程序的区别是什么？" ID="2">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="16.程序性能主要从哪几个方面来分析？" ID="3">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="17.算法效率主要从哪几个方面来分析？" ID="4">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="18.什么是算法？算法的五大特征是什么？to瞥kbhtr,Flat,Fin六[枪fifi月.朴瓜，19.20.时间性分析中，影响算法时间效率的主要方面是什么？，，得装如丫在砚＊血兰闷p雀宣妹大烤之史的右乃日甘，" ID="5">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="21。" ID="6">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="22.试给出下列算法的时间复杂度和空间复杂度的分析：〔1）某个单位职工都有一张职工登记表，设想在任何组合的条件下（如只知道姓名；知道姓名和单位；知道姓名和性别；等等加何存放这些登记表，以便能用最快的速度找到某个人的登记表。" ID="7">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）某班本学期开设政治、数学、英语、数据结构和计算机原理等五门课程，n个学生平均成绩分优、良、及格和不及格四个等级。90分以上为优，80分至90分为良，60分到80分为及格，60分以下为不及格。用C语言写出统计分析算法。" ID="8">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="23.写出求斐波那契序列的迭代算法。" ID="9">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="Sm习1勺；" ID="10">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="试5伯山！城）ITemP＝L.歧11；" ID="11">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="L.过1］砚.rlsmal" ID="12">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="l" ID="13">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
      <Paragraph CONTEXT="｝刀eod" ID="14">
        <fptr EndPN="00000030" StartPN="00000030"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="计算机科学是一门研究信息表示和处理的科学。信息表示包括组成信息的元素之间的相互关系（逻辑顺序）和信息元素在计算机中的存储方式（物理顺序）；信息处理是根据解决实际向题的需要对信息进行加工计算的过程。" ID="1">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
    <Paragraph CONTEXT="在计算机领域中，一般所讨论的“计算”有别于数学概念中的一般计算，通常将计算又称为“运算”或’‘操作”。运算或操作的内涵不仅包括传统意义上的四则运算和各种函数运算（公式化运算），而且还包括数据存取、播人、洲除、查找、排序和遍历等运算。从第一台电子计算机问世以来，计算机的应用主要包括两个方面：数值计算和非数值计计算机发展的初期，计算机主要为数值计算服务，其特点是计算过程复杂，数据类型相对算。简单，数据量相对较少；随着计算机的应用范围深人到各个领域，应用方面也不再限于数值计算，更多地表现为非数值计算应用。非数值计算应用的特点表现为计算过程相对简单，数据类数值计算主要是指对一个或一组数据进行较复杂的四则运算、函数运算或迭代运算等。" ID="2">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000031" TITLE="第二章  线性表" TYPE="Chapter">
    <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
      <div ORDERLABEL="00000031" TITLE="2.1  线性表的定义" TYPE="Chapter">
      <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <div ORDERLABEL="00000031" TITLE="2.1.1  线性表的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <Paragraph CONTEXT="线性表是有限元素（Go,elare;，，e。一；）的有序序列的集合。其中n是有穷自然数，" ID="1">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="e。是表中的元家，每个元素具有.相同的特性，表中元素占用空间大小相同（记为：sizen是表的长度。当n时，表为空；当n＞0时，e。是第一个元素，e。一：是最后一个元素。这里所说的“有序”是指线性元素间的相互位置关系。也就是说，。一，是。。的直接前驱元素，而元素。。一定在元素钧＋：之前，称价＋，是价的直接后继元素。而且，每个元素只有一个直接前驱元素（除第一个元素），也仅有一个直接后继元素（除最后一个元素）。1是指出元素e;在线性表中位置的标号，也称为下标。数据元素e；的具体含义在不同的情况下是不相同的，它可以是一个数、一个字符、一个字符申，也可以是一个记录.甚至还可以是更为复杂的数据信息。无论数据元素结构是什么，都" ID="2">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="址翅衡作牙与醉田七亡们素身的姑切互蜂杜枯约刁于笔" ID="3">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="线性表的数据元素可以由所描述对象的各种特征的数据项组成，这些数据项可以是任何" ID="4">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="数据类型，数据项之间彼此独立。这种情况下，数据元素通常称为结构或记录类型。而包含多" ID="5">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="个结构或记录的线性表也可以称为文件（file)。例如，学生登记表（如表2.2.I所示）可以构" ID="6">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="成线性表形式的一个文件。表中每个学生对应一个结构或记录类型，它由姓名、学号、年龄、" ID="7">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000031" TITLE="2.1.2  线性表的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="31" PhysicalPageNum="31"/>
        <Picture URL="00000032\00000032_new\0001.jpg">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Picture>
        <Paragraph CONTEXT="Crest()" ID="1">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="output{)" ID="2">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="GetElere(lc,xy" ID="3">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="Search{x)" ID="4">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="Insert(It,x}" ID="5">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="1?elete(k}" ID="6">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="PreElem(k,x)" ID="7">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="PrcElem(k,x}" ID="8">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="IsBmpty()｝综上所述可知.线性表中的元素具有广泛的含义。但是同一线性表中所有的数据元素都右妇嘟的玉组沉r日几亡fPl1月声F1困行娜米刑曰布于妾裕磨战，。姐曰对于一个线性表。我们可以定义很多运算.在此只对几种主要运算进行讨论。对于每一种数据结构运算的算法描述.都是与其存储结构有着密切的关系。这也是学习数据结构牢记的在计算机中存储一个线性表可以采用顺序映象和非顺序映象两种方法。顺序映象又称为" ID="9">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="玄转和卜习德配，晰宜良之盆袭鑫全全挂.J卜.而目匕如血考比寸翻卜刊阮吹鹅招二习匕配亩自t二卜字纷浮出备士fLn" ID="10">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="线性表（linear1ist）是一种简单而应用又十分广泛的数据结构，把这种数据结构称之为线性表。是因为构成这种数据结构的数据元素之间，逻辑上有着相互位置之间的线性关系。" ID="1">
        <fptr EndPN="00000031" StartPN="00000031"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000032" TITLE="2.2  线性表的顺序存储及操作" TYPE="Chapter">
      <fptr LogicalPageNum="32" PhysicalPageNum="32"/>
        <div ORDERLABEL="00000032" TITLE="2.2.1  线性表顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="32" PhysicalPageNum="32"/>
        <Paragraph CONTEXT="1.线性表顺序存储棍念线性表顺序存储方式是将线性表中的数据元素连续顺序地存放于存储器中相邻的单元，从而保证线性表数据元素逻辑上的有序性。线性表占用的第一个存储单元的地址就是线性表的首地址，也是线性表中第一个数据元素（ea）的首地址0n-I…ucJIte，｝·：｝巨二‘二｛生1＿＿一［物理地址〔称为基地址）和元素的长度，ize，表中元素。，的地址则可以立即由下面公式求出。注意：这个公式的元素序号是由0到n-1，若元素序号是由.l开始安排，则上面公式应改为：tocacion(e,卜location(ei一）xsize有了这个确定顺序存储结构线性表中元素e；的地址公式河以很快地求出元素e。的地址，实现线性表中任意元素e；的快速存取，其算法时间复杂度O(1}，元素e;的地址计算与线性表的长度无关。由此可知.线性表的连续顺序存储结构具有很高的存取效率，它是一种高效的直接存取存储结构。" ID="1">
          <fptr EndPN="00000033" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="2.线性表顺序存储结构定义" ID="2">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="在高级语言中，可以借用一维数组这种数据类型来描述线性表蒯顶序存储结构。在C语" ID="3">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="言中，首先定义线性表中的元素类型（EType)，然后定义线性表结构：" ID="4">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstrut" ID="5">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="｛ETypeselement;" ID="6">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="int1eagth;intMazSize;}LineasList;LinearListL,L1,L2;可以这样来理解LinearList，即它是一个顺序存储的线性表。其中element是一个一维数组，每个数组元素空间用于存放每个数据元素的数据值，length记载线性表中已存储的数据元" ID="7">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="素的个数，MaatSiz。记载线性表可存储的最多数据元素。最后用LinearList定义了三个线性表：" ID="8">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="L,Ll,L2o如果线性表是前面所述学生信息的情况，则其数据元素结构类型（hype}，可以用C语言这样来描述它：typeefatruct《unsignednumber{ltcharnante[S" ID="9">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="charser[21:" ID="10">
          <fptr EndPN="00000033" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="intage;charplace[201;}student;typedefstruct｛student＊demeet;int1ength;字节，age（年龄）占2个字节，place（籍贯）占20个字节。虽然数据元素内部每个数据项的长度和类型不相同，但线性表中的每个数据兀素是相同的，每个元素的占用相同的字节数{s祖e＝32字节）。" ID="11">
          <fptr EndPN="00000034" StartPN="00000033"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000034" TITLE="2.2.2  线性表顺序存储结构下的操作" TYPE="Chapter">
        <fptr LogicalPageNum="34" PhysicalPageNum="34"/>
        <Paragraph CONTEXT="下面讨论顺序存储结构下线性表的几种主要运算。" ID="1">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="1.构造空线性表L所谓空线性表是指表中没有一个数据元素，但数据元素的空间和线性表结构存在.如图" ID="2">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="L.…‘.！二！｝：｝…＿」….“…引二！.｝$Picture[00000034\00000034_new\0007.jpg]Picture$图2.2.2终f害l空线性&lt;产’1.后，就存t'1一个iTypc类)E1的i组.人小兄1\1二Size,tt}’只有存放数据儿不i分Ali.劝f？、的时间复杂性是Otl构选空线性表L法（real)viodGcat(LincarListL,intcRlari.istSizc)" ID="3">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="构造一个t大R址为MaxListSize的线性表L" ID="4">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="LMaxSizc-1daxListSizc;" ID="5">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="Lclcmcnt=newF'I}e(L.1axS，ze" ID="6">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="L.length=U;" ID="7">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="2.#g;v性表L中的数据乙索进行精出翰出线性cL中所有数据元分（Output)viodOutput(LincarhstSL)" ID="8">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="/z个地输出线性cL中的数据元末" ID="9">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="for(inti=l}i&lt;L.length;itout&lt;&lt;L.dcment(i]&lt;＜二：l不丈！L分析.百法的时间S.Sj性jLIl'Il'th)3k性表T中取k个元素山f故组足从U下标升始的.所以.取第k个兀幸，就ti将卜标为k-1的故组兀求取列分析.法的时间.杂性是U(1)在线性表I，中将第k个元未取全a中算法（GclFaen：)L‘I，i,i儿众t(C`t:x，if；不存在返；UIf:d±e.于tc乡。ltI&quot;1cruc.x1[x[Jittk&lt;IIIk&gt;LIcngth)returnfalse" ID="10">
          <fptr EndPN="00000035" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="xL.clrnunt[‘一I" ID="11">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="returntrur:" ID="12">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="13">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="4.线性表L中查找元素x数据元索的查找可以分为已知数据元家的位笠（存储地址或下标地址）、或已知数据元素的1（关1字）、或己知数据元素取仇范f等条件的f找。数据元索被找到后.返回L可以4找到的数据木身，也可以是找到的数据元索的地址。在数据结构咭，，一般不讨论数据元索找到后如何利川.那是实际问题，而只要完成“找到’。所以，为了提高算法效率，在算法，fr+C找条件一般不要川“仇传递’方式.而通常川‘’地址传递”方式。即引用参数；返回位一般以“返回地址”方式描述。" ID="14">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="mtSe:uch{LmcarLtstfiL.ETypc.Cx)1Ill’r找、.如梁找到.返回、所在:位u下标：勿.甲人找到返回一1" ID="15">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="G.X11nlr0.Y&lt;LJcngth,ttr)" ID="16">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="：f1班＿cl公mcngt】一xlttaumt;" ID="17">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="rctum一！." ID="18">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="1在实现查找算法时，山于数据元素存储在。起点的数组中，所以.当夜找不成功时.只能返回数组卜标以外的ti'i，这里我们在算法中约定为一10}法中查找条件是x.即某个数据元家的际‘4'，一般是已知某个查找关键字（St;archkcy通过E找关键字与线性t中的数鹅元素的关键字的比较完成杳找过程的，因此，算法众找的比较条件也可以表达为：1C找itl的愉况是.找的效据元索存储在线性表的址后一个空盯tJ中.所以t的时间复/性i0(length)oS戏性表L中第k个数据元素之后擂入元素x运界它是指在线性t的元素e、和元hett（%lYk个数据元术）之（tttl#t人一个新的元x，即要在元;e、的地方插人一个元求。为了实现插人，首先需要将元素。：及以后的所有元素都要向r移动一个元术的位耸，即原来的元索ek变成元术etc.t+来的元素ek.r'Si:b元素e、。2.…，1f一一一-一Fvr,tts-u,‘一弃海汉.，之艘IYI千十f书才艺人杯的矛含，＿份林汁原来元素C一、变成元术兔。移动以后.空出e：元农的存储单元才能存人新的元素xo意.实现儿素的插人是有前提条件的，就是要求在线性表的元家‘＿：的后面还有空闲的存储单元可以使；11.否则插人是无法进行的。的算法.插入后线性表的长度加一。线性袅L中第k个致据元.之后份入元.1运算（1侧rt）rCtk&lt;U班Ik&gt;L1cn,tttflL.lenFth-LA1axSrrct" ID="19">
          <fptr EndPN="00000036" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="return卜RRR," ID="20">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="for(tntt-lcngtl-i;t》一k;t一）" ID="21">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="L.clcntcntlt十IJIclcmcntir" ID="22">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="L.clcmcntlk=x:" ID="23">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="1length＋令" ID="24">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK:" ID="25">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="圈$Picture[00000036\00000036_new\0009.jpg]Picture$对插人抹法分析可以知道，运算中存在数据元来的移动，可是这在顺序存储线性表结构中$Picture[00000036\00000036_new\0013.jpg]Picture$$Picture[00000036\00000036_new\0014.jpg]Picture$是不可避免地.最差的情况是.插人点在第一个效据元素的前面.这将移动原来的所有数据元素.所以，该-法的时间复杂性是O(Icngtl卜k)o6线性表I.中侧:a;k个数据元素运葬·般说来.翻除运3是指T剧除线性表中的第K个数据元素，即删除ct_t除的办法是将cit后所有元索e‘.…￡o，依次向前侈动一个元素ft位u后修改线性表的长度为length-e在顺序存储线性表的别除运算‘卜，山f物理空间是价态的.所以不J月专门进行存储空问的释放。事实上.移动数据元素的1r'1时.被脱除元素的空间问时已被释放了.释放到线性表数据元索）趁端,即线性表t！t除前f[1后一个数据元索的空lttjoSwtusUelctayLincarLical二intk)UfFYkt!tLrflw?1,个教据jL术、如果卜存在%I:k'1儿未返回出ei状六码ifIh&lt;IIIk:L.length)returnERROK;〔" ID="26">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="fortmtt-k;t&lt;I-length:i" ID="27">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="L.elam公nthr-扭卜Lckmcnt]i1;" ID="28">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="lcn芒th一一二" ID="29">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="returnnK;" ID="30">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="31">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="32">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT=".26." ID="33">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="厂二二犷1Ir_I一二一！，！，.＿」…L-I-l1-1" ID="34">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="1助！＿二几＿1‘，1场‘.！’一f.n71.JI，。.1.对删除算法分析可以知道，运算中同样存在数据元素的移动，可是这在顺序存储线性表结构中是不可避免的，最差的情况是，剧除在最前面的数据元素，这将移动原来的leng山卜1个数据元素，所以，该算法的时间复杂性是以len砂卜幻。可利用的“空闲’空间。因此。进行元素的插人或删除运算时，有着大量元素的移动，移动元素的多少取决于插人或删除元素的位置，而这种大量元素的移动是十分费时的，所以有着频繁的擂人或删除运算的线性表，是不适合采用顺序存储方式的。另外，在线性表的抽象数据类型中还有一些算法没有进一步讨论，读者可以自已完成。" ID="35">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000037" TITLE="2.3  简单链表存储结构及操作" TYPE="Chapter">
      <fptr LogicalPageNum="37" PhysicalPageNum="37"/>
        <div ORDERLABEL="00000037" TITLE="2.3.1  简单链表的存储" TYPE="Chapter">
        <fptr LogicalPageNum="37" PhysicalPageNum="37"/>
        <Paragraph CONTEXT="附加一个指针域〔也叫链接域）来指出元素e，的直接后继元素e，+i的存储地址。2简单涟表的存储结构定义在C语言中，首先定义动态存储空间分配方式下线性表的数据元素的类型：typodefsttuct" ID="1">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="［" ID="2">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="ETypedata;" ID="3">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="ChainNoJe*iink;" ID="4">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="}ChainNvde;在动态链式结构中，数据元素是由两部分构成的：一是数据元素的数据域；二是数据元素的链接域。链接域指向下一个数据元素存储空间的起始地址，数据元素又被称为结点。当某个结点后面没有结点时（无后继结点），该结点的link值为空（用NULL，或0，或用符号八表示），在这个结构定义中描述的只是一个数据元素的存储结构，整个线性表是由多个这样的结点组成的，每个结点之间用指针值进行“链接”。一个链表除了数据元素结点外，一般还另设一特殊的结点，指向链表中第一个数据结点。通常将这个特殊结点称为“表头结点”，表头结点的链接域的类型是指向数据结点的指针类型，表头结点的数据域可以与数据结点的数据域的类型不同，用于存放线性表的有关“综合，信息。" ID="5">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="表头结点结构定义如下：" ID="6">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="7">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="魂" ID="8">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="HeadETypeTidata;ChainNode*first;}ChainList;这样定义后，就可以引用pdata表示当前数据元素的值，引用plink表示下一个数据元素的她咙LoP的值是动态分配的，指向某个结点在存储器中的存储地址。L是指向表头结点的指针，注意，L指针的类型与P指针的类型是不同的，因为，两种结点的结构是不同的。表头结点的链接域first的类型与link的类型是相同的。需要注意，这是动态存储分配方式下链表的表示法，还有一种静态存储分配方式构造的链" ID="9">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="对结点这样定义以后，将几个结点链在一起，组成一个链接表，称为简单链表，由于每个结$Picture[00000039\00000039_new\0002.jpg]Picture$定义了三个带表头的链表：L,L1,stud。如果链表的表头结点与数据结点的结构是相同的，那么，表头结点的结构定义就可以利用数据结点的结构定义来描述。比如：" ID="10">
          <fptr EndPN="00000039" StartPN="00000038"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000039" TITLE="2.3.2  简单链表的操作" TYPE="Chapter">
        <fptr LogicalPageNum="39" PhysicalPageNum="39"/>
        <Paragraph CONTEXT="1.利用动态存储分配构造简单键表构造一个简单链表就是构造一个空链表。即只产生一个仅有表头结点的链表，表头结点的链接域五rst的值首先设为空（NULL}，表头给点的数据域填人表头的相应数据，并返回（带构造带裘头的简单链表算法（teat)violCrcat(Chain[lstRL)" ID="1">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="（‘声构造个空链表" ID="2">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="L-nchaml.iu" ID="3">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="L一、ftrst一入L'LL导翰出简单链表L中的数据元班算法【Output)vuxlOutput(ChamLutkL).个地愉出liI&lt;1_‘卜的数据兀求Cha,nVodc.current-L一＞first;" ID="4">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="while(current)召unit&lt;。current-xlautCcurrcn！一current-Mink！如果还是以length表示链表的长度，不难分析，竹法的时间复！性是O(length,确定r'单链表L中数据元i（结点数算法（LcnRth)intLcngth(Ch:rinListkLI°I链CLrlr效(iClYtk.l'ChynVodc-current=Lfirst;" ID="5">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="antIcn0:" ID="6">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="夏" ID="7">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="Icn＋十：currentcurrent一，Irnk:l" ID="8">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="ruurnIen:" ID="9">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="｝-1.侧除简单链表中的所有效据元素结点州除链表中所有数据结点后.链表只剩链表表头结点.链表表头的链接域被毁为空，删除过程中.不能两单将衷头结点的链接域的位设为空.应该将链表中的解一个数据结点的逐一别除.J季释放征个结点所：引”的存储空问。如直接将表头结点的链接域设为空.址然叮以滴足空链表的要求，似是.链左中原来的效据结点的空间因汗、样放.扰会造成数据空问不能再刊川.这是学习数据结构时待别要注怠的问翘、viixlDcstrm(CharnLtst.CL)Ul;Ni链表Lr1rlhi（渐YS.»！，井什放结点空间Chun\ode.current:" ID="10">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="current-L一＞first;" ID="11">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="while(L一＞fire)" ID="12">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="【" ID="13">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="current-current一＞link;" ID="14">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="dclac1.一first;" ID="15">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="L·frct-current;乡" ID="16">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="17">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="5.rot链表L中查找第k个元素算法中设定一个指针current.川于J;向链表“卜的一个数据结点.另z一个计数器index,记载（针current已经指向链表中的第儿个效据结点。当II1tjCX的位f于k{l'1时.表示己经找到1一第k个数据元索。当current为空时.说明指针已经指到了链r的Ir后一个结点的后而.说明不存在第k个数据结点.查找失败。txxrlGctF.lcm(Chaml.istfiLmtk,EType&amp;x)《价第k个元rCfx中.如小（(f{L返llfalse,i3tJi41altruc.x帝d(I:·:1)returnfalse;Chan\vdc.currcnli。一＞firsl:mtmdcx-1;&quot;hilt(tndex&lt;kb't&amp;current)互current二currentlink;index｝" ID="18">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="d(currant)" ID="19">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="20">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="x二cuncnt一，.1rt:r.returntrtx." ID="21">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="22">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="returnfalse;kl太人.不f{F:k个结点}" ID="23">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="6.ref单链表中查找数据元素x" ID="24">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="这是已知数据元素值的查找。" ID="25">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="简单链表I.中查找元班x(Search)IN1't1x.果找i'1it回、所(F的地址；Il`未找到SCI11!Ll.ChjinVcxle.current-L一）ftrst;uhilc(currentK及t:urtcnt一卜d:ua’二x)cuncnt二currentplink.if(cuncnt)returncurrent;nturutilll.l;" ID="26">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="27">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="在实现查找算法时，当查找不成功时，在算法中约定返回NULL。算法中查找条件是x," ID="28">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="即某个数据元索的值：实际中，一般是已知某个查找关键字（Searchkey)，通过查找关键字与" ID="29">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="线性表中的数据元素的关键字的比较完成查找过程的，因此，算法查找的比较条件也可以表达为：while(current＆＆currentdatakey！二Searchkey)查找最差的情况是，要查找的数据元素存储在最后一个结点中，所以，算法的时间复杂性查找成功时，返回的是数据元素的结点指针，而不是数据元素的序号。查找成功时，返回的是数据元素的结点指针，而不是数据元素的序号。因为，在动态存储结构中，数据元素没有存储在连续地存储空间中，通过数据元素的序号是无法直接取得数据元素的，所以，知道数据元素的序号值是没的意义的。" ID="30">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="7.简单链表L中第k个数据元素之后插入元素x在动态存储分配方式下链表的某个结点（current所指结点）之后擂人一个数据结点。图" ID="31">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="2.3.3所示为在数据元素结点current后面插人一个9所指结点。" ID="32">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="当找到current后，在cturent后面插人一个新的元素4时，只要先申请到空白结点4，将新" ID="33">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="结点数据值x填人其中，然后分别修改原结点current和新结点4的链接域即可。cnewChairtNodeqdatax;接域的值填人新元素结点的链接域，链表表头的链接域的值修改为指向新元素结点。qlink-Lr&gt;first:" ID="34">
          <fptr EndPN="00000042" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="Lirsc闷;" ID="35">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Picture URL="00000042\00000042_new\0004.jpg">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Picture>
        <Paragraph CONTEXT="L$Picture[00000042\00000042_new\0009.jpg]Picture$$Picture[00000042\00000042_new\0010.jpg]Picture$Suuus1nxrthainListfiL,intIF.Typcfix)fl，在缝表L络，第k个&quot;s:元求之转中炳人t1`z在缝表L络：第k个教拱元求之转中炳人元素、厄井如见不存作价L个，f蟹古祷书Lj、、·‘命口攻认f：.；1.1.111如果不存在第k个儿索或线全鑫及卒网已满.则返1，1出任牛伏态仍.f（k‘《））比turn卜RR（）R；inlindex＝1：C比lin、川e.c。介cn！L－＞fir鱿；" ID="36">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="whllc（In」c笼了k左＆curr亡1月）tll找第k个结点Ind之x今斗；curr亡nt-curr亡n［Ink二If（k劝及及’cu厅enl）仪Ium任止Rk0R：" ID="37">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="Ch滋n人司c，qnewCh山n入记c：q一习ata一；If（k）" ID="38">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="1，鑫石人在‘“rrcnl之后" ID="39">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="q＞Ilnk一‘u汀‘川代·llnL：" ID="40">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="‘IIYTcnt一；·Ilnk-q：｝e】‘C" ID="41">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="Illft：为第一个元次绪点摇入" ID="42">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="刃一》llnkL一》fl玲1：" ID="43">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="L一币r只二q；" ID="44">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="，cturnOK如果已知插人点的指针.在擂人点后面插人新结点.这是最简单的情况，算法的时间复杂性是O(1上面算法是在第k个结点后面插人.所以，要从第一个结点开始查找，直到找到第k个结点，算法的时间复杂性是0少)如果已知插入点的指针，要在擂人点前面插人新结点，这时就要从链表表头开始，先找到擂人点的直接前驱结点（current)，然后，再插人新结点，如果插人点是第n个结点，算法的时" ID="45">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="间复芬黔是O(n-1}a" ID="46">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="如果插人点的指针是InsertP，找擂人点的直接前驱结点（cttrrent）的主要算法步骤如下：ChainNode+current卜&gt;firwhale(currentlink！二InstrtpFibcurrent)" ID="47">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Picture URL="00000043\00000043_new\0016.jpg">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Picture>
        <Paragraph CONTEXT="”.旧‘旧$Picture[00000043\00000043_new\0020.jpg]Picture$(a)剧除前’一～甘旧图2.3.4删除链表中结点" ID="48">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="S.从简单桩表中删除一个数据元素dik&lt;l拍!Lfirst)returnG12RUR;ChatnVodewcurrent-L一》fin.t;ifk-I)IIff除的是链1&lt;中第个结rL一》first-current一＞link;clu:" ID="49">
          <fptr EndPN="00000044" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="IChain\cxlcsy二Ltiro;for(mttndex=l:tndex&lt;k-l&amp;8tq;index十q二q一＞&gt;link;q}ii向第k-l个:rL点ifqII!y一》link)rctumRROR;current=，一＞link;current向a'Sk个结.iq一＞link=currentlink;，dclctecurrcnt:11it玻别+f&quot;点currcn［的空fHlreturnOK;" ID="50">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="I如果已知条件是删除点的结点指针current，这时.就要从链表表头开始查找current的直接前驱结点的指针q。也就是：ChalttNode＊q=Lfirst;while(qlinJc二ttrrent)‘尸1link;" ID="51">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="上节介绍了线性表的顺序存储方式，它有着逻辑关系上相邻的两个数据元素在物理位置" ID="1">
        <fptr EndPN="00000037" StartPN="00000037"/>
      </Paragraph>
      <Paragraph CONTEXT="｛相邻的特征。因此，只要知道第一个元素的位置（即下标），则可以利用寻址公式高效地" ID="2">
        <fptr EndPN="00000037" StartPN="00000037"/>
      </Paragraph>
      <Paragraph CONTEXT="上也相邻的特征。存取一个元素。但是，通过其插人、删除算法的分析也可以看出，它存在着一些缺点：" ID="3">
        <fptr EndPN="00000037" StartPN="00000037"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000044" TITLE="2.4  双向链表" TYPE="Chapter">
      <fptr LogicalPageNum="44" PhysicalPageNum="44"/>
        <div ORDERLABEL="00000044" TITLE="2.4.1  双向链表的存储" TYPE="Chapter">
        <fptr LogicalPageNum="44" PhysicalPageNum="44"/>
        <Paragraph CONTEXT="前面我们讨论了简单链表，这种链表的结点只有一个链接域，如果已知一个结点的地址cxrent，需要找它的直接后继结点是十分简单的事，可是要找其直接前驱结点的地址，却不得不从表头开姗亘踪，算法效率不高。如果为每个链表结点再设一个链接域，存储其直接前驱结点的地址，则解决了这个问题，即这样定义动态链表的结点类型：" ID="1">
          <fptr EndPN="00000044" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructIETypedata;DoubleNade.plin;Double[uode4nlin生:}DoublelVode;其中，mink指向curre皿的直接后继结点，plink指向cumnt的直接前·结点。链表中最后一个结点的mink域为NULL，第一个结点的plink域为NUI.Lo｝.亚卫1三囚七钾耳牛囚二1江亚阵·；到亚工目工习二图2-1双向链表结点结构图2.42双向链表双向链表同样可以有表头存在，表头结点的链接域仍然为几滋，与简单链表的first不同之指向的是一个双向链表的结点。表头结点的结构类型定义如下：处是指向的是一个双向链表的结点。" ID="2">
          <fptr EndPN="00000045" StartPN="00000044"/>
        </Paragraph>
        <Paragraph CONTEXT="tyQedefstirnctIHeadETypeHdata;" ID="3">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="DoubleNoderfirst;}DaubltyChainl.Jst;对于双向链表的算法的描述注意其特殊性，如访问双向链表中的第k个元素，由于只涉及双向链表的一个指针（向前指针）.算法与简单链表一样。而对于插人和删除算法，需要考虑两个方向的链域的修改，务必注意。" ID="4">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000045" TITLE="2.4.2  双向链表的操作" TYPE="Chapter">
        <fptr LogicalPageNum="45" PhysicalPageNum="45"/>
        <Paragraph CONTEXT="i.双向涟表L中第k个数据元素之后擂入元素x图2.4.3是在双向链表的cturent元素后面插人一个元素x的过程。下面给出在双向链表的第k人元Er:11结点后面播人一个元素X的算法。擂人过程是首先从表头开始查找到第k个数据元素的结点，用current指针指向第k个结点.完成插入。图2.43双向链表结点插人双向链表Ksfi‘个故1元泰之后#,入兀泰t法曰StatusIncert(DwhlChainLitit&amp;1：川k.ETrpe.Cx){L&quot;j左1.，卜;k个i儿索之tQ中i人元京xzutt小在第k个儿Xi或线性1'间已满.!11.ir出;状态码" ID="1">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="if(k、U)returnERROR;ntindex1,fathlcKlc.current二Lfirst;" ID="2">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="while(rrkxck.F.Ccurrent)" ID="3">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Picture URL="00000045\00000045_new\0016.jpg">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Picture>
        <Paragraph CONTEXT="{找;k个结点" ID="4">
          <fptr EndPN="00000045" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="mdrxtf(k:U!currentlreturnERRUR.I)。arhlcV1xlc＊yncuD‘xihletilxle:‘劝.data一、，tffk)" ID="5">
          <fptr EndPN="00000046" StartPN="00000045"/>
        </Paragraph>
        <Paragraph CONTEXT="！t5人在。urrcnt之r;y一、plink一‘urrent一。plink;Q一，·plinlcurrent;UuublcKcxlc.p-t:urrmnt一，plink" ID="6">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="p、pl川k一：cumnt-n'mk-415c" ID="7">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="ill作为第一个元米结点扬人9一、plinkf‘一＞(irat;S一，plink二KULL;I)oublctiotlc+p-L-iftrSl:Pplink-l:L一》fir“一9" ID="8">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="re［吸trnUK:" ID="9">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="10">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="2.从双向链表中州除一个数据元素图2.4.4是删除双向链表中current指针所指的元索的描述。下面给出删除双向链表的第k个元素结点的算法。i除过程是首先从表头开始查找到第k个数据元素的结点，用current指针指向第k个结点，完成删除。current‘亚川血砸正" ID="11">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)删除前（b）删除后StstusUclcti(voubleChatnLtst&amp;L,intk!t.UImoiL，'+Jf.%k个收据j〔级。如宋刁、（，在第k个元Jk'1出fifRiS(k·-1II!L一、lint)rclurnERROR;bublc\cxlc+current-L一）rrt:Dt、uhl城1。·p：k“”11别除的if4ii中iimnl一》nGnk;.3.P一》plinlSULL;" ID="12">
          <fptr EndPN="00000047" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="L-fiatp;" ID="13">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="clsc" ID="14">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="Lk、ubleK‘xlc.yt一）frrst'or(tnttndet二1：inllc丫＜k沦尺11；In‘1亡久杆）" ID="15">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="q9nlink" ID="16">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT=":I)returnERRORcurccntq;current1uh'J:ti个yuy-curcrn卜·plink;" ID="17">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="p=currantnhnk" ID="18">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="9nlmk-P" ID="19">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="I）plinl.l" ID="20">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="cicletccurrent;放'i;f't.l点currentF）空问n;turnOK显然，这两个算法的时间复杂性为0(k}o" ID="21">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="如果已知插人点或删除点的指针cwrent，那么，无论插入或删除就没有查找第k个元素结点的过程.这样算法可大大简化，只是已给算法步骤中的一部分，算法的复杂性为。(1)。可见双向链表能提高运算效率，但它多使用了链接域的存储空间，是用空间换取时间。实际中，选摇呱＿劫全会倪百妻组娜目＿伙空和名杜知欠肴而的图妻切允片翻！敝习L中而今" ID="22">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000047" TITLE="2.5  单向循环链表和双向循环链表" TYPE="Chapter">
      <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <div ORDERLABEL="00000047" TITLE="2.5.1  单向循环链表的存储" TYPE="Chapter">
        <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <Paragraph CONTEXT="前面介绍了简单链表，简单链表的最后一个结点的链接域的值始终为空，若将最后一个结点的链接域值定义为指向开头（表头结点或第一个数据结点），则形成一口个环.称为单向循环图z.s.J单向循环链表（循环至表头）及空表由图2.5.1可见，循环链表的最后一个结点的链域指向表头结点，而循环链表为空时表头结点指针指向自身。但是，这种结构在实现时却会出现间题，因为，表头结点的结构和数据元link是无法指向表头结点（ChainList类型）的。同样，当循环链表为空时，表头的First也是无法指向自身的。由图2.5.2可见.循环链表的最后一个结点的链域指向第一个数据元索结点，而循环链表为空时表头结点指针为空（与简单链表的空状态没有区别）。但是，这种结构在实现时就不会$Picture[00000048\00000048_new\0006.jpg]Picture$图25.2单向循环链表（循环至第一个数据结点）及空表循环链表的特点是只要已知链表中某个结点的指针（current)，就可以从该指针开始“周游”循环链表中的所有结点，这时不需要知道链表表头结点的指针。" ID="1">
          <fptr EndPN="00000048" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="空rit隽上4-华rr4应衷fifr县隆占的舌体具。" ID="2">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="currentlink二＝L一》first;" ID="3">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="判断指针指向链表的第一个结点的方法是：current升Lfirst;" ID="4">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000048" TITLE="2.5.2  双向循环链表的存储" TYPE="Chapter">
        <fptr LogicalPageNum="48" PhysicalPageNum="48"/>
        <Paragraph CONTEXT="双向循环链表是利用双向链表中最后一个结点的直接后继链接域（nlink}，使其值为指向2.5.3所示。匕甘怪翌士燮州饱图2.5.3双向循环链表（循环至第一个数据结点）及空表" ID="1">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="由图2.5.3可见，循环链表的最后一个结点的链域指向第一个数据元素结点，而循环链表" ID="2">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="为空时表头结点指针为空（与简单链表的空状态没有区别〕。但是，这种结构在实现时就不会出现问题。双向循环链表的特点是只要已知链表中某个结点的指针（current}，就可以通过该指针“周" ID="3">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="游”双向循环链表中的所有结点，这时不需要知道链表表头结点的指针。" ID="4">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="intmdez=l;" ID="5">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="while(currentp0&amp;s4ciadcz&lt;k)" ID="6">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="【" ID="7">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="current=current一＞nIink;" ID="8">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="index" ID="9">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="于；采用循环链表并不额外增加空间，只是利用了原来的空链域。这种循环办法有时能方便$Ii$i-f-#l言;s'''sb':Pif:3i14b'楼;有一些其他说算法大家只要概念清楚和具有一定的程序设计水平，也不难写出。" ID="10">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000049" TITLE="2.6  模拟指针方式构造简单链表" TYPE="Chapter">
      <fptr LogicalPageNum="49" PhysicalPageNum="49"/>
        <div ORDERLABEL="00000049" TITLE="2.6.1  模拟链表的存储" TYPE="Chapter">
        <fptr LogicalPageNum="49" PhysicalPageNum="49"/>
        <Paragraph CONTEXT="利用动态存储分配构造链表虽然有许多优点，然而，很多高级语言没有提供动态申请(new）和动态归还（delete）存储空间的功能。这时，可以利用静态存储分配方式，由用户来构噩牢雯圣竺壑中生色卿户圣曹竿巴誉曾窖早纽贾烈弊灸壁匕鲤匕』事先定义的数组中申请，使用后又将使用过的空间归还到数组中。链表中的空间不是由系统分配的，而是由用户自己分配的，每个数据元素空间是数组中的一个数组元素，所以，指针的值也不是存储空间的物理地址.而是数组的下标。因此，也将这种链表的指针定义为“模拟为了实现指针的模拟，需要设计用于释放和分配结点空间的过程。" ID="1">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="图2.6.1存储池" ID="2">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="“模拟指针”。" ID="3">
          <fptr EndPN="00000049" StartPN="00000049"/>
        </Paragraph>
        <Paragraph CONTEXT="I" ID="4">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="盯ypedata;" ID="5">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="int1ink;ISimNode;与前面讲述的链表所不同的是链接域link的类型不是指针类型，而是整型（因为数组的下标是整型）。下面是存储池的表头结点的定义：" ID="6">
          <fptr EndPN="00000050" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefs[ruct〔SimNode+node:11指向数组《存储池）的指针intMaxSize：IJ存储池大小intM奴5妞e；灰钾甲.早，2、｝｝24（a）包含三个链表（b）空表图2.6.2模拟链表结构即trod。数组的大小；用avail指向存储池链表（未用空间）的第一个结点，avail在逻辑上被看做指针，但由于静态分配的空间，所以空间的地址是整型。为了简便高效地实现空间的分配和归还，对avail所指的存储池进行操作时，无论是申请空间或释放空间，都在avail所指的链表的表头进行剧除或插人结点。由此可知，从某个链表表头L开始追踪，到达link域内容为一1的结点，就到达了这浦弓连表图2.6.2{a)表示一个数组中存放着3个链表和一个存储池”ail的情况。" ID="7">
          <fptr EndPN="00000051" StartPN="00000050"/>
        </Paragraph>
        <Paragraph CONTEXT="这3个链表构成" ID="8">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="分别是：" ID="9">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L1:A1,A2,A3,A4,AS,A6,A7" ID="10">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L2:Bl,B2L3:C1,C2,C3,C4,CS,Cb" ID="11">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000051" TITLE="2.6.2  模拟链表的操作" TYPE="Chapter">
        <fptr LogicalPageNum="51" PhysicalPageNum="51"/>
        <Paragraph CONTEXT="模拟链表各种运算的算法与前面所述的动态存储分配方式下链表运算的算法相似，只是由于是利用数组实现静态存储分配，因而算法的具体描述需要按数组的表示方法描述而已。模拟链表的初始化过程就是定义一个数组，并将整个数组链成一个存储池。其基本思想是，将定义的结点数组的链域从第一个元素开始逐个地链接到下一结点元素，即结点link域的值以下一个元素的下标赋值，而最后一个结点的link域以一1值。杖拟链表的初始化算法（Crcat)voidCnat(SimChainList&amp;L,intMaxSpaccSizc)" ID="1">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L.D1axSize=MaxSpacesize;" ID="2">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L.nocle=newSimNodc[L.D1axSize" ID="3">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="for(tnti=0;i&lt;L.MaxSizc-1;i" ID="4">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L.n目c【11.link＝i＋1；" ID="5">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L.node[L.11taxSize-1I.link-l;" ID="6">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="L.avail-0;" ID="7">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="2.模拟链表中结点空间的分配" ID="8">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="当我们需要结点空间时，则在这个可用空间链表的表头“摘取”一个结点，“摘取”结点的" ID="9">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="思想是：将avail链表第一结点作为一可用结点空间取走（从avail链表中删除），可用空间链表表头指针指向avail链表的下一结点。模l链表分配结点空间算法（Gelnodr)" ID="10">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="intGetNode(SimChainList＆L)" ID="11">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="{ll拟链表分配结点空问" ID="12">
          <fptr EndPN="00000051" StartPN="00000051"/>
        </Paragraph>
        <Paragraph CONTEXT="3.模拟链表中结点空l的释放当发生删除时，释放的结点仍要归还到可用结点链表中去，归还（释放）结点的基本思想硕拟链=tti放结点sIHlf7i}（I'CCCVD(IC1wrdFrccl‘xlySnnChainLiuFcL二nt1)" ID="13">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="(n#拟fi)t`iPff(点.[II.L川心clll［。nk一［IV:uI;" ID="14">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="ltv;tll二1；" ID="15">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="14模拟健表中擂入结点的运界!拟链ctl，可能已存在多个链表.分别山不同的指针指向.如LEIG.2If，所示就是存在(1三个链L.如要在其中一个rtt的&quot;IYk个元求后Itfl人一个新元ilc,ii先从该链t的t头开始查找第k个数据元素.如找到t人点k.则利川己定义的分配结点空间算;GctNlxl。巾请一个结点空间.城人新结点的仇，插人新结点到相应的链表咭，.山于校拟链ii一个效组空间，所以rlii人时要提供某链表的第一个结点的下4r地址first参数，fir、t实际上是静态存储空问上某个链&lt;的首地址.StatusInsTtlSinlhunL.islRL.Int＆13rst.rotk.Sinlh。lcR、卜111板拟链入：空F，1.在卜。。招向的Dt!i中，Y个(iti术之后711人元1XJfItIh，(11rctureLRROR:" ID="16">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="Inlp(irtil:tur(mtinde二I;intlc.x·k.CB:p！一l:tnJcxrt)p-L.nodc(pJ.link;rrfC:k个元农：盆（k:，llR&amp;I》一一1)tcturc[iRROR.1。：《1（；cl、以州L）；11认取一I‘iii间" ID="17">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="I,nuJc[qdata二x;tfIk)" ID="18">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="(u,人r:k个u点之." ID="19">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="1.nntJr(qlinlL.notlc[pI.ltnk;L-noclPl-llnk=q:1" ID="20">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="cl.亡" ID="21">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="(llk_p!e(1人（(L;·个Cc7f.为IJLL'ZItY1lnrxlc{tll.llnk二first;" ID="22">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="fir.t-9:" ID="23">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="24">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="returnUI" ID="25">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="26">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="上述算t见.其插人运的时Gt1复杂性也fiU(K" ID="27">
          <fptr EndPN="00000052" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="5.模拟链表中侧除结点的运算在由tlrst扭向的桩衰中川除策k个结点林法《1)clcte1.42/f13人L空ilffru,tsll:r'链1:‘F1Gak个t4元东rk、l1first-I)rcturnERRURup一甘rnt," ID="28">
          <fptr EndPN="00000053" StartPN="00000052"/>
        </Paragraph>
        <Paragraph CONTEXT="tttI:r5tL.nodclhrstGnk.t,$的!个sUclvCII1I1q指向aSk个i.rl的直接!11`Xfinty-Irnt;fcxfmtmda、一I;rocicx&lt;k-1skyI;intkxy1_nndr[y]1ink;tfrq“二liL-nalclyl.lrnk二一I}rcturnERROR;irLnudc[yI.Imk;1-ncxlc[y6nk-Lnxlc(pI.Imk.乡FrecNrxlc{L,p't不tircturnOiC" ID="29">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="30">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="6.模拟链表的输出voidUutput(StmharnList&amp;L,rnt及firxtl{ll校拟链出" ID="31">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
        <Paragraph CONTEXT="川turrcnt;for(cuncnt=lust:currentLcurrent=L.ncxiclcurrcnthnk-Gout«Lncxic[currcnQ.detac&lt;以上我们讨论了静态存储分配下链表的几种主要运算，其他运算的算法也类似于动态存储方式下的链表，限于篇幅不作重述。" ID="32">
          <fptr EndPN="00000053" StartPN="00000053"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000053" TITLE="2.7  多重链表" TYPE="Chapter">
      <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
      <Paragraph CONTEXT="前面介绍了简单链表、循环链表、双向循环链表，可以得出一个结论：链接域给的越多，空间代价就越大，但同时数据的操作效率也就越高。简单链表只有一个链域，为了查找某一特定的元素，需要从表头结点开始沿着每个结点的链接域“扫描”。当然，可以将链表中的元素按的元素，需要从表头结点开始沿着每个结点的链接域“扫描”。当然，可以将链表中的元素按求：ll）由于学校人员经常调动，需要所采用的数据结构便于插人和删除运算。" ID="1">
        <fptr EndPN="00000054" StartPN="00000053"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）需要经常按性别〔sex)、政治面貌（belief)、职称（duty）进行统计。" ID="2">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）当给出一个人名时，能比较迅速地查到他的登记表，了解他各方面的情况。对于这样一个人事管理系统，为了实现经常插人和删除记录的需要，很自然地想到要用一个链表，将每个职工记录作为一个结点，链接在这个链表之中。这样，将全校教职员工的记录串在一个链表之中，倘若需要统计某类人员的人数，如需要统计女性、民主党派的教授人数，采用这种简单链表的办法，即使在全校万余名教职员工（也就是说链表有一万多个结点冲只有一个符合上述条件的人，也需要将整个链表中一万多个记录全部一一读出，进行比较、判别，这种办法效率低下是很明显的。能不能将具有某一特征的人员各自组成一个链表呢？如果这样做，则按性别、政治面貌、·竺刀、左乡杯，从，夕乙众七魄益目虑＝十米业丰水划兰表日艺夕打，具.粉功1】里丹奏去粉妻】补拍而" ID="3">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Picture URL="00000054\00000054_new\0017.jpg">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Picture>
      <Paragraph CONTEXT="必须有3个映像（结点），使它分别处于性别、政治面貌、职称链表之" ID="4">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="中。显然，从存储角度上来说这是十分浪费的，况且插人和删除运算" ID="5">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="需要同时在三个链表上进行，也是不方便的，因而这种多链表的方案" ID="6">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="也不足取。" ID="7">
        <fptr EndPN="00000054" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="让4个链表共享一个结点，即采用所谓共享结构。这种办法下，对于找具有某一特征的人员是比较容易的，只要扫描有该特征的链表即可，具有较高的效率。然而，比起采用简单链表的结构来说，查找效率的提高是以牺牲存储空间为代价的，因为每个记录增加了3个链域，它们需要占用存储空间。换句话说，只有存储空间允许，才能采用这种办法。" ID="8">
        <fptr EndPN="00000055" StartPN="00000054"/>
      </Paragraph>
      <Paragraph CONTEXT="关汀f名｝.拌别贷箭行刁燕袜示研扮画和可司" ID="9">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="｝’｝.｝’匕二一二千" ID="10">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="已～曰1一一卡州一十｝｝｝｝" ID="11">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT=".｝｝｝" ID="12">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="雇另外，如果我们只知道姓名，不知道其他特征，还是需要扫描整个姓名链表。以上介绍了共享结构，它是多重链表的一个例子。因为在每一个记录中有几个链域。使之" ID="13">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000055" TITLE="2.8  链表应用" TYPE="Chapter">
      <fptr LogicalPageNum="55" PhysicalPageNum="55"/>
        <div ORDERLABEL="00000055" TITLE="2.8.1  结点移至表首运算" TYPE="Chapter">
        <fptr LogicalPageNum="55" PhysicalPageNum="55"/>
        <Paragraph CONTEXT="实际应用中，一个数据被使用过后，可能下次还会再次优先使用。如枪人汉字时，一个不太常用的汉字不在首屏上，一旦使用过后一次，接下来或许又会再使用它，用户不希望再翻多stetuc11o、c1'ustiCh;unLnt&amp;L,m" ID="1">
          <fptr EndPN="00000056" StartPN="00000055"/>
        </Paragraph>
        <Paragraph CONTEXT="线i'F人Liik个欲据元农i多" ID="2">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="cxiC.cu仃cnt1.＞lir‘t" ID="3">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="Talc-Lfirs" ID="4">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="ntindex1:index&lt;1-1＆&amp;" ID="5">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="q’-Ilnk" ID="6">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="'yII'cl-Itnk1nyurnLRROR" ID="7">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="currentq:、hnk.curcenll：;I几I" ID="8">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="nk二‘urrent、linlrrcntltnkL-，Crst:点。urrcntuaJ一个nu二currcnl:头i1'n向YA划iii。二Z）K" ID="9">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000056" TITLE="2.8.2  链表的逆向运算" TYPE="Chapter">
        <fptr LogicalPageNum="56" PhysicalPageNum="56"/>
        <Paragraph CONTEXT="链表逆向也是链表学习中一个典型的例子。在逆向链表时一要算法高效，二要使用尽可能少的空间。实现逆向时，首先从链表的表头开始将指针向表尾方向推进，可以设二个指针，分别指向连续的三个结点；然后，对中间一个结点的链接域的值进行修改，使其指向它的前驱结点，再将三个指针向尾部推进一个结点位置，重复此过程，直到最前面的指针指向空。" ID="1">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="2">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="简单链衷：的逆向的林法（知锐rt）" ID="3">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="SLltu、1Ov亡tt（Ch拟nLI、1＆L）" ID="4">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="卜L一》爪5［." ID="5">
          <fptr EndPN="00000056" StartPN="00000056"/>
        </Paragraph>
        <Paragraph CONTEXT="current=p:" ID="6">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="l，一P一＞lrnk;" ID="7">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="urr‘nt一》Ilnk1first:" ID="8">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="L&gt;fir、几－-current;" ID="9">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000057" TITLE="2.8.3  多项式的相加运算" TYPE="Chapter">
        <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
        <Paragraph CONTEXT="多项式的算术运算已经成为链表处理的一个经典间题。下面用链表结构来表示一个多项式的算法，实现两个多项式相加的运算。设多项式为：其中两0刃，1么…川是系数。在计算机中表示一个多项式时，使用一块连续的存储空间来存放晌厂一1.一月" ID="1">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="c)IIL200" ID="2">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="5" ID="3">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="1已＿." ID="4">
          <fptr EndPN="00000057" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="多项式链表Ll和LZ相加，图2.82的系数为零时，删除这一结点，并同时把两指针都前进一项；若指数不相等，多项式指数大的项作为结果结点，并将其指针向前进一项，多项式指数小的指针不动；这样一直进行下去，直到处理完毕为止。两个多项式相加的结果可以存放于新链表中，也可存放于原来两个链表中的一个链表中。下面给出的结果存放于其中一个链表Ll中，两个多项式分别用指针L1和L2指向，两个多项式L1和L2相加的过程如图2.8.2所示。" ID="5">
          <fptr EndPN="00000058" StartPN="00000057"/>
        </Paragraph>
        <Paragraph CONTEXT="L1:5xZU0+3x100+2" ID="6">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="L2:4xt”一3x100+1多项式链ii.l;I.2相加.结点存放在i.l中算法【,1ddPu1})vendAJJPuIy(ChainList&amp;L1.ChainLi‘t＆L2){ll项式链左L1和L2#11)11i点ff放lL1t'" ID="7">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="MODE.p,.q,+p0,＊x;" ID="8">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="intchoice;" ID="9">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="pL1一＞ling;4二L2-link二while(q！一1ULL)＆8t(P！一I`CLL)【if(I，一＞cxp&gt;q一＞cxp)choice-l;if(pcxp=qcxp)cho几ce=2;if(p一》cxp&lt;q一》expjchoice-3;" ID="10">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="switch(choice)" ID="11">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="‘cacI:1P-P:P-p&gt;link;hrcak;)" ID="12">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="ca.e2二" ID="13">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="〔" ID="14">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="p-xocf=P一》coetFy一＞ax:f;" ID="15">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="if(pcocE-二0)" ID="16">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="p=p0Mink:" ID="17">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="18">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="cltcq=q一＞link:hrcxk;" ID="19">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="20">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="case3.l" ID="21">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="x=ncxVUllG;" ID="22">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="xcoef=q一＞ccxf;、一，cxp-cl一，cxp;" ID="23">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="x-link-p;p(1-Mink=x:p0=x;q=tl一＞link;" ID="24">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="break;" ID="25">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT=".48,." ID="26">
          <fptr EndPN="00000058" StartPN="00000058"/>
        </Paragraph>
        <Paragraph CONTEXT="while(yNULL)" ID="27">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="28">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="》读者可以将上述算法改进为结果链表为一新链表的算法，这样做可以保证原始链表数据不被破坏，可重复利用。上述算法主要运行时间花费在指数的比较和系数的相加上。如果L1和一Lz多项式长度分别为m,n，算法的时间性为O(m+n)o" ID="29">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000059" TITLE="2.8.4  十字链表结构的应用" TYPE="Chapter">
        <fptr LogicalPageNum="59" PhysicalPageNum="59"/>
        <Paragraph CONTEXT="十字链表是一种动态存储结构，它的应用主要是为了解决稀疏矩阵存储间题。十字链表能够有效地解决数组中非零元素的位置或个数经常变动和一个大数组中只有少里目卜零元素的存储问题。在十字链表中，每个结点由5个数据域组成：row,col,val：分别表示元素的行、列、数据值。down（下域）：链接同一列中下一个非零元素指针。right〔右域）：链接同一行中下一个非零元紊指针。" ID="1">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="每一行的非零元素链接成带表头结点的循环链表，同一列的非零元素链接成带表头结点" ID="2">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="intc;ol;" ID="3">
          <fptr EndPN="00000059" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="对稀疏矩阵：head3400000000001131450022-100312图中有三种性质的结点。()表示任意一个非零元素a。的结点。行域存放非零元素aij所在的行，即i值；列域存放非零元素a;所在的列，即j值；值域存放非零元素ai9的值；右域指向同一行中下一个非零元素，因每一行为一个循环链表，当无下一个非零元素时，则指向该行表头结点；下域指向同一列中下一个非零元素，因每一列为一个循环链表，当无下一个非零元素时，则指向该列表头结点。" ID="4">
          <fptr EndPN="00000060" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）表示每一行（列）的表头结点。行域、列域的值均为0:行表头结点右域指向下一个行表头结点，最后一个行表头结点右域，指向整个十字链表的表头结点；列表头结点下域指向下一个列表头结点，最后一个列表头结点下域，指向整个十字链表的表头结点；行表头结点下域指向该列中第一个非零结点，因每一列为一个循环链表，当无非零元素时，则指向该列的行表头结点（自己）；列表头结点右域指向该行中第一个非零结点，因每一行为一个循环链表，当无非零元素时，则指向该行的列表头结点（自己）。" ID="5">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）整个十字链表的表头结点。行域存放稀疏矩阵的行数；列域存放稀疏矩阵的列数；右域指向第一个行表头结点；下域指向第一个列表头结点；值域不使用。稀疏矩阵的十字链表存储结构给处理带来了许多方便，但同时处理算法却较为复杂。" ID="6">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000060" TITLE="2.8.5  一个较复杂的机票售票系统的数据结构方案" TYPE="Chapter">
        <fptr LogicalPageNum="60" PhysicalPageNum="60"/>
        <Paragraph CONTEXT="较大的机场，每日航班很多飞行方向，机票也需预售几天的，这时情况复杂得多。现在来" ID="1">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="head1雳归用一个数组f存放飞行方向和指向日期数组指针fptrof数组的元素和数组本身可以这样定义：" ID="2">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="3">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="4">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="‘h肚如山助红均；" ID="5">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="DateEtypefptr;1曰yE'Pe;F1yEtypcf数组共有30" ID="6">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="曰yBt抓珍几301；" ID="7">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="f数组共有30个元素，元素本身是一个记录，它有两个域：胡dress存放飞行方向，而勿tr" ID="8">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="是指向日期数组的指针。用另一个数组d来作为日期数组，由于可以预售5天的票，所以每一" ID="9">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="个飞行方向要占用5个数组单元。d数组共应有30o5二150个单元。d数组的元素和数组可以定义如下：加以犯fstr”ctchard时a【盯；Num七已五勺PCdPtt；）Dateaype；DateEtyped［5」；" ID="10">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="d数组的元素是一个记录，它由两个域组成。" ID="11">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="d皿.域存放机票日期，dP七是指向可乘航班" ID="12">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="intticksum;" ID="13">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="inttickout;" ID="14">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="Ticketehptr;}NumberEtype;NumberEtypeh[3J;其中：aitnum是航班号；ticksum是该航班可供的机票总数；tickout是已售出的机票数；hplz是指针型变量，它指向乘客表的第一个结点。在本系统中，采用动态链表，所以hptr域中的内容乘客链表采用简单链表，以便插人（定票）和删除（退票）操作方便。" ID="15">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="乘客机票记录定义" ID="16">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="如下：" ID="17">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="18">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="（charname[101}Ticket;其中：nam。为乘客姓名域；}ink域指向后继结点的指针域。" ID="19">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000062" TITLE="习题二" TYPE="Chapter">
      <fptr LogicalPageNum="62" PhysicalPageNum="62"/>
      <Paragraph CONTEXT="l‘试分析线性表的特征。" ID="1">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="2.)顶序存储的线性表的元素长度为20，试计算其第laa号元素的存储（相对）地址（设元素标号下限为o)o" ID="2">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="3.试用两种语言编写从100个顺序存取的线性表元素中第51号位置插人一个新元素：的程序。" ID="3">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="4.试用两种语言编写从l00个顺序存取的线性表元素中删除第2S号元素的程序。" ID="4">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="5.某百货公司的仓库有一批电视机，按价格从低到高构成一个简单链表结构的账目文件，存储在计算机中，链表的每个结点包含单价及相应价格的电视机的数量。现又有h台价格为，幼由SIU1JIARFYTG山Ar4甘露日寺性的省诀么" ID="5">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="6.用简单链表存储一个整数序列ai，as，，ap；然后按逆序、,际t，，aZ，a，打印出该序列，六矛礼曰牛甘催件＿" ID="6">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="7.假定以简单rwsr表结构存储着整数序列=g，，as,，ao（a,感aZ崛a3‘‘a）和一个空闲栈V," ID="7">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="!t，'uh奴全it千4S?dE,D.fitDi汾i{t;翻支硫子月p右兰觉亡。＿。＿＿6台＿‘阳；井；寿U者之牵宾性市月粗伦尧" ID="8">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="ai+l，且将空出来的存储单元归还空闲栈去。" ID="9">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="试写出计算简单链表长度：ize（即结点的个数）的算法。" ID="10">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）合并表头指针为1和k的两个表，为S链表；(S）从S链表的r处将表分成为两个表1和ka用双向循环链表重做n题。12.13.某个仓库存放有各种牌号的收录机，试设计简单链表人库、出库的帐目来往程序，要求标日日桥她白断的县" ID="11">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="14.试列举二个可应用线性表的信息管理系统的实例，二个使用线性表存储结构，一个使用链式存储结构，并画出系统数据结构示意图，并写出插人、删除和修改算法。巧.试给出交换链表两结点的算法。" ID="12">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="16.试给出链表中第i个结点如被访问，则将该结点移至表头（表尾或前移一个位置）的算法。" ID="13">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="1，衬公中铂木雄皂由T县廷占知.具杜含众乡今，曰冲出大翻1二.a士六分‘楠一日rtv-FxJwtisk" ID="14">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="17.的算法。" ID="15">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="15.将表头结点与信息结点定义为不同结构类型，试给出动态链表删除算法。10空以＿劫姑泊渔刑蛇雄七山的榷＿枯占作当丰』一挂占七矛扣‘山二石素念介生" ID="16">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="19.定义一种结构类型，将链表中的第一结点作为表头结点。试给出动态链表插人算法，要求算法中对插人第一结点前一结点不做特殊处理。" ID="17">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="20.定义一种结构类型，将链表中的第一结点作为表头结点。试给出动态链表删除算法，要求算法中对删除第一结点不做特殊处理。" ID="18">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="21.在静态存储结构方式下，定义一种结构类型，将链表中的第一结点作为表头结点。试给出动态链表删除算法，要求算法中对删除第一结点不做特殊处理。在静态存储结构方式下，将表头结点与信息结点定义为不同结" ID="19">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="22.在静态存储结构方式下，将表头结点与信息结点定义为不同结构类型，试给出链表插人算法。" ID="20">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="23.在静态存储结构方式下，将表头结点与信息结点定义为不同结构类型，试给出链表删除算法。" ID="21">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="24.描述以下三个概念的区别：头指针，头结点，第一元素结点。" ID="22">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="25.线性表有两种存储表示结构：一是顺序表，二是链表。试问：两种存储表示各有哪些主要优缺点？" ID="23">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="26.如果有n个线性表同时并存.并且在处理过程中各表的长度会动态发生变化，线性表的总断相盛白知袖两亦＿太1冲格刃下命件田哪动左祛廷油9场朴玖，" ID="24">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="27。若线性表的总数基本稳定，且很少进行插人和删除，但要求以最快的速度存取线性表中的于安孤／.－亩孚田现劫友检全丢如宁蛋朴欢？" ID="25">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="28.给定一个不带表头结点的单链表，试编写计算此单链表长度的算法。" ID="26">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="，0只如雄松弃南的于安榕祥猫顺库泪胜劝，耸山排去未姑占的兰拉害.衬若左启会玄台均＿于矛它＿言朴" ID="27">
        <fptr EndPN="00000063" StartPN="00000063"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="00000064" TITLE="第三章  栈与队列" TYPE="Chapter">
    <fptr LogicalPageNum="64" PhysicalPageNum="64"/>
      <div ORDERLABEL="00000064" TITLE="3.1  堆栈的定义" TYPE="Chapter">
      <fptr LogicalPageNum="64" PhysicalPageNum="64"/>
        <div ORDERLABEL="00000064" TITLE="3.1.1  堆栈的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="64" PhysicalPageNum="64"/>
        <Paragraph CONTEXT="堆找（也简称栈）是一个线性表，其数据元素只能从这个有序集合的同一端插人或删除，这一端称为堆栈的栈顶（top}，而另一端称为堆栈的栈底（bottom1i.ztx－.-1性表。表头（或表尾〕是开放示算的按顶＿另一端县所示，它是一个栈，我们依次往栈中放人4个元素A、" ID="1">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Picture URL="00000064\00000064_new\0011.jpg">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Picture>
        <Paragraph CONTEXT="的上面，D又压在C的上面。若要访向这4个元素中的任一元素，除D外，其他元素只能先取出D，才能取，3.1.l”到。，只有取出。之后，才能取出B.最后才能赫愈" ID="2">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="取出这4个元素的顺序是D、C、B、A。与放入时的顺序恰好相反，故也称栈为后进先出表或" ID="3">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="牛拼后宋弃筒旅tn闷n（1。。t石。代耐。，.、贵刃nn（瑞一.1·.、主" ID="4">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000064" TITLE="3.1.2  堆栈的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="64" PhysicalPageNum="64"/>
        <Paragraph CONTEXT="ADTSt朗k" ID="1">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="2">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="Dset：是一个只能从同一端插入或删除限定性的线性表（e1，…一，）" ID="3">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="Roet：堆栈的一端＿（。。一：〕称为的栈顶（tOP），而另一端（。。琳为堆找的栈底（卜叱tom）" ID="4">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="OPS以：" ID="5">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="C升，心tac峨）" ID="6">
          <fptr EndPN="00000064" StartPN="00000064"/>
        </Paragraph>
        <Paragraph CONTEXT="1‘BmPty（）压人运算也称人栈操作，是将数据元素X插人到堆栈的找顶，相当于线性表的基本运算{211SCCt，即在线性表的末端插人一个元素。弹出运算也称为出找操作，是将堆栈的栈顶元素取出，相当于线性表的删除运算，即删除判栈空运算，它的作用是判断堆栈是否为空。发生这种情况称之为下滋（uadeTflow为空时，若再执行PoP操作就是一个错误，判找满运算，它的作用是判堆栈是否已满（即预留的空间已为元素充满），若满，再执行压返回栈顶数据元素，即取出堆栈的栈顶上的元素值，但不删除栈顶上的元索，相当于查找线性表的最后一个数据元素。如同线性表一样，堆栈也有顺序存储和链式存储两种存储方式。在不同的存储方式下，上述运算的执行过程是不相同的，下面就两种不同的存储方式讨论堆栈运算的实现。" ID="7">
          <fptr EndPN="00000065" StartPN="00000064"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000065" TITLE="3.2  堆栈的顺序存储及操作" TYPE="Chapter">
      <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <div ORDERLABEL="00000065" TITLE="3.2.1  堆栈顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="65" PhysicalPageNum="65"/>
        <Paragraph CONTEXT="=cl一。·：泣！1＿。。1二1｝“·｝" ID="1">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="C.tol〕二n卜！Max含.7e图3么1堆栈的顺序存储" ID="2">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="假设堆栈中每个数据元素占用滋加字节空间，娜指向（加，司卜1摊找中进栈元素的栈顶" ID="3">
          <fptr EndPN="00000065" StartPN="00000065"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="4">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="ape*elemeat;" ID="5">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="inttap;" ID="6">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="intMaxSize;" ID="7">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="｝5翻uck;StackS,SL,S2;iferir目-＿木16rIr快l!1胜$健trlPmnnt一一个一!EC_iJr'feQ_个6'州-ir'F%fel用哥勺牟'堆栈元素数据值，娜指向堆找找顶元素，MausSiu记载堆栈可存储的最多数据元素。最后用" ID="8">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="C····.L己，LI-T二、klbE_Oclcif" ID="9">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000066" TITLE="3.2.2  堆栈顺序存储结构下的操作" TYPE="Chapter">
        <fptr LogicalPageNum="66" PhysicalPageNum="66"/>
        <Paragraph CONTEXT="下面讨论顺序存储结构下堆栈的几种主要运算。3.2.2所示。" ID="1">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="－－－－，一一，-一下－r一，种种种" ID="2">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="｝肥nt叶｝！｝1-L一』.一＿土一耳图3-2顺序存储堆找的空栈空堆栈产生后，就存在一个E巧笋类型的数组，大小是M山‘ize，表中只有存放数据元素的空间，堆栈找顶指针设为一I（用户约定），即堆栈为空时，栈顶指针“指向”栈底空间的前面。" ID="3">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="不难分析，算法的时间复杂性是仪D。" ID="4">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="构选空堆栈、算洗（（’r。“t）" ID="5">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="、1记Crcat灰ack（Slack＆5.In.＆MaxstackS，，c）" ID="6">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="11构选个最人容旦为MoStacksize的堆找5" ID="7">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="5.Max泉‘c－－M以5协ckSlt七；" ID="8">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="5.elcnl.t‘newgl’yPelS.Ma－xS：zc】；1" ID="9">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="准搜寻吞为分" ID="10">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="堆栈为空，是指堆找中没有一个效据元素，即伐顶指针t叩指！句数据交间的第，" ID="11">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="钩空问）的前lftl，如堆栈不空，top总是指向钱顶元索（t叩的值为非一1" ID="12">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="判断堆栈5是否为空界法（1、Fn，1，t》）" ID="13">
          <fptr EndPN="00000066" StartPN="00000066"/>
        </Paragraph>
        <Paragraph CONTEXT="3.断堆找是否为满所谓堆栈为满，是指堆栈的所有数据空间已经全部用完，即栈顶指针P指向数据空间的.标位置(MaxSize-1下标的空间）。如堆iL不满，l'总是指向找顶元素（top的值小于最大下标位置（MaxS泳一1下标的空间）。" ID="14">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="少4断堆栈、是否为满算法（1廿ull）" ID="15">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="b的11、Full（Stack＆5）侄11判断堆找5是否为满.f（SloP，巧.卜1从51乙cl）rcturntruc；" ID="16">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="rcturnfal犯屯" ID="17">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="18">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="4.返曰找顶元素的值返回堆栈找顶元素的仇.是指将toP所指的堆栈元素的位取出，但足：叩折针不移功，’与然，返回栈5栈顶元索的值（心ell叩）51皿断GctT（树Slack沦5，E乃Pe＆x）111；〔lul姚幸匕鱿‘t：未eT币莽安" ID="19">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT=".r（1、E：nPIy（5））rc妞utnERROR；" ID="20">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="x巧，clcmcn宜15.1啊）］孟比turnOK：！5进钱（又称压入）运算进找运劝.是将一新元素X存储到当前t叩所指的空问的“上”一个位笠.即t叩卜1的的元、可以进找.否则出错。、进找价，I（）p指针要先做村！应的移动。进校（压入）算法（九sh）5七欲us即sh（Stack＆5.Er｝’pe＆x）！Ilx进；浅，返卜！进找后的状态仇" ID="21">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="If（151；ull（5））rctumERROR.5.t‘甲卜；" ID="22">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="Sclclncnllslopl-x二" ID="23">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="即lumOK】" ID="24">
          <fptr EndPN="00000067" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="6.出找（又称弹出）运算元素，然后，taP的值减1。出栈时，首先要判断堆栈中是否存在元素可取，即失刹断栈是否空，StatusPop(Stackb5,EType&amp;z)I/将sfcf的值取至z中.返回出栈后的状态吹if(IsEmpty(SreturnERROR;" ID="25">
          <fptr EndPN="00000068" StartPN="00000067"/>
        </Paragraph>
        <Paragraph CONTEXT="S.elcmcnqs.topJ;" ID="26">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="S.top" ID="27">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK;上面讨论的是堆栈的顺序存储及相关操作，可以看到，堆栈的顺序存储与线性表的结构基" ID="28">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000068" TITLE="3.3  堆栈的链式存储及操作" TYPE="Chapter">
      <fptr LogicalPageNum="68" PhysicalPageNum="68"/>
        <div ORDERLABEL="00000068" TITLE="3.3.1  堆栈的链式存储" TYPE="Chapter">
        <fptr LogicalPageNum="68" PhysicalPageNum="68"/>
        <Paragraph CONTEXT="堆找的链式存储结构的特点，是用物理上不一定相邻的存储单元来存储堆找的元素，为了保证堆栈之间的逻辑上的连续性，存储元紊时，除了存储它本身的内容以外，还附加一个指针" ID="1">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="域（也叫链域）来指出相邻元素的存储地址。" ID="2">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="在c语言中，首先定义动态存储空间分配方式下堆栈的数据元素的类型：" ID="3">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="姚泌喊时n沁t｛它ryaata;域。链接域指向更靠近栈底的，相邻的栈元素存储空间的起始地址，链式栈中的第一个结点就是栈顶元素，最后一个结点就是找底元素，最后一个结点的链接域的值为空。" ID="4">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="日圈" ID="5">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="数握元家结点结构表头结点结构图3.3.1堆找数据元索及表头结,结构链式栈的表头结点的链接域（吻）的类型是指向栈结点的指针类型，表头结点的数据域可以与找结点的数据域的类型不同，用于存放堆栈的有关“稼合”信息。链式找表头结点结构" ID="6">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="定义如下：" ID="7">
          <fptr EndPN="00000068" StartPN="00000068"/>
        </Paragraph>
        <Paragraph CONTEXT="ChainStack;" ID="8">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="S,S1.S2是三个链式找，分别指向找表头结点的指针。注意，它们的指针类型与指向栈结叙的指针的类型是不同的。图3.3.2给出了一个链式栈S的结构，表头链接域top始终指向横顶结点，即链表的第一点。对链式找，一般不存在找满问题，除非存储空间全部被耗尽；链式找空表现为链式伐个结点。" ID="9">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="的表头结点链接域tt的值为空，即链表为空。图3.3.2链式栈" ID="10">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000069" TITLE="3.3.2  链式栈的操作" TYPE="Chapter">
        <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
        <Paragraph CONTEXT="i.构造健式找构造一个链式栈就是构造一个仅有表头结点的链表表头结点的链接域娜的值首先设为点指针。构造链式栈算法（crat)" ID="1">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="violCreatStacklChainSt:kkKS)" ID="2">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="《刀构造一个空找" ID="3">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="S二newChainStack;S&gt;tolrll'LI1" ID="4">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="2.一断链式堆钱是否为空结点到断链式堆钱S是否为空算法（IsEmpty)boolIsEmpt，tChainStackcS){iiJi堆tS#为'" ID="5">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="tfS一，top)rttuntlruC;returnfalsr,勺3返回链式钱找顶元素的值当然.能够取得栈顶位的前提是找中有元索存在返回链式钱S#顶元幸的住(ctTop)StatusGetTp(CttainStack＆S,ETppc&amp;xJ(返回)i}伐s'1，找Iyl兀众至a" ID="6">
          <fptr EndPN="00000069" StartPN="00000069"/>
        </Paragraph>
        <Paragraph CONTEXT="从" ID="7">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="returnUK." ID="8">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="9">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="a.健式找进钱运茸进钱运算是将一新元素、的结点链入到链式钱‘卜.作为链表的第一个结点。x;点进钱后.upiii针就1u1u］它Jt.ruaPu‘hiCluir：St:u:kti.S.t;lpcc&lt;x)、进tiCF'1边r&gt;n的Rfft" ID="10">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="St.tck\axle.rl-rt.wStack\x1c;" ID="11">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="r石data" ID="12">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="nk-S-tigr" ID="13">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="凡一［top-" ID="14">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="rrturnO}k;" ID="15">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="S.式找出找运荞链式浅的出F运3It将top针所7ki的结点fl’［取出.且将找r针tip#向;3一个结点的氏接后继结点.并将原米的第一个结点释放。出伐时.首先要判断堆钱tSt是否存在元末结点可取.即先判断找是否空，不空时，可以出找，否则出错。注意，这个算法与取伐顶元素位的算法GctTop有所不同.两个算法都可以取得找顶指针所指的元水iti，但GctTop:法取位后不会改ttopftYi针.即找中元来的个数不发生改变Status1'uprChamStackRS.L]ylx:mss}｛11rs伐顶的位取至x.返间出找1L]的状i.llrft1、Entpt、IS1rreturn[FtRUFtStuk\ix)c·p5一，top:" ID="16">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="x-1，一＞&gt;d:ti" ID="17">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="5=top-Plink:" ID="18">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="deletep;" ID="19">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
        <Paragraph CONTEXT="returnUK" ID="20">
          <fptr EndPN="00000070" StartPN="00000070"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000070" TITLE="3.4  多个栈共享邻接空间" TYPE="Chapter">
      <fptr LogicalPageNum="70" PhysicalPageNum="70"/>
      <Paragraph CONTEXT="以上讨论了单个栈顺序存储结构和动态存储结构方式下的实现和运算，它能够有效地控贡进先出的顺序数据处理。但是，仔细分析一下就可以发现，在顺序存储结构方式下，栈内制后进先出的顺序数据处理。但是，仔细分析－的元素的多少往往受到堆栈N肠民s的限制。时建立两个栈的情况下，可以在内存开辟一块连续存储空间（一个数组），存储空间的两头（数组的两端）分别为两个栈的找底（bottom)。设空间的范围为（0;MaxSize-I)，则一个找S1从下标0(Sl栈栈顶）的数组元素空间向MaxSizo-l下标方向延伸，而另一个栈S2从下标" ID="1">
        <fptr EndPN="00000071" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="哩夔通纽廷搜巨二‘二二三签缓盛翔除非空间的总容量耗尽，否则都不会出现栈满的情况。这样，两个栈都可以独立地向中间区域延伸，也就是说，两个堆栈的大小不是固定不变，而是可以伸缩，中间区域可以成为两个堆栈的共享存储区，互不影响，直到两堆栈的栈顶相邻时.才出现栈满。这种处理思想，就如同两找中间有一个“活塞一样，而这个“活塞，的厚薄表示两栈还在实际中，若要求使用两个栈，而每个栈的各自容量都不能确定，但两个找的容量之和是一定时，采用这种方法最有效，它能充分利用空间。对于如图3.4.1所示的这样两个找共享存储空间时，栈的运算基本与一个找的运算方法是一样的.只需要注意S2找顶的伸缩方向与前面讨论的栈的定义的方向相反。所以，C栈的找空仍为S1甲toil,S2的找空应为S2.to护MaxSize。而且S2人.和出找操作时，栈顶指针" ID="2">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="另外，两个栈共享相邻区间的情况下，找满的条件应是两个找栈顶相碰的情况。二个找栈满的条件应定义为：需要说明的是，只有两个栈的元素类型相同，才能采用两个栈共享相邻的存储空间。关于两栈共享的相关算法，本书就不再详细讨论，留给读者自己完成。" ID="3">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000071" TITLE="3.5  堆栈的应用" TYPE="Chapter">
      <fptr LogicalPageNum="71" PhysicalPageNum="71"/>
        <div ORDERLABEL="00000071" TITLE="3.5.1  检验表达式中括号的匹配" TYPE="Chapter">
        <fptr LogicalPageNum="71" PhysicalPageNum="71"/>
        <Paragraph CONTEXT="续取下一个字符；·如果取出的右括号不是退出的栈顶左括号所对应的右括号，说明这两个括号匹配失败.结束匹配过程，并报告出错。所有字符全部从字符串中取出（表达式的最后一个字符在实际中是回车符，这里，约定为“＃“字符拼比较后，如果全部正确匹配，堆找中应该是空状态.如果堆栈非空，则说明还有左括号未匹配，这时也应该报告出错。如下面的例子：“I（）（”I（）＃”，最后，堆栈中还有一个括号“o如果取出右括号后，堆栈中无退栈左括号与之比较，即堆栈已为空状态时，这时也应该报告出错。如下面的例子：“f（）（）1｝（）＃”，“｝”无匹配的字符。下面，我们为给出匹配算法口括号的匹配甘法（、1otching" ID="1">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="凡几‘1，、、1.1（hlng吃‘h.rrxPI" ID="2">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="仇掩构农达式中括号的匹配“＃－是人达式的结束符" ID="3">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="Cx铸h" ID="4">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="5场Itchofcr" ID="5">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT=".e" ID="6">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="Enlpty（sJ" ID="7">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="POP（5" ID="8">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="」rnERROR" ID="9">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="占CIf（！IsEmPty（5）" ID="10">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="P叩（5.ch〕ch夕一‘1’）r改umERROR；breJ" ID="11">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="：h＝.ex卜" ID="12">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
        <Paragraph CONTEXT="If口sEltll，ty（5））似umERROR；" ID="13">
          <fptr EndPN="00000072" StartPN="00000072"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000073" TITLE="3.5.2  表达式的求值" TYPE="Chapter">
        <fptr LogicalPageNum="73" PhysicalPageNum="73"/>
        <Paragraph CONTEXT="在高级编译语言翻译成低级语言的过程中，编译程序或解释程序要做的另一件工作就是表达式的转换。所谓表达式的转换，就是将在高级语言源程序中的表达式转换为另一种书写顺序，以后运算时按转换后的表达再进行计算结果。序：后级表达式：【操作数】9操作数】【操作符】如数学代数式：X=YEA+BxCD的表达式的三种表示为：中级表达式：x／Y气A祀记）／0前级表达式：一／XY/+AsBCD后辘表达式：XY/AI3CD／一不同的表示方法中，书写顺序不同，平常使用的就是中缀表达式。在中级表达式中，有时而是以操作符和运算符之间的排列顺序来表示运算的顺序。" ID="1">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="前级表达式的运算规则是：连续出现的两个操作数与在它们前面的且紧靠它们的运算符" ID="2">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="构成一个最基本的运算步骤。" ID="3">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="后级表达式的运算规则是：每个运算符与在它们之前出现的且紧靠它们的两个操作数构" ID="4">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="成一个最基本的运算步骤。后级表达式中，运算符出现的顺序就是表达式运算顺序。" ID="5">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="下面，假设表达式已经被书写成后级表达式形式，并将表达式存储在一个字符串中，然后" ID="6">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="从左至右地扫描这个字符串，并利用堆钱，最终求出表达式的结果。" ID="7">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="表达式运算的算法思想：从左至右的依次从字符串中取出每个字符，若取出的字符为“字" ID="8">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="母”，则是一个操作数，将其压人堆栈；否则，是一个操作符，从堆校中退出一个值（第一个操" ID="9">
          <fptr EndPN="00000073" StartPN="00000073"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="10">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="ch-sutfixcxp" ID="11">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="12">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="Pop(S,result" ID="13">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="14">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000074" TITLE="3.5.3  背包问题求解" TYPE="Chapter">
        <fptr LogicalPageNum="74" PhysicalPageNum="74"/>
        <Paragraph CONTEXT="假设有一个能容纳总体积为z的背包，另有n个体积分别是wt,wz,w3，一，％的物品，现在要在n件物品中选出若干件物品恰好装满背包，求出满足要求的所有解。实现背包问题的思想是利用尝试回逆法。首先将所有的物品从从0到n-1编号，每个物品的体积值存储在一个对应的数组w中，以后物品就用物品的编号来代替。另外算法实现时，使用一个堆栈So算法的思想：从0号物品开始顺序地选取物品，如果可以装人背包（装人后不满），则将该物品的编号进栈（堆栈中是已装人背包的物品）；如果当前选取的物品k装不进去（如装人，总体积大于T)，则选取下一个物品（k+1，尝试装人。如果尚未求得解，又已无物品可选，则说明上一个装人的物品不合适，就将堆栈退出一个" ID="1">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="每剥导一组解，就输出堆栈中的所有物品编号（输出不退找，只是遍历所有堆栈中数据），" ID="2">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="f5" ID="3">
          <fptr EndPN="00000074" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="Tr:nerseSt。ckfS下面我们以w数组中的背包,论算法过程中r种值的变化状态{T=103CI®35.1所示。" ID="4">
          <fptr EndPN="00000075" StartPN="00000074"/>
        </Paragraph>
        <Paragraph CONTEXT="州＿曰＿曰曰曰" ID="5">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="＞仁」＞｝｝·｝5｝！｝！1。「一1厂刁厂刁，广」片」。" ID="6">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="目一目一曰二川、曰’曰、曰＿曰’曰＿｝" ID="7">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="川川川川一川曰一曰一曰曰‘曰" ID="8">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="T＝l’介1翻产卜城，’间T－ST习T二4T目T’＝31" ID="9">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="！洲…3工二4几.，二4工。.。4；." ID="10">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="州目曰曰曰。曰曰｝" ID="11">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="T＝ZT司T＝7T二31.‘3护f梁T二IT幻T目T＝5" ID="12">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="4" ID="13">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="＞目目巨" ID="14">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
        <Paragraph CONTEXT="r＝ST二41’＝gT二IT＝！0" ID="15">
          <fptr EndPN="00000075" StartPN="00000075"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000075" TITLE="3.5.4  地图四染色问题求解" TYPE="Chapter">
        <fptr LogicalPageNum="75" PhysicalPageNum="75"/>
        <Paragraph CONTEXT="用不多于4种颜色为地图染色，使相邻的行政区不重色问题，是到薄机科学中著名的定理／一入～各区的颜色：称为色数。" ID="1">
          <fptr EndPN="00000076" StartPN="00000075"/>
        </Paragraph>
        <Picture URL="00000076\00000076_new\0003.jpg">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Picture>
        <Paragraph CONTEXT="直到所有区域全部被染色；若用Cj色素染色D：行政" ID="2">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="区，则与周围已染色的行政区（进入堆栈的行政区）不重色，则将该区域的C和D;进栈；否则依次用下一色素进行试探；若出现用4种色素中的任意一种色素染顶的（上一个行政区）色素，即退栈回溯，以另一种色" ID="3">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="素对退栈的行政区重新染色。" ID="4">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="实现这一算法时用一个关系矩阵r[nn]来描述各区域之间的边界关系,第i号区域与第" ID="5">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="7号区域相邻，则r[ij1，否则x[i]UJ，关系矩阵如图3.5.3所示。当然.也可以将与某区域" ID="6">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="妇战的陌愉台鑫注女＿个蛀妻由耸备烤晓田水招若妞刁、杆补陌七忿雪台含仇在全全里裤去公山的弓于" ID="7">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="5，用来记载每个行政区域当前染色结果，堆栈中的元" ID="8">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="素记载每个被染色的行政区和对应的色-，如图3.5.4所示。" ID="9">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="田" ID="10">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="1234567" ID="11">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="lI0111112J，o0003｝i001104】保持指针，upkeep4｛1Q1011" ID="12">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="5】1O1101Q】读取指针，°P" ID="13">
          <fptr EndPN="00000076" StartPN="00000076"/>
        </Paragraph>
        <Paragraph CONTEXT="IintAresIttdex;intColarlndex;苦E心p:四染色开法（apCokrr)voidMapColar(tntr[1[),intn)" ID="14">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="将地图用四种色染色.n个地区tl的相rys关系{rr1ftt中li示" ID="15">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Picture URL="00000077\00000077_new\0009.jpg">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Picture>
        <Paragraph CONTEXT="intcurrcnW二I;" ID="16">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="intcurrcntC=1;" ID="17">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="StackS:" ID="18">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="EI'ypex;" ID="19">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="x.ArcaIndcx=currcntA;" ID="20">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="x.Cdorlndcx＝currentC" ID="21">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="Push(S,x1S;地R1y色71t染色.)进找" ID="22">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="，，rrrnrAa.i·lairfit11I31i!tl.4G*F,fIk,CurTcntA干今；whlle（currcn叭＜＝n）lt叩kCep沼toP；llf呆留当前栈顶指针日ag二trUe：llflag为五时.表示与堆伐中己染色的区域比较时未发现负色while（！卜F：nply（5）＆＆nag协从找顶至栈底与已染色区域逐个比较有无重色IPoP〔5.xllli卖取栈中一个数据元末if（x.Colorlndex＝currcnIC＆＆rlcurrcn以1【x.ArL＝，山dcx］）" ID="23">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="11伐中读出的区域已使用色家与当价准备染色区域要使用色家相同，且两个区域相邻" ID="24">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="nag‘佃se，办无法使用当lrl色素染色，需改变色家或退找，结束比较" ID="25">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="26">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="if（IsEmpty（5））11与已染色区域比较.无一同色" ID="27">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="11／将当前区域号及使川色素进找，并准备下一个试域兮，从色素1开始尝试" ID="28">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="x.Arcalndex气Ilrrcn认：" ID="29">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="x.C倪以Indcx式urrentC；" ID="30">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="5.t0P二toP‘ccP；Push（5.x）；" ID="31">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="CllrrcnLA＋＋；CUrrcntC-1；" ID="32">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="｝e15e" ID="33">
          <fptr EndPN="00000077" StartPN="00000077"/>
        </Paragraph>
        <Paragraph CONTEXT="]ae°truc," ID="34">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="下而.我们再给出另外一种实现染色的算法.；戈思思与前面的完全一徉，" ID="35">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="o、d\tapCdcx(antr(I.：成n]【int：二！；ll表diJ：lll人示色术int1ints(1;堆找s(i]j;只将色号进栈.区蛾编号就是堆栈数组S的卜4ri十十屯j二1;while(i&lt;n)《" ID="36">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="k、;Ilk#fi示已染色的Ik" ID="37">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="while(k&lt;i)h&amp;kr(ikj)k＋＋；11枚洲己染色的1邻地IZ是否与当11+1准备t,色CAB色iEi){如相:区不!fl色.进找记下?A色t7R.3F4续对下一地C从t色起进行%#y5(11x;1＋十；j=1" ID="38">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="39">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="clsc" ID="40">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="41">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="j1I发生1t（色，川J-1色继续ut]ni.whilc(JA)" ID="42">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="(1一变9钱1:1{ti的色LJ二姚11＋1；]）l" ID="43">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="44">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="堆栈的运算在计算机科学中应川相当1‘泛，无论是在系统软件还i在应用G1f软件中，堆" ID="45">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="栈随处可见.在后述的树一章中树的各种作递归运算都将使用堆栈" ID="46">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000078" TITLE="3.6  队列的定义" TYPE="Chapter">
      <fptr LogicalPageNum="78" PhysicalPageNum="78"/>
        <div ORDERLABEL="00000078" TITLE="3.6.1  队列的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="78" PhysicalPageNum="78"/>
        <Paragraph CONTEXT="（故也称为限定性线性表）。.68队列是一个线性表，其数据元素只能从这个线性表的一端插人，而从另一端删除，删除端称为队列的队头（front插人端称为队列的队尾（rear)o也可以说，队列是限定只能在表头（或表尾）进行插入和在表尾（或表头）姗除运算的线.。表头和表尾为开放运算的两端。性表。现在用实例来说明这个定义的含义。如图3.6.1所示，它是一个队列，我们依次往队列中」‘.LA！.匕｝～至｝D！fron：Trcart" ID="1">
          <fptr EndPN="00000079" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="图16.t队列" ID="2">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="取数据时（删除），又称出队，总是从队列中fio此所指的位置取走数据。擂人数据时，又称进队。总是在队列中rcar所指的位置后面添加。取走数据与放人时的顺序恰好相同，故也称队列为先进先出表，简称FIFO（Rrstinfirstout）表。" ID="3">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000079" TITLE="3.6.2  队列的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="79" PhysicalPageNum="79"/>
        <Paragraph CONTEXT="D以：是一，个从两端分别进行擂人和俐除限定性的线性表" ID="1">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="OPS改；C比州加e姆（）肠E娜州〕h凡11（）oe企比。《）" ID="2">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000080" TITLE="3.7  队列的顺序存储及操作" TYPE="Chapter">
      <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
        <div ORDERLABEL="00000080" TITLE="3.7.1  队列顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
        <Paragraph CONTEXT="1.队列顺序存储概念队列顺序存储方式.是将队列中的数据元素连续顺序地存放于存储器相邻的单元，以此来保证队列数据元素逻辑上的有序性。但为队列分配的连续存储空间的第一个存储单元不一定存储的是队列队头元素，因为，如果第～个存储单元存储的总是队列中队头元素(front指针不动），就会出现每次出队一个元素，M故51气纯地向同一个方向移动，就会造成队列像尸条“蟠虫”慢慢地“爬过”队列定义的全部空间，而这条“蟠虫，只要“爬过”的空间就无法再次得到利用，即造成丘。。t指针前面的存储单元不能再存储数据元素，如图3.7.3所示。" ID="1">
          <fptr EndPN="00000080" StartPN="00000080"/>
        </Paragraph>
        <Paragraph CONTEXT="3.7.4就是队列指针“转头”的事例。0123-3\i:uSii.c-Ire.ir1frontf`I3.73列)iilIxt1al事实上.至此为止问题还没有得到完全真正的解决。下面首先分析队列中如果没有一个队列元索、即队列为空时.队列的指针状态。就以{13.7.4为例。如t队列中的所有元戒全t出队，队列出队时。.将front所指的元素tub（走.然后将front#el针后移一个位'，J)Siyi`么队列中的全部元-出队后队列的iii针状态如图3.7.5所示。可见，队空时fornt指针Y.tl向ttlrJi苍1｝一’｝｝一］一＿］’｝.’二｛｝｛rc.ujtrontly)3.7.5to为y元则出1?Q(tI3.7.61{示的状态012:id1,1axSizc1l可AA_，一｝互」.（颐1一几…1（下’l’lllx.7.6Ili)为tai从图3.7.G可见.formfn·指向：ear指针的“卜一个”位笠。就是说.无论Iltp队满ii针的(I对位置是一样的这状使刘断队空和队满出现户d题.所以要解决这个问题解决的方t:是：在定义的队列存储Ill中，(if出一个数据元索的空间不用〔为了保持队列空问有1tlaxSire,{L定义数组时，设（组的人小Lj\:lYS1LlI.可以理解这个不用的问N-个环形管中的”fu.它总是紧邻lA列中的第一个数据儿素.是可以移动的，即这个空I1,iL" ID="2">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="1I" ID="3">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="断袱井说粉1＿.…‘、.…！＿、IL，l.“”二J," ID="4">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="1钊37.8抓环队夕。1落M盯51，t（.11一〔货茨一于：：关一洛：4‘”）！1附3.？9姗环队，lJ为，.2状态进队11.t.首先将：ear指针移动到“下·个”位铃.再将新数据元素存lllrear所指的位笠.如果队列存满了就会出现如图3.710所示的情况。此时，队尾指针：eal的’‘下一个”位丑就是fro：1［于行全1所指的位置.1芝11队满f付的抬tt一状态" ID="5">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="洪的问题J各Max凡1，e毛滋挂簇！舅。1i’.’’1.不了一！’二，1，：1，一｝rcar‘6MaxSI，c门麟举戴。｝·｝。1.｝｝1" ID="6">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="尘些卫上立」越胜笠狙一二一土－二止1‘｝一（二1、生队51，亡ltI3：711洲环队列的吸序存储" ID="7">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="2.队列顺序存储结构定义" ID="8">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="队列结构定义：如昨山fsOuCtt" ID="9">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="它巧声诫已口en七int台即仁intte翻叮" ID="10">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="intMaxsi阴；IQ切.uc；伽，Q，Ql.QZ；" ID="11">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000083" TITLE="3.7.2  队列顺序存储结构下的操作" TYPE="Chapter">
        <fptr LogicalPageNum="83" PhysicalPageNum="83"/>
        <Paragraph CONTEXT="下面讨训顷序存储结构下队列的几种主要运算。" ID="1">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="1.构造空队列所谓空队列是指队列中没有一个数据元素，但数据元素的空间和队列结构产生，如图o1n-Ii缺S1zc.＿L.一图3.712掀环队列的顺序存储空队列产生后，就存在一个盯ype类型的效组，大小是Mosizc＋1，队列设为。（JIlf”约法的时间复杂性是0（l）：构造空队gIJQ算法（‘’代“tQ。。u。）vi浏Cr。以Qucuc（Qucuc及0，1，t＆人笼axQ因ucsi，cj111构造一个及大齐以为MaxQueucS、ie的队列Q" ID="2">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.卜iaxs】ic＝Ma飞QucucslZc；" ID="3">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.clcmcn卜汉wE‘lyl兄IQ.Maxsize于11；" ID="4">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.front二0；" ID="5">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.re解（）；l2利断队列是否为空" ID="6">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="即froot＝rear。" ID="7">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="判断队列Q是否为空算法（hEmPty）" ID="8">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="b，们、E。、P几）‘Quou。＆Q）" ID="9">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="11，少11断队列Q是否为空" ID="10">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="11（Q.frt一试2.rcaJ）rcturntruc：" ID="11">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="retum即弓c：l3刹断队列是否为满系是：front＝rear＋l。这里“％”丧示求余数。d(Q.fnmt二刊Qrc:tr+l)°p1Q\i.txSiictIreturntrue:R妞umf.ilvr;" ID="12">
          <fptr EndPN="00000084" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="4.返回队列队头毛素的位返同队列队头元te1的ll1是将front后而一个位置的队列元素的值取出.但是front指针不移动。StatusGetFront(QueueftQ.11pefix){IIilli&gt;f.列Q’I'头少i:if(IsEmpty(QreturnERROR;xQ.clcntcntQ.iront+lQ.ti4sxSiie+1)J.raurnUK.｝" ID="13">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="5.进队运界" ID="14">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="进队列运竹是将一新元索x7储到当[iJre.1r所Ji7空间的“下一个”位盆。进队时，首先要判断队列‘争，是否存在儿素存放的空间.即先判断队列是否满，不满时.、可以进队列.否则出错。进队算法（F.nQucuc)(JJxiQ队列.返回进队)后的状态tif(IsFull(QreturnERKOK:" ID="15">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.rearQ.rrar+l)°fQ1axSnc＋t" ID="16">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.clcmGtt(Q.rcar』一x;" ID="17">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK;" ID="18">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="19">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="6.出队达葬出队运算是将队列中队头指针所指的“卜一个”t谁i的元索取出。做法是：首先将队列队头指针front先向“下·个”位咒移动.然后.取出移动后front所指的数据元素。出队时.i汪意，这个算法与取队列队头元素fii的算法GetFront有所不同.两个算法都可以取得队列中队头的元素值.但GetFront算法取i解iF不会移动Front指会f-，取值后队列中元素的个数也不发生改i队炸法。hQutue)StatusDcQueue(QueuecQ.L7pped:x)[u将Q队列队头的SItx中.并移动front指针，返回出队列后的状态ff[if(IsEmpty(QreturnFRROR;" ID="20">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="Q.front二（Q.frr,nt+IQ.t;txStzc+1" ID="21">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="x1.element[Q.frontJ:" ID="22">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK;上面讨论的是队列的顺序存储及相关操作，可以看到，队列的顺序存储运算中主要是指针的变化较复杂。" ID="23">
          <fptr EndPN="00000085" StartPN="00000084"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000085" TITLE="3.8  队列的链式存储及操作" TYPE="Chapter">
      <fptr LogicalPageNum="85" PhysicalPageNum="85"/>
        <div ORDERLABEL="00000085" TITLE="3.8.1  队列的链式存储" TYPE="Chapter">
        <fptr LogicalPageNum="85" PhysicalPageNum="85"/>
        <Paragraph CONTEXT="队列的链式存储结构的特点，是用物理上不一定相邻的存储单元来存储队列的元素，为了保证队列之间的逻辑上的连续性，存储元素时，除了存储它本身的内容以外，还附加一个指针域（也叫链域）来指出逻辑上相邻元素的存储地址。" ID="1">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="在c语言中，首先定义动态存储空间分配方式下队列的数据元素的类型：" ID="2">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="typederatruct" ID="3">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="l它吻讲血加；JQueueNoda;在动态链式结构中，队列结点由两部分构成：一是数据元紊的数据域；二是数据元素的链接域。链接域指向后一个相邻的队列元索存储空间的起始地址，链式队列中的第一个结点" ID="4">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="就是队头元家，最后一个结点就是队尾元素，最后一个结点的链接域的值为空。" ID="5">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="链式队列的表头结点的链接域（介OM和啊）的类型是指向队列结点的指针类型，表头结点的数据域可以与队列结点的数据域的类型不同，用于存放队列的有关“综合”信息。链式队列表头结点结构定义如下：｛" ID="6">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="HeadLIrpoHdata;Queuel'ode+froat;" ID="7">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="n，，自.Nriv.r户.r." ID="8">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000086" TITLE="3.8.2  链式队列的操作" TYPE="Chapter">
        <fptr LogicalPageNum="86" PhysicalPageNum="86"/>
        <Paragraph CONTEXT="t.构造健式队列构造一个链式队列就是构造一个仅有表头结点的链表，表头结点的链接域front和rear的值首先设为空（NULL）值，表头结点的数据域填人链式队列表头的相应数据，并返回表头结lt式队iJ竹,云（(r.atQucuc)iodCon二，tQucucharnQucuc＆Q)" ID="1">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="{ll;造一个队列" ID="2">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="newCtt:tinQuouc:" ID="3">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="Q一、(root-Nt1LL:" ID="4">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="Q一》rc:rr-NULt.荟" ID="5">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="2.列断住式叹列是否为空刘断链式队列Q是否为空算法（[F.ntpty)boolIsLmptylCharnQucucS:Q)(ll1P;iil夕)Q是否为空" ID="6">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="dQ&gt;4ont)returntrue;returnfalsa}" ID="7">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="3.返回链式队列队头元索的位变返回链式队列Q队头元众的值（GrlFrvrol)StatusG。tl‘n;nt(LharnQucucF:Q.ETy{x.x&gt;硬112；1，1。我夕JQ'IriJ.hlfSif:itxifaEuy，IV1QnuunERRnR," ID="8">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="Ch:nnVclc.pQ-front:" ID="9">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="x-Pdata;rYUrnUK,产进队运算是将一新元°x的结点链人到链式队列中.作为链表的址后一个结点链式队列进队算法（I;nucuc)Status1=trucuclChttinuwc!CQ.F7yxx)(、进Q:1;4d,问进i41的状t.位" ID="10">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="QururNrxlr·y-rrcwQucuCNrxt:" ID="11">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
        <Paragraph CONTEXT="9一＞hnllLLL;" ID="12">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="QueueVc,le.p-Q-rca" ID="13">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="P一全Imk&lt;卜" ID="14">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="Q-rt.uq" ID="15">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="returnUK" ID="16">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="5.链式队列出队运葬链式队列的出队运炸ti:将frontiii针所ri的结点位取出。tl将队列指针front指向下一个结点.并将原来的第一个结点释放。出队列时，首先要判断队列中是否存在元素结点可取.即先判断队列是否空.不空时.可以出队.否则出错。注意，这个算法与取队列队头元索仇的算Getr'ront有所不同.两个算法都可以取队列队头指针所指的元索位.但Getf-ront=法取位后不会改'1,frontft&quot;3针.即队列元米的个数不发生改变。Jtatus1ltueue(C‘h:un(lucut.Q,Fr}rcS,x)ukyQiy1T的“l1't`x中.iI'i出4:914的x1j!ifaE:mpa》(QreturnF:RRUR" ID="17">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="Qucut\cxic.p-Q.front:" ID="18">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="xQfrun［一x1：a;" ID="19">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="QCratt=Q.Cruot&gt;hnk;" ID="20">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="deletep;" ID="21">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK;" ID="22">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="23">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000087" TITLE="3.9  队列的应用" TYPE="Chapter">
      <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
        <div ORDERLABEL="00000087" TITLE="3.9.1  列车重排" TYPE="Chapter">
        <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
        <Paragraph CONTEXT="货运列车共有n节车厢，每节车厢将停放在不同的车站：假定rn个车站的编号分别为1,2，3，…，m.贷运列车按照第rn站至第1站的次序经过这些车站。车厢到达某个目的地时，为了便于从列车上卸掉尾部的车厢，就是必须重新排列车厢，使如果不是，则把它移动到缓冲铁轨上，再按输出次序要求轮到它时才将它放到出轨上。缓冲铁轨是按照:（队列）的方式使用的。不能成功地重排，则返回false，否则返回true,缓冲铁轨！I砧,q3,6,1,9,8,5二4，，I4,8,73.2,14,7抽人轨出轨开始时创建一个指向k个队列的表头数组ik]。其中，Q田（1＝l.2，…，k）表示第i个缓" ID="1">
          <fptr EndPN="00000088" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="的车厢号，minQ是mines号车厢所在的缓冲铁轨（即队列编号）)oRearrangementTractc调用Output和Hold两个算法。算法。utlwt用于将当前在缓冲铁轨中可以送到出轨的车厢送至出轨，它同时再寻找缓冲铁轨中最小的车厢编号，修改minQ和mines。算法Hold根据车厢调度规则，把某个车厢current送人一个缓冲铁轨，如果cu二nt可缓冲铁轨中现有各车厢的编号均小于current；如果有多个缓冲铁轨都满足这一条件，则选择一个缓冲铁轨队尾（左端）车厢编号最大的缓冲铁轨；如果已有车厢的缓冲铁轨中，队尾车厢编县抚十月户。.rr，t欣.～f刹余消妥一，洲卜穴OitsAh牵李t1itn月.招盆灵七1kx.firt里Fe二r" ID="2">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="如果也无空缓冲铁" ID="3">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="轨.则无法调度。" ID="4">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="夕（车Itt[il.，矢t,nrrau片cmrntlrack" ID="5">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="{ll从缓冲铁#IL中''mines;st,Uutput{m：nN,mrnQ,Q,k,nl:owUut，二" ID="6">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="(" ID="7">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="(else将r(1.1人装个沉冲fhIifHold(r(iminll,nunQ.Q,k二，1/班lullaN]true1&lt;示送人成功rctumfalser" ID="8">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="9">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="returntrue;" ID="10">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="｝voidOutput(inl&amp;minFi,tnt.t;tmmQ,QurucQ(1,mtkmtn)从minQ出fa?c小车即m.nll，月·‘夕找卜一个ft'c小（r1mmlllmrnQ.intCurrent;IlNqri-ili" ID="11">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="1)cQucuc(Q(minQminll从队列，rtinQ出队fa'i:小的今Vii]minllCAUL«”从“«minQ＜二’i.R冲S&quot;4h)出’'«mmH&lt;C到出'1&quot;«cndI;mmll-nTl:itx3:L一个坡小车厢编y.它比实卜。车加兮大.以n换Gxfinti=I:i＜二k;i什）(1Iifi%2捡ft所fla列的首,找tIIF)mmllylmrnQcurrc川月cl卜ront（QI.Lx）；ifL!IxEropty(Q[icurn;nt&lt;mmlltmint1cu二nt.minQ一，：" ID="12">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="]" ID="13">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="井" ID="14">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="》" ID="15">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="bexaI1old(tntcurrent,intommH,mt&amp;mmQ.QurucQ]1,rntk)(1/为'1-W&quot;Icurrent.f优JY冲liL.xl17,t(1.;l'1返&quot;falx.traL1cstCushion=il;11日II1rt't统r1?r;ziE1夫轨.为0Kt农1cs未找到{的缓冲杖轨13estl.srst0;intx:Il-ifil)i:fur(mt：二1；：＜二k；1＋＋）11扫描y冲tix4hIf（1正mP。）（Qll］））冲铁Li不c;etRcarQ[iJ,x11t:¢tyV冲t大马九‘rr一书-pa`s;t.放人xtC(currengxRcptx&gt;RrstLasQ" ID="16">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="z成为4t的址大车tl" ID="17">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="liestl.ast-x:" ID="18">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="Licstushion二1；" ID="19">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="20">
          <fptr EndPN="00000089" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="苦elseIlcu二nt小于已使用的级冲{1！中itk.一节''1(11的'ak#，则进人未{川的i冲i4LidBcstCuahxm)rewrnfalcaifii可Ifl（f］粉冲铁软.儿法粥度.失效" ID="21">
          <fptr EndPN="00000090" StartPN="00000089"/>
        </Paragraph>
        <Paragraph CONTEXT="Oucu(Q(BestCu.humJ,cu二nt1:11把current进人lf)优杖轨队p.J" ID="22">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="4xficurrrntG1;成力11Jr的mines*t1minQ,）:l:J:延fe" ID="23">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="tumtrue" ID="24">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000090" TITLE="3.9.2  投资组合问题" TYPE="Chapter">
        <fptr LogicalPageNum="90" PhysicalPageNum="90"/>
        <Paragraph CONTEXT="企业已拥有定量资金，准备将这部分资金投资。经过投资分析，有多个可供投资的项目，并且可顶知可供投资的项目的资金需求及投资回报率。可是，面临的向题是由于资金是定量的，不可能同时进行需要资金量大的几个较高回报率的项目，只能从较高回报率项目和较低回报率项目中选择项目进行组合投资，以使投资回报最大化.同时不再追加资金。这样就可能产生多种组合方案，进而从多种组合方案中选择一种组合的处理。为解决此类问题.首先决定哪些项目可以组合，对于不能同时选择的投资项目称为冲突项目。然后再核算各种项目组合的资金需求总量，如某种项目组合的资金需求总童超过已拥有的定量资金，则认为该种组合不可行；如存在多个组合方案的资金需求总童都不超过已拥有下面我们仅讨论求取各种不冲突组合的算法，这类向题又称为划分子集问题。企业决定将atz;&quot;o项目作为投资侯选项目这里a表示侯选项目的项目编号抽象为项目集合Aa；,处，…，‘｝。不能归人某投资组合方案的项目，表现为集合中的某些元素之间会发生冲突，可表示为集合上的关系卜｛（％幼1，如a属于R集合，则表示a与、之间存在冲突。" ID="1">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="根据R关系将人集合划分成不冲突的若干个组合，即划分为不相交的子集A,Az" ID="2">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="n)，使任何子集上的元素均无冲突。" ID="3">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="如共设9个投资项目，项目编号以整数1-n表示，则：集合A1,2,3,4,5,6,79" ID="4">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="R=f(x,8}，(4,9(2,9).(z,1(2,匀,(,6).(S,9),(5.句,(4.S(5.7(G(3n,(3,b" ID="5">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="由此R集合，则可得出的可行子集划分为" ID="6">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="]234S6789At1,3,4,8}Af{2,7)Ap5}A{G,4}" ID="7">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="LIO10000000｝根据冲突关系集合导出一个冲突关系矩阵" ID="8">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="2{10001101LIr。如抓麒中、与，对应位'为i,则i" ID="9">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="那么状态数组的最后结果为：12345GT89即g[11=s[刃=s41[81=1，也就是项目at,as,丸,as属于同一子集，其子集编号是1;s[21=i71=x,也就是项目赴，衡属于同一子集，其子集编号是2；等等。形成上述状态数组的过程，就是划分子集的算法处理过程。为实现划分过程，设循环队列" ID="10">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="Q，初始化时，每个元素存放项目编号。队列的变化过程是：将队列中的所有元素逐个出队一次，每次第一个出队的项目编号作为进人新子集的第一个项目，以后出队的元素与已进人当前子集的项目进行比较.如不与进人当前子集的任何项目发生冲突测作为进人当前子集的项目几是属于当前子集的项目不再进队，队的元素构成再次筛选的初始队列元索，由于形成某一子集的元素不再入队，队列元素在不断减少，直至队列中无出队元素，子集划分过程完成。每次开始划分一个新子集时，第一个出队的元素不需要判断冲突关系，因为这时是一个新" ID="11">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="子集形成的开始，新子集中无任何项目，也就不存在进人项目与其中已进人项目的冲突，即直接作为所形成新子集的第一元素，直接形成5数组对应位置的状态值，而以后出队的元紊是否属于该子集，就要根据冲突关系矩阵来比较决定。" ID="12">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="x'1分子1法（I)i、i‘iun)" ID="13">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="roidUt、，slon(tntr[l(j,intn)" ID="14">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="lln个项I.1分不冲突的Y.冲突关余存‘敌全H中c示QurucQ;intrc.ukerp;" ID="15">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="mlcurrent;l！日jtiifur(t-l,t＜一n,t牛，）叮项月编勺进队，结果初如化状态敌组5LnQucu议Q.iJ·Slil-众srt=！:子&gt;tehile(!1sLmptQ" ID="16">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="17">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="rC1rl:CCj7fC:lr:长°17Ij(iilLnit(un）S)currcnt)二sct;I/currcnt进人当前子集1" ID="18">
          <fptr EndPN="00000092" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="spa" ID="19">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="20">
          <fptr EndPN="00000092" StartPN="00000092"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000092" TITLE="习题三" TYPE="Chapter">
      <fptr LogicalPageNum="92" PhysicalPageNum="92"/>
      <Paragraph CONTEXT="1.下图为铁道板道站，右边轨道的4,3,2,1编号车厢可以被带人站，且可以在任意时间被拖走，则左边轨道上可能出现多少种排列次序？又对于一个栈，给出输人项为A,B,C,D。如果输人序列为A,B,C,D，试给出全部可能的输出序列。试说明哪些输出序列是可能的，哪些输出序列是不可能的。贫iet旦ifrftr!!.t&quot;b7门,eur'nx_[li1-＿;当-fl.ri3E,f311&quot;Xillff.irhLtF!td左己一劫奴宜互月抹并朴成抉首9若其中某序列得不到，则说明原因。" ID="1">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="A，C，B，E，DA，C，B，D，BB，C，A，D，EB，A，D，C，EE，D，B，C，A" ID="2">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="4.试用栈实现链表倒排的算法。" ID="3">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="5.有一有序的链表（从小到大），试利用栈筛选出结点值大于给定值vo的所有结点至找中，" ID="4">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Picture URL="00000092\00000092_new\0012.jpg">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Picture>
      <Paragraph CONTEXT="主日‘巴么‘J.备岛闷，，甲习沙舀J.止，创卜，刁对二石卜尾只六乡暇芬口灵产」奄护认，代艺.J牙口左如、" ID="5">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="试给出静态存放分配方式下的链式找的进找、栈浦、栈空算法。利用两个栈：1和蛇模拟一个队列，并写出队列空、人队和出队的算法。给定一个由100个存储单元组成的初始为空的存储区域，并用它构成顺序存储队列，以整数序列作为输人。当n》0时表示将n人队，当，1时表示人队列中出队一个元素，尔0表6.7." ID="6">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="8.示运行结束。设计一程序将队列构成环形状态，并给出队空、队满、人队、出队程序。将上题100个存储单元组成空白链表，用静态存储分配方式构成链式队列完成上题要求程" ID="7">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="序设计任务。" ID="8">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="后一个结束符为回车换行符。I4.试给出静态存放分配方式下的链式队列的进队、队满、队空算法。1气右空停出冲良场1.二。/v/7t'PII田特蛇冲岸两七飞胜。.，六了－的场作舟皿＿巧.有字符串次序为3.y－－aly八7，试利用栈将次序改为3y.ay7＾l－－的操作步骤。（用j代表扫描该字特申过程中顺序取一字符进栈的操作，用8代表从中取出一字符加人到新字符串尾的出栈操作。）例如，ABc变成为B以，则操作步骤为万Sjss。按照运算符优先级，画出对下列算术表达式求值时操作数栈和运算府找的变化过程：A＋B屹＊n下.E。16－，7.试写出一个判别表达式中开、闭括号是否配对的算法。" ID="9">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="本章将介绍计算机程序设计中应用非常广泛的数据结构：栈。逻辑上，它应属于线性表的范畴，只是与线性表相比，它的运算受到了严格限制（故也称为限定性线性表）。之所以单独讨论它，是由于它在程序设计中十分重要。" ID="1">
      <fptr EndPN="00000064" StartPN="00000064"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000094" TITLE="第四章  串" TYPE="Chapter">
    <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
      <div ORDERLABEL="00000094" TITLE="4.1  串的定义" TYPE="Chapter">
      <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
        <div ORDERLABEL="00000094" TITLE="4.1.1  串的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
        <Paragraph CONTEXT="由于字符串实质上就是线性表.虽然是特殊的线性表，但其特殊性只是数据元素的类型，" ID="1">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="对数据元素之间的关系没有影响，所以字符串的逻辑结构与线性表是一样的，即：对于字符串" ID="2">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="Sclcz…c：'（nabc：只有一个后继c2,c。只有一个前驱c，除c：和Cn-，外，c;(2" ID="3">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="5＝，cl。：…（n〕0），c：只有一个后继cZ，c。只有一个前驱c卜：，除c：和cn一，外，c‘（2" ID="4">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="感1毛n-1）都有且只有一个前驱c卜1和一个后继ci＋，。由于对字符串的操作通常是以字符串的" ID="5">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="整体作为对象的，所以，在实际应用中，对字符串中字符之间的这种逻辑关系的关注程度不如" ID="6">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
        <Paragraph CONTEXT="串置为空串等。在下面的串抽象数据类型定义中将给出这些操作的具体定义。" ID="7">
          <fptr EndPN="00000094" StartPN="00000094"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000094" TITLE="4.1.2  串的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
        <Paragraph CONTEXT="CampareStr(S1,52)" ID="1">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Picture URL="00000095\00000095_new\0002.jpg">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Picture>
        <Paragraph CONTEXT="CoacatStr(StS1,52,53)" ID="2">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="ReplaceSu[8cS1,52,53}" ID="3">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="从字符串51中侧除第P个字符开始、长度为1即的子申" ID="4">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="若字符串S1中有和非空字符串S2相同的子申，则返回子申" ID="5">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="S2在SI中第P个字符之后第一次出现的位1；否则返回。" ID="6">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="返回已存在的字符串5中字符的个数，即；字符申S的长度" ID="7">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="用52返回字符串51中从第P个字符起、长度为l。的子申" ID="8">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="若字符串S为空串，则返回TRUE.否则返回FALSE将字符串S为空申InsertStr{t51,p,S2)DeleteStr(8cS1,p,len)IndexStr(SI,S2,p}Suetgth(S)EmPtYSMS)ClearStr(dtS}｝对于4PSct中的基本操作可以有不同的定义方法，而且：在上述13个基本操作中，有些操" ID="9">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="(Coapare5tr)、串的联接（Cancat5tr)、求串的长度（StrLeflgth）和求串的子串（StrSub)，可以" ID="10">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="实现除了串的撤消（Deslroy5dr〕和将一个串置为空串（ClearStr）以外的其他操作。通常称" ID="11">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Paragraph CONTEXT="AssignStr,CampareStr,ConcatStr,StrCcngth和StzSub这5个操作构成的集合为OPSet中的最" ID="12">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Paragraph>
        <Picture URL="00000095\00000095_new\0026.jpg">
          <fptr EndPN="00000095" StartPN="00000095"/>
        </Picture>
      </div>
      <Paragraph CONTEXT="串的特殊性表现在元素为字符的线性表，通常称串为字符串。于是对字符串可作如下描述：字符串是由零个或多个字符组成的有限序列，一般记为：5c,c：一cn'(n妻0)其中，cczcn部分的单引号是为了表示字符串S是特殊的线性表月为一般线性表表示拟ci,cZ，…，c。）。c‘（1威‘n）是字符集中的一个字符;n是字符串中字符的个数，称为字符串的长度。零个宇符的串称为空串，其长度为零。下面对字符串的逻辑结构进行描述并给出字符串的抽象数据类型定义。" ID="1">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000095" TITLE="4.2  串的表示和实现" TYPE="Chapter">
      <fptr LogicalPageNum="95" PhysicalPageNum="95"/>
        <div ORDERLABEL="00000095" TITLE="4.2.1  串的静态顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="95" PhysicalPageNum="95"/>
        <Paragraph CONTEXT="charelem[MaxSize];" ID="1">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="intMaxSize,Length:jSSlring;对于这种存储结构，字符串的实际长度Length可以在MaxSi二范围内变化，一旦字符串的实际长度超过这个预先定义的最大长度，则超过部分的字符将被截去，称之为“截断”。例如，当MaxSize=S时，字符串SIabc'和字符串S2-uvwxyx'的静态顺序存储状态如图$Picture[00000096\00000096_new\0007.jpg]Picture$$Picture[00000096\00000096_new\0008.jpg]Picture$(a)S1-ay的静态顺序存储状态（b)S2-uvwxyz，的静态顺序存储状态图4.2.2字符串的静态顺序存储状态下面给出在静态顺序存储结构下串的联接（ConcatStr）和求串的子串（StrSub）操作的实现算法。" ID="2">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="I.的联接操作二ConcatStrSI,52.S3)例如，S2abcS3uvwxyz，则Sl牙abcuvwxyz'，即：串的联接就是将两个串中一个串的头与另一个串的尾相联接。这里，对于CancatSbrSI,S2,S3}作，是将S3的头与S2的尾相在静态顺序存储结构下实现该操作主要是要考虑“截断”问题，即：该操作得到的结果S1有可能是不完整的联接结果。因此，算法中应该有相应的状态报告。具体算法如下：争态顺序存储结构下串的联接算法C:oncatStrtSStnng＆51,SStnngS2.SSvmuSf(S21cngth，S3.lengthSl.tif;rxSiic)d:iitififc3LrI;K巧2.lcngth;iS1.c1crnJ：1[,S2.c1crnJ二for(iI,i&lt;二S3.length;i。卜）Sl.ckntJS2.lcngth，i-I]二S3clcm[i-I51-length-S2.knglh+S3.lcngth(SISLuSize&gt;S2.IengthkZRISI1AazSuo-S&quot;Jength，S3.length断悄况-2.length;tSlclcm[iIJ巧2.clci尸“（1＝1；.＜‘51.M奴51，巴一S2.Icngth" ID="3">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="S1.clcm[S21ength+i］二S3.elcm(t-11" ID="4">
          <fptr EndPN="00000096" StartPN="00000096"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i二1:ic=Sl.LiaxSiic;iSl.clcm[卜IS2.elc川(i-1！;" ID="5">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="SI.length二SI.AtaeSiZc:" ID="6">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="ntum-1;当S2.length+S3.length.Sl.MaxSize时，S1得到的是完整正确的结果；$Picture[00000097\00000097_new\0005.jpg]Picture$②当S1.MaxSize.52.lesgthtS3.length并且S1.MaxSizeS2.length时，S1得到的是“截③当S1.MaxSize落S2.ltngth时，得到的也是“截断&quot;的结果若SI.MaxSize=S2.Iength,则截断的是整个S3；若S1.MaxSizeS2.length，则截断的除了整个53还有S后面的一部分。当有“截断’时，返回“一l&quot;；没有“截断”时，返回“+1" ID="7">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="2.求串的子辛操作：StrSub(S1,St:S2,p,len)字符，v’起，长度为4的子串’wvxy“截断”间题，还要考虑P和len的合法性间题。" ID="8">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="只有当1cpcSl.lengih并且U‘leneSl.Iengtlrp+l时，P和len才是合法的。因此，算法中要白矛才去口r份配卜引卜J匕生扭，扫匕目产女日甘.企七丹性一厂＿静态顺序存储结构下求串的子名算法" ID="9">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="mtStrSub(SStringS1.SStnng3St,intp,tint1cn)" ID="10">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="11">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="ifp&lt;1二盯F二·Sl.length)Illcn&lt;Ullpcn&gt;Sl.length-palp91en不i" ID="12">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="return0;" ID="13">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="if(S2.Bfaxsac1cn)" ID="14">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="（for(i=laic=lcn:iS2.clcm(i-I)巧I.clcm(pi-1）一IJ.Slength-Icn:return1;" ID="15">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="16">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i-l;i&lt;巧2faxsizc;iS2.elcm(i-1卜S扭clcm(p.（卜1卜1J;S2.lcngth=S2.rfaxsirr.rctum一：》当P或len不合法时，返回“Ay；当p或1二合法时，返回当有“截断”时，返回u-laa" ID="17">
          <fptr EndPN="00000097" StartPN="00000097"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000097" TITLE="4.2.2  串的动态顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="97" PhysicalPageNum="97"/>
        <Paragraph CONTEXT="的动态顺序存储结构如图4.2.3所示。" ID="1">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="洱白立立二二上兰图4.”宇符串的动态顺序存储结构其中，eletn用来表示动态的一维数组类型的空间，是有Length个元素、元素类型为字符的一维数组类型，用来存放字符串中的字符。Length存放字符串的实际长度。当Length为零时，eletn为空（NULL)a" ID="2">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="相对于此结构的类型用HString表示，其描述如下：typedefstruct｛char+eletn;根据7要分配相应大小的存储空间oitttI.engtlt;}Hstring;现算法。" ID="3">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="1.串的联接操作二ConcatS&gt;rSI,S2,S3)动态顺序存储结构下求串的联接算法voidConcatStr（万{String&amp;S1,HStnngS2,HS(ringS3){if(SI.clcm！二tiLL)deleteSl.clem;S1.elcm-newchar[S2.length+S3.length" ID="4">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="for二l:ieSIcngthaSl.elem[i-I]幼2.elem[i-11.for(i=l;iS3.length;iSLclcm[S2.Icngth＋卜11S3.clcm[i-lSI.length=S2.length+S3.length;l由于存放S1的依的存储空间是按S2和S3的实际长度的和分配的，所以，不会再出现“截断”问题。之求串的子串操作：StrSub(S1S2,p,len)在动态触序存储结J下实现该作不用再考虑u断”问题.但还是要考虑p和len的合算法中还是要有相应的状态报告。少毛休算法如F动态顺序存储结构下求串的子串操作intSvSub(HStringSl,HString&amp;S2,intpintIcn)ifp%1-II(p&gt;S1.lcngth)I班cn:dI(1cn&gt;S11ength-p+11lpy1cn不合法return0:" ID="5">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="，ff52.elem’一NULL)delete[JS2.elem:" ID="6">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="iflen)S2.elem-NULL:" ID="7">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="8">
          <fptr EndPN="00000098" StartPN="00000098"/>
        </Paragraph>
        <Paragraph CONTEXT="fcu(i;i＜二Icn;i" ID="9">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="ti2.ckm1】二SLclemlp+li-I)" ID="10">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="S21engthIcn;" ID="11">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="rcturn1:" ID="12">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="1当p或lcn不合法时，返1n1.0.；当P或len合法时，返1舀1" ID="13">
          <fptr EndPN="00000099" StartPN="00000099"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000099" TITLE="4.2.3  串的链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="99" PhysicalPageNum="99"/>
        <Paragraph CONTEXT="同线性表一样，字符串除了可以有顺序的存储结构外。还可以有链式的存储结构。只是由于字符串的元素是字符，所以字符串的链表有其特别之处。即：除了和线性表的链式存储结构一一链表一样，一个结点存放一个字符外，还可以一个结点存放多个字符，所以，在字符串的链式存储结构中，相应链表的结点有所谓“大小”的问题。当一个结点中存放一个字符时，结大小为I的链表，图4.2.4(h）是结点大小为3的链表。乱，份卡口～皿侄翰图牡A（a）结点大小为1的链表比脱劝｝｝····｝丁’干符；next是指向下一个结点的指针，" ID="1">
          <fptr EndPN="00000100" StartPN="00000099"/>
        </Paragraph>
        <Paragraph CONTEXT="相对于此结构的类型用LString表示，其描述如下：" ID="2">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefswct" ID="3">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="4">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="charch[N/M由用户自已定义" ID="5">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="Chnode*nezt;" ID="6">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="}Chaode;" ID="7">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="8">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="9">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="Chnode*Slrhead,Stttail;" ID="10">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="int1ength;}J.String;在选择结实际分配的存储位显然，存储密度越小，存储空间的使用率就越低，而存储密度越大，存储空间的使用率就越高。那么，存储密度与字符串链表结点的大小是怎样的关系呢？假设每个指针所占的空间可存放4个字符，那么当结点的大小是l时，此链表的存储密度只有20%，如果结点的大小为" ID="11">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
        <Paragraph CONTEXT="4，则此链表的存储密度就提高到SO%。但在对字符串进行处理时，用结点大小为1的链表表示，其效率要高于用结点大小为4的链表表示。由于在实际应用中，所处理的字符串往往很长难在存储效率和处理效率中找到非常合适的平衡点，因此，字符串的这种存储结构是不太实用的。对于字符串在链式存储结构下基本操作的实现也不作讨论，读者有兴趣可自己给出有关" ID="12">
          <fptr EndPN="00000100" StartPN="00000100"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000100" TITLE="4.3  串的模式匹配算法IndexStr(S1,S2,p)" TYPE="Chapter">
      <fptr LogicalPageNum="100" PhysicalPageNum="100"/>
        <div ORDERLABEL="00000101" TITLE="4.3.1  普通模式匹配算法IndexStr(S1,S2,p)" TYPE="Chapter">
        <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
        <Paragraph CONTEXT="丰牛牛李51：51吸为…阮为砂l’.’几52：p，认…p.1入" ID="1">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="如此反复，直到下面两种情况之一：或者到某轮匹配时满二p1二加，一介1＝PIn，匹配" ID="2">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="成功，In业xs城51，52，1）的值为1；或者到52移到了无法与51继续比较为止，即当52移到51" ID="3">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="串的模式匹配算法" ID="4">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT=".ntlndexS喊11Stringsl.115tnngSZ.IntP）" ID="5">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="f" ID="6">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="1＝Pj二1；" ID="7">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="wh.1试（1＜“51.kn浮！，）灸＆0＜＝5乙.公n邵h））" ID="8">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="if（S［elcn、11-1！二巧2.elemU-1］）" ID="9">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="10">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="卜1；j弓＋1；" ID="11">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="12">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="el弘士" ID="13">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="f" ID="14">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="1勺一＋2：jl：怪" ID="15">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000102" TITLE="4.3.2  改进的模式匹配算法KMPIndexStr(S1,S2,p)" TYPE="Chapter">
        <fptr LogicalPageNum="102" PhysicalPageNum="102"/>
        <Paragraph CONTEXT="I.改进的模式匹配算法的基本思想" ID="1">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="分析普通模式匹配方法.当进行第t轮匹配时：" ID="2">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="SL:SySystSc+szskzgrrk-lSt+k‘.‘Si-k41Si-k+2“‘si-igisi+l’.‘sn" ID="3">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="S2,PiPzP3二k-1PkPk+3·Pl-k+3PJ'k.z·Pj一PiPi*k二Pm遇到sr-plsSt+1=Pz,..,Si1=Pr，但sp时，就要对51和S2进行回溯.而且S1和S2都是“深”回溯，即：S2要回到p,,51要回到s+i，再进行新一轮的匹配。然而，仔细分析，回溯的程度没有必要这样深。S1中从。t+，到S；之间的字符，若St+lPl+St+2*p1.St+3P1.''+st+rPi+st+r+1=P1，则至少从St+i到：i+r这一部分是不必回溯的。进一步，如果存在一个k{k&lt;）使‘5、15…5、1,Sk+1Sik+2Sirl-FlpzP3溯：第二：S2则只用回溯到Pk，即新一轮的匹配从Sl的s‘与S2的Pk开始。这样，整个匹配过程中，S1没有回溯，S2则是尽可能“浅”地回溯，使匹配效率大大提高。改进的模式匹配算法KMPIndexStr{S1,S2,p)的基本思想正是如此，即：在某轮匹配中遇到灸二Pic+i二p2+,Si-leiisiPl时，,一轮匹配从s。与P{k&lt;j沮有，‘-k+ist+zsi_1PiPzP3Px1`）的比较开始。现在的问题就是，这个k怎么找，即：当si*PJ时，s＊应该与S2中的哪个字符开始进行新一" ID="4">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="轮的比较，或者说当匀Pi时，S2要回溯到第几个字符？" ID="5">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="前面的分析已谈到，如果存在一个k(k&lt;j）使" ID="6">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="1，其他情况例如，模式串5脚abcaababc，，其next数组各元素的值如下：确定next数组各元素的过程如表4.3.1：当j＝5时，｛kll＜k＜j》集合为：｛234卜于是，要对（p：，P’以PlpZ，p承狱PI仰功，p甲刃；随些模式串52中的子串进行比较，以找出｛234｝集合中满足条件’p；p必，二p卜外k，1功一＋2…外1’的最大值。由于在（p：，P4）、（plPZ，p3p‘）、" ID="7">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="〔p：卜脚，pZ众刃4）这些子串中，只有PI即；，所以，next［5卜2。读者可自行写出对应于」＝7的集合Ikll欢＜j｝，并列出各个k对应的子串，以分析为什么next【7］＝3。对j＝8、」＝9也可同样如此。$Picture[00000103\00000103_new\0011.jpg]Picture$率下翎州；有件" ID="8">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="上述确定next数组各元素next山的过程是从n既t数组定义出发，直接通过j与k的关系得到next川的，而实际上，可用递推的方法从next田得到next口＋l！，此递推可以从ne双数组定设next印＝k，这表明在模式串52中存在下列关系：，Plp动·如，＝喻二、Pj－k＋2·PJ－－r（4－－1）这就表明，next争11＝k’＋l，因为k'text[k所以有：next[j+11=rtextX]cl(4b)若PIS，则再取，Ptpa,P二，'Pr中第next[k'】个字符与f?i进行比较.……，依此类推，直到某$Picture[00000104\00000104_new\0004.jpg]Picture$一个Pi与此时的模式串中的某个字符相等，利用式（4-6定next[j+l］的值；或者不存在任何k'kj）满足式（4-5}，则根据next数组的定义得到用上述递推的方法，在已经求得前7个字符的next值的情况下.求next[7+11(nextj+l]}o已知n既t［7卜3（祠，目），而1=e1M二，即f？却试Px产i这时再将P7和Pt（因为next[31=1," ID="9">
          <fptr EndPN="00000104" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="3.建立n二t数组的算法" ID="10">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="总结上述建立next数组的方法，模式串S2的每个字符，除了Pt对应的next[11习,p2对应" ID="11">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="的next[21=1外，对于其他字符p](2cj‘an-l,m为S2的串长），将Pi与pk(k=next[l）比较，" ID="12">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="若Pi二pr,lnext11=nextlu则,重新取值二xt因郡够顽kl～k再将与Pk比较，……，" ID="13">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="如此反复，直到某个k值使Pip，或k0ncxt[j+11=next[k1。具体算法如下（注意算法中" ID="14">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="next数组元素从0开始编号）：" ID="15">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="止立.数组算法" ID="16">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="vitiJCctncxt(HStrinbSintRmcxt[J)" ID="17">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="18">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="j＝1：ncxt［0］0；k刃；" ID="19">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="whllc臼＜Slcn名th）！{j-J+1;k-k+1,nCxtj-l1=k;J" ID="20">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="dsck-ncxt[k-1J;" ID="21">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="22">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="23">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="d改进的技式匹配荞法" ID="24">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="有rnext,（组.就可给出改进的拱式匹配算法了" ID="25">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="串的级式匹配葬法intKMPInclexStr(IIStnngSL,1lStnngS2,intp)" ID="26">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="else-ncx砚(j1d(1:S2kYigih)returnS2.Icngth.c1kreturnU" ID="27">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="》" ID="28">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="将主甲S1第P个开始的字符s;{p‘i缤n,n=Sl.lengtlt)，与模式串S2从第f开始的字符p(1jgym,m=SZ.length}c次进行比较：若sit,sppx····,断刃m，则匹配成功，这时，I-F仍一1，算法返回i-1,到第next[j]个字符，即：next[17一，再将Pi与s；进行匹配，若仍然不等.继续回溯，直到某P=s或j习+则进行斗、与外、开始的匹配过程.……。如此反复直到或者匹配成功，则算法返回i-m+l；或者S1再无法与S2进行匹配，即：i=51.length+l，而」‘SZ.length，则算法返回0," ID="29">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="模式匹配是字符串处理中最重要的操作之一。对模式匹配操作是这样定义的：若已存在本节将根据上述基本思想，给出两种不依赖于其他字符串操作的模式匹配算法，一种是普通模式匹配算法，另一种是改进的模式匹配算法。下面分别讨论。之下竺接中的字揍出为垂田翩木丽良之盆卖会玄古均" ID="1">
        <fptr EndPN="00000101" StartPN="00000100"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000105" TITLE="习题四" TYPE="Chapter">
      <fptr LogicalPageNum="105" PhysicalPageNum="105"/>
      <Paragraph CONTEXT="1.设aJI二8teaf]ef,1good',tmorning',dr`tea，,eao" ID="1">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）调用ConcatStc(tf,b,c)后，结果是什么？若再接着调用ConcatStr(t2,t1,a}结果是什么？" ID="2">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="（，、弓用田斗祝”卜了。企‘。、已全鑫月区丰熟村令i." ID="3">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="{3)调用】ndexStr(a,d,1lndexStr(a,e,1)、IndexStr(c,e,1}结果分别是什么？" ID="4">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）连续执行以下调用，s中结果是什么？StrSub{a,s1,1;SLrSuh(a,sZ,8.8ConcatStr(s3,sI,b);" ID="5">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="ConcatStr(s,s3,s2" ID="6">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="2空白串与空串有何区别。" ID="7">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="3＿份.曰义＊，＋尹.h二，xl2_d1，!uF3i'ass-rlit#4'fE_1能很5!h7" ID="8">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="3.写出在静态顺序存储结构下玩serts四〔＆S1，p，5乃操作的实现算法。写出在动态顺序存储结构下。pystr碑51，52操作的实现算法。" ID="9">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="写出在结点大小分侣叨为1和4的链式存储结构下ConCa‘城＆S1，52，劝操作的实现算法。" ID="10">
        <fptr EndPN="00000105" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="写出在结点大小分别为1和4的链式存储结构下5昭ub（sl，及52，p，Icn解作的实现算法。4.5.图。11‘设串采用链表结构存储，利用本章所定义的运算，给出下列算法：把一个串中从左到右最Sir.出孤1sb改亦1c:#一个串中从左1右第=k出PIsbt'亦ffi:cP！一个串中从方到右全部sb改变成c；把一个串中从左到右第三次及以后出现的sb改变成。；把一个串中倒数第一，第二，第三个：b串改变成c（提示：利用一个栈找出倒数第一，第二，第三个：b的位置）。12已知串a和b.试用两种不同的存贮结构，求所有包含在a中而不包含在b中的字符构成的新串。" ID="11">
        <fptr EndPN="00000106" StartPN="00000105"/>
      </Paragraph>
      <Paragraph CONTEXT="13.设：和y是表示成单链表的两个串，试写出一算法，找出x中第一个不在y中出现的字符（假定每个结点只存放一个字符）)o" ID="12">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="串是一种特殊的线性表，其特殊性表现在这种线性表的元素是单个的字符。计算机处理的大量非数值问题中，串的应用是最广泛的。但在广泛应用中，串总是整体作为处理对象的，有其特有的方法。" ID="1">
      <fptr EndPN="00000094" StartPN="00000094"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000107" TITLE="第五章  树" TYPE="Chapter">
    <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
      <div ORDERLABEL="00000107" TITLE="5.1  树、森林的概念" TYPE="Chapter">
      <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
        <div ORDERLABEL="00000107" TITLE="5.1.1  树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
        <Paragraph CONTEXT="定义：一棵树是非空的有限元素的集合T，其中：·有一个元素称为该树的根（root)o。除根以外，其余元素（如果存在）分成k_U个不相交的集合'ri,Tz····，Tt，而每一个集合T;又都是树。树&quot;i,Tx，Tr称为根的子树。树中的元素通常又称为树结点。显然，树的定义是一个递归的定义。我们用树定义树，按递归技术的规定，这是可行的，因为具有一个结点的树必由根组成，而k&gt;1个结点的树则借助于少于k个结点的树来定义。" ID="1">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000107" TITLE="5.1.2  树的术语" TYPE="Chapter">
        <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
        <Paragraph CONTEXT="父亲）。。兄弟和堂兄弟：同一父亲的孩子结点互为兄弟。其双亲结点在同一层次上的孩子结点互为堂兄弟。·祖先：一个结点的祖先是指从树的根到该结点所经分枝上的所有结点。·子孙：一个结点的子树上的所有结点都称为该结点的子孙。" ID="1">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Picture URL="00000108\00000108_new\0009.jpg">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Picture>
        <Paragraph CONTEXT="I的度为零，它们是终端结点，也叫叶结点，都是结点A的后代，A是它们的祖先。结点A,C,D,G的度不为零，它们是分枝结点。·有序树和无序树：如果将树中结点的各子图5」2树的层次树看成是从左到右有序的（即不能互换，这在树" ID="2">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="的定义中没有限制），则称该树为有序树，否则称为无序树。" ID="3">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="之所以要讨论有序树，是因为在计算机中，数据的存储是有序的.所以我们讨论树时也规" ID="4">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="定树的子树Ti,T2,…,Tk是有一定的相对次序，同一层次的子树交换相互间的位置就构成不同的树，如图5.1.3(a）和（b）就是两棵不同的树。$Picture[00000108\00000108_new\0023.jpg]Picture$$Picture[00000108\00000108_new\0024.jpg]Picture$点就变成了森林。如图5.1.3所表示的树，如果删去" ID="5">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="根结点A就变成了以B,C,D为根结点的三棵树组成的森林。反之，n棵树组成的森林只要加上一个根结点，然后将这n个树作为这个结点的子树则森林就（{a)(b)图5.1.3两.不同的树" ID="6">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000108" TITLE="5.2  二叉树定义及性质" TYPE="Chapter">
      <fptr LogicalPageNum="108" PhysicalPageNum="108"/>
        <div ORDERLABEL="00000108" TITLE="5.2.1  二叉树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="108" PhysicalPageNum="108"/>
        <Paragraph CONTEXT="的二叉树有一棵右子树F;等等。" ID="1">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="很明显，二叉树的定义也是一个递归定义。" ID="2">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Picture URL="00000109\00000109_new\0003.jpg">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Picture>
        <Picture URL="00000109\00000109_new\0004.jpg">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Picture>
        <Paragraph CONTEXT="2.二又树的定义与树的定义的区别" ID="3">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="{1)二叉树存在着空树；但树不能为空。" ID="4">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）二叉树中的每一个结点只可食睛0个，1.个或2个孩子，也就是说，二叉树不存在度大于2的结点；而树中的每个结点可以有多个子树。" ID="5">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)二叉树的子树有左右之分，两者不能颠倒；但树的子树一般是无序的。除以上区别外，上一节引人树的有关术语对于二叉树也适用。" ID="6">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="3.满二叉树的定义若二叉树中所有分枝结点的度数都为z，且叶子结点都在同一层上，则称这类二叉树为满二叉树。一棵满二叉树除了最深一层上有叶子结点外，其他层次上都是分枝结点，如图s.2.2" ID="7">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="所示。" ID="8">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="4。顺序二叉树的定义如果对满二叉树从上至下、从左至右地从i开始编号，如图5.2.3所示，如有一棵包含有n的结点一一对应，则称这类二叉树为顺序二叉树，如图5.2.4所示。图5,2.3一裸从上至下、从左至右地从1开始编号的满二叉树" ID="9">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Picture URL="00000110\00000110_new\0001.jpg">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Picture>
        <Picture URL="00000110\00000110_new\0002.jpg">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Picture>
        <Paragraph CONTEXT="5.完全二叉树的定义若二又树中所有分枝结点的度数要么为2，要么为0，称这类二叉树为完全二叉树。$Picture[00000110\00000110_new\0006.jpg]Picture$$Picture[00000110\00000110_new\0007.jpg]Picture$可以从满二叉树，顺序二叉树和完全二叉树的定义中得出结论：满二叉树一定是顺序二叉树和完全二叉树。而顺序二叉树和完全二叉树之间没有因果关系。图5.27的二又树既是一棵顺序二又树，又是一棵完全二叉树。如果在此树中去掉结点I，则图5.2.7是一棵顺序二叉树，但不是完全二叉树。" ID="10">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
        <Paragraph CONTEXT="5.退化二叉树的定义如果一棵非空的二叉树只有一个叶子，且其余结点均只有一个孩子，则称这棵二又树为退图5.2.8退化的二叉树" ID="11">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000110" TITLE="5.2.2  二叉树的性质" TYPE="Chapter">
        <fptr LogicalPageNum="110" PhysicalPageNum="110"/>
        <Paragraph CONTEXT="1.性质i在二叉树的第亩层上最多有2个结点（i）i当i二1时，21-1=1，这时只有一个根结点，显然结论是正确的。假设，对于所有的j(lsji）结论也成立，即第j层上至多有-，个结点，那么，我们也可以证明当j=i时结论也成立，证明如下：由归纳法假设知道，第i-1层上至多有尹个结点，由于二叉树的每个结点至多有两个孩" ID="1">
          <fptr EndPN="00000111" StartPN="00000110"/>
        </Paragraph>
        <Paragraph CONTEXT="子，所以第i层上最大结点数应为第i-1层上最大结点数的两倍，即第i层上最多结点数为：" ID="2">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="2.性质2" ID="3">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="可以由性质1推出上述结论。显然，深走显然，深度为h的二叉树的最大结点应为各层最大结点之和，即为：七l艺(i层上的最大结点数）一艺2i一‘二2“一，亩一1t二i" ID="4">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="3。性质3证明：二叉树中每个元素（除根结点外）有且仅有一个双亲结点。而孩子结点与双亲结点" ID="5">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="4.性质4证明：设二叉树的度为1的结点数为nl，又由于二叉树中所有结点的度数都小于或等于2,所以其结点总数n应为：n二nwl+nz(5-1)除根结点外其余结点都有一个枝进人，则二叉树中的分枝总数b为：tin-1{5-2}又由于度为1的结点发出一个枝，度为2的结点发出两个枝，所以有：bnx+2n2(S-3)" ID="6">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="从5-2式和5-3式得到n-1=n2nx，整理得" ID="7">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="n=2nz+nl+1(54)" ID="8">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="击《，志产买n‘月d‘自全闰日〔乡石丁」且.＿一＿、.石耳！》丹当且今求" ID="9">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="5.性质5于其中任意编号为i的结点（lirn）有：$Picture[00000112\00000112_new\0003.jpg]Picture$当i=1时，按顺序二叉树的定义知，i的左孩子是2.即如果2i=2*1岌n时，结点1的左孩i+子是2，当2t=2*1&gt;n时，说明不存在两个结点，当然也没有左孩子。若2i+1=2*1+1蕊n，结点121回‘t＋l因四zl＋t有右孩子为3，若2i+1=2*1+1&gt;n，说明该结点不图5.2.9顺序二叉树父子关系存在，所以无右孩子。现在假设对于所有的i(liaii的左孩子是2i且当2in时无左孩子;i的右孩子是2i+1,当2i十1&gt;n时，无右孩子。我们再来证明，对于结点i+l，性质6的（2）和（3）也是成立的。因为，根捆顷序二叉树的特点，与l+1的左孩子相邻的前两个结点是i的左孩子和右孩子，由上述假设知，i的左孩子是2i,i的右孩子是2i+1（见图5.2.9}。因此，i+1的左孩子应是2i十公理（1＋l），如果2(i+1n，说明该结点不存在，所以i+1无左孩子，而i+1的右孩子应是2i+卜2(i+1F1，若Z(i+11&gt;n，说明不存在该结点，也就无右孩子。因此结论（2)和（3）得证。最后来证明结论（1)0当i=1时，i就是根结点，无父亲，当ill时，由结论（2}和（3）知道，如果i为左孩子，即2{if2i，则结点irz是结点i的父亲；如果i为右孩子，设i=2p+l,i结点的父亲应为P结点，p＝（卜1）今恤J，所以无论哪种情况均有结点l;rz」是结点i的父亲。证毕。" ID="10">
          <fptr EndPN="00000112" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="如从左至右，从上至下的，对每个结点从0开始编号，对于其中任意编号为i的结点（0" ID="11">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="inn-l有：(}若i0，则i的父亲是{i-12；若i=0，则i是根结点，无父亲。(z）若2{i+116n，则i的左孩子是2(i+11；若2{i+11&gt;n,则i无左孩子。" ID="12">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="{）着2{i+1}‘n，则i的右孩子是2(i+1)；若zti+in，则i无右孩子。" ID="13">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000112" TITLE="5.2.3  二叉树的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="112" PhysicalPageNum="112"/>
        <Paragraph CONTEXT="o。，_加尽茉坦生妹朴七组姑占创牛与芦树翻右闷芦为甘。幕个子树机扶县一个一1树" ID="1">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Picture URL="00000113\00000113_new\0001.jpg">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Picture>
        <Paragraph CONTEXT="｝" ID="2">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000113" TITLE="5.3  二叉树的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <div ORDERLABEL="00000113" TITLE="5.3.1  二叉树的顺序存储概念" TYPE="Chapter">
        <fptr LogicalPageNum="113" PhysicalPageNum="113"/>
        <Paragraph CONTEXT="在顺序存储结构下，数据元素的逻辑关系是以数据元素存储的相邻性来实现的，而不是以指针方式来表示数据元素的逻辑关系。首先我们来表示一裸满二叉树或顺序二叉树的顺序存储。根据性质6，对一棵满二又树或顺序二叉树可以按层次从左至右地存储每个结点，即根结点存储在静态存储空间的首地址（0$Picture[00000113\00000113_new\0007.jpg]Picture$情况如图5.32所示。Ot2345bIA】BlclDl$IFIGf图5.3.1一裸满二叉树图5.3.2满二叉柑顺序存储而对于一裸退化的右单枝二叉树，如图5.3.5所示，以顺序存储方式存储时的情况如图5.3.6所示。图s.3s退化右单枝二叉树图53.6满二又Ii序存储从上面的各种二叉树的顺序存储可以知道，只有满二叉树或顺序二叉树的空间利用率是最大的.退化的右单枝二叉树的顺序存储的空间利用率是最低的。事实上，一个具有n个结点的二叉树（深度为h）可能最多需要21空间来存储。当每个结点都是其他结点的右孩子时，存储空间达到最大。当然满二叉树或顺序二叉树以顺序存储是合理的，但是，这种顺序方式存储时，结点的插人和删除十分困难，需要大量数据元素移动，所以二叉树一般不采用顺序存储方式存储。顺序存储的二叉树的结构定义与线性表的结构定义没有什么区别，只是按照性质6的关系来处理各结点。这里就不再描述结构类型。有到顶序存储方式下的二叉树的运算在这里不" ID="1">
          <fptr EndPN="00000114" StartPN="00000113"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000114" TITLE="5.3.2  二叉树的链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <Paragraph CONTEXT="1.二叉树的链式存储概念由于二叉树的每个结点的最大度数为2，因此，统一给出二叉树的每个结点的模式，不管二又树中结点的度数是0，或1或2。我们定义二叉树中的结点类型如图5.3.7所示。｛鲤乡笼丝！绪群坪.创考向右誉书唾｝" ID="1">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="图5.3.7二叉树链式结点结构" ID="2">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="如果二叉树的某个结点有左右孩子，则左右指针不空；如果二叉树的某个结点只有左或右" ID="3">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="孩子，则其右或左指针就为空；如果某个结点是叶子结点，则其左右指针都为空。每个结点的" ID="4">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="存储空间都以动态申请方式获取。如此定义的结构中，含有扭个结点的二又树中，共有链接域" ID="5">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="2n个，空闲的（不用的）链接域nI个（为什么？）。所有线点之间的关系是由每个结点的链" ID="6">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="接域来表达的。" ID="7">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="2.二叉树的健式存储结构定义" ID="8">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefsrructBT,P.q都是指向二叉树中树结点的指针，一般我们约定用BT指向一棵二叉树的根结点。" ID="9">
          <fptr EndPN="00000115" StartPN="00000114"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000115" TITLE="5.4  二叉树链式存储结构下的操作" TYPE="Chapter">
      <fptr LogicalPageNum="115" PhysicalPageNum="115"/>
        <div ORDERLABEL="00000115" TITLE="5.4.1  二叉树的操作概念" TYPE="Chapter">
        <fptr LogicalPageNum="115" PhysicalPageNum="115"/>
        <Paragraph CONTEXT="二又树的运算是与二叉树的定义是紧密相关，二叉树定义的特点中最突出的是定义的递归性，所以二叉树的运算有很多都是以递归方式完成的。" ID="1">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="z.二叉树的前序、中序和后序遮历所谓遍历，是指按一定的规律和秩序访问树中的每一个结点，且仅仅只访问一次，在访问每个结点时，可以修改它的内容，打印信息或做其他的工作。对于线性表来说，由于每个结点只有惟一的前驱和后继，这是一个很容易的事，但二叉树是非线性结构，不存在事实上的惟一前驱和后继，必须人为地作出规定，然后找出一个完整的有规律的遍历方法。若用L代表左孩子，R代表右孩子，D代表根结点，则二叉树有以下6种排序方法：DLR（根左右），LDR（左根右），LRD（左右根）" ID="2">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="DRL（根右左），RDL（右根左），RLD（右左根）" ID="3">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="为了简化，规定排序只能先左后右，则只剩下3种排序方法：DLR（根左右），LDR（左根右），LRD（左右根）如果再以根结点在排序中的位置来称呼这3种排序（遍历）方法，则有：·LDR（左根右）称为中根排序（中序）；" ID="4">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）中根排序（LDR）规则。首先按中根遍历的规则访问二叉树的左子树，如果左子树都已遍历，则访问左子树的根结点，然后，按中根遍历的规则访向二叉树的右子树。图5.4.I所示二叉树中根遍历结果为二DIBEAIFCLGM," ID="5">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）后根排序（LRD）规则。首先按后根遍历的规则访问二叉树的左子树，如果左子树都" ID="6">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="已遍历，则按后根遍历的规则访问二叉树的右子树，然后，访问二叉树的根结点。图5.4.1所示二叉树后根遍历结果为二IDEBFLMGCAo" ID="7">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="2.二叉树的层次遮历按层次遍历二叉树可规定为4种基本形式：" ID="8">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）从上至下、从左至右访问结点。图5.4.1的遍历结果为二ABCDEFGULMo" ID="9">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)从上至下、从右至左访问结点。图5.4.1的遍历结果为:ACBGFEDMLJI," ID="10">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）从下至上、从左至右访问结点。图5.4.1的遍历结果为：IJLNIDEFGI3CAo(4〕从下至上、从右至左访问结点。图5.4.1的遍历结果为：IVILTIGFEDCBAo" ID="11">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="3.构造二又树所谓构造二叉树，就是设定若干个结点.按一定的结构将这些结点联接成一棵二叉树。构造二叉树的过程分两步进行：一步是先构造结点；第二步是将产生的结点联接在一起。" ID="12">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="4.计算二叉树的深度计算二又树深度时，利用递归方式，先求到左子树的高度扭吹，然后再求到右子树的高度" ID="13">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="Hright；最后比较左子树和右子树的高度，取其最大值，即二叉树的高度。" ID="14">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="5.删除二叉树要删除二叉树，就是要删除其所有的结点，删除时不能从二叉树的根结点开始删除，而应" ID="15">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="该从二又树的叶子结点开始删除，否则将无法完成全部结点的删除并释放。删除过程可利用遍历的过程，从叶子开始，先删除左子树，再删除右子树，最后删除根结点。" ID="16">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="6.统计二叉树结.点数统计二叉树中的结点数可以利用任何一种遍历方法，在遍历时，每次访问一个结点时，就在统计个数的计数器中加一。" ID="17">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="7.插入结点或侧除结点在二叉树中插人或删除一个结点时，如果知道是完成哪两个结点的链接，是非常简单的事情，但是，找两个链接结点可不是一件简单的事。如果插人点找到了，准备擂人一个结点作为｝如果插人点找到了，准备擂人一个结点作为该结点的左孩子，如插人点没有左孩子.问题" ID="18">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000116" TITLE="5.4.2  二叉树的前序、中序、后序遍历操作" TYPE="Chapter">
        <fptr LogicalPageNum="116" PhysicalPageNum="116"/>
        <Paragraph CONTEXT="栈结构类型，算法的效率相对较高，算法本身具有综合性，是学习中重点关注的方法。" ID="1">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="1.二叉树的前序遮历(i)前序遍历的递归算法。按照前序遍历规则，首先访间根结点，然后遍历左子树，最后遍历右子树。soldPreOriler(I3mary'frceNode+HT)二又树的前序ig！递归算法" ID="2">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="if(BT)《tout«I3Tdata«i问二又树的u.1PrcOrdcr(BT一＞I.Chi)dPrcUrdcrlBT一》kChild" ID="3">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="}j" ID="4">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）前序遍历的非递归算法。由于有些高级语言没有递归机制，而且递归效率又较低，所以下面给出非递归过程的遍历算法，算法中借助于一个堆栈，用迭代的方法实现其二叉树的遍" ID="5">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="历。首先定义一个堆栈，堆栈的。letnent的数据类型是指向二叉树结点的指针。定义如下：" ID="6">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineMarStackSize100typedefstruct{6inar}ritreNode.eletaent;inttop;intMaxSiz亡：StackS;非递归前序算法遍历思想：" ID="7">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="A.结点指针非空时，或堆找非空时。如果结点指针非空时，首先访问“根”结点，转B步" ID="8">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="B.然后将访问过的结点指针（一个“根”的指针）进找，再将指针指向访问过的结点的左子树的根，转A步骤。" ID="9">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="C.堆找非空时，退提，指针指向退找结点的右子树结点，转Ao：又树的前序石伪非递归井法（竹d)rderti)voidPreUrdcrN(BinaryTrccNodeoBT)tII-4kttttY百1认;1IFit们Y.i?k" ID="10">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="StackS;BinaryTrccN&lt;xlesp=BT;Cn;atStack(S,tvlaxStackSize产生一个s找，这一过程函数可以不在这里进行1J:ii针ff向1t问过的“结点人IcL爪ptytS)" ID="11">
          <fptr EndPN="00000118" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT=".RCnad:/l9Cr针Y.fps向E'朔i点的右一f.}tf以上是动态存储分配方式下的二叉树的非递归形式前根遍历的算法。在算法中建立一个堆栈5，用来存放已访向过的结点的指针。栈的初态为空，伐的容量与树的深度有关，对于遍历深度为h的二叉树。所设的堆枚至少要h个存储单位。为了更深刻地领会非递归算法的前遍历过程，我们以图5.4.3的二叉树为例，用表54.1跟踪整个遍历过程。表5A.1二叉树前序遥历非递归过程步软访同结点钱5内容P的指向初态A、人人B2BABC3CA9C空（{C的左孩)dAB空{CEf`J&quot;r孩)5AD6pAD空（D的左孩子）7A$EAE空(B的左孩孔9A空｛(E的右孩子）IO空空《A的右孩子】" ID="12">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="（j！中序遍历的递归算法。按照中序遍历规则，首先遍历左子树，然后访问根结点，最后" ID="13">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="遍历右子树。" ID="14">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="又树的中序;53ii归J;(InUrdrr" ID="15">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="，v&quot;IrCCN（c1c.Li" ID="16">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Picture URL="00000118\00000118_new\0030.jpg">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Picture>
        <Paragraph CONTEXT="遥业」升" ID="17">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="LnOtJer(l3T一》LChddl{2）中序遍历的非递归算法。中序遍历的非递归算法中同样借助于一个堆栈，用迭代的方法实现其二又树的中序遍历。堆找的定义与郎笋遍历中相同。韭省落归中序偏乐竺井甲相，" ID="18">
          <fptr EndPN="00000119" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="A.首先结点指针（一个“根“的指针进找，然后将结点指针指向进找结点的左子树的根，重复A步，直到指针指向空（最后一个进找的是最左子树），转S步骤。" ID="19">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="B.堆找非空时，从堆栈中退出一个指向子树的“根”的指针，访问该指针所指结点，转到C步骤。堆找为空时，结束算法。二叉树的中序遍历非递归份法（lnUrdcr\)" ID="20">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="void[nOrdcN(BinaryTrccKudc.13'I" ID="21">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="阴二又树的中序泊历非递归算法StackS:B口aryTrccVudc.p=BT," ID="22">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="CreatStack(S,1,taxStackSizc产生一个空浅.这一过程函效可以不在这里进行du召chile(p)左了树{Push(S,p&quot;结点（未访间）#u针进栈，以后(o朔时冉逛找沪p－）LChlld：11指针yH向该“根“结点左子7｝if（！1、Emply（5〕）刀左子树为空时.i+l用堆找回朔《P叩（s.p）；，l从堆找中弹出回fl结点指针（该结点末访f'l过）cout«p-xlata«'piitG;&quot;fitrr" ID="23">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="卜少、RC、kJ：jl抬针jr,u向回朔结点的右子4f" ID="24">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="lwhilepNlsLmpty(S}.二又树的后序遮历＿1}后序遍历的递归算法。按照后序遍历规则.首先遍历左子树，然后遍历右于数，最石方问根结点。oidPoscU，dcsfBinsryTrecNodc，QT)二又树的中历递归样法" ID="25">
          <fptr EndPN="00000120" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="i(B'I'" ID="26">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="'ostOnler(B7一，LChild" ID="27">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="?uatOrS‘r(BT一，RChild" ID="28">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="gout«BT=，data11访fp{二又树的结点｛" ID="29">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="{2）后序遍历的非递归算法。后腿历的非递归算法中同样借叮碎林，用献的方法实现其二叉树J序遍历·麟的定义与前序或中序遍历中不mho一’一启施历的非递归算法中结点的进栈不卜次，每个结点要进颇次。麟后序‘历的.＿＿＿.介，.＿一已，自比理一二乙么痊龙各怪十书青同姗姑占＿的右子树，并遍历这个右子树，直到该右子树全部退历以后矛矜尽出该“根.结点，访问之。结构中增加一个粉据项.用干识我第几次讲播。汾增加的数据项是佘义挺型县，toolH;并且给i'iB的定义卫为。d泌时表示第一次进栈尹为恤" ID="30">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="巨画亚巫鱼卫兰蛋目" ID="31">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="图5.4.4堆栈中数据元素的结构" ID="32">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="时，表示第二次进栈。也就是说，每个结点指针第一次进伐" ID="33">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="时.B标志以false值进找；退栈时，如果检查其B标志为" ID="34">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="fa}se时，就通过退出的结点指针找其右子树，并改变B标志为。ue，重新将该结点指针进栈；" ID="35">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="如果退栈后检查其B标志为仃u已时，就访问退出的结点，不再进找。堆栈结构为：5如叩它硬BinaryTrNode*ptE" ID="36">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="hool" ID="37">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="于9巧伴日" ID="38">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="非递归后序遍历算法思想：" ID="39">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="A.当结点非空时或堆栈非空时，执行A步骤，否则，结束算法。" ID="40">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="B.当结点指针非空时，结点的进栈标志设为false，结点指针及进找标志进栈，然后将结点指针指向进栈结点的左子树的根，重复B步，直到指针为空（最后一个进找的是最左子树）；结点指针为空时，转C步骤。" ID="41">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="C.堆找非空时，从堆钱中退出一个结点的指针；如果退出的结点进栈标志为Crue，说明该仕古早竺一诗4耳姗耐褚甘待仕古业虫匕劣扑探翻4吞去六嘴欠气二＿汤袅裸业姑户案赚；如果退出的结点进找标志为false，说明该结点是第一次退找，则将进找标志设为二叉树的后r;历非递归算法（InOrdrr\)voidPrnt(kdaN(13utaryTrccV。K1cyRT)里二义树的a序i历非递归芥r" ID="42">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="SuckS;BtnarrTrectcxlcq）二t3T:CreatSt:uk(FcS,fi\t二StackSire产生一个s;找.这一过程函数可以不在这里进行" ID="43">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="STylx:temp,whilep)II!IsEmpty（及Sif印）11找址左子f｛tcmp.l3二false;1fCt进找的结点进栈标志设为第一次进伐tcmp.ptrp;Push(S,[Cmpii点（未访问）fu针及$T志进'.以后［CQ朔时再退浅P-P一＞LChild;fl针于FI^IL%“a&quot;Yr1点左一树" ID="44">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="｝else，t’（！1、EPty（5），11左了树为空时，1川%#i[1X11！p叩（5，tc.，11））；11从堆找中i'出l‘lrJfi.li;计及r志（该结.i未访间过）P-tcmp.prt:1lp向i找结点.古则p7Ui是空，为什么？" ID="45">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="d(tcmp.B)1COlltG&lt;p一川Jta＜＜11访「d该结点沪NUUpi&lt;为空的目的是为il;ltCf" ID="46">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="乡" ID="47">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="d、C" ID="48">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="I" ID="49">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="temp.D-true;11改变进找#c志.71(firif(fr进找" ID="50">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="Push(S,tempP=P一》RChlld；ll衍针衍向’'“的右了树" ID="51">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="I" ID="52">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="！乡标志为false，以t表示进栈标志为trueo表5A3二叉树后序谊历非递归过程步魏访间结点找S内容（t,f是B标志值）P的指向初态空A1AfB2AfBfC3AfBfCf空（(C的左孩于）" ID="53">
          <fptr EndPN="00000122" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="4AfSfCt空(C的右孩子）" ID="54">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="5CAfBf设皿)" ID="55">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="6AtBtD" ID="56">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="7AtBtDf空口的左孩子）" ID="57">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="SAtB[1)tE" ID="58">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="'AtBtDtfif空（S的左孩子）" ID="59">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="10AtBtI}tBt空甲的右孩子）itEAtBtDt空（强J设')!2DAtB‘空皿制设一一一‘些一一一一一一J监····一崖邀钓勉红一.＿＿＿＿" ID="60">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000122" TITLE="5.4.3  二叉树的层次遍历操作" TYPE="Chapter">
        <fptr LogicalPageNum="122" PhysicalPageNum="122"/>
        <Paragraph CONTEXT="按层次遍历二叉树可以有4种遍历形式，从上至下的有2种，从下至上的也有2种，下面" ID="1">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="只介绍从从上至下的2种遍历过程。二叉树的层次遍历结果与二叉树输出时的顺序是一致的一般精出显示或打印一棵树时，是一层层地从上至下输出。按层次遍历是一种重要的遍历方式。另外，层次遍历时，将使用一" ID="2">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="个队列作为辅助来完成遍历过程。" ID="3">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="首先，定义一个队列循环，队列元素是指向树结点的指针：" ID="4">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="《cotx«pdata«'1ltfj问ii结tif(p，LChild)ErxlucucQ,p一》LChild左T.树进Aif(p一＞RCltild)ifDc:Qucuc(RQ,Preturn;fi队返回状lir#ERROR时r.t.（队')各" ID="5">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="}由于是从上至下，从左至右，所以每访间一个结点后，就将该结点的左子树的结点指针进队，然后再将该结点的右子树的结点指针进队；出队时，正好先出来的是左子树的根结点指针。下面以图5.4.5为例，给出按层次遍历的队列变化，见表5.4.402尸气、步翔访石砚流队月OP答Ra它于翻司万。‘扩酬有厂、产、产、初态空空空、一/L-JtABCBC" ID="6">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="/\\2BCDBCE/rti\/。\/n\3CDEFDF、‘尹4/、一产4DEFGEG" ID="7">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="/3EFGFG" ID="8">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="／、6FGGG火二7一二匕一一旦一一一至一一一图5舫－刊裸j咖" ID="9">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="2.从土至下、从右至左地按层次遥.二叉树（Tap_Right)：又树的层次4？历（从上至下，从右全左）味法（LevclOrtlcr'fR)voidLcrclUrdcr1'R(liinary'I'rcehodcoEi)" ID="10">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="(11从!左、从1.卜按)4次fl1h¢'二又树(Top_Right)QucucQ:dtnanTrccNodc.p;Cr.dQucuc{Q,ttaxQucueSic1/产生·个空队列，这过程i数可以不在这里进itp=Kl对其如果从上至下、从左至右地遍历，先将每个结点都进队（包括二叉树的根结点指针），队列中进过队的元素状态如图5.4.6所示；按Top1eft层次遍历后，队列的指针不是图5.45中所示的状态，这里用区函和匾碑示所有进过队的元素队头结点和队尾结点，如果将这个队列元索出栈，其结果正好是从下至上、从右至左地按层次遍历二叉树的结果。01234S6" ID="11">
          <fptr EndPN="00000124" StartPN="00000123"/>
        </Paragraph>
        <Picture URL="00000124\00000124_new\0010.jpg">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Picture>
        <Paragraph CONTEXT="点指针）位置的“队头指针”。实际上，从下至上地遍历二叉树的过程是借助于从上至下的遍" ID="12">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="厉算法来完成的只是最后将队列中进队结果再看做一个堆栈最后进队的结点指针作为找顶，" ID="13">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000124" TITLE="5.4.4  二叉树的其他操作" TYPE="Chapter">
        <fptr LogicalPageNum="124" PhysicalPageNum="124"/>
        <Paragraph CONTEXT="i.构造一裸二叉树" ID="1">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="构造的二又树中有多少个结点、结点之间的关系如何、" ID="2">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="树型结构如何，这些是用户自己决定的。下面以一个例子来" ID="3">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="讨论构造过程。如图5.4.7所示，它是我们想构造的一棵二叉" ID="4">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Picture URL="00000124\00000124_new\0005.jpg">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Picture>
        <Paragraph CONTEXT="树，树中有7个结点，每个结点的数据元素值可以动态地输" ID="5">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="人，也可以事先已输人。下面，我们采用先输人的方式讨论。" ID="6">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="图5.4一构造二叉树" ID="7">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)构造结点" ID="8">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="构道二又树一个结点的y;i&lt;(、tukc\alc要想产生值为“A'，的结点.只执行下面语句：" ID="9">
          <fptr EndPN="00000125" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="兀曰J人.；13inarIteeNoderAptr-MakeNode(x如果按此方法将所有的结点都产生，并以相应的指针指向，接下来的事就是将这些结点联接在一起，构成一棵如图5.4.7所示的二叉树。每次被联接的结点最多有3个结点：“根”结点，左孩子（左子树根）结点，右孩子（右子面定义一个联接过程：" ID="10">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）构造一棵二叉子树（或二叉树）构造二又树的算法（、Iak。·11inar，lrc。）" ID="11">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="void、takcBinaryTrc(Rin.tnTrccNcxk，rWl.litnaryfreeNodc+Icft,R.naryTra:ialcaright)" ID="12">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="联接rWt.lcft,right所i的结点riin针为二又'rWtLChild-lctt;rWt一＞RChild-nght;｝下面我们先将E,G组成为一棵二叉树，即执行：" ID="13">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="再将B,D和E子树组成为一棵二叉树，即执行：A7akeBiIIttt'I'ree(Bp1lpnr,Eprt指针赋给eT。在本例中执行：『卜汽州丈" ID="14">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="a.求二叉树的高度计算二又树高度时，利用递归方式，先求到左子树的高度HigEt，然后再求到右子树的高度班助R；最后比较左子树和右子树的高度，取其最大值，即二叉树的高度。计芥二又树高1的yi;(IlinanHcight)" ID="15">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="mtBinaryHeight{RinaryTrcclvixlcsRT)" ID="16">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT=",1S回" ID="17">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="ifBT)return0:" ID="18">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="intHighL=BinaryficightfRT一＞LChild" ID="19">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="tntIlighR二Btnary圣1eight(B&quot;IRChildif(IfighL&gt;IfighR)voidAinaryl7clctc(HinaryTrccl\cxlc+13'I’)" ID="20">
          <fptr EndPN="00000126" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="l二叉树的！除3Ic" ID="21">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="if(B'I)" ID="22">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="23">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="Binanfh:ltte(BTChild" ID="24">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="13inar4Lh:lcte(13TRChild" ID="25">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="deleteBT;这·的deletefi系r过}" ID="26">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="4.统计二又树中结点的个数统计二又树中的结点数可以利用任何一种遍历方法，在遍历时，每次访间一个结点时，就三计个数的计数器中加一。这里就不再给出其算法了。" ID="27">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="S.S线索树" ID="28">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000126" TITLE="5.5  线索树" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
        <div ORDERLABEL="00000126" TITLE="5.5.1  线索树的概念" TYPE="Chapter">
        <fptr LogicalPageNum="126" PhysicalPageNum="126"/>
        <Paragraph CONTEXT="1.线索树的由来按照任何一种遍历规则对一棵二叉树进行遍历，其遍历的结果一定是惟一的。也就是说，在遍历结果序列中，任何一个结点的前驱或后继是一定义的。在二叉树中讨论前驱或后继一定是基于某种遍历规则而言的，不同的遍历规则所遍历的结点中，某一个结点前驱或后继是不同的。按照我们已讨论过的内容，在二叉树中要想得到一.个结点在某种遍历规则下的前驱或后我们可以得出这样的结论（如图s.a.2)：一个结点fi如果有左子树，则该结点的前驱就是其左子树中最右的子孙P。这个子孙结点的右链接域一定为空，我才」可以在这个子孙结点的右链接域中存放一个指向该结点N的指针，以后，也就可以方便地通过该子孙结点P的右链接域的指针访问到其后继结点N,情形二：中序遍历图5.5.1所示的二叉树时，结点H的前驱是D，结点G的前驱是B，结点X的前驱是A.等。我们可以得出这样的结论（如图5.5.3)：一个结点I:如果没有左子树，则该结点的前驱就" ID="1">
          <fptr EndPN="00000127" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="是其所有祖先中，最接近它的“右倾，祖先P。由于这个结点N的左链接域本身就是空，所以，就将该线点N的左链接域中存放一个指向该结点F前驱的指针。以后，也就可以方便地通过" ID="2">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="反过来理解，一个结点的前驱结点找到了，这个结点就是该前驱结点的后继结点。$Picture[00000127\00000127_new\0012.jpg]Picture$$Picture[00000127\00000127_new\0013.jpg]Picture$·最接近”结点的“右倾“事实上，在二叉树中，n个结点的所有链接域中，只使用了n-1个链接域，还有n+1个链接域是闲着未用的，因此，下面就可以利用这些链接域来实现前驱或后继的指向。这些利用起来的链接域不是指向孩子结点的，而是指向前驱或后继结点的。但是，无论是有本质区别的。可是，要想知道当前指针所指的结点的右链接域或左链接域是孩子，还是前驱" ID="3">
          <fptr EndPN="00000128" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="或后继，仅用指针的值是无法区别的。所以，这类结点的链接域的性质应该与指向孩子结点的链接域的性质是不同的，因此，要对这两种不同的链接域进行区别。区别方法如下：在原来的二叉树结点结构中增加两个标志Lflag或1时，表示对应的链接域为指向前驱或后继的指$Picture[00000128\00000128_new\0011.jpg]Picture$图5.5.4线索二又树结点结构由三种不同的遍历规则得到三种不同的线索树，如图SS.7、图5.5一和图5.5.9分别称为：前序线索树，中序线索树，后序线索树。可以看到，一个结点的前驱和后继在线索树中，是随着" ID="4">
          <fptr EndPN="00000129" StartPN="00000128"/>
        </Paragraph>
        <Picture URL="00000129\00000129_new\0003.jpg">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Picture>
        <Picture URL="00000129\00000129_new\0004.jpg">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Picture>
        <Paragraph CONTEXT="遍历规则的不同而不同的。三种遍历规则的线索树中，最重要的线索树是中序线索树.实际上。二叉树的中序遍历是最有意义的。如果一棵二又树的线索树中，只保留单边的线索，则称这样的线索树是单边线索树。右线索树比左线索树更有意义。这些将在后述章节中再讨论。图5东8二叉树中序遍历线索树图5反，二又树后序谊历线索树" ID="5">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000129" TITLE="5.5.2  二叉线索树的操作" TYPE="Chapter">
        <fptr LogicalPageNum="129" PhysicalPageNum="129"/>
        <Paragraph CONTEXT="下面，我们以动态存储结构方式的线索树来讨论线索树的相关算法。另外，首先将二叉线索树的结点结构定义进行调整如下：t抑初efstn犯ttLampedata;BinaryTreeNodexL.Child;be”且Lflag;0:········T护mRlisDtfl.i.Bin卿Tr份Nede饭”IRfl喝" ID="1">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="1.二叉线索树的遮历二叉树的遍历前面已讨论过，二叉线索树的各种遍历规则仍是原来的规则，不同的是，由于有了线索，所以在遍历时，将利用线索去追踪后继结点.而不硒俐用堆栈方式或递归方式使用额外的栈空间。在遍历时，只需要后继线索就可以了，所以，右线索相对更重要。" ID="2">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）前序二叉线索树的遍历" ID="3">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="前序二又线索树的遍历算法（1’t，印11，闭）r.Icr）" ID="4">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="v‘、dThrcadP代Ot：Icr（R：.，；ttyTrcoN、刁。，BT）" ID="5">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一＞LChild:" ID="6">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="7">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="P二P一）RChild;" ID="8">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="9">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="｝从给出的算法可看到，算法中没有额外的任何空间耗费，算法清晰.简单" ID="10">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）中序二叉线索树的遍历。中序二叉线索树的遍历是一个非常重要的算法.这主要是山于中序遍历的重要性所决定的" ID="11">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="中）犷二又线索树的迫历思想是：" ID="12">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="A.从当前结点指针开始，查找以该结点为报的子孙中最左子孙（向左查找）" ID="13">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="B.访问该结点G将指针指向被访问结点的右链接城所指的结点。如果被访问结点的右链接城是后继(Rflag为true1转s步较；否则，是一个右子树的根.则转A步Ea中序二又线索树的i历算法（InrdcrThrcad)void[nOrderThrcad(BmaryTrxNodcT)中序二叉线索树的迎历" ID="14">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="BinaryTrccK‘xlc.p二BT;" ID="15">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="boot(lac:" ID="16">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="while(!p){whilep-Lflag)j找一探ft的最左子孙" ID="17">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一＞LChild;" ID="18">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="tlag-true;" ID="19">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="while(flag8cR!p)｛tout«pdata«&quot;11访问-r-n点P=P一＞RChild;11查找P的右了树的根或后继-ta点" ID="20">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="ifoRflaoI1/n夕劣.fi/4&quot;l:与不!1fYrL2t+l:tl.1.11Glt!c" ID="21">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="If（！P-Rflag）" ID="22">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="nag＝NULL" ID="23">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="）用链接域的指针，方便地找到了下一个要遍历的结点。对于后序线索树的遍历问题就不一样了，因为序线索树。这里，我们就不再讨论后序线素树的遍历算法。" ID="24">
          <fptr EndPN="00000131" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="2.二又树转化为二叉线索树" ID="25">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="r,、一甘为叶专会获七前良一V始壹树＿" ID="26">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）二叉树转化为前序二叉线索树。二叉树转化为前序线索树的算法思想：另格一木锥姆川业描门古老偏厉代甲粉＿健体廷亩的冬件票拾油和t，阁时去方＿‘树。算法结束的条件是堆找和p同时为空。“访问”过的结点），如果访问到某结点时，该结一占干亡渝不翩蛛擂姑占油亡桩垃褚的均料作去拐尝箱自笠前敬。葬落。偌自4贡木于左孩子的结点；转C步骤。" ID="27">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="c.退栈.直到找到下一个可以“访何”的结点，并用p指向该结点；如果p的前驱（q指自、的去蛙垃拂去右MJI炸。的云桩怂琦枪去必去指向竹，势R雍醛＿又树转化为前序线未树打法（lh「。adPrt吸）r‘1or、）v沃dTh，cadToPr心rdcr（B‘nalyTrccN阅e，STj〔11二又树转化为前序线索树算法" ID="28">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="5认cks：" ID="29">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="Bin娜介民N浏c＊卜B毛q·NULL；Ilq始终指在p结点前望Cre留Stack（＆5.次MaxS以ks：ze）；11产生一个弓‘伐，这w扮le（Pll！IsEn1Pty（’％5））！whi艳（P）l卜＞Rflag习；11假设为0cout《p月司如＜才，；11访问’‘根”结.6.Push（＆5.p大11根结点指针进栈，以后1月朔时冉退钱ir（～心户卜…nn如岑，、爪了，七了切艘泛向方排；体If（卜＞IChll‘1）lq-p；卜＞L目ag一众p甲一＞LChild，1" ID="30">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="cl，亡" ID="31">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="111如果p没有左子树，p的左链接域指向前邓；并准备退找" ID="32">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="P今Llla矛1；p一＞LChlld川：" ID="33">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="q二p；严NULL；llp设为冲ULL为的兄强制退找" ID="34">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="35">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="36">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="if（）1、EmPI）（5））" ID="37">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="t" ID="38">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="P甲Sp）；" ID="39">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="Xd】二If（！P一＞RChl奋d）｛少＞RChlld二x：P一＞Rna斧1；" ID="40">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="}9一》xtlag-t.11二又Nlht;i计的4,u4ff'r志rt为1】" ID="41">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）二叉树转化为中序二又线索树。二叉树转化为中序线索树的算法思想：" ID="42">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="A.设两个指针P和9一个指向前序规则当前可以访问的结点.另一个指向其前驱结点。另设一个堆栈.以非递归方式遭历二叉树。算法结束的条件是堆栈和P同时为空。" ID="43">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="n.丰二声”。去3-拍4拈6F女壮舌古备泣亡浮.封名六知皿健仕含子亡抢.罕.创次冶壮考" ID="44">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="B.“走过”P左子树上约所有结点.直到左子树为空。的左链接城的指针作为z索指向其前'9.并将9指向这个无左孩子的结点；转Cr霖,向）的右链接城为空.r.T将9的右4接城作为线索指向P；转B步7Ro二叉树的中T线索)1法（lhrradlnCfrdcr)" ID="45">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="vad7hmadlnOrdcr(13inaryTrcc:vcxic.RT)(l二又树的中rfs索39-StaclS;RinxryTrc广ti，xic.p=Fi&quot;P,q=DULL;" ID="46">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="CrcatStack(S.、taxStackStzeli'0&quot;一个伐.三考一过程f!t效可以不在这R进行uh：lcIt)II'IcF.mpty(S（uhilc(p)找ftr-r-树！fugh(S.p11«根tci点（未访问月rtt针进找.以后lf}时再退±it(nLChtld)41:StnililiIr7t'E味tul专iitiit（P‘＞LChlld）fp－）Lflag二0：P-p一＞LChild；1C】、C111如果p没有左f树.p的左链按域衍向前骊；并准务退找" ID="47">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="卜＞Iollld气1；卜》Lnag-1；q‘P：p二NULL：llP设为入LllJL为的是张刽去退伐｝l.f（，1、Fnlrty峨5）），l左子树为空，卜刊J下1堆钱闷朔lp‘、P（5.p）；11从堆钱中弹出回必1结点打牙冬1（该分.t.点未访问过）卜＞Rflag刀二IllTii泛为0cout《p一＞data《.‘；111方问’‘银结点if（少q一＞Rchild及＆q，＝P）" ID="48">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="Iq》RChild叩：q一＞Rnag＝1；‘IP；1" ID="49">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="I.＝p一＞RChild：，IJ料1指向回翔结.叔的右T树】" ID="50">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="51">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="3.中序二叉树线索树中结点的擂入将一个由T指针指向的新结点擂人到二叉线素树中.作为5所指的结点左孩子或y所指的结点右孩子。如果V原来已经存在左子树（或右子树），就将原来的左子树（或右子树）作为新结点T的左孩子（或右孩子）。线索树的插人问题中，将5结点与T结点链接在一起是件简单的事情.关键问题是要改变各结点的线索和对应的线索标志。1}中序线索树中插人的新结点T作为5的左孩子插人情形讨论：" ID="52">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)S结点无左孩子（如图5.5.11(a）所示）①新结点T的各值的变化：。链接域的变化：由于T是作为.的左孩子插人的，而T本身无孩子，那么，T的右链接域为线索，且一定是指向T的双亲5，即：T&gt;RChild=S;的左链接域原来是一个线索.指向其祖先中最近的“右倾”祖先，由于T的插入，T成为" ID="53">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="最左子孙，那么，T的左链接域应该线索到S原来线索的祖先结点，即：T一）LChild-LChild;·链接域标志的变化：T结点的左链接域标志恒为1或加此或者为5原来的左链接域标志，右链接域的标志恒为1或权珊，即：T&gt;Lflag=1或true，或T&gt;LflagS&gt;Lflag;" ID="54">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="TRflag=1或true;$Picture[00000133\00000133_new\0021.jpg]Picture$$Picture[00000133\00000133_new\0023.jpg]Picture$SLflag或false;①新结点T的各值的变化：·链接域的变化：由于T是作为5的左孩子插人的，那么，T的右链接域应为线索，且一" ID="55">
          <fptr EndPN="00000134" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="定是指向T的双亲S，即：T&gt;RChi1d=S;而S原来也有左孩子.T作为S左孩子插入后，T成这S的新的左孩子，T的左孩子就是原来v的左孩子。因此，T的左链接域是一个指向J原来左孩子结点的指针，即：T-LChi1d=SLChild;" ID="56">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="·链接域标志的变化：T结点的左链接域标志为恒为a或false或者为S原来的左链接域" ID="57">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="标志，右链接域的标志恒为1或true,pT弓Lflag或false；或T今LflagSLflag;TRflag=1或due,2QS结点各个值的变化：·链接域的变化：由于T是作为S的左孩子抽人的，S结点的左链接域就指向T结点，即：S一＞LChiId=T;.链接域标志的变化：S结点的左链接域标志恒为0或false，即：SLfl昭月或佃5粼③5结点原来左子树中的最右子孙的右链接域的变化。插人前5的左子树中的最右子孙P的右链接域是一个线索，它指向w结点，即w是这个子孙的祖先中最接近这个子孙P的“左倾’祖先。但是，由于T的插人，T成为这个子孙P的最近“左倾”祖先，所以，这个子孙F的可是，已知的指针只有S和T，不知道这个子孙的指针，那么就要找到这个最右子孙P结点，方法是：用一个指针q指向S的左子树的根结点或指向T(T插人后）的左子树的根结点；" ID="58">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="然后，4的右链接域标志不为1或LINE时，一直将9指针向右推进，R指向的最后一个结点就是" ID="59">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="这个子孙P；最后。将4所指的结点P的右链接域指向T，其他值不变。" ID="60">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="通过上面的分析，可以得出以下结论：无论Cy有无左子树，T作为左子树插人时，T的链接" ID="61">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="域的变化是相同的；;T的链接域标志无左子树时为1，有左子树时0，但都可以用原来S的左链" ID="62">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="接域标志修改。也就是说，T结点的链接域值和链接域标志的值与S有无左子树无关。惟一" ID="63">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="接域标志修改。也就是说，T结点的链接域值和链接域标志的值与5有无左子树无关。惟一" ID="64">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="不同的是，5如果存在左子树，就要先查找左子树中的最右子孙，并将最右子孙的右链接域指向T。索树中插入的新结.6.［作力5的左孩子竹次（In（）rd。r-hroadln、t’rtIcrt）q‘r为LC衍ld；whilty-R(lag)" ID="65">
          <fptr EndPN="00000135" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="（1一＞Rchild;9一＞RchildjT;}" ID="66">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="67">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="2）中序线索树中插人的新iii点T作为S的右孩子各种情形的讨论与插人左子树是类似的.这里就不再资述.只给出相应的图示和算法。$Picture[00000135\00000135_new\0009.jpg]Picture$$Picture[00000135\00000135_new\0010.jpg]Picture$最接近s;点的" ID="68">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT=".左倾.祖先P图5.5.12中序线i(i二又树中T结点作为S的右孩子插人中序线，树中擂入的新结点T作为S的右孩子林法（1nOrderThreadlnsertRiRht)voidInOrdcrThreadlnscrtRighl(BinaryTrvcV电dc.S,BinaryTreeNode:t)中序f树中插人的新结.fitT作为S的石孩子棘法BinaryTreeNode.q二P:'f一＞Rchild-SRchlld," ID="69">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="TRt1ag=SR(lag;" ID="70">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="TLchild巧:" ID="71">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="TLflag二l;" ID="72">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="S-Rllag刃;" ID="73">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="if(!T一》Rflag)lli:S右子树中的垠左子孙" ID="74">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="（y=TRchild;whileqLflag)" ID="75">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="9一＞Lchld;" ID="76">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000136" TITLE="5.6  一般树的表示和遍历" TYPE="Chapter">
      <fptr LogicalPageNum="136" PhysicalPageNum="136"/>
        <div ORDERLABEL="00000136" TITLE="5.6.1  一般树的二叉链表示以及它与二叉树的关系" TYPE="Chapter">
        <fptr LogicalPageNum="136" PhysicalPageNum="136"/>
        <Paragraph CONTEXT="前面已经详细讨论了二叉树的表示及相关的基本运算，由于二叉树中每个结点最多只有两个分枝，所以，我们定义二叉树的每个结点的链接域有两个，一个指向左孩子，另一个指向右孩子。但是，一棵树中，某结点的孩子数是不定的，有的结点的孩子数多，而有的可能没有孩子，很难统一。如果非要统一，只能按照度数最大的结点来定义树结点的结构。下面以图5.6.1所$Picture[00000136\00000136_new\0010.jpg]Picture$从而它的4个链接域全部空着。如果类似这种结点很多，就会造成链接域空间的很大浪费。实际中，我们这样定义：将每个结点仍然定义为两个链接域，一个称为son链接域，指向该结点的大孩子，即左边第一个孩子；另一个称为next链接域，指向该结点的右边第一个兄弟（同层同双亲的结点）)o用这种方法表示，son指向的是某个祖先及这个祖先结点下的长子，长孙，长重孙，长曾孙示的结构。二咬蒸～" ID="1">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="图sz一棵树的存储结构" ID="2">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="在上述表示方法中，由于这种办法类似于二叉树的结点表示法，也是两个链域，所以称之" ID="3">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="为一般树的二叉链表历七法。" ID="4">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="下面是结点结构的定义：" ID="5">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="TneeNade*son;" ID="6">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="TreeNvde*next;}TreeAiode;采用这种二叉树的办法来表示一般树，由物理结构上看它们的结点定义是类似的，除数据域data完全相同外.都有两链接域，只有解释不同而己。一般树与二叉树不同的是，每个结点的左边的链接域从逻辑上不是左孩子的概念，而是长子.右链接域不是右孩子，而是兄弟。由于树和二叉树都可以用两个链域来表示，我们来分析一下用二叉链表示的一般树与二5.6.1为例，将它转化为一棵二叉树（如图5.6.3(ab。方法是首先将同一双亲的兄弟从左至右连接起来；然后将双亲与孩子结点的分枝中，除与长子的分枝保留外，其他的全部去掉；最后，再将兄弟相连的横线旋转45’,(a)$Picture[00000137\00000137_new\0013.jpg]Picture$$Picture[00000137\00000137_new\0014.jpg]Picture$图5.6.3一棵树转化为二又树存储表示" ID="7">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Paragraph CONTEXT="由转换结果可以看出，一般树转换成的二叉树其根结点是没有右子树的。反言之，一棵根结点没有右子树的二又树逻辑上也很容易转换成一棵一般树。" ID="8">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000137" TITLE="5.6.2  二叉树、一般树及森林的关系" TYPE="Chapter">
        <fptr LogicalPageNum="137" PhysicalPageNum="137"/>
        <Picture URL="00000138\00000138_new\0002.jpg">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Picture>
        <Paragraph CONTEXT="结点及右分枝上相联的是森林中每棵树的根结点。" ID="1">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="图5.6.5森林转化为树" ID="2">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="多棵树组成的森林然后再将森林中每棵二叉树形式存储树转化为一般树。" ID="3">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000138" TITLE="5.6.3  一般树的遍历概念" TYPE="Chapter">
        <fptr LogicalPageNum="138" PhysicalPageNum="138"/>
        <Paragraph CONTEXT="前面讨论过二叉树的遍历，这里讨论一般树的遍历。对于一棵树，由于每个结点的孩子数" ID="1">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="不一致，故无法确定中序遍历，只能给出一般树的前序和后序遍历的定义。" ID="2">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="t.前序遮历的规则" ID="3">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）访问树的根结点；" ID="4">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="C2）访问第一棵子树；" ID="5">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）从左到右遍历其余的子树（也按前序遍历）)o" ID="6">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="2.后序遮历的规1" ID="7">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)访间第一棵子树（即最左边的子树；对于子树的子树也按后序规则遍历无{2）从左到右访问其余的子树（也按后序遍历）)o" ID="8">
          <fptr EndPN="00000138" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）最后访问根结点。按照上述规则，可以得到图5.6.6ta}所示的一般树的i历结果：前序道历的结果是：ASPGCDEEIiK后序遍历的结果是：FGBCHDIIKEA前y逾历结果是：ABFCsCDHEUK中序谊历结果是：FGSCHDUKEA对比一般树的遍历结果和它对应的二又树的遍历结果，我们发现两者之间有着这样的对应关系：二赶扭应应二里越前序前序后序中序所以，当以二叉树方式存储一棵一般树时，这棵一般树的前序遍历和后序遍历可以借用相" ID="9">
          <fptr EndPN="00000139" StartPN="00000138"/>
        </Paragraph>
        <Paragraph CONTEXT="应的二叉树的前序遍历和中序遍历算法来实现。一般树的层次遍历结果和其对应的二叉树方式存储层次遍历结果就完全不一样了，它们之间没有对应关系。" ID="10">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000139" TITLE="5.6.4  一般树的运算" TYPE="Chapter">
        <fptr LogicalPageNum="139" PhysicalPageNum="139"/>
        <Paragraph CONTEXT="当一般树以二叉树形式存储时，一般树的大部分的运算可以用二叉树的算法来实现，如一般树的前序遗历，后序遍历，结点的个数等。但是，一般树的有些运算是二又树的运算代替不了的，下面就讨论有关的一般树二叉树存储方式下的运算。" ID="1">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="1-fil4rn占nafitrFF票-d-X祝斤她f！者ri-6沟bEr4占rF6itk" ID="2">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="卜以」c" ID="3">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="丁指针所抬结点的变" ID="4">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="〕们" ID="5">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="dc少c亡铸hlle（）1‘一＞nICet山ndcgr亡亡；1一般树二又树形式存储下层次遥历一般树二叉树形式存储下，同一层次的结点存储在右单枝上。图5.6.6（b）中，A结点的下" ID="6">
          <fptr EndPN="00000139" StartPN="00000139"/>
        </Paragraph>
        <Paragraph CONTEXT="支双次迎历·般" ID="7">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="Enyueue" ID="8">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="w}ulc1sEmptQ)" ID="9">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="Dryucuc(Q.T" ID="10">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="N'lll" ID="11">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000140" TITLE="5.7  树的应用" TYPE="Chapter">
      <fptr LogicalPageNum="140" PhysicalPageNum="140"/>
        <div ORDERLABEL="00000140" TITLE="5.7.1  分类二叉树" TYPE="Chapter">
        <fptr LogicalPageNum="140" PhysicalPageNum="140"/>
        <Paragraph CONTEXT="I.分类二叉树概念分类二又树又可以称为二叉排序树或二又搜索树，从名称的多样性上就反映出分类二叉树是一种非常有意义的树。一个典型的应用例子是，在大量数据的处理中，为了便于数据查找，对输人的数据采用分类二叉树的方式存储，从而可以大大提高查找的效率，其时间效率是O(nlogxn)。如果按中序遍历一棵分类二叉树，其结果是一个按某一特征值（关键字）排序的线性序列。所谓分类二叉树是这样定义的：设keyt,keYz,，keYn是一个数据集合中数据元素的又j't关键字（数据元素的其他数据项因与间题地讨论无关，所以忽略），按下列原则建立的二叉树称为分类二叉树。" ID="1">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)每个元素有一个关键字，并且没有任意两个元素有相同的关键字。" ID="2">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）根结点的左子树的关键字〔如果存在）小于根结点的关键字。" ID="3">
          <fptr EndPN="00000140" StartPN="00000140"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）根结点的左右子树也都是分类二叉树。我们给出下列数据集合，它们是数据元素的关rr字，以此构成的分类二叉树如图5.7.1所（如何使中序遍历的结果按关键字降序排列呢？0气杯愈、(a}{b)(c)" ID="4">
          <fptr EndPN="00000141" StartPN="00000140"/>
        </Paragraph>
        <Picture URL="00000141\00000141_new\0005.jpg">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Picture>
        <Paragraph CONTEXT="2.分类二叉树运算" ID="5">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Picture URL="00000141\00000141_new\0009.jpg">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Picture>
        <Picture URL="00000141\00000141_new\0010.jpg">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Picture>
        <Picture URL="00000141\00000141_new\0011.jpg">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Picture>
        <Paragraph CONTEXT="(1)分类二叉树中数据元素的查找。如果知道某个要查找的数据元素的关键字是$Picture[00000141\00000141_new\0013.jpg]Picture$$Picture[00000141\00000141_new\0014.jpg]Picture$searchxey，要想查找到该数据元素存储的地址，其方法是：首先用st戊,xty与根结点的关键字比较，如果相等，则查找成功。如果不等，则与根结点的关键字比较大小，如大于根结点的关键字，说明要查找的数据元素在右子树上。重复与子树根比较的过程；如小于根结点的关键字，说明要查找的数据元素在左子树上，重复与子树根比较的过程，这种比较过程的次数最多与树" ID="6">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="的深度相等。" ID="7">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="分类二又树中立找关幼字为、errchl:e，的绍点值ar法（SvrtllinaryTrrctic二rch" ID="8">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="bootSortBinaryTreeScarch(E3inaryTrrrNode.13T,Efypefiz,KnpeRSearchKey)" ID="9">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="求卉找关被字为Sc二‘hKcy的结点{tix" ID="10">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="13maryTruti&lt;x1e.p-l3&quot;" ID="11">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="while" ID="12">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="if(ScarchKcy&lt;p一）data.ke" ID="13">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="14">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="15">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="xp-xJata;" ID="16">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="raumtrur." ID="17">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="告" ID="18">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="returnfalc;" ID="19">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="》在图5.7.1(i)中查找一个结点（其关键字位为1R）的过程如图5.7.2中的I头走向所示。" ID="20">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Picture URL="00000142\00000142_new\0010.jpg">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Picture>
        <Picture URL="00000142\00000142_new\0011.jpg">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Picture>
        <Paragraph CONTEXT="（2）将结点插人到分类二又树‘1to插人算法与r找法的一个Gt.区别是：z找中.如果找到，则1,1i功。但是，在$ti人时也'I找，K_it找失败时.说明找到了E1人点；查找成功时，说明有'1'的数据元家出现.这在分类二叉树，｝，是不允许的.即插入失败。查找算法中.另设一个搜索指生f的父结点指针，当查找失败时.搜索指针为空.而父结点就是插人结.点的父结点，再来决定是插人在这个父结点的左边还是右边。在图s.7.1()中捅人一个新t;点（其关4zt字4r〔为22）的查找过程如图5.7.3中的l1头走向所不。重复调用这个算扶可以构造一棵分类二又树分类二又树中擂入关抽字为Scnrchltc，的结点位x算法（SortliinarvTreeln.rrt)hoofScxtBinaryTreelncert(BinaryTrceNodcRfif,Lfypecox)(llskwl果小.ft出则插人,xBinaryTrti\ixlc.p二R丁：" ID="21">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="BtnaryTrreodc.parent-NULL:11向P的双亲" ID="22">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="ahilcIp)" ID="23">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="24">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="parent-P" ID="25">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="iCfa.kcyqclstal.cy)" ID="26">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="P二pLChild二" ID="27">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="d记" ID="28">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="iffx.kcy:·pdata.kcy)P-P一）RChild;C！5亡returnfolsc;Illll;l.lii.I41fA1rlr(Yb1.t出现｝找37E入点.为xt}ti·个空atimc人l七rr.并将Fyu点连f?3:parent" ID="29">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="RinaryTrcY:Nodc+q=newBinsryTrceVcxic;" ID="30">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="if(BT)" ID="31">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="原树1卜空if(z.l:eparcnt一＞data.key)" ID="32">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="parcnt，L,Child＝q:" ID="33">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="elk" ID="34">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="paren卜）RChild=q;" ID="35">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="36">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="else人到空树，卜" ID="37">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="BT一：" ID="38">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="rRturntrue;" ID="39">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="l如果插人时允许插人相同值的结点，就要约定有相同值插人时是插在父结点的左边还是右边。另外.对查找算法进行修改，查找中，如果找到相同值的结点，视同查找失败。上述查找部分修改为：" ID="40">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="while(p)" ID="41">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="(" ID="42">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="parent=p;" ID="43">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="if(x.kcy&lt;pdata.kcy)" ID="44">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="p=pLChild;" ID="45">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="46">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="ppRChild:" ID="47">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="》" ID="48">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)删除分类二叉树中的结点。对删除来说，我们考虑被删除结点x的3种情况：lx情况①：可以用丢弃树叶结点的方法来处理。只要把其父结点的左孩子（右孩子）链接域置为空，然后删除该结点即可。如图5.7.4(a)所示.删除x时，x结点是其双亲结点的左孩子（右孩子）)o情况②：即x只有一个非空子树。如果x没有父结点（即x是根结点），则I除结点x,、的惟一子树的根结点成为新的分类二叉树树的根结点。如图5.7.4(b)所示，.除：时，x结点有右孩子（可能是左孩子）。如果x有父结点parent，则修改parent的指针，使得parent即指向、的惟一孩子，然后删除结点x。如图5.7.4(c)所示，删除x时，x结点有惟一右孩子（左孩子）)o" ID="49">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="悄况③：要删除一个左右子树都不为空的结点元素，只需将该元素替换为它的左子树中的最大元素或石子树中的tt（小元索。如图5.7.4(d）所示，删除x时，x结点是其双亲结点的左孩子（可能是右孩子）。为了处理上的方便，将找到的饭大或嫩小结点的值移动到P结点的中，这样就不用处理左孩子或右孩子的问题了。！除分类二叉树中关[TI字为tirarchKc}的结点算法（SortBinaryTrrrl)rlrtr)bootSortf3maryTmcDclcte(13inaryTrceKock&amp;BT,Ktypc&amp;ScarchKcy){11i&gt;rl除关健字位为Se：二hKc}的结l.i" ID="50">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="Bmarfrcc\odc.p=BT,sp;vcnt=KUIparcnt指flp的if(scarchKcy·'pdata)p=pLChlld;" ID="51">
          <fptr EndPN="00000144" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="-Isc" ID="52">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="p-pRChild:" ID="53">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="111－（！P）rclumflase：11没有到tivL.ifp}returnflaw;Il2t1Cslu," ID="54">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="，－又树币构if(pLChild＆RpRChild)111玻刹除结点存在)个子Lp的左子树'1，r'E找fie大元f(右子孙）c=pLChild:pc-p;while(sRChild)进到P的左了树最大元素(fit右了ifi)ps=s;s-sRChild;}pdaG一，＞data：II左1－.树中放人元求（Jtl右T.孙）l’a移刘‘，p=s:parc川二ps:np向L于tf'1'ti&lt;大元0,p.urnt指向，'lt}" ID="55">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p一》LChild)/IpIf'dr只有一个孩1'" ID="56">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="、一P一》I-Child;" ID="57">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="cla.5-P-RChild:" ID="58">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p3T)" ID="59">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="RT一,else判Jtpfir.ptrcntric一还是右孩子parentLChild二s:" ID="60">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="parent一，·RChild-、;" ID="61">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="62">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="deletep;" ID="63">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="rdumtrue;一新报～被侧结点p指向图5.7.4f除一个左右子树非空的结点x" ID="64">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Picture URL="00000145\00000145_new\0001.jpg">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Picture>
        <Picture URL="00000145\00000145_new\0003.jpg">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Picture>
      </div>
        <div ORDERLABEL="00000145" TITLE="5.7.2  堆树" TYPE="Chapter">
        <fptr LogicalPageNum="145" PhysicalPageNum="145"/>
        <Paragraph CONTEXT="I.堆和于的定义1大树和蛟小树定义。在介绍堆树前，我们先定义从大树和最小树®5.7）最大树或最刁咐·最大树：所谓最大树就是每个结点的值都大于或等于其子结点（如果存在）值。·最小树：所谓最小树就是每个结点的值都小于或等于其子结点（如果存在馗。$Picture[00000145\00000145_new\0011.jpg]Picture$$Picture[00000145\00000145_new\0012.jpg]Picture$二叉树本身又满足最小树的条件，则这棵顺序二叉树就是最小堆。在图5.7.5中，惟一满足堆树要求的是（d）所示的二叉树，它是一棚顷序二叉树，且它满足最大树的概念，也就是说，它是最大堆。图5.7.5(a）所示的树不是二叉树，所以不是堆；图5.7.5(b)所示的是最小树，但不是顺" ID="1">
          <fptr EndPN="00000146" StartPN="00000145"/>
        </Paragraph>
        <Paragraph CONTEXT="序二叉树，所以，一定不是堆；图5.7.5{c）和5.7.5(e）所示的两棵二叉树虽然是最大树，但不" ID="2">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="别匝序二叉树，所以也不是堆。在二叉树的概念中我们就已经讨论过，顺序二叉树具有良好的特性：" ID="3">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)顺序二叉树的高度最小，具有n个结点的顺序二叉树的高度是logylo" ID="4">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="如果在这棵树中按分枝查找，搜索的次数可以达到最少；" ID="5">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）顺序二叉树以顺序存储方式存储时，空间不会造成浪费，反而节省了动态存储方式下" ID="6">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="链接域的空间耗费。如果对顺序二叉树中的结点按从上至下、从左至右的顺序从1（或0)开始编号，那么，可" ID="7">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="以方便地计算出顺序二叉树中任何一个结点的父结点（如果存在）的编号（i/2)、左孩子结点的编号（2*i）和右孩子结点的编号（2*i+1)。如果顺序二叉树是顺序存储，这些编号实际上就" ID="8">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="友夕业大令闭的名必摇兰玄当一棵顺序二又树再具有最大树或最小树的性质又会带来什么呢？下面我们以最大堆为例来讨论。" ID="9">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="堆中堆顶结点值是所有结点值中最大的值，所以，求结点最大值的问题在堆中非常简单；另一种最重要的应用是数据的排序。堆排序间题是数据排序的一种经典方法。这种方法的思想是：首先将堆顶元素（最大结结点（左子树或右子树）中选出一个最大结点，" ID="10">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="点）移到结果数据存储空间，再从堆中余下的结点移到堆顶，即将堆中余下的结点重新“调整”为一，移到堆顶，即将堆中余下的结点重新“调整”为一个新堆，再将堆顶结点移到结果数据存储空" ID="11">
          <fptr EndPN="00000146" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="一层中最右的结点。如果第一个数据元素从数组的1下标位置开始存放，那么，第i个结点的双亲（如果存在）就存储在（i/2）下标的位置，第i个结点的左孩子（如果存在）存储在（z*）下标位置，右孩子（如果存在）则存储在（2*i+1数组的0下标位置用于形成堆的过程中，临时存放数据元素的交换空间。数据集合是：Is2,12,5,79,55,24,15,36,16,fi2,12,38。数据集合中，值为I2的有两个，为了区别它们将其中一个加下划线，数据在数组中的存储如下：0123456789101112门's2,I2,579ssZia1is136E1(s汇。[iZa数据在逻辑上关联的数据不一定是接下来的数组空间中的数据。如图5.7.6(a)所示，52关联的两个数据分别是12和5，而I2关联的分别是79和55,5关联的是24和15，等等。数据S是顺序二叉树中右孩子的根结点，存储在第3个位置，下标也是3；它的两个孩子存储在3*2和3*2+1下标位置。如果要将S与它的两个孩子结点值中较大的值进行交换，就是先比较它的两个孩子结点的值，即下标3*2位置的值与下标3＊2+1位置的值进行比较，结果是下标3*2'位置的结点值更大，即24与5交换，也就是下标3位置的值与下标3*2位置的值进行交换。" ID="12">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="推广到一般化，如果要在第i结点（下标i位置）和它的两个孩子结点（如果存在）中找到" ID="13">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="一个最大结点存储在第i个位置，就是比较第i结点，第2*i结点，第2*i+1结点的值，然后再" ID="14">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="进行相应位置值的交换。如果2*i位置更大，则i位置和2*i位置交换；如果2*i+位置更大，" ID="15">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="设数组中数据元素存储的最大下标是HeapSize，整个顺序二叉树中，最下层，最右边的（最在构造初始堆时，首先将所有的叶子结点（最底层结点）看成为若干个子堆，因为每个子或者指向上层的最右边一棵子树的根（1指向上，层时，它下层中的每个子树都己经是子堆），直到1指向第一个结点作为根为止。一漏丢夏。（’c.赫某，蔚虱愈”层子树根结点的调整后示意拒医亘卜。与，，比较后.选中38，38再与5比较，38上移，新位置是38原来存放的位置，有一个孩子24，5再与这个孩子24比较，选中24，所以，24上移，存放到38原来的位置，新位置是24原来存放的位置，无孩子，5存放到24原来存放的位置。随呸hg与62瞰，选中79，再与［2比较，79上移，新位置是79原来存放的位置，有孩子，两个孩子再比较，36与’2比较，选中36，再与，2咚较，、芦角.，‘1.。＿韶添高、牙智甲回切＠＠＠Q乡珍偷位位价亩向尚自甸IJI乙j闷〕之、夕万，IUI皿1二始堆1对闭攀时从24）下好r.然万1（b）调举“当前“层子树为3堆；381.砚！.7’）；为俐＼＿‘当解’仁尸又鲜议鲜＼万＼确伪澎乡Q岁沙回妙智（少习3456789101ll2OI234567R910" ID="16">
          <fptr EndPN="00000148" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="公于巴问r代，甲，尸～侧，价艘笋r，，.，尸竺户，甲，哭，下种，种，，甲吧，竺～r，，巴职r性，吧，尸，.罗，尸，州，.，甲，，79应剐36162写】15｛，2｝，61551珍翻117916213：13615512·：1、，1.21.，6152！，215一勺nll坛士河刀z1’，（d）训整”当Ji屯”J.：r份J为放万：堆；，八.，，t.幼＿“.79；为性七川" ID="17">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="vod从axHoaPIo11（育几Pe。［1.Int幼zc）" ID="18">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="wtule(son&lt;二IlcapSlzc)" ID="19">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="找左石孩子中较大结点If(son才HcpSiic&amp;lwhcap(son]&lt;hcap(con11)5」n芬～；11sa.cHc二,Sitc时.存在右孩子.如左孩子小于石tlc于，son#向右孩子if(heap(01hcap[son大孩子再与工作空间中结点iLl再比较break;1一作空问中L大.找到hcap[01的目标位置heap(sonRhcap[son将大孩子上移生双亲位i" ID="20">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="son2;11son下移一层到上移的结点（大孩子）位置" ID="21">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="}hcap[sonRhcap(U/Jhcap(01存放到月标位且]｝·最大堆中结点的插入后一个叶子结点的双亲结点开始，如果x大于某个子树的根结点，就将这个子树的根下移.并012345678910(lI2345G7K91011" ID="22">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="口卫且丝匡区坦垂业虹一且立坦」L79U38{56,6212415121652J5II" ID="23">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Picture URL="00000149\00000149_new\0020.jpg">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Picture>
        <Picture URL="00000149\00000149_new\0021.jpg">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Picture>
        <Picture URL="00000149\00000149_new\0022.jpg">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Picture>
        <Picture URL="00000149\00000149_new\0023.jpg">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Picture>
        <Paragraph CONTEXT="X二70(a)!li堆中插人结点70(h）从下向上调整堆，中插人t点了0(5.7.7堆中插人fp点if(HaipSirc=MuxSize)returnERROR" ID="24">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="intiIleap3itc;" ID="25">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="·最大堆中堆顶结点的脚除堆顶结点是整个堆中最大的一个结点删除它的同时加果将它移到另一个存储区中存放，然后再将删除堆顶后的堆重新调整为一个堆。如果重复删除，移至结果区下一个存储空间存储，再调整新堆的过程，直到堆中的所有结点被全部删除，最后在结果存储区中的数据就是按从大至小的排列。删除后调整堆是间题的关键。当删除堆顶结点后，当前堆中的结点就减少了一个，当前堆中的最后一个存储空间的结点就应该存放到前面的某个结点空间位置，也就是" ID="26">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="HCao1ol二5一”eaPIUIStawt、taxHcapDclctc{EI}pra(1,F,TrpeRcxl'Ii人xT4ir！人J‘[" ID="27">
          <fptr EndPN="00000151" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="Ilcap-a.if(H‘叼、Sitel)returntiRROR;J1Fjx=heap(IIIh大en.l存欣f'1xhwp[UJ=he”p(11tap5iceIi;Zr一个结点（I玫到hc：，plo］.调整堆‘1，元;i(dJ个rott=l,sun=2.i;whsle(sonIleapStze)" ID="28">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="29">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="if(son&lt;HcapStccS.B:hcap]sonlhcap[son-11)" ID="30">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="sontt" ID="31">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="hreak," ID="32">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="一、n;下移农结点F.针.继续比较" ID="33">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="son-son.2:" ID="34">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="35">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="heap[t】二hcap]01;" ID="36">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="returnOK:" ID="37">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="38">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="，堆排序" ID="39">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="堆&quot;序的过程.利川I除堆[r结点米完成的。堆顶结点是i个堆，1tjtk大的一个ti点，删除它的同时.将它移到另一个结果存储区‘卜存放.然后再将删除堆顶后的堆飞新闷竿为一个堆。如果重复删除.移至结果区卜一个介铭空间存储，直刘堆中的所有结点被全都删除.最后在结果存储区中的数据就是按从大至小的职序排列：7G实上，不必再3f另·个结果存储区.只要将!1除的堆顶结点有放:iJ当前堆的fr'c后一个叶r结点空问‘卜就可以因删除堆顶结点时，本身就要为从后一个叶子结点重新找一个存放空问。也就足说，剧除的结点只是存放在原来-17的尾部.并从尾部向前存放，堆中的全部结点副涂时，数拟仍然存放在这个数组中.只是从小到大地重新排列，如果把它石做堆.也就是个fry小堆.且按层次3历时有序。图5.7.y所J:的是3个结点的排序过t.其他结点的排序过程省略。堆排序算法(ll利用t佳对a【1：nl故组的故据排}Iheap=a:faxHuiplnit(heap,insnIIfIcap¢/J屯i化为A！大准ETvp;x.farhnti=n1;i》二I;i)｛MaIlcepDclctclhrap,xhcap[itlx:1" ID="40">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="41">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
        <Paragraph CONTEXT=".14I" ID="42">
          <fptr EndPN="00000151" StartPN="00000151"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000152" TITLE="5.7.3  树的路径长度和哈夫曼树(Huffman)" TYPE="Chapter">
        <fptr LogicalPageNum="152" PhysicalPageNum="152"/>
        <Paragraph CONTEXT="1.树的路径长度(I)简单路径长度。从树中一个结点到另一个结点之间的分枝构成这两个结点之间的路径。两个结点间的分枝数就是这两个结点之间的路径长度。所谓树的简单路径长度，是指从树的根结点到每个结点的路径长度之和。图s.7.zo和图s.7.11都是具有9个结点的二叉树。树图5.7.10的简单路径长度为：1x2+2x3+3x3.17,树图5.7.11的简单路径长度为：1x2+2x4+3x2=16,由上两图可见，如果结点数相同，则顺序二叉树是具有最小简单路径长度的二又树。" ID="1">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）加权路径长度。如果树中的每个叶子结点有权值，即每个叶子结点的大小不同（重要性不同），那么从叶子到根结点之间的长度，就是叶子的权值与叶子到根绒点之间路径长度" ID="2">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="〔分枝数）的乘积，也称为叶结点的加权路径长度。月阵胃树的加权路径长度，是指树中所有带权叶结点的加权路径长度之和。.13都是具有4个叶结点的二叉树。树图5.7.12的加权路径长度为：翻1田‘，lq配1七n大口抉乞求石平二由，祛业龙占飞止飞J不，，山通主，一傀弓6＊3科＊3＋2＊2＋3＊2＝400可看到，结点的权值大的结点更接近根结点，树的加权路径长度就相对更小。6价2户图5.7.12一裸带权二叉树图5.7.13一棵带权二叉树在实际应用中，如情报检索、信息编码，往往将数据元素的信息或信息存放的地址存人叶结点之中.分枝结点仅仅用于检索判断条件。而不同的信息具有不同的检索频率，实际检索时，检索频率高的信息应该检索判断的次数尽可能少，也就是说，检索频率高的信息存放更靠近树根的位置上，检索频率高的信息就是检索概率大的信息，概率就是一个权值。大权值的结点如限，牙全扣之俘泪日妇；大五含‘由.树的协j寿幼玄辞址宫角静月尹姗的俪切眩杯裕磨故，1、" ID="3">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="2.哈夫受树及构成算法" ID="4">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="哈夫曼树又称为最优二叉树。有n个结点，它们分别具有不同的权值，将这n个结点作为叶结点可以构造出m种不同的二叉树，这些二叉树具有不同的加权路径长度，则其中加权路径长度最小的二叉树称为最优二叉树或哈夫曼树。" ID="5">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="构造最优二叉树的算法是由哈夫曼给出的，所以。我们又称最优二叉树为哈夫曼树。" ID="6">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="不同的算法构造哈夫曼树时有一些差异，但思想是一样的，下面我们利用堆来实现。首先" ID="7">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="定义堆树的结点结构。前面讨论过，堆结点实际上是一个数组元素，其中包含大小不同的堆结" ID="8">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="点值，这个结点值在构成哈夫曼树时就是权值。另外，堆结点中我们还定义一个链接域，链接" ID="9">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="域的指针指向二叉树的结点，最终构成的哈夫曼树就是一棵二叉树。所以堆结点（哈夫曼堆结点）结构定义如下：" ID="10">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="B.定义一个堆数组heap。数组元素由两个数据项组成：权值域（w，或wL+wR权值）和指向二叉树结点的链接域。初始化时，heap(i]的每个权值域为叶子结点权值w;；链接域分别指向对应的二叉树叶子结点。" ID="11">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="C.对hCaP进行初始化堆运算。" ID="12">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="T看offY.r决J67Sl+" ID="13">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="D." ID="14">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）申请一个二叉树结点空间，由沙指向；" ID="15">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）删除堆顶元素，并存放到L中（再重新调整堆）；" ID="16">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）再删除堆顶元素，并存放到R中（再重新调整堆）；" ID="17">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）将L和R的权值相加存放到D的权值域中（可以存放判断条件）；" ID="18">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="（6）ptr为根，L链接域所指的子树为左子树，R链接域所指的子树为右子树，构造一个新子树ptr；（7〕D的链接域指向新子树的根p叭晶髻$Picture[00000155\00000155_new\0004.jpg]Picture$$Picture[00000155\00000155_new\0005.jpg]Picture$公" ID="19">
          <fptr EndPN="00000155" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="（c）侧除3,a的堆" ID="20">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Picture URL="00000155\00000155_new\0011.jpg">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Picture>
        <Picture URL="00000155\00000155_new\0012.jpg">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Picture>
        <Paragraph CONTEXT="暑" ID="21">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Picture URL="00000155\00000155_new\0015.jpg">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Picture>
        <Paragraph CONTEXT="L!" ID="22">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Picture URL="00000155\00000155_new\0017.jpg">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Picture>
        <Paragraph CONTEXT="垦‘" ID="23">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="几扩" ID="24">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Picture URL="00000155\00000155_new\0022.jpg">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Picture>
        <Paragraph CONTEXT="落" ID="25">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="鬓一" ID="26">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="尹" ID="27">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Picture URL="00000156\00000156_new\0002.jpg">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Picture>
        <Paragraph CONTEXT="：)u5人l6后的堆" ID="28">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="(k)lt1i,16后的堆" ID="29">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Picture URL="00000156\00000156_new\0008.jpg">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Picture>
        <Paragraph CONTEXT="(1)人27后的堆$Picture[00000156\00000156_new\0011.jpg]Picture$Eiinxn&quot;I'ncNcx)c·fiuffmanl'reeintaJ】.intn)111根据权恤（权叭存放在a]1:川）构造哈夫3树.形t,if.的1大受t一仪动态链接的二又fkluffmanNex)c.heap二newuffman[odcln-IJ;a义一个哈夫受准数组Liinaryl'rechcx)c+ptr;forfinli二1:i：二n:i产n个n{1一--f,{ptr=LfakcTlxlc(a]i产生一个¢,AI点.rata(，ss-r川于的权伯" ID="30">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="hcap(iI.weigh［一alil：Ilal：1的位存欣列哈夫岐堆yt.的权位]‘－一‘.’········/r41dJallFi.,tY.tfti4tfEt5G#f&quot;rt。卜Syrheapl［1.rOx-ptr" ID="31">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="、1：nHcapln￡t（愉ap：，）；l，’按哈大曼1作‘1，的权位大小构适一个最小月" ID="32">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="｛ptr-ncwBm.1t1'rccVaic;/ljl:IjliN二个i人丝树ecrMln[Ie“pUelete(L11从堆‘1’侧除堆项结：l，’.（存放到u夫性{yuf`iI.中R1inHcapDclac{R11从堆，Ir刹f堆rro4r1.fl'1Jn大鱿唯结4!iRr1r11rvrioh.二1uriohrtR····hr口LrLivntvl;1！二ikIIytii:6丢HtCha:nrl" ID="33">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="D.we：ght二L.＊ei沙t本R.卿19卜1；p卜＞dat卜D.w‘ghl；II哈大梦树结点data：’l’t是台并结点的权fi’（" ID="34">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="MakeTr恻ptr.Lr拟.R.叫kllL，R所棍的子树.作为ptr左右子树生成一个新子树" ID="35">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="。‘洲邓试11哈人趁堆结点。的链接域招向新子树的报。‘r。时邓试劫inlleaP［nsert归）；l入1：。Ileapoelctc（D）；11川除哈夫经堆，1，狱后抽人的堆结点" ID="36">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="ddelc日hcaP；ll释放冶夫受堆结点空r.J烈ump比刀返回哈夫经树报结点衍针刃由上述分析结果可以得出两个结论：" ID="37">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）当叶结点的权值不相同时组脚匝序二叉树并不一定是最优二叉树。" ID="38">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）为了构造最优二叉树必须将权值最大的结点尽量靠近根结点。" ID="39">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="3.哈夫受编码哈夫曼编码是一种文本压缩算法，是根据符号在一段文字中的相对出现频率不同，来压缩" ID="40">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="编码。" ID="41">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="假定有n个字符的字母表和由该字母表中的符号组成的信息，我们希望将字母表中的字" ID="42">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="符用二进制进行编码，从而用这些符号的编码代替组成信息的符号来完成对信息的编码。目前进行快速的远程通讯常常要用到这种编码信息传送。为了高速地传送信息，需要高效的编码的译码技术。下面讨论如何用我们前面学到的知识来完成这一任务。" ID="43">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，我们现在假定信息由A、B、C、D4个字母组成，并赋予它如下的代码：" ID="44">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="盯呐of〔符号）c帅e（编码〕" ID="45">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="血nlnA别塑远以笠呈上鲤旦工蜘翌～" ID="46">
          <fptr EndPN="00000158" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="eA" ID="47">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="A" ID="48">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="日110" ID="49">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="CIODlll则信息ABAccDA的编码变成QU卫旦皿边」旦Q，只剩下13位了。在很长的信息中，若所但需要注意的是，选择这样一个高效的编码方法时，一个符号的编码不应该是另一个符号编码的前缀。这是由于上述编码信息的译码是从左到右进行的。如果一个符号x的编码。（x）是另一个符号y的编码c切的前缀测译码时遇到c（x）就无法确定是符号x还是符号y的编码前缀。二叉树，图中每个结点的内容包含一个字符和它出现的频率，这样一裸二叉树就是哈夫曼（物丘hlan）树。$Picture[00000158\00000158_new\0020.jpg]Picture$一旦哈夫曼树构成以后，在字母表中任何符号的编码就可以通过从表示该符号的叶结点开始攀登到树根来确定。编码初始化为空，以后每攀登一根左枝附一个0到编" ID="50">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="码左边，每攀登一个右枝附一个1在编码左边，直至树根为" ID="51">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000158" TITLE="5.7.4  判定树" TYPE="Chapter">
        <fptr LogicalPageNum="158" PhysicalPageNum="158"/>
        <Paragraph CONTEXT="现在分析图5.7.1b。如果。+b-cad+eff，则可知假币一定在这六枚硬币之中，而不是g或bfl当下次再称又发现a-d&lt;b+e，此时由于d和b交换了位置不等式仍然成立，说明两个问题：①。和f不是伪造的；Qb和d同样不是伪造的。所以a和e中间有一个·的，这时只要用一枚真硬币b与：比较一下就行了：若a=b，则说明。为假且重；否则：为假且.轻。如果a+b=b+e,假且重；否则c为假且轻。如果a+d&gt;b+e，则肯定b和d中有一枚'的，这时只要拿一枚真的a与b比较即可：若a=b，说明d为假且重，否则b为假且轻。" ID="1">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="枚都可能为假，且可能重也可能轻，共计16种情况。每条线路上恰好有3次比较。" ID="2">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="从不并" ID="3">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="-He-LC-f-Lb-d-Lg-Hh-h-Hg-Lb-d-c-Lf-Ha-Lo-H" ID="4">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT=".－He－－Lc-f－Lb-d-Lg-Hh-h-H合L图5.7‘t6八枚硬币的判定树" ID="5">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000159" TITLE="习题五" TYPE="Chapter">
      <fptr LogicalPageNum="159" PhysicalPageNum="159"/>
      <Paragraph CONTEXT="1.由3个结点组成的树型有多少种？树有多少种？，山1木姑占拍礴的一了翻廿姗刑右之小劫7一万树右名，b劫92.3.什么样的二叉树不是树？" ID="1">
        <fptr EndPN="00000159" StartPN="00000159"/>
      </Paragraph>
      <Picture URL="00000160\00000160_new\0001.jpg">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Picture>
      <Picture URL="00000160\00000160_new\0002.jpg">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Picture>
      <Paragraph CONTEXT="9.画出权值为18,21,5,3,1,4,11的哈夫曼树，并计算出其加权路径长度。1Q.将一般树用线索树表示,写出将子树l插人到一般树中作为一般树结点N的第i个子树的算法。" ID="2">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="11.画出图5一习l的两棵二又树的前序和后序线素树表示法，且写出在前序和后序情况下求树中任一结点lt1的前驱和后继结点的算法PTl。和nexto" ID="3">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="12.将一般树用中序线索树表示时，试写出将任意结点N的第1棵子树从树中删除的算法。" ID="4">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="13.试设计一个算法利用判定树的原理确定12枚币中的一枚假币，真假之区别仍是在于重量之不同.或轻或重.并画出判定树形，" ID="5">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="14.巧.编写算法：将二叉树中所有结点的左右子树相交换。" ID="6">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="16.编写算法：判定给定二叉树是否为二叉排序树。" ID="7">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
      <Paragraph CONTEXT="17.一般树以二叉树方式存储，试给出按层次遍历（4种）的算法。" ID="8">
        <fptr EndPN="00000160" StartPN="00000160"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="本章将讨论另一种极其有用的数据结构一一树。它适应于反应层次关系的数据对象的研$Picture[00000107\00000107_new\0003.jpg]Picture$图s.1.i一裸学院信息的树" ID="1">
      <fptr EndPN="00000107" StartPN="00000107"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000161" TITLE="第六章  图" TYPE="Chapter">
    <fptr LogicalPageNum="161" PhysicalPageNum="161"/>
      <div ORDERLABEL="00000161" TITLE="6.1  图的概念" TYPE="Chapter">
      <fptr LogicalPageNum="161" PhysicalPageNum="161"/>
        <div ORDERLABEL="00000161" TITLE="6.1.1  图的定义" TYPE="Chapter">
        <fptr LogicalPageNum="161" PhysicalPageNum="161"/>
        <Paragraph CONTEXT="图就是顶点和边的集合。一般描述为图G＝口，El，v（G）为图G的顶点集合，必须是有穷" ID="1">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="(a){b)" ID="2">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.1.1两个典e的图" ID="3">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000161" TITLE="6.1.2  图的术语" TYPE="Chapter">
        <fptr LogicalPageNum="161" PhysicalPageNum="161"/>
        <Paragraph CONTEXT="·边：连接图中顶点的连线，表示两个顶点之间的某种关系。可以用顶点对来表示，如图" ID="1">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Picture URL="00000161\00000161_new\0003.jpg">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Picture>
        <Picture URL="00000161\00000161_new\0004.jpg">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Picture>
        <Paragraph CONTEXT="V。和VZ之间的关系可以用（VI，v2）表示，图6.1.1（b）中顶点V；到顶点叭之间的关系可以用＜v：，vZ》来表示。" ID="2">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="。弧：连接图中顶点的有向连线，表示两个顶点之间的某种关系。可以用顶点对来表示，$Picture[00000162\00000162_new\0001.jpg]Picture$$Picture[00000162\00000162_new\0002.jpg]Picture$·权：与图中的边或者弧相关的数。" ID="3">
          <fptr EndPN="00000162" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="·网：带权图。" ID="4">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Paragraph>
        <Paragraph CONTEXT="·子图：如果存在这样的两个图：" ID="5">
          <fptr EndPN="00000162" StartPN="00000162"/>
        </Paragraph>
        <Paragraph CONTEXT="CV,E?G，二｛VE'}那么称图G'是图G的子图。如图6.1.3所示，图6.1.3(b）和图6.1.3(c）是图6.1.3(a）的子图。，图“的一个子图二｝图”一个子图{a){b){c)图6.1.3子图·路径：从起始顶点到终止顶点所经过的顶点的序列。·路径长度：路径上边或者弧的数量。·连通图：任意两个顶点之间都至少存在一条路径的无向图。义的，它既可以是有向边，也可以是无向边。·平行：如果有若干条边的头和尾都是相同的，称之为平行边。·多重图：包含有平行边的图都称之为多重图。本章以后所讲的都是简单图。" ID="6">
          <fptr EndPN="00000163" StartPN="00000162"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000163" TITLE="6.1.3  图的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="163" PhysicalPageNum="163"/>
        <Paragraph CONTEXT="上面已经详细讨论了图的定义及相关概念，下面我们将重点围绕图的抽象数据类型进行" ID="1">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Paragraph CONTEXT="讨论。" ID="2">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Paragraph CONTEXT="ADTGraph" ID="3">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Paragraph CONTEXT="短" ID="4">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Paragraph CONTEXT="pset：非空有限顶点集合v" ID="5">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Paragraph CONTEXT="刀.时。d卜六右想节有占山之月梦卜凌注翻垂场翼乡由的俪占知角的兰玉" ID="6">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
        <Picture URL="00000163\00000163_new\0010.jpg">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Picture>
        <Paragraph CONTEXT="内tM欲（＆qv，v幽e）；BE'STraverse(BcG,v}" ID="7">
          <fptr EndPN="00000163" StartPN="00000163"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000163" TITLE="6.2  图的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="163" PhysicalPageNum="163"/>
        <div ORDERLABEL="00000163" TITLE="6.2.1  邻接矩阵表示法" TYPE="Chapter">
        <fptr LogicalPageNum="163" PhysicalPageNum="163"/>
        <Paragraph CONTEXT="如果图G是有向不带权图，可以用下面的邻接矩阵来表示：卜｝：氢价，‘五否则如果图G是无向带权图，可以用下面的邻接矩阵来表示：,Nevi}oE" ID="1">
          <fptr EndPN="00000164" StartPN="00000164"/>
        </Paragraph>
        <Paragraph CONTEXT="习5月1i否则如果图G是有向带权图，可以用下面的邻接矩阵来表示：" ID="2">
          <fptr EndPN="00000164" StartPN="00000164"/>
        </Paragraph>
        <Paragraph CONTEXT="＊i，卜｛资璧黔否则八蒸钩厂了心(a){b?④{c）{d$Picture[00000164\00000164_new\0017.jpg]Picture$$Picture[00000164\00000164_new\0018.jpg]Picture$图5.2.14种典,的图11100［011Q000110`k0000000，00｝｝Doolo，‘0，0｛！0，。。1‘0‘0‘｝｝ooD0000010」Lo0000（a）（b）362“1卜64山co。。69二｝卜。二，，。。吕。。｝｝。。二5二6“‘5‘｝｝。“。aoZ9一二4｝｝。。。。‘二。。4司Laa（。〕（d）从图中可以看出，无向图对应的邻接矩阵提岁寸称的。有向图对应的邻接矩阵则不一定对称。采用这种表示方法，可以根据矩阵的第1行列元素的值，直接判断某两个顶点之间是否邻接。而且计算顶点的度也很方便：对于无向图中的顶点Vt，它的度就是邻接矩阵中第宝行的和；对于有向图中的顶点v.，它的人度就是第1列的和，出度就是第1行的和。" ID="3">
          <fptr EndPN="00000165" StartPN="00000164"/>
        </Paragraph>
        <Paragraph CONTEXT="2.郁接矩阵的实现" ID="4">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="按照前面的描述，图可以采用一个二维数组来存储表示。具体的存储结构定义如下：t曰dsect(intdara;intvertexJum;intedge力um;}Crraph;" ID="5">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="3.基于郊接矩阵表示的图的建立采用邻接矩阵表示方法，可以用下面的算法建立图。基于邻接矩阵表示的图的建立算法nit于邹i迈P&lt;小的有向帝权(lryz立升法vrIdCrcatcGraph(GraphRb){tntn,tua.econd;cout«&quot;iK人xl的数Crrnn»g.亡dgtnum;cnutNf人1？点的'1(i（一；cm»g.vcrtcx_num;" ID="6">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="g.data-newtntg.vettcx_numfca(n=O;n&lt;g.vcrtcx_num;n" ID="7">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="gdata(nJ“newmt(gvertcx_numfrx(1intfirst.g.cr坟cx_num;fits什）for(second-0;sec:ond&lt;g.venex.num;second+" ID="8">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="g.cL。ta(tirslacrmd]二IhFIVITY:for(n-O,n&lt;g.edryc－num;n洛《。out＜子洁输人第’《叶i«'条{t的i'Q头项点h'1序号“：" ID="9">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
        <Paragraph CONTEXT="cin&gt;到、rst;:OUI&lt;G&quot;1入N一＜&lt;n+l«弧的irt1S！点的fY;“:cin»sccond:tout«&quot;i)人权’；cin»R.datalfirstsecond]:" ID="10">
          <fptr EndPN="00000165" StartPN="00000165"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000166" TITLE="6.2.2  邻接表表示法" TYPE="Chapter">
        <fptr LogicalPageNum="166" PhysicalPageNum="166"/>
        <Paragraph CONTEXT="t.都接表的概念对于图G中的某个顶点v,，把与它相邻接的所有顶点（如果是有向图，则是所有邻接自该顶点的所有顶点）串起来，构成一个单链表，这个链表就称为顶点V‘的邻接表。如果图G有。个顶点，那么就会得到n条邻接表。为了有效地对这n条邻接表进行管理，每条邻接表的前面都增设一个表头结点。所有的表头结点可以存储在一个数组中。" ID="1">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="为了避免各顶点信息的重复存储，可以规定，各顶点的基本信息存放在表头结点中，表头结点的基本格式如图6.2.3所示。data分量存图b.23表头结点的基储各表头的基本信息。点是相同的，只需要把边的另外一个顶点表示出来；另外，边本身可能存在权等信息，也需要表" ID="2">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="点数组中的下标，info表示该边的权等信息，next指向链表中的下一个结点。" ID="3">
          <fptr EndPN="00000166" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="图6,2.4边的基本格式一个图对应的邻接矩阵是惟一的，而对应的邻接表却不是惟一的，因为邻接表中各结点出现的顺序和建立图时的输人顺序有关。当解决实际问题时，到底是采用邻接矩阵表示好，还是采用邻接表表示好呢？下面作一个分析。邻接表表示中的一条单链表，对应于邻接矩阵的一行，边表中结点个数等于一行中非零元素的个数。若无向图G具有n个顶点，e条边，那么它的邻接表表示中有n个表头结点和2e素的个数。若无向图G具有n个顶点，e条边，那么它的邻接表表示中有n个表头结点和Ze个链表结点；若有向图G具有n个顶点，e条边，那么它的邻接表表示中有n个表头结点和Ze个链表结点；不管图G是否有向，只要有n个顶点，那么在邻接矩阵表示法中，就要占据n拍个存储单元。如果图G是稀疏图，邻接表表示比邻接矩阵表示节省存储空间；如果不是是稀疏图，因为邻接表中有额外的附加链域，那么采取邻接矩阵表示法较好。" ID="4">
          <fptr EndPN="00000167" StartPN="00000166"/>
        </Paragraph>
        <Paragraph CONTEXT="2.逆邻接表的概念" ID="5">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="在邻接表表示中，对于无向图，顶点的度很容易计算，第1个单链表中的结点个数就是顶" ID="6">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="度，就需要访问每一条单链表。" ID="7">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="在某些情况下，可能要大量计算有向图顶点的出度获在某些情况下，可能要大量计算有向" ID="8">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="图顶点的人度。为了方便地解决后一个向题，这里引进逆邻接表的概念。" ID="9">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="逆邻接表的概念和邻接表的概念基本一样，惟一的差别在于：邻接表表示中，如果是有向" ID="10">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Picture URL="00000167\00000167_new\0019.jpg">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Picture>
        <Picture URL="00000167\00000167_new\0020.jpg">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Picture>
        <Paragraph CONTEXT="图，是把所有邻接自某顶点的所有顶点串起来，构成一条单链表；而在逆邻接表表示中.是把所" ID="11">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="有邻接至某顶点的所有顶点串起来，构成一条单链表。" ID="12">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.2.7给出了一个有向图的逆邻接表表示。图6.2.7一个有向图的逆邻接表表示" ID="13">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="3.郁接表的实现" ID="14">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="邻接表中，结点的定义如下：" ID="15">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="t押翻efst1Ct" ID="16">
          <fptr EndPN="00000167" StartPN="00000167"/>
        </Paragraph>
        <Paragraph CONTEXT="113'I'ypedata;＊如e目；" ID="17">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="}AdjList;" ID="18">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstrua{AdjList。headjist;intrertex`nttm;11顶点数：…J～‘一，，一.，，今卜劝公rintedgettttn;" ID="19">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="4.基于邻接表的图的建立采用邻接表表示方法，可以用下面的算法建立图。派于邻接农衰示的图的建立林法nth于:i1t1iiJ:EX)有11.G#ZC:1的ft抹tcurdCruHCC'itaph1djCir.l,h&amp;g)扭tntn,tttst.second,rrctgttt:A内喻“址，p；cout«'人ifl(ti'iirin»g.alpC－nom:coot«°aA人Tot的;t1cing.vcrtex_num.g.hcad_liujHersdll.ict(F.rertex＿numl:fw几。一A;n＜名.stncxnom:。一）" ID="20">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="g.hcd_I：.tlnl.lkad-Nl1I.lfor(n-o.n‘9曰9兔nun、）石cuutcc&quot;i地入n二、c'iiru?h弧头)点约序弓cm»fu鱿" ID="21">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="coot&lt;Cih人第‘＜＜.，.＜才条笼的弧尾该点的序修“" ID="22">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
        <Paragraph CONTEXT="r,n»seeond:coot&lt;Cihli}人该弧的tnnrrciFht;P一：,cw.4dj\，x3e.pnfc，二knight:p&gt;anuthKvcrtcr.mound:(snrsl-ghc:kl_hw(Iir、tl,Fr.ad;ghe.tJ_lt+t(firsthead-P一》next:该:法虽然只fi介绍了有向图的建r'L.t加改r.问样可以谁立（于邻接表的无向EFI以及丛f逆邵援表的有向图，" ID="23">
          <fptr EndPN="00000168" StartPN="00000168"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="相对于树来说，图的结构更为复杂，顶点、边之间的联系更为密切，简单的二重链表，甚至" ID="1">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="更多重链表已经无法表达它们之间的这些复杂关系了。由于图中各个顶点的度差别可能很大，这就给图的存储表示带来了很大的困难。这里先给出几种常见的存储表示方法，但要强调的是，在解决实际问题的时候，并不一定要拘泥于这里所给的描述，可以根据实际情况来最终确定存储表示的方法。" ID="2">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000168" TITLE="6.3  图的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="168" PhysicalPageNum="168"/>
        <div ORDERLABEL="00000169" TITLE="6.3.1  深度优先搜索遍历" TYPE="Chapter">
        <fptr LogicalPageNum="169" PhysicalPageNum="169"/>
        <Paragraph CONTEXT="t.概念" ID="1">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="深度优先搜索.历是按照如下步骤进行的：在图G中任选一顶点V;为初始出发点，首先，访问出发点yi，并将其标记为已访问过，然后，依次从V。出发，搜索V；的每一个邻接点vj，若v;未曾访间过，则以V;为新的出发点继续进行深度优先搜索遍历。显然上述搜索法是递归定义的，它的特点是尽可能先对纵深方向进行搜索，所以称为深度优先搜索遍历。瓜丫一一石乃叮、如图6.3.1所示，假定从顶点Vo出发开始搜索，标志数2又入／弓r" ID="2">
          <fptr EndPN="00000169" StartPN="00000169"/>
        </Paragraph>
        <Paragraph CONTEXT="2.算法实现为了保证能够从顶点v。返回到访问它之前访问过的顶点v;，就需要把顶点的访问序列记来。在递归实现中通过系统堆栈来达到这一目的，在非递归实现中则需要通过显式堆栈" ID="3">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="录下来。来达到这一目的。深度优先搜索的递归实况算法11基f邻接示约们TiI的深]优先搜索递归林cordUl·S(AdjGraphg.intv.int＊visltcd)" ID="4">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="{AdjlcttlC»u;" ID="5">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="VI、IICd[Vl:tout«v&lt;c&quot;一》：fcx(w-g.head＿口ist[vJ.hrsd;w;w.w一》nc入t)" ID="6">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="ifvisitrd[u&gt;anothcr_vcrtcxpDrs(g.w一》anather_vcrtex,visi［ed1voidDFSI7ans(AdjGrapltg}{int.vicitul,i;vlsitai-new1nllg.ccrtex_numnrmsctlvisitcd.O.siictifpnt)。g.vcncx_nunl" ID="7">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i-Oargenex_num;ir，)" ID="8">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="Dl‘5（琶，1.vi‘itcd）；" ID="9">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="deletevisited;I深度优先搜索的非递归实现算法" ID="10">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="l,C于邻接表7示的有向t的at:lrl:优先搜索t递]11算voidDFS(AdjGraphg,intc,int=vidtcd){inlstack[10001J/stack[MAX入ODEJ;" ID="11">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="inttop;1/伐ly！指[lnt1;AdjNudc»pt;civet«v«°进行1方问top=9:" ID="12">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="visited[v]‘1;已访问标志stack[topv;" ID="13">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="whlle(topU)" ID="14">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="[pt=g.hcad_licl[似tack[tc11I.hcad;" ID="15">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="p卜p卜，ncxt；11找一个未被访f]过的邻接顶点" ID="16">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT="ifpt}tcp一xj]，返[41#1ily一次被tiJ问过的7C?.i" ID="17">
          <fptr EndPN="00000170" StartPN="00000170"/>
        </Paragraph>
        <Paragraph CONTEXT=")" ID="18">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="奋" ID="19">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="voidDFSTrumlAdlGraphg)" ID="20">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="int。risitCd.t:" ID="21">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="visual=newintog.venex_num" ID="22">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="rnemset(sisttcd.0.幼icwf(inqsgvrrtcx_num" ID="23">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="Cori=0a'g'cncx＿num;t+" ID="24">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="Df(ga,vtsucd" ID="25">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="delete(Jvi“忆cam.1" ID="26">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="木炸法的实t!tf为CNn'" ID="27">
          <fptr EndPN="00000171" StartPN="00000171"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000171" TITLE="6.3.2  宽度优先搜索遍历" TYPE="Chapter">
        <fptr LogicalPageNum="171" PhysicalPageNum="171"/>
        <Paragraph CONTEXT="I.概念宽度优先搜索遍历是按照如图G.3.2所示的步骤进行的：在图G中任选一顶点v;为初始出发点，首先访问出发点v,，接着依次访间v;的所有邻接点Qi.Qx，一，然后，再依次访问与4,伍,…邻接的所有未曾访问过的顶点，依此类推，直至图中所有和初始出发点v;这种方法的特点就是以出发点为中心，一层层地扩展开去，先对横向进行搜索。所以称为宽度优先搜索。如图6.3.2所示，假定从顶点0出发开始搜索，标志数组的初®b.3.2它们对应的标志数组元素都为I，按照任意的顺序访问顶点v1.：和v3，然后置其标志iES(AdGraph6,mtv,tnt.eta(1AXIMU、1" ID="1">
          <fptr EndPN="00000172" StartPN="00000171"/>
        </Paragraph>
        <Paragraph CONTEXT="、山洲" ID="2">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="hr" ID="3">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="‘r" ID="4">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="stted[v" ID="5">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="cuc[hcad】二、：" ID="6">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="while(headt&lt;P-g.hcad1i.t[yurue[hcadp.hcad:lflcJtij¢twhttc(p！二N" ID="7">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="t=pan‘uhcrvertcz" ID="8">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="v犷s，t71t" ID="9">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="wmt(g.、crtcx＿nuncrrtctcvtsited,U,wti，fiintg.vttc:ifvistl" ID="10">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="BFS（9.［.、lslted）" ID="11">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="Clete(Jvtsned;" ID="12">
          <fptr EndPN="00000172" StartPN="00000172"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="图的遍历是从某个顶点出发，按某种秩序对图中所有顶点各做一次访问。若给定的图是连通图，则从图中任一顶点出发按某种秩序就可以访向到该图的所有顶点。图的遍历主要有两劫舌幸仁。娜磨抒习卜抽套产庄粉月卜怕省鉴图的遍历比树的遍历复杂得多.因为图中的任一顶点都可能和其余顶点相邻接，所以在访" ID="1">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Paragraph>
      <Paragraph CONTEXT="问了某个顶点之后，可能会延着某条路径又回到了该顶点。为了避免有顶点被重复访问，必须" ID="2">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Paragraph>
      <Paragraph CONTEXT="记住每个顶点是否被访问过。所以，在遍历的过程中，设置一个标志数组visited[n]，它的初值为FALSE，一旦访问了某顶点，便将其对应的数组元素置为TRUEo" ID="3">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000172" TITLE="6.4  最小生成树" TYPE="Chapter">
      <fptr LogicalPageNum="172" PhysicalPageNum="172"/>
        <div ORDERLABEL="00000172" TITLE="6.4.1  生成树" TYPE="Chapter">
        <fptr LogicalPageNum="172" PhysicalPageNum="172"/>
        <Paragraph CONTEXT="连通图的极小连通子图就是原图的生成树。f设图G有n个顶点，图T是图G的生成树，那么图T肯定具备n个顶点和，1条边。如果图T少于n-1条边，那么它肯定不是连通的；如果图T有多于n-1条的边，那么它肯定不求连通图的生成树，可以用前面介绍的深度优先搜素、宽度优先搜索算法来实现，得到的分别称为深度优先生成树、宽度优先生成树。" ID="1">
          <fptr EndPN="00000173" StartPN="00000172"/>
        </Paragraph>
        <Paragraph CONTEXT="图6.4.1列举出了一个深度优先生成树和宽度优" ID="2">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
        <Picture URL="00000173\00000173_new\0006.jpg">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Picture>
        <Picture URL="00000173\00000173_new\0007.jpg">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Picture>
        <Picture URL="00000173\00000173_new\0008.jpg">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Picture>
        <Paragraph CONTEXT="(a）连通图（b）深度优先生成树（。）宽度优先生成树" ID="3">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000173" TITLE="6.4.2  最小代价生成树" TYPE="Chapter">
        <fptr LogicalPageNum="173" PhysicalPageNum="173"/>
        <Paragraph CONTEXT="t.最小代价生成树的棍念图5.4.2给出了几个城市之间的直线距离，现在想能够通话，而且电话线的总长度最短。如果把它看做一个图，该图的生成树就是能够保证任意两个城市之间可$Picture[00000173\00000173_new\0006.jpg]Picture$20以通话的方案，而且电话线的条数最少。但是实际要求是电话线的J急长度最短，这就需要在众多生成树中寻找" ID="1">
          <fptr EndPN="00000173" StartPN="00000173"/>
        </Paragraph>
        <Paragraph CONTEXT="2.Prim算法Prim算法可以求解出给定连通网络的最小代价生成树。它的基本思路如下：假设连通网GV.E}，图TU,ME}是图G的最小代价生成树，求图T的步骤如下：" ID="2">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)令uY{traMB0uQ是集合V中的任意一个顶点；t2）在所有的u〔U,v〔V一，而且（(u,v)EE的边中。找一条权最小的边(w,Vi，将v；并人集合U.将边（(ui,vJ并人集合ME;" ID="3">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）重复步骤2，直到u=v$Picture[00000174\00000174_new\0010.jpg]Picture$$Picture[00000174\00000174_new\0015.jpg]Picture$（d）（。）（f）$Picture[00000174\00000174_new\0018.jpg]Picture$$Picture[00000174\00000174_new\0019.jpg]Picture$假设连通网的存储由邻接矩阵实现，即m算法的实现如下所述：Prim法的买现" ID="4">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="方茱扫协接矫阵人示的门的Prin、只法实现" ID="5">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="voidPrim(Graphg,intv)" ID="6">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="{int，门，gtntr,m,n,mtn,tcmp_m,tctnp_n;flatnewint[g.vertex＿nummemset（生lag,0saeof(mtg.vcrtcx_numflak卜卜l:/I把lilt.v放人火iiU" ID="7">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="Cu(i动;i&lt;g.acrtcx_num-I;i" ID="8">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="{min=IKFIIITY;ifflag[rrflag[n]）二1KScgdata[mn]cmin)flag[mflaF[n]）二t1:r:" ID="9">
          <fptr EndPN="00000174" StartPN="00000174"/>
        </Paragraph>
        <Paragraph CONTEXT="tcmp_m=m:" ID="10">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="tcntp_n=n." ID="11">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="｝cout·tentp_m«&lt;“一，‘了tcmP＿n‘、cndl；K-data(temp_rntemp_nIIFIVITY;1，扭1艺工仑此边门afremnml_I" ID="12">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="ilag(tcmp.n卜I;" ID="13">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="14">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="dclctc(p7ag:1在买现的过程中，定义了一个标志数组，如果某顶点在集合U中，则将其对应的数组元素置to本算法的时间复杂度为0(n、o" ID="15">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="3.Kruslcal算法儿”七叭算法也可以求解出给定连通网络的最小代价生成树。它的基本思路如下：忽撞,奋f[r-rv1ZiI1.Fl&lt;Ir.t4ft名I.fflB&gt;k奋f?klrtfh案llen门盯_{1)令T＝｛v，1必｝｝，也就是说，T最初由n个顶点和。条边构成；{2）在E中选择权最小的一条边，如果该边加人到T中之后，会形成回路，放弃该边，在其余的边中再找权最小的一条边；" ID="16">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）将该边从E中侧除，加人到图T的边集中去；" ID="17">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）重复步骤2和3，直到图T中包含n-1条边。图6.4.5演示了对于图6.4.3{a)中的连通网络，使用Kruska！算法求解最小代价生成树的④0④.兰习④二" ID="18">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="④④。④④16" ID="19">
          <fptr EndPN="00000175" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="（a}(b)(c)在算法实现的过程中，需要判断图T中是否有回路。最开始图T中有n个离散的顶点，可以看作n个连通分量，每个顶点所在的连通分量号用数组，etnumber来表示，最开始每个顶" ID="20">
          <fptr EndPN="00000176" StartPN="00000175"/>
        </Paragraph>
        <Paragraph CONTEXT="点对应一个唯一的连通分量号；每当加入一条符合条件的边，连通分量的数量就要减少一个，" ID="21">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
        <Paragraph CONTEXT="1亨全汉It兀互分吮Il" ID="22">
          <fptr EndPN="00000176" StartPN="00000176"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000176" TITLE="6.5  最短路径" TYPE="Chapter">
      <fptr LogicalPageNum="176" PhysicalPageNum="176"/>
        <div ORDERLABEL="00000177" TITLE="6.5.1  单源最短路径" TYPE="Chapter">
        <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
        <Paragraph CONTEXT="求从某个顶点出发，到达其他所有顶点的最短路径问题，称为单源最短路径。开始顶点称$Picture[00000177\00000177_new\0003.jpg]Picture$$Picture[00000177\00000177_new\0004.jpg]Picture${a)(b}图6S.1顶点V。到其他所有顶点的最短路径假设图Cr-fV,E}，从顶点Vo出发，计算到达其他所有顶点的最短路径。假设图G采用邻接矩阵存储，矩阵本身存储在数组山阳[1[］中，定义集合S为已经求出的距离顶点Vo最短的顶点集合，那么集合V-C就是待计算的顶点集合。定义数组disc[】中保存顶点Va到各顶点的定义数组dist［】中保存顶点vo到各顶点的" ID="1">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）令未tVo｝。" ID="2">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）令di毗1］月幽口切田，1是除顶点va以外的其余各顶点的序号。（3冰认5中选取一个击哎1值最小的顶点v肥顶点v加人到集合5中去再对集合v－5二一崖犷阅穿，1”。二’‘二1―.－了一”’一一’.，r." ID="3">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="刁1认1‘·，IJ.｝r·叫" ID="4">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="假设1妇G采用邻接矩阵存钻，Dijk从ra算法的实现如下：" ID="5">
          <fptr EndPN="00000177" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="Dijk、tra林法的实现dlst=HeretnggYcrtc.x＿nuntl:S-newintlg.、Crtrx_numpath=newchars.vertenurnfor(i=O:i;g.vcrtcx_num,一＋〕Palh[iImt+ch:tr[!Wfurfi二0；1，9.vcr：cxnu，n；1＋＋）11公］始化1」1、1【1】＝9.d公a！vl！1】：if(disl[i]VFIV[TY)sprintl(p:t吸h[i1ao」一只‘d”.v。1）；else" ID="6">
          <fptr EndPN="00000178" StartPN="00000177"/>
        </Paragraph>
        <Paragraph CONTEXT="、trcPy（Pathlll、～月）；" ID="7">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="S[i)-0:" ID="8">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="}5['1-1：11把溉点放人井';slhfar(hla&lt;g.Yertc+c_num;i[min-Ilvf·lil'1'Y:" ID="9">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="J二氏for气k刀;k&lt;g.Ycncx-num.ktr)lYS'，找list[1;j(it'1小的fit(;rncru.c.e,trt.t.m" ID="10">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="(min-dict[k" ID="11">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="j=k;}S(」t:11把找#tj的r点放入t05rtortk-oaR.v7tcx一口um：k＋＋）11擎改Vs中-f..的dirt[1tfS[k]FtdcdtstlllR-JJlll[kl＜山、t[k" ID="12">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="(ditit[l二diu[j]g.d.tta[jkl" ID="13">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="sprintf(tcmp,odk" ID="14">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="alrcpy(patltlkpa吸h[tstrcat(pttt!l[ktrntp" ID="15">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="】！tc.r{i-U:i·.gvcrtcx_num;ir)cout«dis［川.＜二卜川。【11＜尤cno11：" ID="16">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="delctr[Jdist;delete[[S:for(i二0：1＜9.vcrtcxnumj一）" ID="17">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="delete[)Path[il:" ID="18">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="dclett[Jpath:｝" ID="19">
          <fptr EndPN="00000178" StartPN="00000178"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000178" TITLE="6.5.2  任意两个顶点之间的路径" TYPE="Chapter">
        <fptr LogicalPageNum="178" PhysicalPageNum="178"/>
        <Paragraph CONTEXT="如果要求任意两个顶点之间的最短路径，可以依次把每个顶点当作源点，调用Dijkstza算假定网络G用邻接矩阵表示，矩阵本身用数组dal适[lFloyed算法的基本思想是：递归地产生矩阵序列Ao,Ai，Az····q-i，矩阵Ak（k司，1，2，…）的元素凡rU7为从顶点1到顶点a且中间不经过编号大于k的顶点的最短路径长度,A,卜：就是最终的运算结果。也就是最原始的直线距离。然后，在所有的路径中增加中间顶点va，如果新得到的路径长度小于原来的路径长度，那么就以新路径替代老路径。也就是对于每一个矩阵元素Ao[yJG进行计算，or]17=in[A-i[i17.AiEi]ifl3+A一：[o]U7}。接着，在所有的路径中增加中间顶点v，,m果也就是对于每一个矩招旨配r7di占者各曰是三虱任自台二勃日眸右介j乳辛开瞥.玄鑫』民图6.5.2列举出了使用Floyea算法对图6.5.1(a）的求解过程。爬巴竺”。尸瞥竺”1foioc’“lII于里引｝，甘份里期｝，“份里引｝巴三当份‘”｝｝’旧”份州" ID="1">
          <fptr EndPN="00000179" StartPN="00000178"/>
        </Paragraph>
        <Paragraph CONTEXT="l，，W.L，＂引1“W.u别1，WW.unWbooocaoiuuJ【movao1uuJSaoaoaoiuu" ID="2">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="109900，［01099o001［010（助。蚕一O」。20，，｝卜。加，001卜。20。。0602。｝｝。二。602。｝｝。。060二。100］卜。。100］t。。。10［0‘030（90，。0）1厂0’030如到ro‘030阅叫｝‘。20（80）阅｝20劝月。｛｝，”20卿州" ID="3">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="｝，.”的2“曰。的”60201卜，。（3O）201" ID="4">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="｝叫1”’”，｝！‘””’｝" ID="5">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="L‘二的100」t，CO，100」L，，，100」份兰吧吧1｛“份翌望凹［0份竺吧020（80）阅！卜0208040｛卜020。”的20｝｛6020｝卜。。卜｝卜aoaa。二。1o0」t.coo1。。」L。。二1。（d）＾2（e）A3（f）A4图6.52使用RO班劝算法对图6工1（a）的求解过程n叮cd算法实现如下：" ID="6">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="11.，）’’d算法的实现" ID="7">
          <fptr EndPN="00000179" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="voldAllshort乃t入th（GraPhg）if(ijdtd'tm(rl[JI&lt;INNL1'Y)sprintC(path[i1Vj;°rod一％dijelse" ID="8">
          <fptr EndPN="00000180" StartPN="00000179"/>
        </Paragraph>
        <Paragraph CONTEXT="pathll］匕110］习；" ID="9">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="}阮〔k＝O；k之忿·、ettex-um:kfor(i习;i&lt;g.vertex＿num:ifcx(jl:j&lt;g.verlcx_num:j«" ID="10">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="if(tjm[ikmlk]Lim[ij" ID="11">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="[m17Umlil[kl必m]k]UI:" ID="12">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="strcpyfpath[ijpalh[ik" ID="13">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="、.calfp：thlillJI.门.尸）：" ID="14">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="strcat(path[iaj,path(kj" ID="15">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="}tor(i-0:i才g.eertex_num:i-yfur(JO:j&lt;g.vcrtcx-num;jprintf°bdnillJl" ID="16">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="cout«endl;" ID="17">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="卜foni-U:ig.vertcx_num:i什）(frx(j=O:jvcrtcx_num:j‘print9wspath[ijcow«cnd卜" ID="18">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="｝for(i二O;i之g.vertex_num;ifnr习g.vertex_num;j+，)dcletc[jpath[ijfor{1-0;i＜g.ecrtcx_numy(delete[1m[t" ID="19">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="dcletc[1p:uh[i" ID="20">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="I" ID="21">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="dcluc[1m;" ID="22">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="cilcteI1Pam:" ID="23">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="！这个竹L`L的时Ittj艾11l:c为。(I13)" ID="24">
          <fptr EndPN="00000180" StartPN="00000180"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000180" TITLE="6.6  拓扑排序" TYPE="Chapter">
      <fptr LogicalPageNum="180" PhysicalPageNum="180"/>
        <div ORDERLABEL="00000180" TITLE="6.6.1  AOV网" TYPE="Chapter">
        <fptr LogicalPageNum="180" PhysicalPageNum="180"/>
        <Paragraph CONTEXT="很多工程或任务都可以进一步分解成为很多更小的子工程或子任务，这些子工程或子任务在执行的过程中，有的可以并行执行，有的有一定的前后依赖关系，或者说优先级。有些分支情节没有这样的约束。假设某个电脑游戏剧本有如表6.b.1所示的游戏情节，这些情$Picture[00000181\00000181_new\0002.jpg]Picture$$Picture[00000181\00000181_new\0003.jpg]Picture$图6.6.1游戏情节的关系图像图6.6.1。顶点表示活动，弧表示活动之间的优先关系.这样的有向图称为顶点表示活动网（ActivityOnVertex)，简称AOV网。在AOV网中，如果从顶点v。到顶点v;之间存在一条路径，则称顶点V；是顶点v;的前驱，顶点V是顶点i的后继；如果＜Vi,Vi》是AOV网中的一条弧，称V。是V的直接前驱，V是i" ID="1">
          <fptr EndPN="00000181" StartPN="00000180"/>
        </Paragraph>
        <Paragraph CONTEXT="的直接后继。在Aov网中，不应该出现有向环路，否则，某个活动就会成为自身的前提条件，从而形成悖论。可以采取拓扑排序来检测图中是否存在环路。" ID="2">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000181" TITLE="6.6.2  拓扑排序" TYPE="Chapter">
        <fptr LogicalPageNum="181" PhysicalPageNum="181"/>
        <Paragraph CONTEXT="对于给定的Aov网，各顶点之间呈现的是一种非线性关系，在某些情况下，必须构造这些顶点的线性序列，确定各顶点之间的先后关系，这样的线性序列称为拓扑有序序列。构造" ID="1">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="Aov网拓扑有序序列的过程就叫拓扑引游o" ID="2">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="如果给定的Aov网存在有向环路，那么肯定构造不出所有顶点的线性序列，反之，如果不存在有向环路，则是可以的。拓扑排序的步骤如下：" ID="3">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="{1)在人OV网中任意选择一个没有前驱的顶点并输出。" ID="4">
          <fptr EndPN="00000181" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）重复步骤1和2，直到AOV网中的所有顶点都被输出或者剩余顶点都有前驱。拓扑排序结束后，如果所有的顶点都被输出，那么说明网中没有环；如果有剩余顶点，而且这些顶点都有前驱，那么说明AOV网中存在有向环路。图6.b.1拓扑排序的结果为：可以直接从该堆栈获取，这祥每次查找人度为零的顶点就不用搜遍整个表头结点数组。该堆‘Uar.rrer曰＿s条11rc理纷xr：siFbErrrr声.邓接表表头结点数组的新定义如下：" ID="5">
          <fptr EndPN="00000182" StartPN="00000181"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstructlintindegree:.head;" ID="6">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="AdjList;" ID="7">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="typcdefstruct{AdjList*head1ist;intvertex一”urn;11顶点数intCdge_nnm:在建立邻接表之后，可以采用下面的算法计算1CICCgCCC域：甚丁邻技表表示的有向图计约入度的算法11hli?f人，l；的丫1C1！-人h;的" ID="8">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="vcarlC.rlnJcJccl:Jltraphd.g)" ID="9">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="{irrt=tcm(r，几tr:.、d)卜‘xlc+p;砚cmp=nrwint(g.vcncx_nurnmr:nr.cuhtnp,Q,sicroP(intgvenex_numlorU城l;i·g.vcrlcx_num;rj{p二r.hcad_hst(t1.head:whilrlp)" ID="10">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="(tcmp(p一了·anuthcc_rcrlcx卜一；" ID="11">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="1P一户nexl;}1tiK一（i二琴二rrtr、＿num:i卜＋、" ID="12">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="瑟hC7t1＿1r‘I(IU1dC夕R`e-lCI[Iplldcl。公11t.1，：拓扑排序的算法实现如下：墓于邻接表农示的有向图的拓扑排序算法，l,t丁邻接农丧示的有向图的拓扑排序开法、uid'fopSo八（.4d)Graphg)" ID="13">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="(intstzck(1i:\IWG人11,wp;" ID="14">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="uui..nundta" ID="15">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="Adjlrxlcrp" ID="16">
          <fptr EndPN="00000182" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="1nP-1）r(i一。:igvcrtcznunriUf!uf1人座/It的4x点人f(t(q.h;tJ＿1ist!iinJegtcr二" ID="17">
          <fptr EndPN="00000183" StartPN="00000182"/>
        </Paragraph>
        <Paragraph CONTEXT="cl.（飞叩］" ID="18">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="vhtle(top，二l" ID="19">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="stacltcrP" ID="20">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="，！卜－" ID="21">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="iumhcr" ID="22">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT=":out«" ID="23">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="〕二9卜。1＿1、、tl砚I.head:" ID="24">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="uhile(p)" ID="25">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="【J=P&gt;another_vcrtcz;" ID="26">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="g_hcaJhat(s)mdcgrec一屯氏！乡hcad＿1。、屯IJI.‘t、山咨cc）、top;tac6(wpl一：" ID="27">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="28">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="p二‘&gt;&gt;nczt," ID="29">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="t" ID="30">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="f!number&lt;9.vCrtcLnurn)" ID="31">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
        <Paragraph CONTEXT="。以（了州含有t.1路’." ID="32">
          <fptr EndPN="00000183" StartPN="00000183"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000183" TITLE="6.7  关键路径" TYPE="Chapter">
      <fptr LogicalPageNum="183" PhysicalPageNum="183"/>
        <div ORDERLABEL="00000183" TITLE="6.7.1  AOE的概念" TYPE="Chapter">
        <fptr LogicalPageNum="183" PhysicalPageNum="183"/>
        <Paragraph CONTEXT="很多工程在实施的过程中，需要对工程的进度进行管理，要保证工程按期完工，甚至提前完工，如果工程进度出现了滞后，如何才能尽可能加快进度呢？这里介绍的AOE网，可以解决这些问题。一个有向无环图，让边表示活动，顶点表示事件，边的权表示活动的持续时间，这样的图就称为边表示活动的网（activityonedge)，简称AOE网。因为工程只可能有一个开始点和一个结束点（不能有环），所以AQE网只有一个人度为Q在这个网中，任务a2的持续时间为9.只有当任务aZ完成以后，事件V：才可能发生；只有务a;和a：都完成以后，事件VS才可能发生。接下来，要做的主要有两件事情：求出整个当任务为和a：都完成以后，事件vs才可能发生。工程的最短完工时间，找出会影响整个工程进度的关键路径。" ID="1">
          <fptr EndPN="00000184" StartPN="00000183"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000184" TITLE="6.7.2  关键路径的概念" TYPE="Chapter">
        <fptr LogicalPageNum="184" PhysicalPageNum="184"/>
        <Paragraph CONTEXT="（1）工程的最短完工时间：由于在工程进行的过程中有些活动是可以同时开展的，所以工程的最短完工时间是指从源点到汇点的最长路径长度。" ID="1">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（2）事件的最早发生时间：从源点到事件v，的最长路径长度，称为事件v、的最早发生时间，用ve（1）表示。" ID="2">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）事件的最迟发生时间：在不影响工程进度的情况下，事件V；最迟应该发生的时间，用vl（i）表示。" ID="3">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（4）活动的最早开工时间：在不影响工程进度的情况下，活动人的最早开工时间，用e（i）表示。" ID="4">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）活动的最迟开工时间：在不影响工程进度的情况下，活动钩最迟应该开工的时间，用1（1）表示。" ID="5">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（6）活动的时间缓冲量：活动ai最迟应该开工的时间一活动姚的最早开工时间。" ID="6">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（7）关键路径：从源点到汇点，路径长度最长的路径。" ID="7">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="（5）关键活动：关键路径上的活动。它的特点是.最早开工时间等于最迟开工时间。" ID="8">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000184" TITLE="6.7.3  关键路径的算法" TYPE="Chapter">
        <fptr LogicalPageNum="184" PhysicalPageNum="184"/>
        <Paragraph CONTEXT="最早、最迟发生时间。事先，作一个约定：活动衡用弧＜j，k＞表示，对应的权用w臼，劝表示。e（1）＝ve石）1（1）＝vl（k）一we，k）根据这两个公式就可以求活动的最早、最迟开工时间。先求事件的最早发生时间，计算公式如下：ve巧）“ax｛ve（k）＋侧kj）卜J＝1，2，…，n-1其中k表示以vj为弧头的所有弧的尾，并且已知ve（0卜0，利用该公式可以求出各事件的最早" ID="1">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="发生时间。" ID="2">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="对于汇点来说，它的最早发生时间等于最迟发生时间。按照下面的公式可以倒推出各事" ID="3">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="件的最迟发生时间：" ID="4">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="vl勺）＝min｛vl（k）一tU，k〕｝，j＝n-2，一，2，1" ID="5">
          <fptr EndPN="00000184" StartPN="00000184"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(2}w17" ID="6">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(310" ID="7">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(422" ID="8">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(534" ID="9">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(b)＝42" ID="10">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(741" ID="11">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve{8)料0" ID="12">
          <fptr EndPN="00000185" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="ve(958图b.7.1中，各顶点的最迟发生时间依次为：vl(9ve(958vl(8v1(9）一18=44vI(7v1(914=48Y1(5Y1(9）一1b=42vl{Smin{vl(612,v1(711min{34,37｝二30v1(4v1(8）一18=22vl{3vl{520=14vl{2vI(5）一9=21vl(1vl(2）一9=12vl(0min[vl(1）一8,v1(3）一14,v1(422}相应地，各活动的最早开工和最迟开工时间如下：e（1），vc（0）＝01（1）＝vl（1）一8e(2ve(181(2v1(2）一二12e(3Ye{2171(3v1{5)一＝21e(4kvef5341(4v1{61234e(S1+e16)121f5)vl{16=42e(b)ve{04＿1(bv1(314d]e{7卜ve{31t).1(7v1r24=1Qe(8ve{S）二30i(8v1{7）一11二3?e(9ve(741i(9）二vl(91asse(14vef01=0if14v1(41-22＝0e(11卜ve(4221(11v1{818=22绒1-21业e84(l＿k立2v1(9》一I8＝41如果一个括动的最早开始时间与最迟开始时间相等，那么它就是关键活动。可以看到，活动a4,as,、,a，ao，aii，as：的最早开工和最迟开工时间是相等的，它们都是（活动。这些活动分布在两条关键路径上：序的相反顺序来计算各事件的最迟发生时间，下面给出计算各事件的最早发生时间、最迟发生时间的算法实现。从丁c1ie示的,roc[的拓t卜排F3il.int。CSTACK.C?OP;f放！：扑N列的伐utt.vc,＊vl:voidCnucalPa吸h(Adj[irnphg)｛.，们j；Ad)Kcxlc‘p:" ID="13">
          <fptr EndPN="00000186" StartPN="00000185"/>
        </Paragraph>
        <Paragraph CONTEXT="CTOP二～l;CSTACK二newint[g.vcrtcx_nwnve=newtnt[9.vertex_numVI二newto咤1容.vortc又＿num】；memcet(vr,0,si，eof(intg.rrrrtrx_nwn'iopSort(gIrk6事f#的ft;tr'r时fur(i二0屯1＜9、cftc人＿num：1什lv1[t］一veJg.vcnex_num-l:whilefC'I'OP:＝O)II求cJ‘f-r的rrx迟1，时i](i-CSI人（了K【CTOP】；C:TnP一：p=g.hcacl_lisr[iI.hrad:whcle(p)" ID="14">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="lj-P一》.uwtlwrvertex:" ID="15">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="tf[vl[tJ&gt;(vIV！一p&gt;info" ID="16">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="vllix'111卜p一）rota:" ID="17">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="p二p&gt;ncxt;" ID="18">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="｝】for（卜0;i‘g.vcrtc、＿num;i二）声脑出经：果coin«vc[i]«aI[tccndl:】" ID="19">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="w，idTopScxt(AdCraphg)1inlstack[MAall911,top;" ID="20">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="intij,numhrr:" ID="21">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="AdjKcxle*p;" ID="22">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="top-1;numher‘0.for(i;i&lt;.vcncx-nu‘二ir1/把所有人1为。的顶点入钱rf(g.hcad_list[iindeglee＝二0)[wp" ID="23">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="stack[topJ=i;" ID="24">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="25">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="while(tap0)" ID="26">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="{i=clack[topJ;" ID="27">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="top" ID="28">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="number" ID="29">
          <fptr EndPN="00000186" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="-176CSI人CK【＋＋CI01，1＝：；jl保存犷f：护卜1！夕1P‘名.h亡ad＿11、tlljhcdd；，h，1op）11求齐件rJf1i、-1‘l1'tlIJ°P一）;inunc亡r_rcrtcx,rf(vclll‘&lt;«Ii1＋P一＞&gt;inG，))vcIJI犷vc！11＋卜，：nlP=P一，‘rltYI;" ID="30">
          <fptr EndPN="00000187" StartPN="00000186"/>
        </Paragraph>
        <Paragraph CONTEXT="Ip“bIrrJd_list(iJ.head:while(p)JP一）anrnher_vertcx;ghead_IistUJ.indegreeifg.hcad1isl(j]indcl犷cc;(tup" ID="31">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="stackItup)一：" ID="32">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一，next:rfinumhcrcg.、crtrt_num)CUUi«&quot;（中X有环”：）" ID="33">
          <fptr EndPN="00000187" StartPN="00000187"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000187" TITLE="习题六" TYPE="Chapter">
      <fptr LogicalPageNum="187" PhysicalPageNum="187"/>
      <Paragraph CONTEXT="1.写出下列各图的：（1)每个顶点的人度和出度；(2}图的邻接矩阵；(3)图的邻接表；(4)图的逆邻接表；(3）图的强连通分量。" ID="1">
        <fptr EndPN="00000187" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="令图6-习1图6-习2图6-习3编写一个程序，用于愉入数据建立图吞习2的逆邻接表。" ID="2">
        <fptr EndPN="00000187" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="证明：若无向图G的顶点度数的最刁讨直大于等于2,SG中存在一条回路。" ID="3">
        <fptr EndPN="00000187" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="有n个顶点的无向连通图至少有多少条边？有n个顶点的有向强连通图至少有多少条边？试举例说明。义" ID="4">
        <fptr EndPN="00000187" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="3.4." ID="5">
        <fptr EndPN="00000187" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="5.如果有向图采用邻接表作为存储结构，写出计算图中各顶点的人度的算法。" ID="6">
        <fptr EndPN="00000187" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="6.写出深度优先搜索和广度优先搜索的递归算法。l2）从顶点0出发进行广度优先搜索所得到的广度优先生成树。六城市的交通里程如下表所示.求出交通网的最小生成树。$Picture[00000188\00000188_new\0003.jpg]Picture$9.10.根据下面的ASE网求出关键路径的长度和至少一条关键路径。I1.求出图6一习5中顶点vo到其余各顶点的最短路径。" ID="7">
        <fptr EndPN="00000188" StartPN="00000187"/>
      </Paragraph>
      <Picture URL="00000188\00000188_new\0008.jpg">
        <fptr EndPN="00000188" StartPN="00000188"/>
      </Picture>
      <Picture URL="00000188\00000188_new\0009.jpg">
        <fptr EndPN="00000188" StartPN="00000188"/>
      </Picture>
      <Paragraph CONTEXT="·178" ID="8">
        <fptr EndPN="00000188" StartPN="00000188"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="在数据结构中，图比前面章节所讲述的的线性表、树等都更为复杂。而且，图这种数据结构在解决实际问题中也有着广泛的应用，比如说：当驱车旅游时，需要在众多路线中选择一条连线最短的情况下，连接多个节点。这些间题都可以通过本章所讲述的内容解决。" ID="1">
      <fptr EndPN="00000161" StartPN="00000161"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000189" TITLE="第七章  数组" TYPE="Chapter">
    <fptr LogicalPageNum="189" PhysicalPageNum="189"/>
      <div ORDERLABEL="00000189" TITLE="7.1  数组的定义" TYPE="Chapter">
      <fptr LogicalPageNum="189" PhysicalPageNum="189"/>
        <div ORDERLABEL="00000190" TITLE="7.1.1  数组的逻辑结构" TYPE="Chapter">
        <fptr LogicalPageNum="190" PhysicalPageNum="190"/>
        <Paragraph CONTEXT="对于一维数组，由于其和线性表的关系，其逻辑结构与线性表相同，在此不再赘述。对于如下所示的二维数组：alla12alj-l81jal,j+1at，b181b,azlazz‘一azj-1azjawla2,b：一1aze,1：：：｝111：at.lai-1Zals-1ai-ljai-lj+l”’ai-I.b,一］aI,bsallaizaw-laila;j+1aib-18ib_ai+1,1ai+l,2’ai+lj-1ai+1jai+lj…ai+l,b：一18i+l,b,1！！1：1！1：ab-l,lab；一l.y”’abi-l.j-1ab：一飞.jeb，一1.1+1abf-1.D2-3ablb_abI]ab`2abi.j-18b，jabi,j+1abi.b：一1ab］b,其中任意一个元素肠与其他元素之间的关系视它下标的取值而有所不同：" ID="1">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="abja当i二b,，j二b2时，abib：在行的方向上有一个直接前驱Sb二b：一：，在列的方向上有一个直接前驱a。一，,b,当1=1,2.二jib二1时，a1j在行的方向上有一个直接前驱$1J-：和一个直接后继alp+，在列的方向上有一个直接后继补勾，没有前驱。当i=b1，2崛j崛bZ-l时，abij在行的方向上有一个直接前驱abi,i二和一个直接后继、j+S在列的方向上有一个直接前驱丸.刁j，没有后继。当El暇b-1。J=1时sai：在列的方向上有一个直接前驱ai-l,l和一个直接后继在行的方向上只有一个直接后继气十：，没有前驱。当2si‘b-l,jb时，a,：在列的方向上有一个直接前驱ai一：,b：和一个直接后继ai+1,6,,在行的方向上只有一个直接前驱气b：一：，没有后继。由此可见，二维数组中的元素最多可以有Z个直接前驱和2个直接后继。同样，三维数组中的元素最多可以有3个直接前驱和3个直接后继。推而广之：n维数组中的元素最多可以有n个直接前驱和n个直接后继。综上所述，数组的确是一个非线性结构，但由于在通常情况下，数组的维数以及各维的上" ID="2">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="界和下界是固定的，即：数组的规模是固定的，加上数组与线性表有着密切的关系，所以，数组" ID="3">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="的处理与其他复杂的结构相比并不复杂，对数组的基本运算没有插人和删除，因此，除了数组" ID="4">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="的创建和撤消运算外，对数组一般只讨论以下两种运算：" ID="5">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）给定一组有定义的下标，存取相应的数组元素；" ID="6">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）给定一组有定义的下标，修改相应的数组元素的值。" ID="7">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000191" TITLE="7.1.2  数组的抽象数据类型" TYPE="Chapter">
        <fptr LogicalPageNum="191" PhysicalPageNum="191"/>
        <Paragraph CONTEXT="素i的直接后继。" ID="1">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="ChangeValue{cA,e,j1,j2，二‘，jn)" ID="2">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="改为e的值。jl,j2,…,jn有定义" ID="3">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="撤消已创建的数组ADestroyAcrayA}1" ID="4">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="数组是一种数据结构。要特别指出的是，这里所说的数组与高级语言中数组的概念不同：高级语言中的数组指的是一种数据类型，映射的是一组连续的存储单元，是存储结构范畴的概念；而这里的数组则是数据结构范畴的概念，它包括了逻辑结构、存储结构以及其运算的表示和实现等内容。数组这种数据结构，其元索是由一个值和一组下标组成，即：数组是“下标一值”偶对的集合。在数组中，数组元素的下标与值是一一对应的，即：对于一组有定义的下标，都存在一个" ID="1">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="与其相对应的值，这种下标与值的对应关系乃是数组结构的特点。根据下标的个数，数组可分为一维数组、二维数组、三维数组……依此类推。比如，对于数组A:" ID="2">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="若AairIj1，2，，bl,b1是j：的长度，J。是ai.的下标，si：是与j，对应的某种数据" ID="3">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="Pali`8b：1alb=alb=alb:822823叫以区砰有：'4b，_{{a]1a12813Slb_{a21a22a23a2b_}，一（abilSbiyab13,ab.b,}}还可以这样看：Ab__（{alla21abil{a12a22ablz)，(a13&amp;二…abi3，一（alb`a2b18b'b_即每一列为一个一维数组，并视为A的一个元素。同样，一个三维数组可以用其元素为二维数组的数组来定义，以此类推，就可以得到n维数组的递归定义。前面我们讨论过线性表（el。…c。），从上面对数组的定义看，线性表（{el勿en）可L看做是一个一维数组；反过来，一维数组（(al,azabl）可以看做是定长的线性表。多维数组均可经由一维数组递归得到，由此可见，数组与线性表的关系非常密切，可以说数组是线性表的一个推广，而线性表是数组的一种特殊情况。从一般概念上，数组（一维除外）是一种非线性的数据结构，元素之间是“多对多”的关" ID="4">
        <fptr EndPN="00000190" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="系，但在通常情况下，数组的维数以及各维的上界和下界是固定的，因此，数组的处理与其他复杂的结构相比较为简单。下面，我们对数组的逻辑结构进行描述并给出数组的抽象数据类型定义。" ID="5">
        <fptr EndPN="00000190" StartPN="00000190"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000192" TITLE="7.2  数组的顺序表示及运算" TYPE="Chapter">
      <fptr LogicalPageNum="192" PhysicalPageNum="192"/>
        <div ORDERLABEL="00000192" TITLE="7.2.1  数组的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="192" PhysicalPageNum="192"/>
        <Paragraph CONTEXT="用一组连续的存储单元存储数组元素，称为数组的顺序存储结构。由于存储单元是一维" ID="1">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="：1a21a22a23’alb," ID="2">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="alZal3a器a刀" ID="3">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="A、lxbZab，Zao13根据在7.1中的讨论，数组A可以看成：" ID="4">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="A、1＝（（alla：Zal3…alb：），（aZ：翔劫…aZb：），一（a6、la、Zab.3…ab.、：））或" ID="5">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="A、2二（（al，aZ：…a），（a：2赴2…ao.2），（a，，a二…ab：3），…，（alb：a、、…ao.。：））两种一维数组。顺序存储Ab，或Ab：的元素，就有二维数组的两种顺序存储方式，即：以行为主的次序存储数组元素的方式和以列为主的次序存储数组元素的方式。" ID="6">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="1.以行为主的次序存储数组的元素按行为主的次序存储数组A的存储结构示意如图7.2.1所示。其中：1i崛b，1j_bz。可见，只要给出二维数组A中任一元素的一组下标（(i,j)，就可很快计算出相应元素的存储位置。推广到三维数组。根据在7.1中讨论的关于三维数组与二维数组之间的关系.对于三维数组Abi，b_*b，可以看成是有b，个元素，每个元素是bZxb，二维数组的一维数组。假设三维数组A的第一个元素all，在存储单元中的地址为Loql，1，11.数组的每个元素占L个字节.则第1个二维数组的第一个元素aj，1在存储单元中的地址为Loql，1，lj邢一1）二bZ、b3、L，因为，在该元素之前，有（卜1）个bZ、玩的二兰佳数组。根据翔1，的地址及二维数组元素地址的计算公式（7-1）就可得到三维数组Ab.、bJ中任意元素峋k的地址LOc（内。的计算公式（7－2）：LOC［i，j，k］＝LOC〔1，1.1］＋［6-1）、bZ欠场蜀一1）xb3＋k－－l］xL（742）其中：1‘1《b：，1司燕玩，1《k共场。" ID="7">
          <fptr EndPN="00000193" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="实际上，总结对三维数组的推广，从所存储的元素下标的排列规律可以看出，所谓“按行" ID="8">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="L以二口；，jZ，…，jn］＝LOC［1，1，…，1］＋［灯，一1）xbZ“b3、…Xb。" ID="9">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="＋Q卜1-1）xb。" ID="10">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="＋0。一1）］xL" ID="11">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="可将此公式缩写成：n" ID="12">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="Loco1，jZ，一j以·LOC［…，，1＋Zc心厂‘）（7－3）其中：味＝L，ci－：＝bixc；（2岌1鉴n）a" ID="13">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="2.以列为主的次序存储数组的元素个元索占L个字节，则二维数组A中任一元素&amp;i的存储地址LOC[i,j]可由如下公式确定：其中：li毛b：，I续j‘bz。同样，只要给出二维数组A中任一元素的一组下标（{i,j)，就可“按行为主的次序存储数组的元素”规律的总结，可以得出，所谓‘.按列为主的次序”存储的元素下标的排列规律是先排最左的下标，从左向右，最后‘目一crss.rtrtnginr.卜aw.ia‘atiM[r.习c_子伏井1比dfi二二rrfeFrLrk.3Lrrnrrtilt排最右的下标。" ID="14">
          <fptr EndPN="00000194" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="算公式为：LOC[i,j,k]二LaC[1,1,1k-1)xblxbzj-1)xbl+i-11xL(7-S)且。假设”维数组Ab‘xbxb，的第一个元素aj，(n个1）的存储单进一步推广到n维数组。J二1)xb" ID="15">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="血LCCfJi,jz&gt;'二，j。＝Loc［一‘1-ciCi1)(7-6;其中：cl＝L，ci＝b卜lxc卜1（2续1簇n）。通过上述讨论可以看出，不论以行为主序的存储结构还是以列为主序的存储结构，仍具有随机性，因为数组元素的存储地址是其下标的线性函数，一旦确定了数组的各维的长度，公式(7-3）和（7-6）中的c，就是常数。由于计算数组各个元素地址的时间是相等的，所以存取数组中任一元素的时间也相等，这正是随机存储结构的特点。" ID="16">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000194" TITLE="7.2.2  数组顺序存储结构描述" TYPE="Chapter">
        <fptr LogicalPageNum="194" PhysicalPageNum="194"/>
        <Paragraph CONTEXT="所讨论的是以行为主序的顺序存储结构。其中，elem用来表示动态的一维数组类型的空间，是有blbz、一、b,个元素、元素类型为EType的一维数组类型，用来存放数组A的元素;dim存放数组A的维数；bound：也是用来表示动态的一维数组类型，是有n个元素、元素类型为iat的一维数组类型，用来存放数组A各维的维界。相对于此结构的类型用ARRAY表示，其描述如下：typeaef(ETyperelem;11通过创建获得相应空间intdim;int+botsnds;11通过创建获得相应空间.…，.+j¢2xA.bouads[n-i]" ID="1">
          <fptr EndPN="00000195" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="+jn-" ID="2">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="这里，0毛jj（U3-1,4共i簇n-lo" ID="3">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="A.elera+jaxA.b4u11dS[11xA.baunds[21x…xA.bounds「二11" ID="4">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="+jlxA.bounds[21xA,bounds[31x…xA.bounds[n-l]" ID="5">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="+jZxA.baunds[31xA.boands[41x-二xA.bounds[n-11例如，数组Az。如下所示：(l23A川^t456/5其中，A的元素角闰＝1，aol＝2，角呱＝3，al产，all＝5，al娜。" ID="6">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000196" TITLE="7.2.3  数组顺序存储结构下的操作" TYPE="Chapter">
        <fptr LogicalPageNum="196" PhysicalPageNum="196"/>
        <Paragraph CONTEXT="1.创建维数为n的数组A数组A每维的长度为bl,b2.&quot;.13a该操作的毛要工作是获得数组A的元素及数组A的创这维数为n的·组A的算法（CrcatAmar)vmdCrcwtArray(ARRAYBcA,insn,intbo,tntb[1)[1/h二b.·…饥存放在教组b‘1，" ID="1">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="Adin，二n;t二1二hlr1i-0:irA.dim;it-t+b[i;1.clcm-nCwL:Typc[tJ:A-bound、一newutl[A.dim" ID="2">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="2.在ttiE教组A中读取下标为j。，12.·…jn的元素的依到e中在ni组A中读取下标为.JiJr····的元人的值到c中X法（Get、uluc)vn+d(iclValudARRAYA.F&quot;1'少ptRc,entj[1)" ID="3">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="1：ldj：。·…j：存放在(sfl7中" ID="4">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="t！二八.elem.for一吸）:h:Aslim:ifI'°1111:fcu(j一：rlA.dim;什）口＝12，A.卜以，nd心］：" ID="5">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="tl二tl套t2:" ID="6">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="r二。tf;）" ID="7">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="3.将n维做组A中下标为j，.j，.·…j。的元素的值改为。的值将n维数组＾中下标为11:…i。的元衷的值改为改为t的值排法（hangc'aLte)、uKlhangeValuc(ARItA1'.A,FTypl;e,in[j[J)[nj二」Jfflifail[j‘" ID="8">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="吐几1.clcm-" ID="9">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="for（1习；1‘人.o1.m；1月斗）" ID="10">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="11">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="for(j-i-1：j＜A.d.m；j什）" ID="12">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="Q-tZ＊A.b‘，und、日1：" ID="13">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="tl二tlt" ID="14">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="1.日二‘1" ID="15">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="4.撤消已创建的数组A" ID="16">
          <fptr EndPN="00000196" StartPN="00000196"/>
        </Paragraph>
        <Paragraph CONTEXT="{D二troyArray）的算法请读者自己写出。" ID="17">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000197" TITLE="7.3  矩阵的存储及操作" TYPE="Chapter">
      <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
        <div ORDERLABEL="00000197" TITLE="7.3.1  矩阵的定义及操作" TYPE="Chapter">
        <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
        <Paragraph CONTEXT="矩阵是很多科学与工程计算问题中研究的数学对象，一个具有m行a列的矩阵是一个m行。列的二维表，这种矩阵有mxn个元素。若m=n，则称该矩阵为n阶方阵。在这里，我们并不讨论矩阵本身的间题，而是讨论在计算机中如何表示矩阵，以便对矩阵进行有效的操作。从前面的讨论可以看出，矩阵是与数组有同样结构的数据。站在数据结构的角度，m。的矩阵可与二维数组这种数据结构相对应，即：矩阵的逻辑结构与二维数组的逻辑结构相同。在数学问题中，对矩阵有多种操作，这里只列出矩阵的转置和矩阵相加操作。" ID="1">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000197" TITLE="7.3.2  矩阵的顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
        <Paragraph CONTEXT="在7.3.1中指出，矩阵的逻辑结构与二维数组的逻辑结构相同，那么，矩阵的顺序存储结构，包括矩阵元素存储时在存储空间中的排列次序问题、存储结构图和结构描述等，就与在7.2中所讨论的基本相同.这里不再赘述。对矩阵采用顺序存储方式，可以随机地访问矩阵中的每一个元素，因而能够较为容易地实现对矩阵的各种操作。然而，这种存储方式所占空间的大小与矩阵的规模相关.在矩阵的实际应用中，经常会遇到这样一些矩阵，它们的规模比较大，即阶如反高，但矩阵中有许多值相同的元素或值为0的元素。L匕如，对15x15的矩阵，若有LO个元素的值非零,215个元素的值是0，若仍然采用这种顺序存储方式，则在存放矩阵元素的225个存储空间中，就有215个单元存放的是0，即：浪费了很多存储空间来存放实际上可以不必存放的元素。因此，针对矩阵的这种情况，应该采用另外的方法对矩阵进行存储，这就是压缩存储的方法。所谓压缩存储就是为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。例如，对上述15xI5的矩阵只需设法给这1Q个非零元素分配存储空间就可以了。" ID="1">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000197" TITLE="7.3.3  特殊矩阵的压缩存储及操作" TYPE="Chapter">
        <fptr LogicalPageNum="197" PhysicalPageNum="197"/>
        <Paragraph CONTEXT="特殊矩阵是指有许多值相同的元素或值为零的元素在矩阵中的分布有一定规律的矩阵。" ID="1">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="对称矩阵、三角矩阵和三对角矩阵等都属于特殊矩阵。" ID="2">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="aid=aji(l感i《n,1‘j‘n)" ID="3">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="则称A为对称矩阵。" ID="4">
          <fptr EndPN="00000197" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="a0，当且仅当i＜j（1戴落。，1司亥n）若有一个n阶矩阵A中的元素满足下列性质则称A为三对角矩阵门图7.3.1是4种4阶特殊矩阵的例子。I2420230002723697II01484560006359481！0039789100040782(a)三对角矩阵（b）下三角矩阵（c）上三角矩阵（d）对称矩阵图7.3.14种4阶特殊炬阵示例下面讨论对称矩阵的压缩存储方法。n阶对称矩阵中，除对角线以外都是一对一对的对称元素，根据前面谈到的压缩存储的思想，存储这样的对称矩阵只需为每一对对称元素分配一个单元即可，这样，n阶对称矩阵的n2个元素就只需n(n+1)12个元索的空间。通常，采用以行为田eVARllifeTUrY丰YnRl.1h寸;fZslGtr41愉fiP.t良7艘ifi米H1''斤吹公!1{c、门J限万eTrrry" ID="5">
          <fptr EndPN="00000198" StartPN="00000197"/>
        </Paragraph>
        <Paragraph CONTEXT="的类型描述。对于n阶对称矩阵A，其压缩顺序存储结构如图7.3.2所示。其中，elem用来表示动态的一维数组类型的空间.是有xt(n+1)12个元素、元素类型为EType的一维数组类X41，用来存放矩" ID="6">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="阵A的下三角的元素（包括对角线上的元素）)abounds用来存放矩阵A的维界。相对于此结构的类]用SYMMATRIX表示，其描述如下：01n(n+ly2-1" ID="7">
          <fptr EndPN="00000198" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct王Elope»elem;通过创建获得相应空间baancls巨二］!7334阶对称矩阵压缩顺序存储状态图7.3.1(d）中的元素a与A.elem[33-1N2+2-11(iy7,pA.elem[41相对应.其值为90图7.3.1中（d）中的元素aaz与A.elem[33-1)12+2-11c3，即A.elrrn[41相对应，其值为9," ID="8">
          <fptr EndPN="00000199" StartPN="00000198"/>
        </Paragraph>
        <Paragraph CONTEXT="矩阵的压缩存储。总之，对特殊矩阵的压缩存储就是将二维结构的数据用一维数组类型空间" ID="9">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
        <Paragraph CONTEXT="下面给出对称矩阵在上述压缩顺序存储结构下相加操作的算法。设A和B均为n阶对称矩阵，则矩阵C=A-f-B也是n阶对称矩阵，即：clc1(c与，为C的任意元素，li‘n,1cj&gt;sn)且i=ii。这里，A,B,C均采用s'uluVy;类型结构。因此只用将AtiB中包括主对角线在内的下三角元素相加即可求得矩阵C。具体算法如下：称矩阵在压绍顺序存储精构下扣加滋作加决NatnxfSY、1tATRIXS1MY1,YfR1?FSY111" ID="10">
          <fptr EndPN="00000199" StartPN="00000199"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000199" TITLE="7.3.4  稀疏矩阵的压缩存储及操作" TYPE="Chapter">
        <fptr LogicalPageNum="199" PhysicalPageNum="199"/>
        <Paragraph CONTEXT="如何对稀疏矩阵进行压缩存储呢？根据压缩存储的基本思想，对稀疏矩阵只用存储其中的非零元素，对零元素则不分配存储空间。由于在稀疏矩阵中非零元素的分布没有规律，为了保持非零元素在矩阵中的逻辑关系不变，为了便于实现矩阵的各种运算，在存储其中的非零元素时，除了存储非零元素的值外，还要同时存储该元素在矩阵中的行和列的位置。因此，对于稀疏矩阵，首先要用一个称为三元组的表将其中的所有非零元表示出来，然后，用相应的存储" ID="1">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="方法将此三元组表存储起来，实现对稀疏矩阵的压缩存储。" ID="2">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="l.三元组表若A是一个稀疏矩阵，有t个非零元素，肠是其中的一个非零元素，则（(ia;）是表示该" ID="3">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="：元素的一个三元组。t个这样的三元组按一定的次序构成的线性表.就是三元组表。这里" ID="4">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="非零元素的一个三元组。" ID="5">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="的次序指的是按行为主的次序和按列为主的次序。" ID="6">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，稀疏矩阵Aa.。如下所示：" ID="7">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Picture URL="00000200\00000200_new\0013.jpg">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Picture>
        <Paragraph CONTEXT="TripleList1,4,3(1,7,2(2,2,5(2.5,8(2,8,4" ID="8">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="(3,3,7(3,6,1(4,2,6" ID="9">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="TripleList=2,2,5(2,4,6(3,3,7(4,i,3(5,2,8(6,3,1(7,1,2(8,2,4三元组表中的每一个元素是一个三元组。所谓按行为主的次序就是在三元组表中，先排第一行非零元的三元组，再排第二行非零元" ID="10">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="的三元组，接着排第三行非零元的三元组……以此类推。按列为主的次序就是在三元组表中，" ID="11">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="先排第一列非零元的三元组，再排第二列非零元的三元组，接着排第三列非零元的三元组……以此类推。" ID="12">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="在以下的讨论中，采用其按行为主的三元组表。有了三元组表，对稀疏矩阵的压缩存储问题实质上就转化成对相应三元组表的存储问题。对三元组表的存储方法有两类：一类黝匾序的存储方法；另一类是链式的存储方法。" ID="13">
          <fptr EndPN="00000200" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="2.三元组顺序表Clemt-0一！I二习MsxSize-1Y‘一舟刹半旦一箕兰旱琴一’｛一刊｝口一1习" ID="14">
          <fptr EndPN="00000201" StartPN="00000200"/>
        </Paragraph>
        <Paragraph CONTEXT="MaxSizeI!rawcolvalue图7.3.4稀It矩阵压期JZ序存储结构―二元组顺序表相对于此结构的类型用TSMatri、表示，其描述如下：" ID="15">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="妞即曰d，肚ud" ID="16">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="17">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="imrow,coI;EIpevalue;}Triple;饥阎吐5位”以ITriplefelern;1li！过创建获得根应空间introws,cols;intMaxSrze;例如，上述a.。的稀疏矩阵用TSMatrix类型存储后的状态如图7.3.5所示。假设A的最大非零元个数为l0a0123456789产一，产一‘一、r一‘一、r－‘，产一一、尸一，矛－‘，尸“，" ID="18">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="｝1卜｝31卜卜卜｝’2三丁；i1Z卜卜卜卜卜3卜卜卜卜卜门］" ID="19">
          <fptr EndPN="00000201" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="向｝臀二L.一艺笠“咒下面以矩阵的转置为例，讨论用这种三元组顺序表来存储稀疏矩阵后如何实现对矩阵的操作。设A是有m行、n列且有t个非零元的稀疏矩阵，其转置矩阵B则是有n行、m列且也有t个非零元的稀疏矩阵，且aiab;(a和b;‘分别为A和B的任意元素，li城m,1‘j‘n)o若A用三元组顺序表表示，则B也应该是用三元组顺序表表示。为简化问题.我们就在" ID="20">
          <fptr EndPN="00000202" StartPN="00000201"/>
        </Paragraph>
        <Paragraph CONTEXT="rowcolvela已rowoolvaluerowcolvalue" ID="21">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="暴" ID="22">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="1｛14413I1｝2！2｛511" ID="23">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="2｝1i7｝2I2L_2二14｝6！2" ID="24">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="312｝2j5'3｝3｝3f7｝3" ID="25">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="4121518I4｝4I1｝3I" ID="26">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="5｝218｝4｝S！SI2I8！5" ID="27">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="6｝一！3｝7｝6｝6！31i16$Picture[00000202\00000202_new\0016.jpg]Picture$$Picture[00000202\00000202_new\0017.jpg]Picture$81＿.44216｛8｝8！.2｝4｛$图7,3.6(a)A.t:l二图73.6(b)B.eiem图73.6{c)Aekrn由A4一：求其转置矩阵BB,的过程实质上就是由LEI7.3.6(a)所示的三兀组表A.elem求得图7.3.6(b）所示的三元组表Belem的过程。从转置矩阵运算本身来看，对每个非零元而言.从A置换到B，只需将A.elem的第一列数与第二列那口寸换即可。但这样得到的三兀组表并不是[7.3.6(b示的三元组表，而是图7.3.6{c)lr示的三元组表Ae1em，显然，Aclem没有满足以行序为主序存放非零元的原则，还须按ro＊对Aelem进行升序排序，才能得到Belem。这种从A.elem得到Belem的方法是先转置,再进行调整，使转置矩阵的三元组表Belem中的元素按以行序为主序存放的原则到位。该方" ID="28">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="法的低效之处显然在调整上。这种方法的基本思想是以矩阵A的行序进行转置。" ID="29">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="能否直接得到以行序为主序存放的Belem呢？可以考虑这样的方法，其基本思想是以矩" ID="30">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="阵A的列序进行置换。具体做法是对于A的每一列cal，对A.cl。从第一行起整个进行扫描." ID="31">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="扫描中，当得到与当前col相等的三元组，将其转置到B.elem中由指针k所指出的位置上（k" ID="32">
          <fptr EndPN="00000202" StartPN="00000202"/>
        </Paragraph>
        <Paragraph CONTEXT="Cor(co】二t;wl＜二Acols:cd" ID="33">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="之ur（1＝1二1＜，A.记rl，1‘；.奋＋）" ID="34">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="if(A.clrml-1Jcol一l)" ID="35">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="36">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="37">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="J分析这个算法，其主要工作是在col和1的两重循环中完成的，所以，该算法的时间复杂度为O(A.colsxA.terms)。当稀疏矩阵A的非零元个数的量级为A.rowsxA.cols时.其时间复杂度就变为。(A.rawsx{A.cols)z）了（例如：假设34X10的炬阵中有IOQ个非零元)o我们知道，O(A.rowsxA.cals）是矩阵用二维数组类1，即非压缩的顺序存储结构存储时实现转置运算算法的时间复杂度，可见，压编存储虽然节省了存储空间，但时间复杂度却提高了，所以，上述算法只适合于稀疏矩阵的非零元个数远远小于稀琉矩阵的规模的情况。再进一步分析上述算法，其低效之处主要是每得到转置矩阵B的一行非零元（即矩阵A数），并由此推算出转置矩阵B每行的第一个非零元在B.eiem中的位置。然后对A.elem从头" ID="38">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="=1" ID="39">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="(7-8)" ID="40">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="2SrSB.raws{A.cols)" ID="41">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="n[r]021ii111" ID="42">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="pCrli13a5678" ID="43">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="该方法对应的算法如下：" ID="44">
          <fptr EndPN="00000203" StartPN="00000203"/>
        </Paragraph>
        <Paragraph CONTEXT="fx(r二2:r＜一H.roMr" ID="45">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="pir-tplrn(r一，I" ID="46">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="fur1Acrm，" ID="47">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="11士！满＾。Icm.完成转节" ID="48">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="tooldcui11才d：11取1，Aelem第：于万丫兀'S11rnlacrd" ID="49">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="hruup(acol(" ID="50">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="111仅,qc1C711{i1行‘ultil为acultil'nil1P.n在“.clan，的1'f;bruw" ID="51">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="了将＾尤Ic：几的行‘：兀31154?5it9H.clcm6}1;hrcxfr" ID="52">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="El.cicm(broN1roµ二Aelcm1J-col:" ID="53">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="Il.clcm(hrc、一Icol-A.dcm！卜1I.rl)N," ID="54">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="Bclc&lt;tn(brow-t、aloedcm(11.、aloe.PI.KY,I！一P（二VII:1CAI行下一个1卜yr元Ei.dcrn中的fF;" ID="55">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="56">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="在该算法中共有4个并列的循环，分别执行rows次、A.terms次、Brows-1次和A.terrns次。时间复杂度为OBOWS#A.termS当A,terms达到A.rawsxA.cols量级时，时间复杂度才上升到O(A.rowsXA.cols)，特别是当A.terms«A.rowsXA.cols时，此算法是很高效的。当然.该算" ID="57">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="法的高效是有一定代价的，因为算法中。用了两个辅助数组。" ID="58">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Paragraph CONTEXT="3.行逻辑健表从上面的讨论可以看到，在创建用三元组顺序表存储的稀疏矩阵时，要给出该矩阵可能有的最大非零元个数，但随着矩阵加减和乘操作的执行，非零元的个数将发生变化，也可能增加，也可能减少。当非零元的个数招讨预先估计的最大个数时，就会引发异常。当然，也可以在有关算法中增加对非零元个数发生变化时的判断，当出现非零元的个数超过预先估计的最大个消老空间。显然这种额外的工作将使有关算法的效率降低。另一方面，若在创建时对矩阵中还有，当非零元的位置发生变化时，要增加对三元组表的调整工作，同样会影响有关算法的效率。因此，三元组顺序表只适合非零元个数变化不大的稀疏矩阵。这里讨论的行逻辑链表是属于链式的存储方法，这种方法的基本思想是以行序为主序将稀疏矩阵的每一行非零元链接起来。具体实现可有多种方案，这里讨论一种带行指针数组的单链表表示方案。具体做法是：设立一个指针一维数组r,r(i］是指向第i行第一个非零元结点单链表表示方案。具体做法是：设立一个指针一维数组r，rli］是指向第1行第一个非零元结点的指针。非零元结点的结构有三个域v和next分别存放该结点对应的非零元所在的列、非零元的值和指向与该非零元在同一行的下一个非零元结点，使每一行非零元结点链接成一个单链表。由于每个非零元的行信息由该非零元对应的非零元结点所在单链表的头指针在数组" ID="59">
          <fptr EndPN="00000204" StartPN="00000204"/>
        </Paragraph>
        <Picture URL="00000205\00000205_new\0001.jpg">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Picture>
        <Paragraph CONTEXT="”厂刁" ID="60">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="termsI" ID="61">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="相对于此结构的类型用RI.SMatrix表示，其描述如下：intc;ETypev;" ID="62">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="Cnade»nexr" ID="63">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="}Goode;" ID="64">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefstruct" ID="65">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="t" ID="66">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="C冶阅err;刀通过创建获得相应空间" ID="67">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="intmws,coIs,ternas;" ID="68">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="}RLSMatrix;例如，稀疏矩阵抽沼如下：其按行为主的三元组表TripleList为：TripleList1,4,3(1,7,2(2,2,5{2,5,8(2,S,d(3,3,7(3,5,1(4,2,5用RALSMatrix类型存储后的状态如图7.3.8所示。图7.3.8" ID="69">
          <fptr EndPN="00000205" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="创建用上述带行指针数组的单链表表示的r行c列空稀疏矩阵A的算法如下：.195voidCrcatcRLSMatrixtt2LSMa.nx&amp;Aintr.unc)t" ID="70">
          <fptr EndPN="00000206" StartPN="00000205"/>
        </Paragraph>
        <Paragraph CONTEXT="、rows-r:Acols-c:A.tcrnu劝U:" ID="71">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="Ar=ncwCnodclA.rotssl:" ID="72">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="`Of{：二1＜二；：.＼rows二1‘＋）人减t-1tiULI" ID="73">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="；下面以矩阵的相加为例，讨论用这种带行指针数组的单链表来存储稀疏矩阵后，如何实现对矩阵的操作。设A是有m行、n列且有tl个非零元的稀疏矩阵，Y是有m行、n列且有t2个非零元的稀疏矩阵，CA+B也是有m行、n列的矩阵，且％4石+b（1i￡m,1cjten,c3和b'd是矩阵" ID="74">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="A、矩阵B和矩阵C的任意元素），但非零元的个数小于或等于tl+t2，只有当a护心或者b;1[1或者atj#。且bn0且ab.i时，c.的值才非。。当C的非零元个数超过（mxn)X0.3，就可认为。，1户曰二‘压了六片生二fib7用带行指针数组的单链表来存储稀疏矩阵A、稀疏矩阵B，对于矩阵C的存储结构可按下列思路进行选取：一是不论所求的C是否稀疏矩阵，一律采取和AFB相同的存储结构；二是如果事先能估算出所求的C不再是稀疏矩阵，则可选择用二维数组类型表示C。这里采用第一种方案。例如，稀疏矩阵A带行指针数组的单链表如图7.3.8所示，稀流矩阵B带行指针数组的单" ID="75">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="所求矩阵C创建后的状态如图7.3.10所示。" ID="76">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="在此状态下经过A+B运算后得到的矩阵C带行指针数组的单链表如图7.3.11所示。" ID="77">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="." ID="78">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="‘几卡｛小｝例5i：.’iii" ID="79">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Paragraph>
        <Picture URL="00000206\00000206_new\0029.jpg">
          <fptr EndPN="00000206" StartPN="00000206"/>
        </Picture>
        <Paragraph CONTEXT="图7-9稀琉矩阵$4&lt;：的带行指针数组的单链表r阶：队亚口桩口｝圃口colsg一七倪26尹37二卜G9工孙B4A，。国，一止惬五团图？.3.11炬阵CSA+B的带行指针数组的单链表当A,B和C已创建且经过拍人已建立稀疏矩阵A和稀疏矩阵B后，求矩阵C=A+B的过程实质上就是在矩阵C的创建状态下建立每一行单链表的过程，即：对于C的行指针数组的每一行C.r[i]，扫描A和B的相应行的链表.如果A和B的相应行的链表头指针A.r[i]和B.r[i]都为空，则c.rCI为空，结束本行的工作；否则，创建C本行的当前结点，A和B相应行的链表都从第一个结点开始。根据指向A和S相应行链表当前结点的指针的状态分以下三种情况处理C的当前行：{1)A和B当前M的指针都不为空，则分以下三种情况处理C的当前结点：QA和B相应行链表的当前结点的列号相等.则C本行的当前结点的列号取其中一个、值取两结点的值之和，A和B相应行链表当前给点的指针都同时指向下一个结点；QA相应行链表的当前结点的列号小于S相应行链表的当前结点的列号C本行的当前结点的列号取A的当前结点的列号、值取的A当前结点的值，A当前结点1指针指向下一个结点：前结点的列号取B的当前结点h号.4取的B当前结点的值刀当前结点的指针指向下一个" ID="80">
          <fptr EndPN="00000207" StartPN="00000206"/>
        </Paragraph>
        <Paragraph CONTEXT="结点；" ID="81">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="C的当前结点处理完毕后，存放C的非零元个数的单元要增加I，并且要为处理C本行中" ID="82">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="的下一个结点做准备。这时特别要注意第①'况，当两非零元的值相加的结果为0时，C的" ID="83">
          <fptr EndPN="00000207" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="当前结点就不用链接到相应链表中。1{1Akt1i:til!iity:i；的1连表夫士1金下t行‘.lj泛。结‘：德‘行处tl-ncsCntxleal-nextUL:C.巾.14二t吸；11'jll（’11:t1iviic的%r-Icr点eh.lc(〔p'-V1a.IRtfyNULLb二;tt5况处那c.的当116=si点tf(tVULL)(Il，ncwC'nude;ll:next-t\L'LLanext二tl" ID="84">
          <fptr EndPN="00000208" StartPN="00000207"/>
        </Paragraph>
        <Paragraph CONTEXT="tfrp·c=二q＞c〕1，夕石‘夕扣等｛tl&gt;c-p-mac:七卜》v-P4一》v:" ID="85">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="P二卜＞nex［：q川＞nexl：井cl、c1/4j不Qitffpc&lt;y一、）l/rcl!ld'ii点)列号小7'B当ljif结i的列兮(tl一＞c=pc;tIv=！卜，、;f'I'nextdsc当前结.）的列号大卜“当角经：点的列号{tl一＞。一。I一＞c;tI一》v一。I一。、:yy一：·nrrt7i川》一（1)（飞fIiil1j：X71个;irlilli1（12‘11；tl‘11一＞next:Clcrnu.几。nn、+l1dlp’二、UI.L)US1＾的村11戈结点" ID="86">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="f)O" ID="87">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="！11川二二\lLL)(ll二ncaCnoclc.tt一：·nctitUL.t？一，nCa[一七ItI&gt;c=p一＞c:t1一＞vr一：·v：p”1卜河1以t.t2成1;t1_tf一＞ncxt;C.tcrcns-C.1心m巧。1：）、h.1犷‘P卜、L’l.1.）；" ID="88">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="cheiffy！二、ULL)S,7备j1iJ?jl!Cidtda" ID="89">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="90">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="if(tl=KULL)(tl二ncaCnode;tI一＞ncxl＊KULL;t？一》next-tltI夕=y一＞&gt;c;t1一》、1一）v:y-y一之tk'xl:.，＿.色，.t_、····r····，一了＿＿＿＿＿.。" ID="91">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT=")ahilc(qVULL);" ID="92">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT=")l/if" ID="93">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="for(该算法的时间复杂度为U(C.rowsx{A.tenm二B.terms" ID="94">
          <fptr EndPN="00000208" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="4.十字链表十字链表也是属于链式的存储方法。在十字链表中，稀疏矩阵每一行的所有非零元用一表的头指针分别都用一维数组类型的空间存储，称作行头指针数组和列头指针数组。整个十在十字链表中表示非零元的结点由5个域组成，即：行域$Picture[00000209\00000209_new\0003.jpg]Picture$（row）、列域（col）植域（Yal二）、向下域〔down知向右域（h沙t）.如图7.3.12所示。相对于稀疏矩阵中的任意一州卜零元殉，tow域存放非零相对于稀疏矩阵中的任意一州卜零元殉，tow域存放非零图73.12十字链表的结点结构元、的行，即1值；。of域存放非零元甸的列.即j值；value域存" ID="95">
          <fptr EndPN="00000209" StartPN="00000208"/>
        </Paragraph>
        <Paragraph CONTEXT="放非零元甸的值；tignt域存放与非零元气同一行的下一个非零元结点的地址；down域存放与非零元鞠同一列的下一个非零元结点的地址。可见，存放非零元殉的结点既是第1行链表中$Picture[00000209\00000209_new\0011.jpg]Picture$例如，稀疏矩阵报，：如下：其按行为主的三元组表TriPle口st为：知加山st＝＝（（1，4，3），（1，7，2），（2，2，5），（2，5，5），（2，5，4），（3。3，7），（3，6，1），（4，2，6））用十字链表存储矩阵A的状态如图7.3.13所示。其中，row，、cols和ten.5分别存储稀疏矩阵的行数、列数和非零元的个数。r用来表示动态的一维数组类型空间，是有m。个元素、" ID="96">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="针。c也是用来表示动态的一维数组类型，是有col：个元素、元素类型为CL刀od。类型指针的" ID="97">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="一维数组类型用来存放指向列链表的第一个非零元结点的指针。CL刀ode类型结构如图7.3.13" ID="98">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="所示，用来存放稀疏矩阵的非零元。" ID="99">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="01234567" ID="100">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="片络" ID="101">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="甘一一今匡一应习口国国t0" ID="102">
          <fptr EndPN="00000209" StartPN="00000209"/>
        </Paragraph>
        <Paragraph CONTEXT="{introw,cal;ETypevaUie;sir¢ctvnode+rr'ight,tdown;ICL队xl峨typedefClnode*Wick,typedefstruct" ID="103">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="fHIink*c,sr;1li,过创建获4相应空间introws,cals,terms;}RCLSMatriz;入" ID="104">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="Arti，1‘入，" ID="105">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="入W1" ID="106">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="A.c[tIJ一入C下面以矩阵的相加为例，讨论用十字链表来存储稀疏矩阵后冲川可实现对矩阵的操作。例如，稀疏矩阵A的十字链表如图7.3.13所示，稀疏矩阵B的十字链表如图7.3.14所示，41234567" ID="107">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="愉气蕊" ID="108">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="日囚国口" ID="109">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="c" ID="110">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="r" ID="111">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="0" ID="112">
          <fptr EndPN="00000210" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="20I234567一耳沪敏" ID="113">
          <fptr EndPN="00000211" StartPN="00000210"/>
        </Paragraph>
        <Paragraph CONTEXT="’叮一黔.叱鹭霉cr求矩阵C二A+B的过程实质上就是在矩阵C的创建状态下建立每一行简单链表和每一列简单链表的过程，该过程可参照用带行指针数组的单辘表存储的稀疏矩阵相加运算的方法，在相应方法中只要在处理矩阵C的当前结点时，再加上列方向上的链接处理，其他问题的考虑和处理方法就和带行指针数组的单链表存储的稀琉矩阵相加运算的方法基本一致。字链表存储稀疏矩阵相加运算算法" ID="114">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT=".oidinsertclnoddRALSlatrix.CC.introH.二：colF.Typevalue){t=newCLnode;t一＞mu二row;t&gt;colcola&gt;value=value," ID="115">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="t一＞right二ivULItclown二Nul.L；刀准备新幼点P-C.r[row-1iffpNt;LL)whilc(p一、rightNULL)p=p一＞right:p)Nl；lrouTi的Ie}后·个LkNq-C.C[CO1）:if(q！二NULL)wMlc(qdownNULL)ql&gt;down;q指向;cd列的fi.4Kiciifcp二ILLC.r[mw-I]二t.elseIright二rrIY/71.链接)f7rJstd上if(q=Nlil.L)C.c(col-11=t;clxcq一》Down=t将结点链（到列链2上" ID="116">
          <fptr EndPN="00000211" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="C.tcrrns-（.tcrms-1;/1-1元个!iloidAJdS.Matrix(RLSwlatrixA.Ra1.S、latnxB,Rr1LSlatrut及1!CA，Z3｛AFliLi的川r.行(J7Lc大,r针rt力空，结束4、行tiwhilcpt:I.Iec(q，二为ULLJ)三仲怡况处3C的当前结点tfipcol=q一》。）l）1，川9川写！tCl(P-、、aluc甲y一、、aJucil)insatclno,lctiC.l卜，八，城pee）。日卜duc＋l之一valuePP－一g)tt:yl一，right:}else/lyr)S不等iC(pc&lt;q一沁）11＼当前结点的列小于日1fMiic点的列S'i(insertclncxlc(C,p，ruw,lrcnll卜＞vall，叮：P干一）rightd比从、当前结点的列移大｝8当前结点的夕」号}rnscrtclncxli,y一，row,yx'dysvalucq_q一，right;lwhiled(p：一NULL):Ir!+1Af3;1liJr，i" ID="117">
          <fptr EndPN="00000212" StartPN="00000211"/>
        </Paragraph>
        <Paragraph CONTEXT="do！inscrtclnoJc{C,p》row,pcolp一＞value声p=nght;" ID="118">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
        <Paragraph CONTEXT="lwh，le（p竺举LLL）；clcccfiy!uVUI.L)/IiiJB11;1#1应it,r" ID="119">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
        <Paragraph CONTEXT="clo眨tnscrtclncx)c(C.q&gt;tnw.y一＞cnlyvalueqq-yright:" ID="120">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
        <Paragraph CONTEXT="}wttilc(ilNULL" ID="121">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
        <Paragraph CONTEXT="l/hf" ID="122">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
        <Paragraph CONTEXT="1/1(cKI用十字链表存储的稀琉矩阵相加运算的算法如下：其中，intlertelaode(RAISMatri&gt;c&amp;C,introw,intcolEPypea1ue)算法完成在十字链表C中，行号为row、列号为col、值为vela。的结点，C的非零元个数加1的工作。AddSMatrix擂人行号为r。钾、列号为(IZLSMatrixA,RAL.MattYxB,EiAISMatlrrix&amp;C}法完成C^A+H的工作。A、B、C均用十字该算法的时间复杂度为O{C.rawsx(A.terms-B.tetms" ID="123">
          <fptr EndPN="00000212" StartPN="00000212"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000212" TITLE="习题七" TYPE="Chapter">
      <fptr LogicalPageNum="212" PhysicalPageNum="212"/>
      <Paragraph CONTEXT="l.已知二堆数组A[4[bl，其中每个元素占3个单元，并且A[0101的地址为1200。试求元素" ID="1">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="A[11[3)的存储越山企〔分别讨论以行为主和以列为主的方式进行存储时的结论）及该数组共" ID="2">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="3.设A是一个a阶上三角矩阵，将它按列序存储在一维数组b［。＊（叶1）121中，如果a[i][j]存放在b(k]中.给出求解k的计算公式。" ID="3">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="4.已知稀疏矩阵A如图7一习1所示，分别画出它的三元纫灰序表和十字链表。" ID="4">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="5.巳知稀疏矩阵M的三元组表顺序表如图7一习2所示，写出M的矩阵形式。加一" ID="5">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Picture URL="00000213\00000213_new\0010.jpg">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Picture>
      <Paragraph CONTEXT="01005" ID="6">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="ooo7o" ID="7">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="46000SD900I10nnnnn口、Size｝1200D00图7一习1图7一习2" ID="8">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="6.分析算法voidcrea。叮ay（ARR户y＆A，intn，intb［］角时间复杂度。" ID="9">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="7.写出撤消已创建的数组A的算法：DestroyA仃ay（A只R户万＆A）。。乍考申寸汗必尹东百防力：丁娘臼而良左催姑均（QV飞旧叨也TpfY、下怕铂坦柞的室翎健件" ID="10">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="8.写出对称矩阵在压缩顺序存储结构（SYMMArRIX）下相乘操作的实现算法。相乘的结果仍然用压缩顺序存储结构（SYMMAIRIK）存储。" ID="11">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="9.写出在三元组顺序存储结构下稀疏矩阵相加操作的实现算法。相加的结果仍然用三元组顺序存储结构存储。" ID="12">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="10，写出在带行指针数组的单链表存储结构下稀疏矩阵转置操作的实现算法。转置的结果仍" ID="13">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="00000214" TITLE="第八章  内部排序" TYPE="Chapter">
    <fptr LogicalPageNum="214" PhysicalPageNum="214"/>
      <div ORDERLABEL="00000214" TITLE="8.1  排序的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="214" PhysicalPageNum="214"/>
      <Paragraph CONTEXT="排序csorting把一个无序的数据元素序列整理成有规律的按排序关键字递增（或递减）排列的有序序列的过程。待排序的数据元素序列构成一个线性表，当这个线性表使用链式存储结构存储时，排序方法非常有限，一般只能采用类同8,3.1小节将要介绍的直接插人排序法，即顺序地把待书眸序列中的各个数据元素按其关键字大小直接插人到已排序序列的适当位置中。待排序的数据元素序列可以是任意的数据类型。例如，图8.1.1为某班学生考试情况表，" ID="1">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="表中每个学生的情况包括学号、姓名、三门课的考试成绩以及这三门课的平均成绩。" ID="2">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="国群共罄" ID="3">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="图8.1.1学生成绩表" ID="4">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="我们可用下面的结构体定义该问题的数据元素类型。" ID="5">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstrut[" ID="6">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="【" ID="7">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="mt1Vo;" ID="8">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="charName[201" ID="9">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="floatCPMark;floatDSMark;floatPGMark;据元素个数。在该结构体中，共有6个数据项：如果希望按学号对学生考试成绩表进行抖游.则数据元素r[i]的排序关键字是它的数据项r[iI.no；如果希望按考试的平均成绩对该表进行排以根据实际需要，选取其任一数据项作为排序关键字。在本章的讨论中，我们把数据无素称为记录，把具有n个记录的待排序序列表示为Rl,凡，&quot;rRe。把作为排序依据的记录的某个数据项称为排序关键字，简称为关键字或排序码，记录D.的排序关键字表示为Riey,Ri.key的数据类型表示为Keyyi，它可以是整型、实型、字符型等基本数据类型。" ID="10">
        <fptr EndPN="00000215" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="由于在讨论记录序列的排序时，我们只关心作为排序依据的关键字，所以，在本章各个算" ID="11">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="法的实现时，如不加以说明，均认为待排序的序列中，各记录的数据类型为如下的EType结构" ID="12">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="体类型。以下未作特别说明时，均认为Ke}Type为int类型o" ID="13">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="4ideEineMAXSI7E10011顺序表的最大长度" ID="14">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="卜八，州，‘福耐r户vTvna.if'1'胜翻爪电妙兰柑宁坐对吩教刑" ID="15">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="呢已.fintKeyTyP‘" ID="16">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="t刀辉def“tr’Uct" ID="17">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="｛K即TyPckey；刀关键字项班即已eletn；刀其他数据项班即已eletn；）R“泊川；姚间吐。网Ct｛R忱。记r［MAXS攻见＋1］；" ID="18">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000216" TITLE="8.2  待排序数据对象的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="216" PhysicalPageNum="216"/>
      <Paragraph CONTEXT="我们知道，排序的算法与待排序的数据的存储结构密切相关。通常待分类的数据在内存中有三种存储方法：" ID="1">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="1，顺序存储结构待分类的文件按自然顺序存储在一块连续的内存空间中。该文件也即是一个采用顺序存储的线性表。对这类文件，在排序过程中不但要进行关键字的比较，而且还要进行相关记录的移动。故而，排序的效率与比较次数和移动次数二者息息相关。" ID="2">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="2.链式存储结构待分类的记录作为一个链表的结点来存储。该文件即是一个采用链式存储的线性表。对此类文件，当进行关键字比较后，需要调整记录位置时，只需修改结点的指针，而无需移动记" ID="3">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="录。" ID="4">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="3.地址向量结构文件待分类的文件的记录存储在内存中，但它不一定是连续的，各记录的首地址按文件中记录的原有顺序依次存储在单独的连续存储空间（地址向量）中，如图(a)(b)图8.2.1地址向量存储示意图" ID="5">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000216" TITLE="8.3  插入排序" TYPE="Chapter">
      <fptr LogicalPageNum="216" PhysicalPageNum="216"/>
        <div ORDERLABEL="00000216" TITLE="8.3.1  直接插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="216" PhysicalPageNum="216"/>
        <Paragraph CONTEXT="的序列中。依次类推，对序列中的第I个记录Ri排序时，R。前面的1-I个记录已组成了有序序列R犷，R了，·…R“，将Rt.y依次与RYIkey,‘2kty…进行比较，找出一个合适的J(1c=ja=i-1)，使得RBI'.keys=RkeyRiccy，然后把记录A.，,Ri-I’全翎f7序地后移一个位置，将R放到J位置上，就完成了序列中第i个记录的插人排序。当完成了对序列中第n个记录R，的插人后，整个序列排序完毕。直接插人排序过程如图8.3.1所示。方括号口中为已排序的记录的关键字，键字表示它对应的记录后移了一个位置。初始关键字序列：[6514S78b26" ID="1">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="第二次排序：[48坠178626" ID="2">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="｝·第三次排P:f486578)b261第四次排f:[46$公业l26第五次排序：[4b8Z65781." ID="3">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="下划横线的关" ID="4">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="图83.1直接擂人排序" ID="5">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="在直接插人排序过程中，对其中一个记录的插入排序称为一次排序。直接插人排序是从" ID="6">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="第二个记录开始进行的，因此，长度为tl的记录序列需要进行n-1次排序才能完成整个序列的" ID="7">
          <fptr EndPN="00000217" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="排序。例如，在例8.1中，序列长度为b，所以fu.3要作S次排序。下面给出直接插人排序算法实现。法。下面分析直接插人算法的时间复杂度。我们分两种情况来考虑：在这种情况下，第二个for循环次数为零，因此在一次排序中，关键字的比较次数为1，记录的移动次数为2，即（tri+11移动次数二2(n-1)仆书比较次数二2曰(i+t)，一1n+22廿刁移掀熟艺（妇全减卜lxn＋4。上述两种情况是最好和最坏的两种极端情况。可以证明，原始序列越接近有序，该算法的" ID="8">
          <fptr EndPN="00000218" StartPN="00000217"/>
        </Paragraph>
        <Paragraph CONTEXT="效率也越高。如果原始序列中各记录的排列次序是随机的。关键字的期望比较次数和记录的" ID="9">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="期望移动次数均约为n2/4.因此，直接插人排序的时间复杂度为饰今。" ID="10">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000218" TITLE="8.3.2  折半插入排序" TYPE="Chapter">
        <fptr LogicalPageNum="218" PhysicalPageNum="218"/>
        <Paragraph CONTEXT="在此介绍另一种插人排序一折半插人排序。它的基本思想与直接插人排序法类似，其" ID="1">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="·位众月井三系拙擂人占的青冰卜吉注坛A到卜良月.愉亘对火希盖配通井名口云落片它台奋石口劲如龟石7户论启口云再" ID="2">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="区别仅在于寻找插人点的方法上。" ID="3">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="字，就说明应插人在中心位置后面；否则应擂入在中心位置的前面。不断重复上述步骤，直到" ID="4">
          <fptr EndPN="00000218" StartPN="00000218"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="5">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="6">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000219" TITLE="8.3.3  希尔排序" TYPE="Chapter">
        <fptr LogicalPageNum="219" PhysicalPageNum="219"/>
        <Paragraph CONTEXT="希尔（Shell）排序又称缩小增量排序，是D.L.Shell在1959年提出的一种排序方法。它的基本思想是：不断把待排序的记录分成若干个小组，对同一组内的记录进行排序，在分组时，始终保证当前组内的记录个数超过前面分组排序时组内的记录个数。" ID="1">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="希尔排序具体的作法是：先设置一个整数量dl，称之为增量，将待排序的记录序列中所有距离为d：的记录放在同一组中，例如，若d1=5,则记录R,.凡.Ru…放在同一组中，记录Rz," ID="2">
          <fptr EndPN="00000219" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="R,RiZ-·放在另一组中，如此类推；然后对各组内的记录分别进行排序，这样的一次分组排序过程称为一次封句字；再设置另一个新的增量山，使da&lt;d,，采用上述相同的方法继续进行第二次排序…如此进行下去，当最后一次排序时，设置的增量d1时，表明序列中全部记录放在了同一组内，该次排序结束时，整个序列的排序工作完成，在希尔排序的各次排序过程中，组内记录的刹句宇可以采用前面介绍的直接插人刹游法，也可采用其他合适的方法。例8.2设待排序的序列中有iz个记录，它们的关键字分别为65,34,25,87,12,38,5b,单可取dtdlZl初始关健字序列G53425$712385646E4779223GS3425871238564614779223七雄巷叁当引｝结果序列5G3414771223654625879238SC341477122365452587923$匕十书兰书书牛片目二！｝(b）第二次排序（c）第三次排序图83.Z希尔排序希尔排序算法（、hrll％。d）voidShcllSurt(SyLiu&amp;L,intdl[,intNumhcr)" ID="3">
          <fptr EndPN="00000220" StartPN="00000219"/>
        </Paragraph>
        <Paragraph CONTEXT="fu用希尔排序法对记ir[O]一；1，11排序.d力堆址位致组" ID="4">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="lunttxr1t1MLY个致.i=趁]内x111直接js,人" ID="5">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k,m,Spun:" ID="6">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="Rccordt;" ID="7">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="班凡丫（nl刃；m＜N.，mh件；n卜呻）" ID="8">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="《" ID="9">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="Span=dlm" ID="10">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="Far{kdl:k&lt;Sp:：n:k一）" ID="11">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="(" ID="12">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i-k；：＜L.Ltn肿一I;it=Span)" ID="13">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="14">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="1.1＿币、SPanl；" ID="15">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="J二：；" ID="16">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="whil(j18t&amp;kcy&lt;L.r(jI.key)" ID="17">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="(" ID="18">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="L.r十Span】二Lr(jJ;" ID="19">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="1－＝sp二.；" ID="20">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="盆" ID="21">
          <fptr EndPN="00000220" StartPN="00000220"/>
        </Paragraph>
        <Paragraph CONTEXT="】" ID="22">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="1在希尔算法中，参量Number表示增量的个数，各次排序时的增量值顺序存放在数组d中，各组内的记录采用直接擂人法进行排序。外层fv：循环控制希尔排序的次数，内层for循环使序列中的各个记录进行组内排序。希尔排序法的时间复杂度分析比较复杂，它实际所需的时间取决于各次排序咏嘈量的取字比较次数和记录移动次数接近于O{n(logzn)z)。由于该分析涉及一些复杂的数学向题，超出了本书的范围，故这里不作详细的推导，有兴趣的读者可查阅相关文献。由于希尔排序法是按增量分组进行的排序，所以希尔翻游是不稳定的排序。希尔排序的了省名乙磨去1沦班粉妈n了n盛含考忿到要良赶公丢用司口山查盆绷七甘占6之，幕夸劝，.卜皮从占毖粗空间复杂度为常数级ao" ID="23">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="插人排序法是一种由初始空集合开始，不断地把记录插入到合适位置的排序方法。常用的坛人月肚库幸仁右吉住摇人排良知姿衍到卜良姿衍J＝I卜良J上）（上毛古土执,纷v1-bFri1排良刁布#的插入排序法有直接插入排序和希尔排序。希尔排序并不是直接意义上的插人排序，而是希$Picture[00000216\00000216_new\0004.jpg]Picture$$Picture[00000216\00000216_new\0005.jpg]Picture$尔排序的分组概念上的插人排序，即在不断缩小组的个数时，把原各组的记录插人到新组的合适位置中。" ID="1">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000221" TITLE="8.4  交换排序" TYPE="Chapter">
      <fptr LogicalPageNum="221" PhysicalPageNum="221"/>
        <div ORDERLABEL="00000221" TITLE="8.4.1  冒泡排序" TYPE="Chapter">
        <fptr LogicalPageNum="221" PhysicalPageNum="221"/>
        <Paragraph CONTEXT="冒泡排序（bubblesort）是一种简单常用的排序方法。这种排序方法的基本思想是：将待排序序列中第一个记录的关键字Rl.key与第二个记录的关键字RZ.key作比较，如果RkeyR.kcy，则交换记录R：和R在序列中的位置，否则不交换；然后继续对当前序列中的第二个记录和第三个记录作同祥的处理，依次类推，直到序列中最后一个记录处理完为止，拢" ID="1">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="通过第一次冒泡排序.使得待排序的II" ID="2">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="个记录中关键字最大的记录排到了序列的最后一" ID="3">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="个位置上；然后对序列中的前n-1个记录进行第二次冒泡排序，使得序列中关键字次大的记录" ID="4">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="排到了序列的第n-i个位置上；重复进行冒泡排序，对于具有n个记录的序列，进行n-1次冒" ID="5">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="泡封睁后，序列的后n-1个记录已按关键字由小到大地进行了排列，l下的第一个记录必定是" ID="6">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="关键字最小的记录，因此，此时整个序列已是有序排列。" ID="7">
          <fptr EndPN="00000221" StartPN="00000221"/>
        </Paragraph>
        <Paragraph CONTEXT="I" ID="8">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="ch:uig~0" ID="9">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="frr0二＜J;rrr]" ID="10">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="if(L.r[ihcy）L.r(i+lI.key)" ID="11">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="砚" ID="12">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="RccorJtemp-L.r(iJ;" ID="13">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="1.r[iL.r[i+11;" ID="14">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="L.r！1＋11减cmP；" ID="15">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="chtu1片e" ID="16">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="，" ID="17">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="J一；" ID="18">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="二" ID="19">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="）一鑫二臼在该算法中，待排序序列中的n个记录顺序存储在叹田，坟1］，…，吐，1］中，外层far循环控制排序的执行次数，内层for循环用于控制在一次排序中相邻记录的比较和交换。冒泡排序算法的执行时间与序列的原始状态有很大的关系。如果在原始序列中.记录已“正序”排列，则总的比较次数为nl，移动次数为。；反之，如果在原始序列中，记录是“逆序”贻怪J补幻刁泡排序算法的时间复杂度为仪矛）。对于冒泡法分类，可以有很多的变形和改进。" ID="20">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
        <Paragraph CONTEXT="例如：当原文件的关键字序列为(2,3,4,5,6,1}时，用前述算法，外循环要执行5次才可完成；而此时若采用从后向前比，第一次外循F将最“轻”的记录冒泡到文件顶部，那么此时就只需要一次循环，减少了很多重复的比较。还将最“轻”的记录冒泡到文件顶部，那么此时就只需要一次循环，减少了很多重复的比较。还" ID="21">
          <fptr EndPN="00000222" StartPN="00000222"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000222" TITLE="8.4.2  快速排序" TYPE="Chapter">
        <fptr LogicalPageNum="222" PhysicalPageNum="222"/>
        <Paragraph CONTEXT="序列中的排列位置，同时也把剩余的记录分成了两个子序列。分别进行快速排序，又确定了两个记录在序列中应处的位置，并将剩余记录分成了四个子序列；如此重复下去，当各个子序列的长度为1时，全部记录排序完毕。下面先介绍第一次快速排序的方法。设置两个变量i,j，它们的初值为当前待排序的子序列中第一个记录的位置号low和最后一个记录的位置号high。将第一个记录作为标准记录放到一个临时变量Temp中，使它所占的" ID="1">
          <fptr EndPN="00000223" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="位置腾空，然后从子序列的两端开始逐步向中间扫描，在扫描的过程中，变ti,j分别代表当例8.4有8个记录，它们的初始关键字序列为{60,SS,48,37,I0,90,84,36}，用快速排序法对它们进行排序。若选取第一个记寿若选取第一个记录作为标准记录，则第一次排序过程如图8.4.2所示。在该图中图示口处表示当前腾空的位置。在排序时,先将与Rk+在该图中图示口处表示当前腾空的位置。在排序时着先将60与凡抚y相比较.因“卜36，所以将助＝7）放到Rj（1习）处，完成了第一步操作；然后令60与55相比较.因60》55.所以对序列进行一次快撼渊卜序后.用同样的方法对子序列继续进行快速排序，直到各个子序列的长度为1终止。对于例8.4所给的记录序列，它的整个排序过程如图8.4.3所示。1犷件月一图民4一快速排序快速排序的算法Intl，叭itlon（R“沉drll.in［low.inthigh）1／l7寸记录序列LrllowhlghJ进行一次快速排序.并将本范川的元索按标准元索分为两部分，" ID="2">
          <fptr EndPN="00000224" StartPN="00000223"/>
        </Paragraph>
        <Paragraph CONTEXT="lj几标准元术在这两邵分之luJKcy几浑5［andjrdKcy：R忱“dTcmP；Tcmp-rllOw】：刀成备际冷记录放人中间单元" ID="3">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="StandardK卿一rllowl.女y；11卞范IH的妇、准元欢wh，Ic‘10w＜hi忿1，）llkl.表的1吻端交桥效户1中问扫描lwhilc门‘）w＜high＆及rlhigh］·kcy＞～石tand；［rdK亡，）higr卜：rllow行1二rlh：ghl：114齐小于标准，L双的数据往前放" ID="4">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="whil改luw山1户及及rflowl.kcy《。从；.、1：，ro1‘cy）" ID="5">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="w～斗；" ID="6">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="rlhig矛一］。11。。］；1琳人！·标准兀求的数据往后放" ID="7">
          <fptr EndPN="00000224" StartPN="00000224"/>
        </Paragraph>
        <Paragraph CONTEXT="tntSt:utJarJLcx" ID="8">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="if(luw:htgh-I)" ID="9">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="{" ID="10">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="titandanloc-Y:utition‘R,luu,hlgh" ID="11">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="llit;1to＊二hi;hlr，丁次4.1分.九返同坏准f含竹" ID="12">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="Q、nrtlr,IoH.Stvxlaril1.‘x.Qsurt(r,SU+n、larJl.nC+l,htthJ" ID="13">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="14">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="15">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="otJQw‘k5xt{Sgltukl" ID="16">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="xt1Y1犷kLxllt1快zLiF1" ID="17">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="Q、ort(LR,U.1.1ength-11/low和high111?tl(flO,L.lenah-Ii,1i{】在上述QuickSort算法中.待排记录序列顺序存放在r(lowJ,r[lauv+lr[higta｝中，变量" ID="18">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="i，1指示左右两端当前扫描到的记录的序号，变量Temp为存放当前标准记录的临时变量。该算法采用了递归的方法，快速排序也可有非递归的方法实现，有兴趣的读者不妨将该算法改写为非递归的形式。快速排序算法的执行时间取决于标准记录的选择。如果每次排序时所选取记录的关键字值都是当前子序列的“中间数”，那么该记录的排序终止位置应在该子序列的中间，这样就把" ID="19">
          <fptr EndPN="00000225" StartPN="00000225"/>
        </Paragraph>
        <Paragraph CONTEXT="原来的子序列分解成了两个长度基本相等的更小的子序列，在这种情况下，排序的速度最快。若设完成n个记录排序所a的比较次数为T(n则有：荃以石仕比名王虑圈只左月了叭解二轰冬的＿娜伦法一可树甘由编落洲卜廷占抓秦茶一一洲卜成列姑占由的佰七擂5.4.4(x)所示的一棵满二叉树，其中每个结点都表示一个序列，结点中的值为该序列的长度，分解次数k就等于树的深度log2n，所以有：若原始记录序列已“正序’排列，且每次选取的记录都是序列中的第一个记录，即序列中关键字最小的记录，此时，快速引脾就变成了“慢速排序”。由此可见，快速排序时记录的选取非常重要。在一般情况下，序列中各记录关键字的分布是随机的，所以每次选取当前序列中的第一个记录不会影响算法的执行时间，因此算法的平均比较次数为O(nlogn}o分析例子可知，快速排序是一种不稳定的排序方法。最坏情况下为n，因此快速排序法的空间复杂度为。(n" ID="20">
          <fptr EndPN="00000226" StartPN="00000225"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="井知协撞挑岸＿拉浦挑良抹具一劫斗陌沈丫坎排良如扮忆七" ID="1">
        <fptr EndPN="00000221" StartPN="00000221"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000226" TITLE="8.5  选择排序" TYPE="Chapter">
      <fptr LogicalPageNum="226" PhysicalPageNum="226"/>
        <div ORDERLABEL="00000226" TITLE="8.5.1  直接选择排序" TYPE="Chapter">
        <fptr LogicalPageNum="226" PhysicalPageNum="226"/>
        <Paragraph CONTEXT="前序列中的第2个记录RZ交换位置；在第三次排序时，R3的关键字最小，所以记录R3不动，直接选扦排序炸，去voidSclcctSonll-istL)" ID="1">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="(川红援选扦排序法心rLrlol-Ir(n-IH绪i" ID="2">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="uui.j.Sma71;" ID="3">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="Rcaxl-rrmP" ID="4">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="for(1=U;i&lt;L.Lcngth-Ia-。)" ID="5">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="Small" ID="6">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="SrsalI-" ID="7">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="iftSma川二i" ID="8">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="L.r(Sm。川二Thap;" ID="9">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
        <Paragraph CONTEXT="}1在该算法中，1Bc定待排序的记录顺序存储在数组r的：(，，T[A-11中，外循环用于控制排序次数，内循环用于查找当前关键字最小的记录，变量Sma11用于标记当前查找到的关键字最小的记录在数组中的位置。在进行第i次排序时，数组元素r［0J，雌IJ，…，找卜1］已组成有序序列，这时要在rfil，…，迁n-11中寻找关键字最小的记录放到：［i］中，因此，首先令Small=i，然后利用内循环在r(i+I】到r[n-11中进行比较，循环结束时的Small值就是当前这次刹游时所找到的关键字最小的记录在数组中的位置。若i沪SmaIl,则交换币］与：(Small]的值，这样就将当要移动二从算法中可看出，在直接选择排序中，第一次排序要进行二1次比较，第二次排序时要进行n-2次比较……所以总的比较次数为：{n-1n一卜…＋1气n-1)nf2" ID="10">
          <fptr EndPN="00000227" StartPN="00000227"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000227" TITLE="8.5.2  堆排序" TYPE="Chapter">
        <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
        </div>
      <Paragraph CONTEXT="录序列的后面，直到序列中所有记录都已排序为止。" ID="1">
        <fptr EndPN="00000226" StartPN="00000226"/>
      </Paragraph>
      <Paragraph CONTEXT="两种常用的选择排序方法是直接选择排序和堆排序。堆排序是一种时间复杂度为0{n(lagzn)）的排序方法。5.1直接选择排序直接选择排序（straightselectionsort）是一种简单且直观的排序方法。直接选择排序的序列中第二个记录交换位置·4·…如此重复下去，直到序列中全部记录排序完毕。在直接选择排序中，每次排序完成一个记录的排序，也就是找到了当前剩余记录中关键字" ID="2">
        <fptr EndPN="00000226" StartPN="00000226"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000228" TITLE="8.6  归并排序" TYPE="Chapter">
      <fptr LogicalPageNum="228" PhysicalPageNum="228"/>
      <Paragraph CONTEXT="归并排序（MergeSart｝也是一种常用的排序方法。最经常使用的归并排序方法是二路归并排序。二路归并的含义是把两个有序的序列合并为一个有序的序列。在第二章中我们曾经讨论了顺序存储结构和链式存储结构下有序线性表的归并算法，本节将讨论对于无序记录序列的归并排序方法。二路归并排序的基本思想是：将有n个记录的原始序列看做n个有序子序列，每个子序列的长度为1，然后从第一个子序列开始，把相邻的子序列两两合并，得到[川21个长度为2或]的子序列（当子序列个数为奇数时，最后一组合并得到的序列长度为1)，我们把这一过程称为一次归并排序；对第一次归并排序后的〔叭价子序列采用上述方法继续顺序成对归并，如此重" ID="1">
        <fptr EndPN="00000228" StartPN="00000228"/>
      </Paragraph>
      <Paragraph CONTEXT="复，当最后得到长度为n的一个子序列时，该子序列便是原始序列归并排序后的有序序列。下面我们分步讨论二路归并祠游的实现方法。" ID="2">
        <fptr EndPN="00000228" StartPN="00000228"/>
      </Paragraph>
      <Paragraph CONTEXT="Z.两个有序序列的合并由二路归并排序的基本思想可看出.在归并排序过程中，最基本的问题是如何把两个位置相邻的有序子序列合并为一个有序子序列。设有两个有序序列L，和Lz，它们顺序存放在数组：［ll〕，…，r［u，】和ral,，r[uz！中，其中有lz=u：。它们所对应的关键字序列为〔kl：，kl.，1，…，ku.）和（k【_,kl_fi，一k)。若两个序列归并的结果放在数组Swap的同样的位置上，即Swap[ll，Swap[uz】中，则归并的方法可描述如下：" ID="3">
        <fptr EndPN="00000228" StartPN="00000228"/>
      </Paragraph>
      <Paragraph CONTEXT="设置三个变量i,j,m，其中i.」分别表示序列Lt和Lz中当前要比较的记录的位置号，初值i=11，1z.m表示数组Swap中当前记录应放置的位置号.初值m。归并时，反复比较Ki和蜀的值：(f）若K;sK;，则r[iSwap[m],i幼+l,m=m+1;" ID="4">
        <fptr EndPN="00000228" StartPN="00000228"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）若KK，则r[j]斗Swap[m],j勺+1,m=m+lo" ID="5">
        <fptr EndPN="00000228" StartPN="00000228"/>
      </Paragraph>
      <Paragraph CONTEXT="2.一次二路归并排序一次二路归并排序的目的是把若干个长度为size的相邻有序子序列，从前向后两两进行归并到若于个长度为2*size的相邻有序子序列。这里有一个问题'记录的个数n为2*size的整数倍时，序列的两两归并正好完成n个记录的一次归并；否则，当归并到一定位置时，剩余的记录个数不足2*si二个，这时的处理方法是：" ID="6">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)若剩余的记录个数大于size而小于2＊size，把前size个记录作为一个子序列，把其他剩余的记录作为另一个子序列，根据假设可知，它们分别是有序的，采用前面所讲的方法对这" ID="7">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）若剩余的记录个数小于，12，根据假设可知，它们是有序排列的，可以直接把它们顺序放到数组sw叩中。在该算法中，要归并的各个有序子序列依次顺序存放在r［ol，吐1］，…，r［卜1］中，各个子序列的长度为S1ZC，但最后一个子序:的长度可以小于ko次二路归并排序的抹法tiaf\1Yge(FtcwrdrlLRccordcwal&gt;Inivie,‘川Y对，i`勿Jrtnl-r(nI(z!Ifl-ty门Jf-JI}l毕.+个（Ili1‘文件f列的t交度为、.，cnti,IhI.u卜I,IhubZp,Ibl二(1:/i;·个1'文It.f夕IJ）的起拍f污竹刀whllc(161sii&lt;“一1)咧Lf1!/ii1.u'卜uJ1'1.Ii的J'" ID="8">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="Ib二！bl，幼11弟＿个，‘C+(1ij=朽l[1'i起万9f'i" ID="9">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="ubl=1h21;个，：义‘'f1fSn;J的v_eiIrpbz-SV。一!n-I)tiiYu%I:一个了序李1Eli'triub2厅，cltic" ID="10">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="uhb2iir1r(1=lbl,j=lb2;i&lt;ubl&amp;djuhI/iij11J个子文If（rfi］Lcy御IJI·k叮）swapcp弓卜！-r(i1:lN" ID="11">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="swap[spt+】一r(J'，u-hlk(i《一ubl序夕‘I已归并充.将卜i’－列！中11余的i已.li)f存放分J9C'ClSK':IpI(1" ID="12">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="‘二:Il、卜＋卜rl" ID="13">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="N'h11ClJ＜二llhZJ" ID="14">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="1hllI已归1完将序夕12Illy！余的记,t1617i4;3i'IJLtIIsnap中stirp(sp＋十］一r自‘门Ib!-uh2" ID="15">
        <fptr EndPN="00000229" StartPN="00000229"/>
      </Paragraph>
      <Paragraph CONTEXT="一初始关裤l%1:727371232I66864｝第一次归并结果生么户里气气当巡丛｛1第二次归并姗～气兰气兰当书卫“｝｝第三”井结果。夭笠生兰牛进兰星乡丝｝｝第四次归井臀.分卫卜遗一～一斗子二全代.…！图8.6二路归并排序" ID="16">
        <fptr EndPN="00000230" StartPN="00000230"/>
      </Paragraph>
      <Paragraph CONTEXT="3.二落归并排序＿路归并排序就是对原始序列进行若于次二路归并排序。在每一次二路归并排序中，子序列的长度为上一次子序列长度的2倍，当子序列的长度大于等于n时，排序结束。ti:吃xdsoi）从" ID="17">
        <fptr EndPN="00000230" StartPN="00000230"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000231" TITLE="8.7  基数排序" TYPE="Chapter">
      <fptr LogicalPageNum="231" PhysicalPageNum="231"/>
        <div ORDERLABEL="00000232" TITLE="8.7.1  用二维数组表示桶" TYPE="Chapter">
        <fptr LogicalPageNum="232" PhysicalPageNum="232"/>
        <Paragraph CONTEXT="实现基数排序的一个基本问题是如何实现桶结构，可以采用一个二维数组来实现。在二维封睡且中，第一个下标表示桶号，第二个下标表示在桶内各记录的存储顺序号。例如，在图8.7.1中，如果用二维数组实现桶结沟，则各次排序时二维数组的内容如图8.7.2.所示。下面的RadixSortl算法用于实现基数排序，其中原始记录序列存储在数组r［0］，…，tl，11" ID="1">
          <fptr EndPN="00000232" StartPN="00000232"/>
        </Paragraph>
        <Paragraph CONTEXT="中，记录的关键字为m位的整型量。j712006000006712aao134;a2sooazai＿13aoao34z" ID="2">
          <fptr EndPN="00000232" StartPN="00000232"/>
        </Paragraph>
        <Paragraph CONTEXT="8413420480-429，二：0000，二0…!254OfiB00’一“$5,ao00-712585000-sal二‘_o000-」_o00…丫（丈石000…丫侧拓048肠习000-712000…134000｝。＿intIrncth-l0一犷tt‘:布rK1dtxSat！‘一1CU,Icnglh,mcou＜一’«cnilfur(i二0.1叮承。，犷lhi吞＋：coot七&lt;Teal11" ID="3">
          <fptr EndPN="00000233" StartPN="00000232"/>
        </Paragraph>
        <Paragraph CONTEXT="t、tdRad:xSoRl(Typcrll,uttmintmJ111讨记滚rlUI-r[n-trat行关iE..为。、Lf&gt;riPt的t么{ififa9F为二维clin!iJ,k,Number.poucr:" ID="4">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="1，.tCfI01：111于应洲的1｝致器EC}ped[IUtiL\X\lil:IIt[效f1/的ik二1：power-1;" ID="5">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="whde(kc_m)" ID="6">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="〔" ID="7">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="it(k1)" ID="8">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="pourr-l" ID="9">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="cl亡" ID="10">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="povcr-power.1U:1‘时：气瓦1＜1氏1＋＋）。川一住IIIfr代ilfor(i-U;i&lt;n;if{ll将各记.kk'crl!Ur的fi.lt1-rliJ.kc，'llx、wcr(r[t1.fc》p，«r.l(1ti.IQx{11=x[11;1:。I[jll‘1111rlil:nunLhr-t）二几，r〔1司.1＜1任1＋，）{Il从i中iF1'itftil(c卜】！一U)" ID="11">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="for(=0j‘=c川;，‘)" ID="12">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="【" ID="13">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="r[Vumh川一d[tll.ll:" ID="14">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="15">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="16">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="在上述的RadixSartl算法中二维数组d用来实现桶结构尸维数组。是对应桶的计数器。" ID="17">
          <fptr EndPN="00000233" StartPN="00000233"/>
        </Paragraph>
        <Paragraph CONTEXT="：[i]表示当前排序时第i号捅中含有的记录的个数减1。在进行排序时，如何求取关键字x第k位的值xk是一个重要的问题。这里采用的公式为：其中个位的k=1,在上述算法中，while循环用于控制基数循环的次数。在while循环中，首先算lk的值，下面第一个for循环是将从上述算法中可看出，采用二维数组实现桶结构不失为一种简单方便的方法。但有可能造间的大量浪费。例如，若有1的个记录，它们在某次排序时，有可能均匀地分布到d个桶成空间的大量浪费。例如，若有1的个记录，它们在某次排序时，有可喂中，也有可能全部被分配到某一个桶内，因此，二维数组的大小应设为的空间为n，所以，必然要浪费（d－－l）n个存储空间。当n或d很大时，显然不宜采用这种方法。勺汗.冲全为钓的一仙叙r刹比击叹七卜且田劲太以知！中书盯捅会全姗妞沪水以劝！隶于导一木捅周时右花石本活当抖每个队列表示一个桶，同时有两个指针变量分别指向当前的队头结点和队尾结点。往捅中放置记录相当于在队尾插人结点，从桶中往回收集记录相当于在队头删除结点，当队头指针等于队尾指针时，表示该桶中的记录收集完" ID="18">
          <fptr EndPN="00000234" StartPN="00000233"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000234" TITLE="8.7.2  用链式存储结构实现桶" TYPE="Chapter">
        <fptr LogicalPageNum="234" PhysicalPageNum="234"/>
        <Picture URL="00000234\00000234_new\0007.jpg">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Picture>
        <Paragraph CONTEXT="［" ID="1">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="2" ID="2">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="一申1一｝二’囚" ID="3">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="d-1" ID="4">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="链表中的结点可定义为如下的n己lxnedc类型：" ID="5">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="lyP曰efs七刀ct" ID="6">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="4" ID="7">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="E勺详datl称" ID="8">
          <fptr EndPN="00000234" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="犷户u尸八m户卜。t，·int[ub;radIxnode*lirtk;)rad{zhead;vt、idRadixSort2(El}per[1,Intn,tntml(N对记;rtr[UJ-r(n-11进行关i字为.。位uiFJ{（的毕数il)fi结构力链式存[in构Ittl1小k,l.powcr:raditncxlc.p二9radixhcadhcad[lUfix(jU;J&lt;10）一）llii化,y" ID="9">
          <fptr EndPN="00000235" StartPN="00000234"/>
        </Paragraph>
        <Paragraph CONTEXT="head(jI.tub一：hodljllink卜Ul，L；】" ID="10">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="powCr二l;" ID="11">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="for(1-0二1111;1进云7m次#i'Itif(i=n)" ID="12">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="power-I:" ID="13">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="elsepuwcr一件，oWCr.lU,for(1二0；1亡n：1＋＋）11／将记录按关i宁:k的大小.i&lt;t#1tHifln的1t1t4-new1adlxnudc:9一习al扭，tll.d：‘a；4一＞kcy浦(II.key:4一＞next=NULL;1r(IJ.kcy，pawcr一（rl1I.hcypowr.1U1)，IU;P二hcad(kI.llnk:1几P～汉L’LL）" ID="14">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="h亡ad！k】link叫；else" ID="15">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="16">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="铸hilc'1p一：，ncxlKL;LLJ" ID="17">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="Pnrxt-y:咨" ID="18">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="19">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="IJ;lonJ=U;J&lt;IU;J.备）{l的sr收[t，li记录P一粉.二：dlJj.lmiwhllc吃P卜Nt，11，）《r(Idata-pdata:" ID="20">
          <fptr EndPN="00000235" StartPN="00000235"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="22">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
        <Paragraph CONTEXT="生基数排序时，总共要进行m次排序，在一次排序中要将n个记录放到d个桶中，又要把各个桶中的记录依次收回来，所以，基数排序的时间复杂度为O(2mn)o" ID="23">
          <fptr EndPN="00000236" StartPN="00000236"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="基数排序(zadixsQR}又称为桶排序，是一种按记录关键字的各位值逐步进行排序的一种方法。它与前面前面的排序方法完全不同。前面的排序方法主要是通过关键字之间的比较和移" ID="1">
        <fptr EndPN="00000231" StartPN="00000231"/>
      </Paragraph>
      <Paragraph CONTEXT="动记录这两种操作来实现的。而基数排序是利用“分配”和“收集”两种基本操作，此种排序方法一般仅适用于记录的关键字为整数类型的情况。设待排序的记录序列中，各记录的关键字是。位d进制数（不足m位的关键字在高位补0)。在进行基数排序时，设置d个桶，令其编号分别为。，1，…，少1。首先将序列中各个记录按其关键字最低血或称最右位）值的大小放置到相应的楠中然后按照桶号由小到大的顺序收集分配在各桶中的记录，对于同一桶中的各个记录则按其进桶的先后次序进行收集，从而形成在该例中，各记录的关键字是三位十进制数，因此总共只需要进行三次排序。" ID="2">
        <fptr EndPN="00000232" StartPN="00000231"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000236" TITLE="习题八" TYPE="Chapter">
      <fptr LogicalPageNum="236" PhysicalPageNum="236"/>
      <Paragraph CONTEXT="1.什么是分类？什么是内部分类？什么是外部分类？" ID="1">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="2、待分类的文件有哪几种存储结构？" ID="2">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="3.什么是稳定排序？什么是不稳定排序？" ID="3">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="4.若在直接擂人排序时，从序列的第一个元素开始查找元素的插人位置，试改写8.3.1节中给出的直捌香人排序算法。" ID="4">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="s.若待拥游的关键字序列为[zs,73,1a,80,1lb,4s，给出希尔排序的过程示意图。" ID="5">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="6，证明希尔排序是一种不稳定的排序方法，并给出一个例子加以说明。" ID="6">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="7.给出以单链表作为存储时的直接选择排序算法。" ID="7">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="s.在一一有n个元素的堆中:去一个元素，试给出相应的算法。" ID="8">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="9.若堆的根结点是堆中值最大的元素，并且从根结点到每个叶结点的路径上。元素组成的序列都是非递增有序的，给出建立该初始堆的算法。" ID="9">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="34，在冒泡排序过程中，会出现有的关键字在某次冒泡过程中朝着与最终排序位置相反的方向移动这种现象吗？请举例说明。在冒泡排序过程中，使相邻的两次排序向不同的方向冒泡，给出实现该要求的算法。" ID="10">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="11.t2，将S_4.2节中给出的快速排序算法改写为非递归的形式。t飞a=日fl林七重挑良考熟＿劫夕院伯密姚岸＿13.14.若待排序的关键字序列为1103，97，56，38，66，23，42，12，30，521，给出用归并排序法进行排序的过程示意图。在你所知的排序方法中，哪些是稳定的？" ID="11">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="荷兰国旗向题：设有一个仪由红、白、蓝三种颜色组成的条块序列，编写一个时间复杂度为" ID="12">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
      <Paragraph CONTEXT="仪旧的算法，使得这些条块按红、白、蓝的顺序排列成为荷兰国旗。己知有三个已排序的序列，每个序列的长度为n，试构造一个归并这三个序列的算法。15.16。17.18.在进行基数排序时，有一种先按关键字的高位值然后按关键字的低位值进行排序的方法，名少田布勿七妇二硫于翻】只，由研公的良泊！4抹拐排良公山排京分刃以奈音图" ID="13">
        <fptr EndPN="00000236" StartPN="00000236"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="对数据元素集合建立某种有序排列的过程称作排序。在计算机软件系统设计中，排序占岌罗云目以毛片可五的翻翻才台素遥纷吞左双＿皿七食田的月胜良首忱待此堂田的沮胜南谊弥右括人挑序＿件怪有相当重要的地位。本章介绍一些常用的排序算法。这些常用的排序算法有插人排序、选择构成的线性表采用顺序存储结构，即采用数组存储。" ID="1">
      <fptr EndPN="00000214" StartPN="00000214"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000237" TITLE="第九章  查找" TYPE="Chapter">
    <fptr LogicalPageNum="237" PhysicalPageNum="237"/>
      <div ORDERLABEL="00000237" TITLE="9.1  查找的概念" TYPE="Chapter">
      <fptr LogicalPageNum="237" PhysicalPageNum="237"/>
      <Paragraph CONTEXT="查找表（searchtable）是由同一类数据元素（或记录）构成的集合。对查找表进行的操作有：" ID="1">
        <fptr EndPN="00000237" StartPN="00000237"/>
      </Paragraph>
      <Paragraph CONTEXT="在查找过程中，把要进行的操作分为两种类型。一种是只检查某个特定的记录是否存在于给定的记录集合（即上述四种操作的前二种操作），我们称这种查找表为静态查找表（staticsearchtable)；另一种查找不但要检查记录集合中是否存在某个特定的记录，而且当该记录不存在时，要把它插人到记录集合中，或者当记录集合中存在该记录时，要将其内容进行修改或$Picture[00000237\00000237_new\0007.jpg]Picture$把它从记录集合中删去，这种查找表则称为动态查找表（dynamicsearchtable)o为便于讨论，在此给出“给定的”一词的确切含义。首先我们需要介绍“关键字”的概念。关键字（key）是数据元素中某个数据项的值.它可以标识一个数据元素。若它可以惟一地标" ID="2">
        <fptr EndPN="00000237" StartPN="00000237"/>
      </Paragraph>
      <Paragraph CONTEXT="识一个数据元素，则称此关键字为主关键字（primarykey)；反之，则称用来识别某些元素的关键字为次关键字（secondarykey)。若数据元素只有一个数据项时，其关键字即为此数据元素宾粼衬攀攀臼图9.1.1通讯录显然，查找算法的设计与记录集合存储时所采用的存储结构有密切的关系。记录集合的存储结构主要有顺序表结构和树表结构。链表结构上的查找方法已在第二章中讨论过，本章不再讨论。通常.静态查找采用顺序表结构，动态查找采用树表结构。静态查找采用顺序表可以最大限度地节省记录集合占用的存储空间，而动态查找采用树表可以减小插人或删除记录所用的时间。不同于顺序表和树表。哈希表的构造采用的是把关键字映射为数据元素存储地址的方录在记录集合中的位置，给定值关键字与集合中的记录关键字所需要进行的比较次数的期望值。对于具有n个记录的记录集合，查找某记录成功时的平均查找长度为：ASL+P;xC;" ID="3">
        <fptr EndPN="00000238" StartPN="00000237"/>
      </Paragraph>
      <Paragraph CONTEXT="n其,P，为查找第’个记录的概率，假设每妊找的记录都存在，则有艺P1;C；为查找第ii=1" ID="4">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
      <Paragraph CONTEXT="个记录所需要进行的比较次数。typede{Struct王" ID="5">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
      <Paragraph CONTEXT="EtypeKeykey;11数据元素数据项中关键字（key）的定义" ID="6">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
      <Paragraph CONTEXT="DataTypedata;" ID="7">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000238" TITLE="9.2  静态查找技术" TYPE="Chapter">
      <fptr LogicalPageNum="238" PhysicalPageNum="238"/>
        <div ORDERLABEL="00000239" TITLE="9.2.1  顺序查找" TYPE="Chapter">
        <fptr LogicalPageNum="239" PhysicalPageNum="239"/>
        <Paragraph CONTEXT="顺序查找是一种最简单的查找方法，假设数据集合中有n个记录Rt.RzR，其关键字" ID="1">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="分别为Keyt,Keyz：，Fyn，它们顺序存放在某顺序表中。顺序查找的方法是：A(t序表的一" ID="2">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="端开始，用给定值的关键字SearchKey逐个1序地与表中各记录的关键字相比较，若在表中找" ID="3">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="到某个记录的关键字与Searc)IKey值相等表明查找成功；若找遍了表中的所有记录，也未找到" ID="4">
          <fptr EndPN="00000239" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="与5，代trcey值相等的关键字，表明查找失败。当得到查找成功或失败的结金白付，查找结束。可见，顺序查找适用于表中数据元素无序的情况：顺序盘找竹法mtSquclScach(SSTablc,KcyTypcScarchKcrlLST中tic找关键字为RearchKcyiF1记录intis｛城】；ttGS&quot;1clcm[：I.Kcy==SearchKcy)returnielsereturn-1.1这个1i:rlt.Wllltc(IN州'ln句，卜下毯含（jl钓1、条f牛俭测.之；要提l［’：J汽找的速h,h川能减标.’处设省·个11r拟的lLl（AiiT峭〕.夕1·令i找过4'r't!11tht一个儿索的关'i’T：升i1t7.itI卜：长度为：" ID="5">
          <fptr EndPN="00000240" StartPN="00000239"/>
        </Paragraph>
        <Paragraph CONTEXT="霄tASLsq=夕S·n=n于," ID="6">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="1二飞或失败两种情况下的平均查找长度为：ASLsq=p(n+12+q(n+1)气n+11-p/2)从上述的分析可以看出，顺序查找方法虽然简单。但查找效率却较低。当已知各记录的查" ID="7">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="找频率不等时，可以改变记录的存储次序，把查找频率高的记录尽可能放到序列的前面，而把查找频率低的记录放到序列的后面.这样就可以提高顺序查找的效率。另外，我们也可以先将各记录按其关键字重新排列，然后在排序后的顺序表中进行下述的二分查找，这样也可以大大" ID="8">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000240" TITLE="9.2.2  二分查找" TYPE="Chapter">
        <fptr LogicalPageNum="240" PhysicalPageNum="240"/>
        <Paragraph CONTEXT="二分查找又称为折半查找（BinarySearch)，是一种效率较高的有序顺序表上的查找方法。该方法的基本思想为：设顺序表存储在一维数组ST中，各记录的关键字满足下列条件；sT[oj.Key‘ST[1.Key二‘ST[n-1j.Keynid，它们分别指向表的当前待查范围的下界、设置3个变'iow,high和mid，它们分别指向表的当前待查范围的下界、上界和中间位置。初始时，令10平＝0，high二n－1，设待查数据元素的关键字为searchKey。" ID="1">
          <fptr EndPN="00000240" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="（1）d：Ilow＋址qhllZ（［1表示下限取整）。$Picture[00000241\00000241_new\0001.jpg]Picture$$Picture[00000241\00000241_new\0002.jpg]Picture$$Picture[00000241\00000241_new\0003.jpg]Picture$$Picture[00000241\00000241_new\0004.jpg]Picture$$Picture[00000241\00000241_new\0006.jpg]Picture$$Picture[00000241\00000241_new\0007.jpg]Picture$$Picture[00000241\00000241_new\0008.jpg]Picture$$Picture[00000241\00000241_new\0009.jpg]Picture$查找关键字为130的记录的过程如图9.2.1(b）所示，这是一个查找失败的例子。在做完第四次二分查找后，上界指示变量low的值大于下界指示变量high的值，说明表中不存在关此不论查找成功或失败，它的效率都要高于顺序查找方法。二分查找的循环结构的算法如下：二分查找算法（!linjr娇careh1soarchxey,函数返回值为该记录在表中的序号，当返回值为一t时.表示查找失败。在实际应用中，经常会遇到记录的关键字为字符串的情况，这时需调用c语言中的字符串比较函数scmp来完成给定值SeaschKey（也是字符串）与各记录的关键字的比较。下面我们分析二分查找法的查找效率。二分查找过程通常可用一个二叉判定树表示。对于例9.1中所给的长度为15的有序表，它的二分查找判定树如图9.2.2所示。图中圆形结点表示内部结点.方形结点" ID="2">
          <fptr EndPN="00000242" StartPN="00000240"/>
        </Paragraph>
        <Paragraph CONTEXT="龚蕊图9.2.2描述二分查找过程的二又判定树在进行查找时，首先要进行比较的记录为ST[71，因此该二叉判定树的根结点表示为⑦。过对应的二叉判定树深度。例如，查找关键字为27的记录所走的路径为：⑦～③一⑤州④,所进行的比较次数为4。一次不成功的查找走的是一条从很结点到某个外部结点的路径，所需的比较次数恰好为二叉判定树的深度。例如，查找关键字为f30的记录所走的路径为：：一11-13-12121进行的比较次数为5。假设有序表中记录的个数恰好为：。20＋2，＋.二＋2卜1＝Zkesl，则相应的二叉每个结点需要进行i次比较。因此，当表中每个记录的查找概率相等时，查找成功的平均查找长度为：" ID="3">
          <fptr EndPN="00000243" StartPN="00000242"/>
        </Paragraph>
        <Paragraph CONTEXT="ASLbin：一又土x2‘一，xi=n+llogi(n+1）一1blogz(n+l）一Ii-inn从分析的结果可看出，二分查找法平均查找长度小，查找速度快，尤其当n值较大时，它的查找效率较高。但为此付出的代价是需要在查找之前将顺序表按记录关键字的大小排序。这种排序过程也需要花费不少的时间，所以二分查找适合于长度较大且又经常进行查找的顺序表。" ID="4">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000243" TITLE="9.2.3  分块查找" TYPE="Chapter">
        <fptr LogicalPageNum="243" PhysicalPageNum="243"/>
        <Paragraph CONTEXT="分块查找又称索引顺序查找，是顺序查找法和二分查找法的一种结合。分块查找法要求把线性表中的元素均匀地分成若干块，在每一块中记录之间是无序的，但块与块之间是有序那么第一块中所有记录的关键字都小于或等于第二块中所有记录的关键字，第二块中所有记录的关键字都小于或等于第三块中所有记录的关键字……这时，我们可建立一个称为索引表" ID="1">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="的顺序表，将每块中值最大的关键字依次存放在该索引表中。" ID="2">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="在带索引表的顺序表中查找关键字等于SearchKey的记录时，需要分两步进行。首先根" ID="3">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="据SearchKey值的大小在索引表中找出该记录可能存在的块，然后在相应块中顺序查找。" ID="4">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="索引表中每个元素可以只包含相应块中的最大关键字。在这种情况下，在索引表中查找" ID="5">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Paragraph CONTEXT="索引表中每个元素可以只包含相应块中的最大关键字。在这种情况下，在索引活时需要记住所查元素在索引表中的序号，该序号就是下一步所要查的记录块的块号。根据块号和每个块的块长就可确定要查块中第一个记录的位置，即该块的起始位置。另一种方法是" ID="6">
          <fptr EndPN="00000243" StartPN="00000243"/>
        </Paragraph>
        <Picture URL="00000244\00000244_new\0003.jpg">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Picture>
        <Paragraph CONTEXT="设索引表中各元素顺序存放在数组is巾，顺序表中各元素存放在数组盯中。若要在顺序表中查找关键字为so的记录，首先比较so和t1aI.xey的值，因为sodso］.xey，所以继续比较80和15111.众y.阳仍大于ls[JI.Key，再继续比较8D和ls[2I.Key,8D还是大于1sE2Ifey，再继续比较8U和ls[3Key，由于s01s[3I.Key，说明要查找的记录只可能在第3号块中。这时由is[3I.lirk值找到第3号块中第一个记录在数组ST中的序号，然后由此开始，在数组ST中顺序向后查找，当查到该块中的第4个记录时，发现该记录的关键字是84。因此查找成功。在进行分块查找时，由于块内各记录的关键字是无序的，所以在块内的查找要采用顺序查" ID="7">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="采用顺序查找法，也可以采用二分查找法。如果线性表中记录的个数很多，被分成的块数相应" ID="8">
          <fptr EndPN="00000244" StartPN="00000244"/>
        </Paragraph>
        <Paragraph CONTEXT="1Ilvie:irnIn.icJc;ir.h一竺叮’、11·“‘cofd·二”ubluchsvc,i:c，typcSc:uchKcy)111分块戊J戈关1理‘产力5。“h爪cy的1己录。索引人为1狱（Jl一卜1.；11！刀徽；1·人为5’r.坎长夕］卜1以k，，亡" ID="9">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="1，，ti·J；11在索，J！人胶，孙八J芝1一众" ID="10">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="铸hll亡几1＜1：1＆花St’itrcl.Kc丫·15川一Kc》）" ID="11">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="i＋" ID="12">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="If.1＞‘.）" ID="13">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="rClunl-1；" ID="14">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="亡1父" ID="15">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="口在胜序人中腆序汽找" ID="16">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="J习、【1】一Iink：" ID="17">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="咐：lds。。rchKcy卜Srrlj1K。）.＆＆，一1、川.link饰1。丫k“，cj" ID="18">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="，卜scarchK。卜一5‘r臼J.Koy）" ID="19">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="c卜t’" ID="20">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="rrl.Irll" ID="21">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="22">
          <fptr EndPN="00000245" StartPN="00000245"/>
        </Paragraph>
        <Paragraph CONTEXT="】下边讨论分块查找算法的平均查找长度。分块查找的过程分为两部分，一部分是在索引表中确定待查记录所在的块.另一部分是在块里寻找待查的记录。因此.分块查找法的平均查找长度是两部分平均查找长度的和，即：AS玩城厅盛5玩十AS与我们假定长度为n的顺序表要分成b块，且每块的长度相等，那么有块长：1＝知七块内各记录的查找概率为1几。当在索引表内对块的查找以及在块内对记录的查找都采用顺序查找法时.有：。豁一攀As诗豁·号表。对长度为loooa〕的顺序表可以分成1(fo0块，每块包含loo个记录，从而构成了一个长度为looo的索引表，该索引表中元素的个数仍然很大，我们可将这个索引表中的元素再分成10块，每块包含l00个元素，又构成了一个长度为to的索引表，从而建立了两级索引表。多级索引表的建立可以有效地提高查找速度。" ID="23">
          <fptr EndPN="00000246" StartPN="00000245"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="静态查找表是在创建过程中建立的，在对数据元素的查找与访问过程中不能对它进行修" ID="1">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
      <Paragraph CONTEXT="改，所以它不提供数据元素的插人与删除过程。在实现上，通常采用顺序表结构。顺序表上的" ID="2">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
      <Paragraph CONTEXT="查找主要有三种方法，这些方法都比较简单，本节对此作一一介绍。" ID="3">
        <fptr EndPN="00000238" StartPN="00000238"/>
      </Paragraph>
      <Paragraph CONTEXT="初始条件：静态查找表存在；操作结果：销毁静态查找表sr" ID="4">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="初始条件：静态查找表ST存在，k周！Vai是和查找表中元索的类" ID="5">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="型相同的给定值" ID="6">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="操作结果：若ST中存在其关健字等于keyval的数据元素，J函数值为该元素的值或在查找表中的位里，否则为“空“。中的每个数据元素Locatest(＆ST,mtn)Destroy_st(BtST}Seazch(SSTatsleST,KeyTypekeyval)" ID="7">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
      <Paragraph CONTEXT="'lYarerse(ST)" ID="8">
        <fptr EndPN="00000239" StartPN="00000239"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000246" TITLE="9.3  动态查找技术" TYPE="Chapter">
      <fptr LogicalPageNum="246" PhysicalPageNum="246"/>
        <div ORDERLABEL="00000246" TITLE="9.3.1  B-树的定义和表示" TYPE="Chapter">
        <fptr LogicalPageNum="246" PhysicalPageNum="246"/>
        <Paragraph CONTEXT="一裸m阶的a一树或者是一棵空树，或者是满足下列要求的m叉树：" ID="1">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）树中每个结点至多有m个儿子结点（子树）。" ID="2">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）除根结点之外，其他的每个结点至少有【ml2』个儿子结点（子树）。" ID="3">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）若根结点不是叶结点，则它至少有两个儿子结点（子树）。" ID="4">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）所有叶结点都在同一层上，叶结点不包含任何信息。我们可以把叶结点看成是实际上不存在的外部结点，指向这些结点的指针为空，也可以把它们看成是查找失败时的结点。" ID="5">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="(5）每个非叶结点中包含下列信息：" ID="6">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="[n.po,{Kl,pt)，（Kz,pz，（KPn" ID="7">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="其中，n为该结点中关键字的个数，有［[m/21-l鉴n_m-1;K;{1&lt;i&lt;n）为关键字且满足KKt;" ID="8">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="P;{Qd&lt;n）为指向其子树根结点的指针且满足pi司.1,2n-1）所指子树上的所有结点的" ID="9">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="关键字均小于K;t。或大于等于Ki,pn所指子树中所有结点的关键字均大于JIno" ID="10">
          <fptr EndPN="00000246" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="有给出记录和指向记录的指针。HTNodexNodePtr[m+11;c子结点指针数组盯刀x＊Elem[m十珍}B丁Node;" ID="11">
          <fptr EndPN="00000247" StartPN="00000246"/>
        </Paragraph>
        <Paragraph CONTEXT="typedefatrurtB'i`A3ode*i＊Nod‘ptr；刀结点指针N侧址po：；刀结点位置（在一个结点内）" ID="12">
          <fptr EndPN="00000247" StartPN="00000247"/>
        </Paragraph>
        <Paragraph CONTEXT="1吐tN侧址Pos；imR以团a吕｝Result；t坤翻ef，加叱t！粗衬的结构定义BTN冈c＊Root九：intN讨创N”m；$Picture[00000247\00000247_new\0017.jpg]Picture$｝B.笼悉；下面我们讨论在B·树上进行查找、插人和删除的方法。…1.口二fl二月目.1二1.…1，.1.‘1，.二‘.，1.…口.1.1二菌菌端菌菌菌自菌白白菌菌白白菌菌菌菌自菌白菌白菌" ID="13">
          <fptr EndPN="00000247" StartPN="00000247"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000247" TITLE="9.3.2  B-树的查找" TYPE="Chapter">
        <fptr LogicalPageNum="247" PhysicalPageNum="247"/>
        <Paragraph CONTEXT="voidf3_Starchf13tree.ht,Kcvf}pcScvchKcy,Result&amp;x)【F3TNalc:cunrcnt二parcel:inli1:hootCound-F八Isrcurrent二bt一＞Ftocttr;从根结点开;parentvULL;点的父ra:点为while(current!Found)《刀服环至血找到叶子结点或已立到所盗关键字i=SgScarch(currcnl,ScarchKcy在一个GJ:~xil内IIi!1&quot;ffikifU＞（）current一＞Kc(t)二.SearchKcy)" ID="1">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="Furnl=7RI!F11才1ii肠-l't找成功chc" ID="2">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="崔" ID="3">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="parent二current:往下:" ID="4">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="current二currant一＞V。xlci'lr[i｝" ID="5">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="1" ID="6">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="if(Found)" ID="7">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="{找成功" ID="8">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="z.NodePtr-current;" ID="9">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="x.NcxlcPot二i;" ID="10">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="x.Ret日ag=T)2Uls;" ID="11">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="}" ID="12">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="else" ID="13">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="{找失败" ID="14">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="x.lvodcPtr-parent;" ID="15">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="x.lcxlcPoe=i:x.RetlIa护FALSE;I例如，在图4.3.1所示的B一树中。要查找值为50的关键字的过程如下：首先将给定值50与根结点a中的惟一关键字1QQ相比较，由于50小于lQ，所以沿着结点：中的o指针向下找到结点b，在结点b中共有3个关键字，因50大于KQ,K,.Kz的关键字3,9,48但小于K3的关键字G6，所以沿着结点b的PZ指针向下找到结点。在结点c中顺序查找到了关键字50," ID="16">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
        <Paragraph CONTEXT="所以查找成功。如果要查找值为7Q的关键字，采用上述同样的方法自上而下查找到结点ti时，因70大于d中!t,的关键字68而小于K2的关键字78,沿其Pt指针向下找，但该指针为空，所以查找失败。" ID="17">
          <fptr EndPN="00000248" StartPN="00000248"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000248" TITLE="9.3.3  B-树的插入" TYPE="Chapter">
        <fptr LogicalPageNum="248" PhysicalPageNum="248"/>
        <Paragraph CONTEXT="录。将关键字SearchKey播人到一棵深度为h+1的m阶B一树上要分两步进行。首先在第h层中找出该关键字应插人的结点x，然后判断结点x中是否还有空位置，若x中关·字的个数小于m-1，表明其中还有空位置，则可将关键字SearchKey插人到x中的合适位置上；若x中关键字的个数等于。1.表明结点z已满，要擂人关键字SearchKey则须拆分该结点。结点拆分可采用如下的方法.以中间关键字为界把结点一分为二成为两个结点，并把中间$Picture[00000249\00000249_new\0008.jpg]Picture$$Picture[00000249\00000249_new\0009.jpg]Picture$结点的上述拆分过程生成的新的结点必定仍满足B一树的定义。(a)7阶S一树（b）插人25后的B一树图9.3.28-的插人例如，将关键字值为25的元素插人到图9,3.2(aJB一树中，这个元素将被插入到结点{20,30,40,SU,b0,70｝中，但该结点以经满了（又称饱和），当新元素要插入到饱和的结点中的时候，饱和结点需要被分裂开。设B是已满结点（饱和结点），现将带有空指针的新元素。插人" ID="1">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="3.Tfnd劝Ir.A.古.木-ir'3iii1/3yi.不tttTl4!4'占田下而的良劝苦金朵世虫括占。到B中，得到一个有rn个元素和研1个孩子的溢出结点。" ID="2">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="m，co，（el，cl），…，（em，叼其中。；是元素，乌是孩子指针。从ed处分开此结点，其中d＝【mf21。左边的元素保留在B中，" ID="3">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="右边的元素移到新结点Q中，（匀，Q）被插人到B的父结点中。新的B和Q的格式为：B：d-1，旬，（e1，cl），…，（c杏1，。0－－1）Q：m-d，cd，（c‘1，c‘1），…，（e，，c动注意B和Q的孩子数量至少是da在本例中滋出结点是" ID="4">
          <fptr EndPN="00000249" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="7，0，（加，0），（25，0），（30，0｝，（40，0），（50，0），60，0】，（70，0）且d＝4。从。。处分开后的两个结点是：B：3，0，（20，0），（25，0），（30，0）$Picture[00000250\00000250_new\0001.jpg]Picture$$Picture[00000250\00000250_new\0002.jpg]Picture$(a)3阶B-{b）插人42的滋出树茵辘蕊荔灸戛(c）插人42结点分裂过程1(d）擂人42结点分裂过程2茵以点从旬丧处分开得到2个结点：B:l,o,(35,0)Q:i,a,(42,0)当把（ao,Q)插人到B的父结点F中时，发现该结点也是饱和结点，插人后，又得到滋出结点，如图9.3.3(c）所示：F:3,B,{4a,Q(54,G(60,H)其中G和H是指向结点卜1和断S的指针。溢出结点F被分裂开，产生结点A。新结点F和A如下：F:1,B,(40,Q}A:1,G,(ba,H)现需要将（50,A）插人到根结点中，在此之前根结点的结构是：R:2,S,(3U,B(SO,T)其中5和T是分别指向根结点和第一和第三棵子树的指针。插人完成后，得到溢出结点如图9.3.3(d）所示：R:3,S,(30,B(SO,A(Sa,T)" ID="5">
          <fptr EndPN="00000250" StartPN="00000249"/>
        </Paragraph>
        <Paragraph CONTEXT="R:1,S,{3a,B)U:1,A,O,T){SD,U）一般应插人到R的父结点中，但是R没有父结点，因此，产生一个新的根结点如下：" ID="6">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="R.(50,U}" ID="7">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="得到的H-如图9.3.3(e）所示。读取结点[3Q,SDI，1和[35,401时执行了3次i盘访间。对每次结点分裂，将修改的结点和新产生的结点写回到磁盘需执行2次磁盘访间，由于有3个结点被分裂，因此需要执行6次写磁盘操作。最后产生一个新的根结点并写回磁盘，又需要占用1次颠外的磁盘访问，因此磁盘访问的总次数为1Q6当擂入操作引起了n个结点的分裂时，磁盘访问次数为h（读取搜索路径上的结点）+2n（回写两个分裂出的新结点）+1（回写新的根结点式擂人后没有导致分裂的结点）。因此，所用的磁盘访间次数为h+2n+1，最多可达到3h+lo上述结点的分裂方法使得在B‘树中擂人结点后，它仍能保持B-的全部特征，从而也可看出，B-上的插人是一个由插人点向根结点递归的过程。" ID="8">
          <fptr EndPN="00000251" StartPN="00000251"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000251" TITLE="9.3.4  B-树的删除" TYPE="Chapter">
        <fptr LogicalPageNum="251" PhysicalPageNum="251"/>
        <Paragraph CONTEXT="设B-的深度为htt，在这棵s-t上删除关键字SearchKey要分几种情况考虑。(2}若被删关键字在树的第h层的某个结点中，并且该结点中关键字的个数等于【m/21-1,若其左（或右）兄弟结点中关键字个数大于恤佗卜1，则把左〔或右）兄弟结点中最大（或最小）的关键字上移到其双亲结点中，同时把双亲结点中大于（或小于）上移关键字的关键字下移到被删关键字所在的结点中。图9.3.4{b）所示的S一树中删去关键字80后的状态如图9.3.4(c)所示。{3）若被删关键字在树的第h层的某个结点中，该结点中关键字的个数等于【m/2卜1，并且其左（或右）兄弟结点（若存在的话）中关键字个数也等于【m/21-1，这时需将被删关键字所在的结点与其左（或右）兄弟结点以及分割二者的父结点中的某个关键字重新组织分配。图9.3.4(c）所示的在B一树中删去关键字116后的状态如图9.3.4(d）所示，此例是父结点中的关键字个数大于[m/211的情况；若父结点中的关键字个数等于［m!21-1，则为下述情况（4)0" ID="1">
          <fptr EndPN="00000252" StartPN="00000251"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）若被[Rroi关键字所在的结点在B-'的第L层上（1s1式h)，且结点中关键字个数等于" ID="2">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="[m/21-1，设被rrfik关键字为所在结点的第i个关键字，则将指针Pi所指结点中的最小关键字放到它的位置上。或将指针PN所指结点中的最大关键字放到它的位置上，图9.3.4{d）中删除" ID="3">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
        <Paragraph CONTEXT="综合情况〔3）和情况〔4）可知，在B一树中删除关键字的过程是一个由被删结点向根-点递归的过程。" ID="4">
          <fptr EndPN="00000252" StartPN="00000252"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在9.2节中介绍的几种查找算法主要适用于顺序表结构,且限定于对表中的记录只进行查找，而不做插人或删除操作，也就是说只做静态查找。如果要进行动态查找，即不但要查找记录，还要不断地插人或删除记录，那么就需要花费大量的时间移动表中的记录，显然，顺序表中的动态查找效率是很低的。本节我们讨论树表和用树结构存储记录集合时的动态查找算法。树表本身也在查找过程中动态地建立。树表主要有二又排序树、平衡二叉树、B一树和B＋树B一树又称为平衡多路查找树或外部查找树，是一种组织和维护外存文件系统的非常有效" ID="1">
        <fptr EndPN="00000246" StartPN="00000246"/>
      </Paragraph>
      <Paragraph CONTEXT="二据结构，它以高效、易变、平衡和对硬件相对独立等特点而成为数据库系统中索引的标" ID="2">
        <fptr EndPN="00000246" StartPN="00000246"/>
      </Paragraph>
      <Paragraph CONTEXT="的数据结构，它以高效、准组织形式。" ID="3">
        <fptr EndPN="00000246" StartPN="00000246"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000252" TITLE="9.4  哈希表的查找" TYPE="Chapter">
      <fptr LogicalPageNum="252" PhysicalPageNum="252"/>
        <div ORDERLABEL="00000252" TITLE="9.4.1  基本概念" TYPE="Chapter">
        <fptr LogicalPageNum="252" PhysicalPageNum="252"/>
        <Paragraph CONTEXT="前两节中讨论的各种查找方法中，由于记录在线性表中的存储位置是随机的.和关键字无关，因此，在查找的过程中都需要依据关键字进行若于次的比较判断，最后确定在数据集合中是否存在关键字等于某个给定关键字的记录以及该记录在数据所形成的表（顺序表或树表）中的位置。查找的效率与比较次数密切相关。如果在记录的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无须做比较或只月翻尺少次的比较就能直接由关键字找到相应的记录。哈希表（hashtable）正是基于这种思想。供使用，即不可能按照一一对应的关系把数据集合中的记录映射到存储空间中。在大多数情况下，哈希函数是一种“压缩映象”.它把记录关键字取值很大的数据集合映射到一个范围确定的表中，因此，冲突（两个或两个以上的关键字映射到同一空间）是不可避免的。根据设定的哈希函数和处理冲突的方法将数据集合中的记录映射到一个有限的连续空间上，并以记录R;的关键字K;的映象H(K;）作为记录R；的存储地址，这一过程称为哈希存储.所设定的连续空间称为哈希表。尽管冲突现象是难免的，我们还是希望能找到尽可能产生均匀映射的哈希函数，以便尽可能地降低发生冲突的概率。另外，当发生冲突时，还必须有相应的解决冲突的方法。因此，构造哈希函数和建立解决冲突的方法是建立哈希表的两大任务。" ID="1">
          <fptr EndPN="00000253" StartPN="00000252"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000253" TITLE="9.4.2  构造哈希函数的方法" TYPE="Chapter">
        <fptr LogicalPageNum="253" PhysicalPageNum="253"/>
        <Paragraph CONTEXT="’构造哈希函数的方法很多，但如何构造出“好”的哈希函数是有很强的技术性和实践性的。这里的‘.好”指的是哈希函数的构造比较简单并且用此哈希函数产生的映射发生冲突的可能" ID="1">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="性最小，也即是说，一个好的哈希函数能将给定的数据集合均匀地映射到所给定的地址区间中。字的各个成分都对它的哈希地址产生影响。下面介绍几种常用的构造哈希函数的方法。" ID="2">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="I.直接定址法" ID="3">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="当关键字是整型数时，可以取关键字本身或它的线性函数作为它的哈希地址。即：H(KK或者H(K)＝aK+b(a,b为常数）例如。有一人口调查表，表中每个记录包括出生年份、人数等情况，若取年份作为关键字，直接定址法的特点是哈希函数简单，并且对于不同的关键字，不会产生冲突。但在实际应用中，关键字集合中的元素很少是连续的，用该方法产生的哈希表会造成空间的大量浪费。因" ID="4">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="此，这种确定哈希地址的方法很少使用。" ID="5">
          <fptr EndPN="00000253" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="选取一个合适的不大于哈希表长的正整数m，用m去除关键字K，所得的余数作为其哈希地址，即：H{KKmodm实际上这些地址是其关键字的最低两位值，因此产生的哈希函数不可能是一个“好”的哈1数。大量实践证明，当m取刁、于哈希表长的最大质数时，产生的哈希函数较好。例如，设哈希表长为2d0.m=199，则上述关键字序列对应的哈希地址为：希函数。关键字：2444L849dl56318843566349地址：148581564177ISD除留余数法是一种简单且行之有效的构造哈希函数的方法。" ID="6">
          <fptr EndPN="00000254" StartPN="00000253"/>
        </Paragraph>
        <Paragraph CONTEXT="3.数字分析法设关键字有d位数，选取其中若干位的值构造哈希地址的方法称为数字分析法。在用数字分析法构造哈希函数时，要事先知道所有关键字或大多数关键字的值，对这些关键字的各位KS：00091.9697K6：000310329K7：000.4＿504万.2KS：000527368而、了价了颐、自、了已滚、自了负而朴为叙述简便，用①，②，一，⑨对关键字的各位编号。由于给定的哈希表长为1000，因此只能选取关键字中的3位十进制数作为其哈希挺山上。" ID="7">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="显然要想避免冲突，应使选取位上各个基数值0，1，…，9出现的频率尽可能一致。" ID="8">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="分析所有关键字的各位值.发现第①，②，③位只出现0值；第④位中6，9，4，5各出现1" ID="9">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="次，3，7各出现2次；第⑤位中1出现4次，5，2各出现2次；第超火立中9出现3次，8，0出现" ID="10">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="2次，7出现1次；第⑦位中4，3各出现3次，6出现2次；第⑧位中0，1，4，5，6，9均出现1次，2出现2次；第⑨位中6，3，5，了，2，8各出现1次，9出现2次。因此，可以选取关键字的映闭阅网佑绍虎的右纺作七且哈杀袖体握菊1加下的姑里.H（KI卜326H（K2）＝709" ID="11">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Paragraph CONTEXT="H（K3）月抖3H（K4）＝715" ID="12">
          <fptr EndPN="00000254" StartPN="00000254"/>
        </Paragraph>
        <Picture URL="00000255\00000255_new\0001.jpg">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Picture>
        <Paragraph CONTEXT="5.折登移位法根据哈希表长将关键字分成尽可能等长的若干段，然后将这几段的值相加，并将最高位的进位舍去，所得结果即为其哈希地址。相加时有两种方法：一种是顺折，即把每一段中的各位值对齐相加，称之为移位法；另一种是对折，像折纸条一样，把原来关键字中的数字按照划分的中界向中间段折登，然后求和，称之为折叠法。例，.fi有一关键字K=347256198，若表长为100Q，我们可以把K分成三段，每段长为3a采用移位法和折叠法所得的哈希地址为：+14S+891H(K〕抠01H(lC1与平方取中法类似，折叠移位法也使得关键字的各位值都对其哈希地址产生影响。" ID="13">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000255" TITLE="9.4.3  哈希冲突的解决方法" TYPE="Chapter">
        <fptr LogicalPageNum="255" PhysicalPageNum="255"/>
        <Paragraph CONTEXT="我们知道，无论如何构造哈希函数.冲突是不可避免的，因此如何处理发生冲突是建哈希表的一个重要方面。假设哈希表的存储结构为一维数组，“冲突”是指由关键字key求得哈希地址H(ey)后，表中下标为H(AY)的分量不空（已有记录），则“处理冲突”就是在哈希表中为关键字为kcy的记录另外安排一个存储空间。常用的方法有两种：开放定址法和链地址法。" ID="1">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="1.开放定址法开放定址法的基本思想是在发生冲突时，按照某种方法继续探测基本表中的其他存储单" ID="2">
          <fptr EndPN="00000255" StartPN="00000255"/>
        </Paragraph>
        <Paragraph CONTEXT="HKcyH(Keydmodm(il,2,…,k(i‘m-1其中，H(AY)为关键字Key的直接哈希地址，m为哈希表长，d为每次再探J时的地址增量。用这种方法时，首先计算出它的直接哈希地址H(Key)，若该单元已被其他记录占用，继续查看地址为H(K已ydl的单元，若也已被占用，再继续查看地址为H(Keyd：的单元，如此下H(Key1r2,H(Key22,H{Key33,H{key43,H(Key5）二6,H(Key6)司,H{Key77,H(KeyB9用线性探测再散列法和二次探测再散列法构造其哈希表。假设记录进入次序为Rl,R2,…,R8，用这两种方法构造的哈希表如图9.4.2所示。用线性探测再散列时，首先记录R1进人A[21中，当R2进入时，与R1发生冲突，向下探测发现A[3】为空，所以将R2放人Aj31。当R3进人时，其直接哈希越山上单元A[31已被R2占$Picture[00000256\00000256_new\0008.jpg]Picture$口－一iZ3d万G" ID="3">
          <fptr EndPN="00000256" StartPN="00000255"/>
        </Paragraph>
        <Picture URL="00000256\00000256_new\0022.jpg">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Picture>
        <Paragraph CONTEXT="A141单元中，记录RZ与R3的冲突不是因哈希函数引起的，而是由再散列方法本身造成的。" ID="4">
          <fptr EndPN="00000256" StartPN="00000256"/>
        </Paragraph>
        <Paragraph CONTEXT="3，建立一个奋共溢出表设A加)为基本哈希表，再设一个公共溢出表Q[v)，一旦产生冲突，均把当前记录放入公共溢出表的当前表尾。" ID="5">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000257" TITLE="9.4.4  哈希表的查找" TYPE="Chapter">
        <fptr LogicalPageNum="257" PhysicalPageNum="257"/>
        <Paragraph CONTEXT="在哈希表上查找关键字为SearchKey的记录的过程很简单，方法是：按照哈希表建立时的哈希函数，根据SearchKey值求出其直接哈希地址，若该地址记录为空，则查找失败；若该地址记录不为空，将SearchKey与该地址的记录的关键字相比较，若二者相等，则查找成功；否则按照哈希表建立时采用的解决冲突的方法，继续在“下一个哈希存储地址”中查找。若在某个“下一个哈希存储地址”中有SearciKey与该地址中记录的关键字相等，则查找成功；若找完所有“下一个哈希存储地址”都未找到时，查找失败。这里，“下一个哈希存储地址”很据哈希表的冲突解决办法具体决定。例如，解决冲突采用链地址法时，口下一个哈希存储地址”指的是对应链表的下一个结点，解决冲突采用开放定" ID="1">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="哈希查找的方法是一种直接计算地址的方法，在查找过程中所需的比较次数很少。由查" ID="2">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="找的方法可以看出，在进行哈希查找时，要根据记录的关键字由哈希函数以及冲突时解决冲突" ID="3">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="的方法找出记录的哈希地址。因此，在考虑哈希查找的效率时.不但要考虑查找时所铭的t理次" ID="4">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="次数，还要考虑求取哈希地址的时间。" ID="5">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000257" TITLE="9.4.5  哈希算法" TYPE="Chapter">
        <fptr LogicalPageNum="257" PhysicalPageNum="257"/>
        <Paragraph CONTEXT=".开放定址法（linearopenaddressing)" ID="1">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="只earrhK，二用耍什宜祝W.iifciF_u杀弃'a96个T妇P,rIpnnty'日V'hti:ld7天今," ID="2">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="阮世比Kcy用来计算起始地址。丛于汗放定址法构造林法11‘.、11朴blc（1川，livir）！l.’构造不数，分尺哈希雨效备、、刁Ivis优二ht-new臼y浑It.，1：" ID="3">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="clllPty-Ilcwboollnll；" ID="4">
          <fptr EndPN="00000257" StartPN="00000257"/>
        </Paragraph>
        <Paragraph CONTEXT="return］:lj11}°om;11下一个AllfwhilcfJi11又返i’ifffl" ID="5">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="r.InmrU无11乡." ID="6">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="r犷tunIJ：lb以，15。二h（K巧卜及ScarchKcy.ETy阵＆r以ull）“艘索与k沂配的元次并放人e.如果不存在这样的元家则返回t’aIse，n七h-11努hsearch（k）" ID="7">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="lftc几笼Pt乡［b】nht！b】1＝5比chKcy）" ID="8">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="rcl.nlra卜c；" ID="9">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="rc、ult＝ht［bl：戊！Ilr了1［1‘rr二｝在上而的函数，t，.共享成员函数Scarch在没有找到关键字依ScarchKcy的元索时返回fal、e.古则返F.ltrlle，若找到该该元素，则在参数tllt中返回该元索。义arch函数调川了函ht［h｝的关键字仇为searchKey；（2）表巾没有关键字f红为scarchKey的元索，emply［bl为ture，为表中没有关键字为SealchKey的元素，" ID="10">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="cmpty［h］为fal，e.ht［b］的关键字依不等T.Sc二chKoy.1＿1表已满基于开放定址法哈希表的播入51；‘tu、卜1‘1、hln，crt（叮》pc＆x）长11存哈希人中扬人K心yT，pcsc二hK。）.＝x.koy；左拍取key位" ID="11">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="Inlh二H怒h凡。含ch（5‘IrchKcy）：" ID="12">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="if（em详，·！bl）lj检查是否能究成抽人" ID="13">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="【" ID="14">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="emPty【b卜口恤】犯；" ID="15">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="hllb卜x：" ID="16">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="rctumOK；lrc吸um‘二RKOR；｝上面程序给出了卜山sh臼sert算法。它首先调用Hashs创珍ch。若H留hsearch返回的1号桶为空，则表中没有关键字为5。川d川公y的元素。可直接将该元紊x插人到该桶中。若返回的楠非空，则要么是桶中已包含了关键字为searchKey的元素，要么是表已满。" ID="17">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="2，链地址法哈希冲突解决办法采用链地址法。t抑edefstl，ct｛" ID="18">
          <fptr EndPN="00000258" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="Ke犷FyPeK勺；Status1lashScarch(C:huinVodc.af1.Kc）T》pcScarchKcv二，.Inuxl){F1i4地力f{t'Jji;A人。‘]tt（找关iilfSiarchKry,a[J，卜A71IIfLLtti点的7（针（二hainNudr*p:" ID="19">
          <fptr EndPN="00000259" StartPN="00000258"/>
        </Paragraph>
        <Paragraph CONTEXT="rolt;iRSranhKc}!ontod;这tl！亡7Rfi;pia数t4i3'P一。1whilc(pNI{LI.RfiIrKcy!·SranhhcP几P一＞link;" ID="20">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="1“‘拼，NLll.）rcwmKt:l.lPtfC'1、全91tfif，1‘illclscrrtump;/Itc于龙}lufil°It.:ittttY111I基于链地址法哈希表的插入，{F:地fltttl;fi&lt;a‘fr'若t't不丁，】关ifC'fJSc:uchKr）(f7i己:rf;s入ti记录ChainKxlc.lu‘二{mtri-SaucllKcyaumud;p=a(iHhilt.fp！NULLRAC.p一＞KcySrarchKcv)irE对fN的i连k中在1龙关讹-为Sc万ct、K叮的记录prc-r:" ID="21">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="lt=It-二、lanl" ID="22">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
        <Paragraph CONTEXT="ifip，二Nlil.l未众找xJ时fi人1'cl己录（l’对应的链人尾9二nrwChainticxJcy&gt;Kcr=ScarchKcy;9一＞{tnk-NULL;ill：川＝=NUI.I冲】二，I：116.1针寸插八1、1(L’IsprN&gt;hnk闪;f.iyiilfrfi人后续1已录rcrumUK:rru人新,r返rrlrctun.ERROR；11长Jl‘人返4'I（已f子f！" ID="23">
          <fptr EndPN="00000259" StartPN="00000259"/>
        </Paragraph>
      </div>
      </div>
      <div ORDERLABEL="00000259" TITLE="习题九" TYPE="Chapter">
      <fptr LogicalPageNum="259" PhysicalPageNum="259"/>
      <Paragraph CONTEXT="1.若顺序表中的记录是有序排列的，试给出相应的顺序查找算法，并分析在查找成功或查找失败时的平均查找长度。么将二分查找算法改写为递归的形式。" ID="1">
        <fptr EndPN="00000259" StartPN="00000259"/>
      </Paragraph>
      <Paragraph CONTEXT="3.在二分查找算法中。如果做下述改动：" ID="2">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）将law二mid+1改为low=mid;" ID="3">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="C2）将high司nid-1改为high=rnid;" ID="4">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）所给的两种改动。问：在这三种情况下，二分查找算法是否正确？试给出一例加以说明。" ID="5">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="若记录集合采用单链表进行存储，给出相应的二分查找算法。" ID="6">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="在分块查找过程中，如果索引表采用二分法进行查找，顺序表采用顺序法进行查找，给出相4.5.应的算法。" ID="7">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="7.已知一个长度为12的线性表【Dec，F七b，Nov，oct，Iunc，SePt，Aug，APr，May，July，J朋，Mar｝" ID="8">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）按各元素的顺序构造一棵二叉排序树；" ID="9">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）若各元素的查找概率相等，给出该二叉排序树的平均查找长度。" ID="10">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="8.从空树开始，给出按以下次序向一个深度为2的3阶B树上插入关键字20，30，50，52，60，" ID="11">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="68，70的建树过程。" ID="12">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="给出在上题所建的树中删去关键字50和68的过程。.如果哈希表采用开放定址法解决冲突，并应用线性探铡再郁咧的方法，试给出相应的插人9.10.算法。" ID="13">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
      <Paragraph CONTEXT="11.对于第7小题所给的元素序列，若采用哈希函数H因＝【UZI（其中1为元素的第一个字母在字母表中的序号肥它们映射到区间。一16中，并采用链地址法解决冲突，给出相应的哈" ID="14">
        <fptr EndPN="00000260" StartPN="00000260"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="在前几章中我们讨论了各种线性和非线性的数据结构，而在这一章中，我们将研究在实际应用中大量使用的用于数据查找的数据结构―查找表。" ID="1">
      <fptr EndPN="00000237" StartPN="00000237"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="00000261" TITLE="第十章  文件" TYPE="Chapter">
    <fptr LogicalPageNum="261" PhysicalPageNum="261"/>
      <div ORDERLABEL="00000261" TITLE="10.1  外部存储设备" TYPE="Chapter">
      <fptr LogicalPageNum="261" PhysicalPageNum="261"/>
        <div ORDERLABEL="00000261" TITLE="10.1.1  磁带" TYPE="Chapter">
        <fptr LogicalPageNum="261" PhysicalPageNum="261"/>
        <Paragraph CONTEXT="磁带作为一种大容量、低价格、高可靠性的存储介质，目前仍然被广泛使用。磁带是一种" ID="1">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="顺序存储设备。磁带机一般由磁带、读i写磁头和磁带驭动器组成。使用时，磁带装在磁带机" ID="2">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="上，磁带驱动器带动磁带正转或反转，同时通过读泻磁头对磁带进行读泻操作.如图lo.l.l" ID="3">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="石片ter.,sicrt:" ID="4">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="磁带格式一般有E/4英寸、112英寸、4MM.SMM等，容量从60M旧到70GB。磁带带面上涂有磁性材料，可以用来存储二进制位。整个带宽被划分成7道或9道，每道存储一位二进制位，所以每横排可以存储7位或4位二进制信息。每英寸磁" ID="5">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="带上存储的位数也称作磁带的密度，常见的密度有80(lbpi或图10,1,1磁带机的运转160f}bpio" ID="6">
          <fptr EndPN="00000261" StartPN="00000261"/>
        </Paragraph>
        <Paragraph CONTEXT="在磁带上读了写一块数据所需要的时间为：其中，‘为延迟时间，即磁头到达传输信息所在物理块起始位置所需时间；t,为传输一个字符所需时间；n为块中的字符数。从公式中可以看到，延迟时间影响到整个的存取时间，而延迟时间依赖于磁头当前位置与所要读刀写的块所在位置之间的距离，若磁头当前位置在第一个工G，要读泻最后一个块，延迟时间就很长，要是读泻第二个块，延迟时间就非常短了。" ID="7">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000262" TITLE="10.1.2  磁盘" TYPE="Chapter">
        <fptr LogicalPageNum="262" PhysicalPageNum="262"/>
        <Paragraph CONTEXT="也可以直接存取，它的存取速度要比磁带快得多。磁盘的盘面被划分成若干磁道，每个磁道又" ID="1">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
        <Picture URL="00000262\00000262_new\0003.jpg">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Picture>
        <Paragraph CONTEXT="每个盘片有两个面。硬盘中的盘片组，最上面一面和最下面一面一般不用。$Picture[00000262\00000262_new\0006.jpg]Picture$盘片套在一个主轴上，并绕主轴作高速旋转.当磁道通过磁头时，就可以对该磁道进行诩写操作。硬盘可以分为固定头硬盘和活动头硬盘。固定头硬盘在每一个磁" ID="2">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
        <Paragraph CONTEXT="f。1。S,JJ" ID="3">
          <fptr EndPN="00000262" StartPN="00000262"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000263" TITLE="10.1.3  光盘" TYPE="Chapter">
        <fptr LogicalPageNum="263" PhysicalPageNum="263"/>
        <Paragraph CONTEXT="标准的CD-RUM盘片直径为l20毫米，共有三层：①聚碳酸醋材质的透明衬底；②铝反导人区、用户数据区和导出区。这三个区都含有物理光道，即连续的阿基米德螺旋线形光道。三个区中的所有物理光道组成了信息区。在信息区，有些含有信息的光道称为信息光道。理光道的一部分，或是一条完整的物理光道，也可以是由许多物理光道组成。" ID="1">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="在导人区、用户数据区和导出区这三个区中，都有信息光道。导人区只羊导人区只有一条信息光道，称为导人光道；导出区也只有一条信息光道，称为导出光道。用户数据记录在用户数据区中的信息光道上。" ID="2">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="对光盘的读取，有以下几种方式。" ID="3">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)恒定线速度。这是早期低速光驱所采用的方式，当读泻光盘数据时，以恒定的线速度对光道操作。那么，对内圈操作时，主轴转速较快，对外圈操作时，转速较慢，采用不同的角速度实现恒定的线速度。在这种方式下、无论伽写光盘上的哪一部分数据，都会得到相同的" ID="4">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="数据传输率。随着光驱速度的提高，为保持恒定的线速度，主轴电机旋转速度要随时变化，不但技术难度较大，而且电机负担加重，造成光驱寿命减短。并难以保证整体性能提升，因此单" ID="5">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="一的恒定线速度被淘汰。" ID="6">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）恒定角速度。这种方式的技术难度相对恒定线速度而言，大大降低。由于光盘以恒" ID="7">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="定角速度旋转，所以光盘内圈的数据传输率比外圈的数据传输率低。" ID="8">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）局部恒定角速度。就是是将恒定线速度与恒定角速度合二为一，在读内圈时采用恒定角速度模式，转速不变读速逐渐提高，当读取半径超过一定范围则采用恒定线速度方式。" ID="9">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）将CD的内圈到外圈分成若干个区域，在每一个区域用恒定线速度速度进行读写，在" ID="10">
          <fptr EndPN="00000263" StartPN="00000263"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="00000263" TITLE="10.1.4  闪存" TYPE="Chapter">
        <fptr LogicalPageNum="263" PhysicalPageNum="263"/>
        <Paragraph CONTEXT="在对存储器进行重新编程之前需要对块或整片进行预编程和擦除操作。一般来说，一个块的擦写时间为IOOms到几秒，读一个字节约为100ns，写一个字节用10-20mso很多产品以闪存作为基本存储单元，再加上IDB.PCMCIA或者USB接口控制电路，可以像使用磁盘一样直接使用它们。典型的有DiskOnModal(DDMI、DiskOnChip(DOC）和优盘等。DOM的读逮度一般不低于2MBls，写速度一般不低于1MB/soDQ（二的读速度一般不低于" ID="1">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="2MBlso" ID="2">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="la.z基本概念下面先介绍有关文件的一些基本概念。" ID="3">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="I。数据项数据项是文件中可处理的数据的基本单位，不能再分解了。记录是由一个或多个数据项按照一定的目的组合而成的数据项的集合。丁" ID="4">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="3.文件文件是由多个性质相同的记录组合而成的集合。如表102.1中，文件是由5条记录组成的，每条记录又是由学号、姓名、性别、系别和年龄这几个数据项组成。" ID="5">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="4.关健字在文件中，如果某个数据项能够惟一地标识不同的记录，称为关键字。一个文件中可以有多个关键字，可以指定一个为主关键字，其余的为候选关键字。关键字可以是一个数据项，也可以是多个数据项的组合，后一种情况称为复合关键字。" ID="6">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="在有些文件中，每条记录的结构和长度都是一样的，称为定长记录，由定长记录构成的文" ID="7">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="件叫做定长文件。如果在表10.2.1的文件中再增加一个备注数据项，并且指定最大宽度为100个字符，且只有“卢林”有备注内容如个字符.其余记录都没有备注内容，在这种情况下，如$Picture[00000264\00000264_new\0025.jpg]Picture$果再采用定长文件，就有些浪费空间，所以可以定义一个不定长文件来保存这些数据。在不定长文件中，每条记录的长度不一定相等。文件操作主要有两种，即查询和修改。" ID="8">
          <fptr EndPN="00000264" StartPN="00000264"/>
        </Paragraph>
        <Paragraph CONTEXT="在a10到azo之间的记录。" ID="9">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）函数查询：给定关键字的某个函数进行查询，如在表10.2.1表示的文件中查询年龄小于平均年龄的记录。" ID="10">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）布尔查询：把前三种查询用布尔运算组合起来的查询，如在表]0.2.1表示的文件中查询学号在asa到IOa之间并且年龄大于22岁的记录。" ID="11">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="6.修改操作" ID="12">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="修改操作包括插人记录、删除记录和更新记录。对文件的操作可以分为实时操作和批量操作两种。" ID="13">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="7.实时操作" ID="14">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="在实时操作方式下，当提出请求后，系统必须立即进行响应和处理，对应答时间有严格要求，系统一般应在几秒钟之内完成操作。如股票交易系统，当用户数据输人进去之后，本地系统必须及时进行处理，及时传递到交易所进行撮合，如果本地系统处理不及时，就有可能造成巨大损失。" ID="15">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
        <Paragraph CONTEXT="8.批量操作记账凭证后，并不要求马上将其记账，而是当输人一批凭证后，再一起记账。指文件在存储介质上的组织方式。常见的组织方式有顺序文件、索引文件、索引顺序文件、散列文件、倒排文件等。" ID="16">
          <fptr EndPN="00000265" StartPN="00000265"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="计算机的存储设备一般可以分为外部存储设备（外存）和内部存储设备（内存）。内存的存取速度快，cru可以直接访问，但容量比较小，一般数据不能长久保存〔例如，停电则数据丢失）。外部存储器有随机存储设备，也有顺序存储设备，数据能长时间地存储在相应的存储介质上。外部存储器容量大，但存取速度相对于内存来说要慢得多.，一般可以忽略内存的存取" ID="1">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
      <Paragraph CONTEXT="时间，而外存储器的存取时间必须认真考虑。" ID="2">
        <fptr EndPN="00000261" StartPN="00000261"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000264" TITLE="10.2  基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      </div>
      <div ORDERLABEL="00000265" TITLE="10.3  顺序文件" TYPE="Chapter">
      <fptr LogicalPageNum="265" PhysicalPageNum="265"/>
      <Paragraph CONTEXT="将记录按其在文件中的逻辑顺序依次存人存储介质而建立的文件称为顺序文件。顺序文lA-臼6br血扣rhf+i,署渔?sF苗6&amp;＿3ihzf;a若落fitr.叨格hftrI3t3nx口1ift良J.＿frbhirn里们币良fi币·产卜+如果顺序的两个物$Picture[00000266\00000266_new\0003.jpg]Picture$新主文件图10.3.顺序文件如图1{1.3.1所示，原主文件是职工的工资文件，在做工资报表前需要对数据进行修改，修改内容如待办文件所示，待办文件根据编号排序。操作过程如下：读出待办文件的第一条记录，赋予变量D，读出原主文件的第一条记录，它的编号小于D的编号，所以这条记录原样复制到新主文件中；再读出原主文件的下一条记录，它的编号等于D的编号，执行更新操作，把这条记录的工资增加94后复制到新主文件中；然后读出待办文件的下一条记录，再赋予变量D," ID="1">
        <fptr EndPN="00000266" StartPN="00000265"/>
      </Paragraph>
      <Paragraph CONTEXT="形成一条新记录，并复制到新主文件中，再把从原主文件中读出的记录复制到新主文件中；然后读出待办文件的下一条记录，再赋予变量D，再读出原主文件的下一条记录，它的编号等于D的编号：执行删除操作，即不向新主文件复制任何内容；再读出原主文件的下一条记录，复制到新主文件；最后.新主文件的内容就是所需要的数据。对于磁带1F文件只能顺序查找，其平均查找长度为n(n+1)12,n为文件中记录个数。对于磁勿顶序文件，也可以采用分块查找或二分查找，但如果文件很大，存储在多个柱面上时，二分查找将会引起磁头的来回移动，反而可能会降低查找的效率。" ID="2">
        <fptr EndPN="00000266" StartPN="00000266"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000266" TITLE="10.4  索引文件" TYPE="Chapter">
      <fptr LogicalPageNum="266" PhysicalPageNum="266"/>
      <Paragraph CONTEXT="借助索引文件，可以提高查询操作的效率。$Picture[00000267\00000267_new\0002.jpg]Picture$$Picture[00000267\00000267_new\0003.jpg]Picture$图14.4.1索引文件索引文件的查询方式为直接存取或按关键字查询。步骤如下：因为索引表一般比较小，所以首先把索弓｝表读人内存，在索引表中查找，如果有所要找的记录，则进行第二步，根据索引项的指示在外存上读取该记录；否则表明不存在该记录。查询过程中，最多访问两次外存：读索引，读记录。剧除一个记录时，只用删除索引表中相应的索引项即可。插人记录时.将记录添加到数据区的尾部，同时在索引表中相应的位置插人索引项。如果记录很多，相应的索引表也会变大，可能无法一次将整个素引表读入内存，可以把整表明某一块中的最大记录号。指针指向块中第一个索引项的地址。在这种方式下，查询数据最多要访问三次外存，但在数据量大的情况下还是很有用的。" ID="1">
        <fptr EndPN="00000267" StartPN="00000266"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000267" TITLE="10.5  索引顺序文件" TYPE="Chapter">
      <fptr LogicalPageNum="267" PhysicalPageNum="267"/>
      <Paragraph CONTEXT="记录的物理顺序按关键字的顺序存放的索引文件叫做索引顺序文件。对这类文件可以采门口石七书企沪必，刁匕d、川匕鹅奎孕分月毕盆1该柱面的磁道索引，这里的磁道索引是指为该柱面的不同磁道建立的索引。在同一个柱面内部，数据又是按盘面的次序顺序存放，所以又可以为同一柱面的不同磁道再建立一个索引。每个索引项由基本索引项和滋出索引项组成，每一部分又都包括关键字和指针。基本索引项的关键字表示该磁道中最后一个关键字的值（该磁道中的最大关键字），指针指向该做道第一个" ID="1">
        <fptr EndPN="00000268" StartPN="00000267"/>
      </Paragraph>
      <Paragraph CONTEXT="记录的位置。滥出索引项的关键字表示该磁道滋出区中记录的最大关键字，指针指向该磁道" ID="2">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
      <Picture URL="00000268\00000268_new\0006.jpg">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Picture>
      <Picture URL="00000268\00000268_new\0007.jpg">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Picture>
      <Picture URL="00000268\00000268_new\0011.jpg">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Picture>
      <Paragraph CONTEXT="#FUi+klll$Picture[00000268\00000268_new\0013.jpg]Picture$#F1uCn1二二二图ID.S索引顺序文件" ID="3">
        <fptr EndPN="00000268" StartPN="00000268"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000269" TITLE="10.6  直接存取文件" TYPE="Chapter">
      <fptr LogicalPageNum="269" PhysicalPageNum="269"/>
      <Paragraph CONTEXT="利用杂凑（Hash）技术组织的文件称为直接存取文件。它的特点是利用一个散列函数，劳记录的关键字产生记录的地址。它主要使用于关键字范围分布广泛，而实际关键字取值根据记录的关键字产生记录的地址。的数目又很小的数据集，如某文件记录的关键字的取值范围是从40Q001到892789，而实际记录个数只有1893个，经杂凑函数散列到磁盘上的记录成组存放，每组有若干个记录，构成一个存储单位，称为捅。如果一个桶能够存放m个记录，即m个散咧地址相同的记录可以存放在同一个桶中，这的办法是把这条记录放到另一个桶中，这个捅称为溢出桶。滋出桶大小和基桶相同，相互之间用指针连接。为了节省查找时间，基桶和滋出桶的物理位置应尽可能近。由于分配是随机进a二［[n/m]iba叫做装载因子，一般a的值在0.8与0.9之间。T=a(4+乌)其中，a为存取桶数的期望值，对链地址处理滥出来说，awl十a/2;t为存取一个桶所孺要的时间八为在内存中顺序查找一个记录所需要的时间。删除记录时，只用在被删除的记录上做一个姗除标记即可。直接存取文件的优点是存取速度快，插入、删除方便，无需索引，节省空间。缺点" ID="1">
        <fptr EndPN="00000269" StartPN="00000269"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="00000269" TITLE="10.7  倒排文件" TYPE="Chapter">
      <fptr LogicalPageNum="269" PhysicalPageNum="269"/>
      <Picture URL="00000270\00000270_new\0001.jpg">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Picture>
      <Picture URL="00000270\00000270_new\0002.jpg">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Picture>
      <Picture URL="00000270\00000270_new\0003.jpg">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Picture>
      <Picture URL="00000270\00000270_new\0004.jpg">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Picture>
    </div>
      <div ORDERLABEL="00000270" TITLE="习题十" TYPE="Chapter">
      <fptr LogicalPageNum="270" PhysicalPageNum="270"/>
      <Paragraph CONTEXT="1.简述磁带文件、磁盘文件的特点。" ID="1">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="2.假设有一个书籍管理文件.有这些数据项：编号、书名、购买日期、单价、出版社，创建一个" ID="2">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="2.的数量。在上题的文件中输人八条记录，写出其倒排文件结构。3.4.光盘驱动器在读取光盘数据的时候，除了可能采用恒定线速度的方法，还可能采用什么方法？它们各有什么特点？对于第二题所描述的数据，编写程序，在录人数据的同时，按照书名建立索引文件，然后根" ID="3">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="5." ID="4">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="据索引文件实现按照书名查询的功能。" ID="5">
        <fptr EndPN="00000270" StartPN="00000270"/>
      </Paragraph>
      <Paragraph CONTEXT="一、线性表目的：构建顺序表，并完成顺序表中数据元素的插人和侧除。内容：建立包含至少10个数据元素的带表头结点的顺序表，在第k个数据元素之后擂人一个新数据元素；删除第x个数据元家。实验二单链表的建立、插入和删除目的：构建单链表，并完成键表中数据元素的插人和删除。新数据元素；删除第k个数据元素。实验三单链表的逆向目的：完成单链表中数据元素的逆向。要求：给出程序及逆向单链表结果。二、栈与队列目的：初始化一个顺序栈，完成数据元素的人栈和出栈。内容：初始化一个顺序栈，并从键盘输人若干数据元素，完成数据元素的进栈；从栈中逐个地将数据元素出栈。" ID="6">
        <fptr EndPN="00000271" StartPN="00000271"/>
      </Paragraph>
      <Paragraph CONTEXT="二、毕目的：字符串以顺序方式存储，求一子串。内容：给出包含7A个字符的数组，求出起点为i长度为u的子串。要求：给出程序及子串结果。实验一二叉树构建及前序、中序、后序递归遍历目的：构建一棵二又树.完成前序、中序、后序递归遍历。要求：给出构建程序及遍历结果。实验二二叉树前序、中序、后序非递归遍历目的：用前序、中序、后序非递归方式遍历二叉树。" ID="7">
        <fptr EndPN="00000272" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="内容：对实验一构建的二叉树，用前序、中序、后序方法递归遍历二叉树（堆栈及队列程要求：给出程序及遍历结果。内容：从上至下，从左至右〔从右至左）方式遍历二叉树（堆栈及队列程序自已构建）。实验四分类二叉树的构建及遍历内容：给出10个数据，构建一棵左il大的分类二叉树。要求：给出程序及中序遍历结果。内容：对包含6顶点的以邻接表存储的无向图进行深度优先遍历。要求：给出程序及遍历结果。目的：用Prim算法构造最刁、生成树。要求：给出程序及层次遍历生成树的结果。实验三求图的最短路径目的：用邻接矩阵存储图，求图的单源最短路径。" ID="8">
        <fptr EndPN="00000273" StartPN="00000272"/>
      </Paragraph>
      <Paragraph CONTEXT="内容：对包含8顶点的以邻接矩阵存储的有向图，求图的单源点出发的最短路径。六、数组实验一稀疏矩阵的转里内容：给出10行la列的稀疏矩阵，将存储为三元组，并对转置。要求：给出程序及转置结果。实验一Shell排序内容：给出包含lao个随机数的数组，用shell排序方法（增量序列为：I,3,5,7）对数组中的数据排序。" ID="9">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
      <Paragraph CONTEXT="要求：给出程序及排序结果。" ID="10">
        <fptr EndPN="00000273" StartPN="00000273"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="在实际数据处理中，往往有着大量的数据需要处理。对于各种原始数据、中问数据和最终麟奥＿本很名桔冷下髻尊供杆方祛而寸杜朴具左播粉娜的＿劫基宜素的士吐＊鑫愉" ID="1">
      <fptr EndPN="00000261" StartPN="00000261"/>
    </Paragraph>
    <Paragraph CONTEXT="处理结果.在很多情况下带要进行存储。" ID="2">
      <fptr EndPN="00000261" StartPN="00000261"/>
    </Paragraph>
  </div>
  
</METS>
