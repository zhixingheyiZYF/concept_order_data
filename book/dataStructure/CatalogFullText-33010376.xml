<?xml version="1.0" encoding="utf-8" standalone="no"?>
<METS xmlns:METS="http://www.loc.gov/METS/" xmlns:gdm="http://sunsite.berkeley.edu/GDM/" xmlns:xlink="http://www.w3.org/TR/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" TITLE="Zhejiang University.jdl.China-America digital library project" TYPE="Section" xsi:schemalocation="http://www.loc.gov/METS/http://www.loc.gov/standards/METS/METS.xsd">
  
    <div ORDERLABEL="1" TITLE="第1章  绪论" TYPE="Chapter">
    <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
      <div ORDERLABEL="1" TITLE="1.1  基本术语" TYPE="Chapter">
      <fptr LogicalPageNum="11" PhysicalPageNum="11"/>
      <Paragraph CONTEXT="数据（Data)：描述客观事物的数字、字符以及一切能够输入到计算机中，并且能够被计算机程序处理的符号的集合，即计算机能够加工处理的对象或信息。数据的含义十分广泛，在不同的场合下具有不同的含义。例如一本书、一篇文章、一张图表、一盘录音或录像带等是数据，一个单词、一个算术表达式、一个数值、一个字符等也都是数据。数据元素（DataElement)：数据的基本单位，即数据这个集合中的一个个的客体。在程序中数据元素通常是作为一个整体来被处理的。例如对于一个数据库文件来说，每一条记录就是它的数据元素：对于一个字符串来说，每个字符就是它的数据元素；对于一个数组来说，每一个单元就是它的数据元素。一个数据元素可以由若千个数据项（数据项是数据的最小单位）所组成。例如对于学生简历来说，每一个记录表示一个学生的信息，它是由若干个数据项所构成的，如表1-1所示。由表中可知，一个数据元素由6个数据项所组成，而每个数据项是不可再分解的最小的数据，它分别描述了客体（学生）的某一方面的特征。学号姓名性别爱好身高备注" ID="1">
        <fptr EndPN="00000012" StartPN="00000011"/>
      </Paragraph>
      <Paragraph CONTEXT="20000301.王刚男足球1.73＿盘，＿＿＿主男小提琴1.78‘u&lt;入NJVJ王!J1、7丁止行.J、夕亡布二1.10一，一通－－－－.2《心X）3以南晓飞男舞蹈1.80三好学生数据对象（Dataobject）：具有相同特性的数据元素的集合，是数据这个集合的一个子集。例如，自然数的数据对象是集合｛1，2，3，…｝，而由26个英文字母组成的数据对象则是集合｛A，B，C，D，…，2｝。数据处理（DataProcessing）：是指对数据进行查找、插入、删除、排序、计算、输入、输出等的操作过程，数据结构（Datastructure）：简单而言是指数据元素之间的联系。因为数据是客观世界事物及其活动的描述，而任何事物及其活动都不是孤立存在的，彼此之间必然存在着某种联系。由于这种联系是内在的，或根据人们的需要所定义的，被看作是“逻辑”上的联系，因此，又把数据结构称作数据的逻辑结构或逻辑关系。数据结构在计算机存储器上的存储表示称之为数据的物理结构或存储结构。由于存储表示的方法有顺序、链为了确切地描述数据结构，通常采用二元组表示：DB＝（D，R）" ID="2">
        <fptr EndPN="00000012" StartPN="00000012"/>
      </Paragraph>
      <Paragraph CONTEXT="刀丑是一种数据结构，它由数据元素的有限集合D和刀上二元关系的有限集合R" ID="3">
        <fptr EndPN="00000012" StartPN="00000012"/>
      </Paragraph>
      <Paragraph CONTEXT="所组成。其中n＝｛试｝1续1〔n，n）0｝R＝｛‘11匀〔m，m）1｝试表示第1个数据元素，。为刀刀中数据元素的个数，特别地，若n＝0，则D是一个空集，故DB也就无结构而言，或者说它具有任何结构；rj表示第j个二元关系（简称关系），m为D上关系的个数。在本书所讨论的数据结构中，只讨论m＝1的情况，即R＝｛；｝。D上的一个关系犷是有序偶的集合。对于r中的任何一个有序偶对＜x，y＞（x，y任D），把x叫做有序偶对的第一个元素，把y叫做有序偶对的第二个元素。有时，把" ID="4">
        <fptr EndPN="00000012" StartPN="00000012"/>
      </Paragraph>
      <Paragraph CONTEXT="有序偶对的第一个元素称为第二个元素的直接前驱，简称前驱；称第二个元素为第一个巾于同一种逻辑结构可以映射成不同的存储结构，如顺序存储结构或非顺序存储结钩（或称为链式存储结构），因此，数据的存储结构一定要正确地反映出数据元素之间的逻辑关系。" ID="5">
        <fptr EndPN="00000013" StartPN="00000012"/>
      </Paragraph>
      <Paragraph CONTEXT="为了具体说明这一点，一F1'再举一个例子。例如，一个具有20个记录的反映学生家庭地址情况的数据文件，其记录在文件中的先后顺序是按学生学号从小到人排列的，如表i-2所示。" ID="6">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="表1-2学生家庭地址表学号姓名城市街道门牌号199ROR011i(Sj.北s;i1:1Ftit大;f2(199R(IR02张强.1海淮海中路31199ROSO3F健i岛香港中FR.……199ROR20F'军门十｛中山路l9该数据文件中记录之间的逻辑关系是一个线性关系（因此也称该数据文件为一个线;rrrs-n;!4t‘t1-竹*nr,nCII浓f而3r1T01性;tP.口川币良左祛姑构和偏车性表）。对应于这个逻辑结构，在计算机内可以有两种物理结构，即顺序存储结构和链式存储结构。前者用一块地址连续的存储空间依次存放该文件的20个记录，id录物理上的先后关系映射了记录逻辑上的先后关系。也就是说，逻辑上相邻的两个数据元素，其存储位置也相邻。后者则用20个称为链表结点的存储空间分别存放这20个记录，每个结点物理地址上可以不连续，但是通过链指针来映射记录之间的逻辑关系。见图1-1所示。" ID="7">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="图卜l线性链表示意图由此不难想到，在实现某种操作之前，首先需要选择合适的存储结构，而同一种操作在不同的存储结构中实现的方法不同，有的则完全依赖于所选择的存储结构。可见，数据的逻辑结构与存储结构是紧密相联的两个方面。综上所述，数据结构所要研究的主要内容，可以简单地归纳为以F3个方面：(l）研究数据元素之间固有的客观联系（逻辑结构）。" ID="8">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）研究数据在计算机内部的存储方法（存储结构）。" ID="9">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)研究如何在数据的各种结构（逻辑和物理）上实施有效的操作（算法）。因此，应该说数据结构是一门抽象地研究数据之间结构关系的学科。" ID="10">
        <fptr EndPN="00000013" StartPN="00000013"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="4" TITLE="1.2  算法的概念" TYPE="Chapter">
      <fptr LogicalPageNum="14" PhysicalPageNum="14"/>
      <Paragraph CONTEXT="数据结构，歹算法之间存在着密切的联系。算法的结构设计和选择，在很人程度上依赖于作为其华础的数据结构，即数据结构为算法提供一i'上具，而算法则是应用这些工具来具体解决问题的方案。凡是从事过程序设计的人都会有这样一个体会：程序设计过程中有相当多的时间花费在构思算法上，一以有了合适的算法，用具体的程少笋设计语言来实现（编写程序）并不是一件很困难的事情。有个著名的观点是：算法＋数据结构二程序。从这个角度_1：说.要设计出一个好的程序，在很人程度上取决于设计出一个好的算法。算法（Algorithm）是对特定问题求解步骤的一种描述，是用来解决某个问题的一些指令的集合。它是指令的有限序列，其中每一条指令表示一个或多个操作。由此可以说，程序就是用计算机语一言表述的算法，流程图就是图形化的算法，甚至一个公式也可以l1L算法。在计算11领域，一个算法实质上是根据所处理问题的需要，在数据的逻辑结构和物理结构的基础上施加的一种操作。由于数据的逻辑结构’歹物理结构不是唯一的，在很大程度土可以由设计人员进行选择和设宝十，因而处理同一个问题的算法也不一定是唯一的；即使具有相同的逻辑结构与物理结构，但如果设计思路和技巧不同，设一计出来的算法也不会相同。显然，根据数据处理的需要，为所处理的数据选择合适的逻辑结构与物理结构，进而设计出比较满意的算法，是学习数据结构这门课程的主要目的。作为一个完整的算法，应该满足下面5个标准，通常称之为算法的基本性质：确定性算法中的每一条指令必须有确定的含义，不应该产生二义性，即不允许出现不同的人对一于每个指令有不同理解的情况。并且，在任何条件卜，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输tf;o有穷性一个算法必须在执行有限的步骤之后结束，并且每一步骤也都必须在有限的时间之内完成。可行性算法中描述的每一个操作，都可以通过己经实现了的基本运算，执行有限次后来完成。输入一个算法有零个或若干个输入，这些输入都来白于某一特定的对象的集合。" ID="1">
        <fptr EndPN="00000014" StartPN="00000014"/>
      </Paragraph>
      <Paragraph CONTEXT="输出一个算法有一个或多个输出。算法还有一个重要的方面，就是构成这个算法所依据的方法（公式、方案、准则）。有许多问题，只要对数据对象进行细致的分析，就能确定处理方法，有一的问题则不然。不过，作为寻找设计思路的基本思想方法，对任何算法设计都是有用的。这些方法通常有枚举法、归纳法、递归法等等。算法独立于具体的计算机与具体的程序设计语言。在设计一个算法时，应选择一种合适的方式来表达算法思想，或者说，有了解决问题的算法思想，应选择一种合适的语4言来描述算法的各个步骤。在计算机发展的初期，人们往往用自然语言来表达自己的算法思想。一卜面看一个简单例子。例如，判断正整数M和N哪个大。可表达为：UOM减N，将差值赋给,时变量R②判断R是否为零。(a）若R等于零，则IL;和N一样大。(b）若R大于零，则M大于No(c）若R小于零，贝，1M-1、于N,类似的简单问题用自然语言表达还是可以的，但很快就会发现，采用自然语言描述很不一方伸.巾不盲观.雨谈不卜有自奸的可律阵.稍微复杂一些的登注就难以夫算法很不方便，也不直观，更谈不上有良好的可读性，稍微复杂一些的算法就难以表达，甚至无法表达。另外，由于自然语言本身的一些限制，用它描述的算法可能会出现些，但依然没有解决复杂算法的表达问题，而且移植性也不好。图i-z'al断正整数M和N哪个大的流图如果算法直接采用某种具体的程序设计语言来描述，则将受到具体语言语法细节的限制（如繁琐的变量说明、语句的书写规则等等）。本书在进行算法描述时，采用“类C语言”作为工具。所谓类C语言就是在ANSIC语言的基础上所做的取舍，它忽略了ANSIC语言中语法规则的一些细节，描述出的算法清晰、直观，便于阅读和分析。这样书写的算法，虽然不能直接在计算机上执行，但经过稍加修改和补充，就很容易变成计算机所能执行的程序了。" ID="2">
        <fptr EndPN="00000015" StartPN="00000014"/>
      </Paragraph>
      <Paragraph CONTEXT="对于上面的问题，用类C语言描述的方法为：" ID="3">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="voidComp(intM,intNJ" ID="4">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="5">
        <fptr EndPN="00000015" StartPN="00000015"/>
      </Paragraph>
      <Paragraph CONTEXT="R二H-N；elseif(R&gt;0)printf(&quot;M&gt;N&quot;elseprintf(&quot;M&lt;N&quot;｝" ID="6">
        <fptr EndPN="00000016" StartPN="00000015"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="6" TITLE="1.3  算法描述" TYPE="Chapter">
      <fptr LogicalPageNum="16" PhysicalPageNum="16"/>
      <Paragraph CONTEXT="本书采用的“类c语言”是ANSIC语言的一部分。以下作简要说明。(I)预定义常量#defineTRUE1#defineFALSE0" ID="1">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)数据元素类型约定为elemtype，同学们在使用该数据类79时自行定义。" ID="2">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)基本操作的算法用以下形式的函数描述：函数类型函数名（函数参数表）｛／＊算法简单说明＊／语句体；" ID="3">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="4">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）赋值语句变量名二表达式；变量名［］＝表达式：" ID="5">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）条件语句条件语句1if（表达式）语句体：条件语句2if（表达式）语句体；" ID="6">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(6）循环语句for（赋初值表达式序列：条件：修改表达式序列）语句体：while（条件）语句体；do" ID="7">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="语句体；}while（条件）：" ID="8">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(7）结束语句函数结束语句return表达式：异常结束语句exit（异常代码）：6" ID="9">
        <fptr EndPN="00000016" StartPN="00000016"/>
      </Paragraph>
      <Paragraph CONTEXT="(8)输入和输出语句输入语句scanf([格式串l，变F-i.1，变量2,，变量n输出语句printf([格式串〕，表达式1，表达式2,，表达式。）：" ID="10">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="(9)逻辑运算逻辑“与”对，f.A＆＆B，当A的值为0时，不再对a求值。逻辑“或”对于al1a,°'A的值为非0时，不再对a求值。" ID="11">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="(10）符号和函数符号LX」表示不大-X的最大整数，如L2.7J=2.符号［Xl表示不小于二的最小整数，如x3.11=4:m%n表示m对。取模。" ID="12">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="(11）注释单行或多行注释／，说明文字＊／单行注释，’／说明文字" ID="13">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="7" TITLE="1.4  算法分析" TYPE="Chapter">
      <fptr LogicalPageNum="17" PhysicalPageNum="17"/>
        <div ORDERLABEL="8" TITLE="1.4.1  时间复杂度" TYPE="Chapter">
        <fptr LogicalPageNum="18" PhysicalPageNum="18"/>
        <Paragraph CONTEXT="一个程序在计算机中运行时，它所花费的时间与许多因素有关，其中最主要的因素有：(）问题的规模n，例如，是求io个数相加还是求iooo个数相加。" ID="1">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）编译程序所产生的机器代码的质量。" ID="2">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）机器执行一条指令的时间长短。" ID="3">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）程序中语句的执行次数。一般情况下，前三个因素与计算机系统的硬件、软件以及要解决的问题有关，也就是说，不同的计算机系统可能会产生不同的结果，只有第四个因素直接与算法有关。因此，通常的做法是，把算法中语句执行的次数作为算法时间多少的度量。知道了解决同一个问题的两个不同算法的语句执行次数，就可以比较出它们的时间复杂度。这种把语句执行次数的多少作为算法时间度量的分析方法称为频度统计法。一条语句的频度（FrequencyCount）就是指该语句被执行的次数。而整个算法的频【例1-11对n个数累加求和的算法做时间复杂度分析。算法A：累加求和intsum(intA(1，intn)／＊A表示一维数组，n表示数组的大小＊／｛" ID="4">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)s二0＊给累加变.s赋初值＊／Ofor(i二1:i＜二n;is二s+A(i/＊进行累加求和＊／" ID="5">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="（3）returns：／＊返rp值＊／｝计算机执行这个算法时，第（1)步和第（3)步都只需要一次赋值操作。为了分析第（2）步语句的频度，可改写为：" ID="6">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="i二1;first:ifi&gt;nthengoto1ast:s二s+A[ii二i+1:" ID="7">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="gotofirst:" ID="8">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="last:returns;" ID="9">
          <fptr EndPN="00000018" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="8把各条语句的执行次数加起来，就得到了算法中所有语句的频度之和，即为4n+2整个算法的语句的频度若用f(n）表示，有f(n)=4n+2当。一co时，f(n)jn成正比。丁二是，引入一个符号。‘英语单词Order的第一个字母的大写，读“.人欧”），记为f(n)=0(n)表示’J介，，足够人时，该程序的运行时间的度量jn为同一个数量级，或者说，运行时间F1n成正比。riii给出求。的一个IIY:格的数学定义。若n足够人，有吵斋一常”／。则称函数f(n）与g(n）同阶：或者说，f(n）与g(n）为同一个数量级，记作f(n)=O(g(n))土式即表示算法的时IJ复杂度（TimeComplexity)，其#1n为问题规模（人小）的度量。算法的时间复杂度采用数量级的形式表示后，将给其求解带来很大的方便。这时只需要分析影响一个算法运行时间的主要部分（如循环语句）即可，不必对每一步都进行详细的分析：同时，最主要部分的分析也可简化，一般只要分析清楚循环体内“语句执行次数”即可。例如对于算法A，只要根据第（2)步的循环次数就可求出其时间复杂度为O(n)a" ID="10">
          <fptr EndPN="00000019" StartPN="00000018"/>
        </Paragraph>
        <Paragraph CONTEXT="算法B：矩阵相加" ID="11">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="voidmatrix(A,S,C,n)" ID="12">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="A,B,C分别为n阶矩阵，A,B表ij&lt;个加数，C表示和＊／｛" ID="13">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="for(i二1;i＜二n;i" ID="14">
          <fptr EndPN="00000019" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="f.or(j二1：j＜二n：〕＋＋）C[i][j]二Alillj］＋B［1］tj］：｝对于上述算法B，只要弄清楚双重循环内语句的频度值为尸，就可求出其时间复杂X为0IZ)表卜3给出了各种有代表性的g(n）函数的算法在不同n值时的运行时间。表中凡未注明单位的时间单位均为L''秒（10一“秒）。因算法的实际运行时间随机器而异，所以此表土的时间主要用于相互比较。表1-3算法的运行时间与g(n）函数和n的关系g!n)Loginnnlog2nnzn3ns2&quot;n!n二204.32086.44008秒3.2秒1.05秒771世纪n=405.340213160064毫秒1.7分12.72.59x10'世纪n二605.9603543600216秒13分366纪2.64x10“世纪从表中可以得出两点结论：" ID="15">
          <fptr EndPN="00000020" StartPN="00000019"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)当g(n）为对数函数、幂函数或它们的乘积时，算法的运行时间是可以我们称这些算法为有效的算法；当g(n)为指数函数或阶乘函数时，算法的运行时间随着n而迅速增长是不可接受的，我们称这种算法是“坏”的算法或无效的算法。" ID="16">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）随着n值的增大，各种g(n）函数所对应的运行时间的增长速度大不相同，足够大时，对于各种不同数量级的g(n）函数，其时间复杂度存在着下歹d关系：O(login)&lt;O(n)&lt;O(nlog,n)&lt;O(n=)&lt;····O(2&quot;)&lt;O(n!)一个算法的时间复杂度除了与问题的规模n有关外，还与输入的具体数据以及数据的输入次序有关。当输入的具体数据及次序不同时，其算法的时间复杂度也可能不同。所以，当计算一个算法的时间复杂度时，还要考虑到具体数据输入时的各种可能情况。【例1-2】一维数组A[n]中查找值等于给定值K的算法为：int1ocate(A[nI.K)｛／＊查找成功时，返回对应的下标；查不到时，返回一1值＊／U)i二Os" ID="17">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)while((i＜二n-1）＆＆（Ali］：二K))主十十；" ID="18">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)if(i&gt;n-1)return-1:" ID="19">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturni;｝此算法的时间复杂度主要取决于第（2)步的比较次数（即循环次数加1)，而比较次数不是固定的，它与具体的数据输入有关。当元素A[01等于给定值K（即最好情况）时，只要进行一次比较，则其时间复杂度为O(1)即不随n的大小而改变）：当没有任何元素等于给定值时（即最坏情况），表明查找失败，需要进行n次比较，则其时间复杂度为O(n)：当考虑到数组A中每个元素都有相同的概率（即为1/" ID="20">
          <fptr EndPN="00000020" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="(n+1))，则平均比较的次数为：n+12所以，从平均情况看，时间复杂度为口n)o以后分析一个算法的时间复杂度时，一般考虑平均和最坏这两种情况。对于最坏情况，通常比较容易求出；对于平均情祝，往往需要概率统计等方面的数学知识，进行严格的理论推导后才能求出。为了简化起见，我们一般不作理论上的推导，而是直接给出" ID="21">
          <fptr EndPN="00000021" StartPN="00000020"/>
        </Paragraph>
        <Paragraph CONTEXT="‘士；入，不扮十诀＋J二＿/、全匀户7士j尔,t5f二习乏拭了有1县叔万袄f翻IJ法夕异一&quot;r!t日汁I'F11牺fff!t断-fuF%Tt'" ID="22">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
        <Paragraph CONTEXT="结论。不过，对于一个算法来说，往往是相同的。" ID="23">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="11" TITLE="1.4.2  空间复杂度" TYPE="Chapter">
        <fptr LogicalPageNum="21" PhysicalPageNum="21"/>
        <Paragraph CONTEXT="和算法的时间复杂度类似，空间复杂度是衡量算法所需存储单元的量度，记作S(n)=0&lt;g&lt;n其中n为问题的规模。一个算法在计算机的存储器上所占用的存储空间包括：存储算法自身所占用的空间，如存储自身的指令、常量、变量等占用的空间.存储算法的输入／输出数据所占用的空间。算法在运行过程中临时占用的额外空间。输入／输出数据所占用的存储空间是由所解决的问题决定的，不随算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长度成正比，要压缩这方面的存储空间，就必须编写出较简练的算法。算法的空间复杂度比较容易计算，包括局部变量（即算法范围内定义的变量）所占用的存储空间和系统为实现递归（如果算法是递归的话）所使用的堆栈空间两个部分。" ID="1">
          <fptr EndPN="00000021" StartPN="00000021"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="对同样一个问题，不同的人能够写出不同的算法。对算法进行分析，可以从解决同一个问题的不同算法中，选择出较为合适的一个，也能知道如何对现有算法进行改进，从而有可能设计出更好的算法来。算法分析的目的在于改进算法的设计。对一个算法进行评价时，首先要看算法是否正确，这是前提条件。所谓算法的正确性，是指当输入一组合法的数据时，算法能够在有限的时间内，得出正确的结果，而对于不合理的数据输入，也能够给出相应的错误提示信息。通常要验证一个算法是否正确，可以通过输入不同的数据来进行测试，特别是可输入一些极端情况下的数据来进行验证。然而，要从理论上证明一个算法是否正确却不是一件容易的事情。对算法进行分析时，除了要考虑算法的正确性外，还需从以一F三个方面来考察：(i)根据该算法编写出的程序，在计算机中运行时间的度量，即所谓的时间复杂度。它是一个算法运行时间的相对度量。" ID="1">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）根据该算法编写出的程序，占用计算机存储空间的度量，即所谓的空间复杂度。" ID="2">
        <fptr EndPN="00000017" StartPN="00000017"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)其他方面。诸如算法的可读性、‘可移植性、简单性以及容易测试等等。从理论上讲，一个好的算法既不占用很多的存储空间，运行时间又短，并且在其他方面性能也好。然而，实际上时间与空间的占用往往是一对矛盾，因此，十全十·美的算甚至是不存在的。有时候，一个形式上看起来很简单.的算法，其对应的程序的运行要比一个形式上复杂得多的算法花更多的时间，而一个运行时间很少的程序占用的存储空间却很大。在具体设计一个算法时，要综合考虑以上诸方面的因素。" ID="3">
        <fptr EndPN="00000018" StartPN="00000017"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="11" TITLE="1.5  算法设计的基本步骤" TYPE="Chapter">
      <fptr LogicalPageNum="21" PhysicalPageNum="21"/>
      <Paragraph CONTEXT="人们通常习惯于采用修补的方法来设计程序，即先把程序写出来，设法使之运行，" ID="1">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="di/iSt二引阶念L之二；于1击舰卜；丰滚；d、,t:云r才r,1w丁I:i举.rrw室戈才、哟-夕丰;n;十于寸#s弓午r,BL'1然后再修改补充。这种设计方式效率极低。为此，’下凡个阶段来完成。" ID="2">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）明确需求首先应该弄清已知的信息（输入）以及要产生的结果（输出），设法写出一个尽可" ID="3">
        <fptr EndPN="00000021" StartPN="00000021"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）设计算法设计算法时，可以不考虑最终所使用的程序设计语言，只需集中精力解决处理问题的顺序。为了得到一个有效算法，应该了解一些基本的算法设计思想。人们从不同的角度把算法分成一些基本方法，如分治法、动态规划法、递归法等等。究竟选择何种方法，要视具体问题而定。" ID="4">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）算法效率的分析对于己经设计好的不同算法。从时间复杂度、空间复杂度以及其他一些方面进行比较，选择一种好的保留下来。" ID="5">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）算法的实现首先确定所选用的程序设计语言，然后确定数据对象的表示方法，程序中要用到的变量的类型，以及需要多少数组等等，最后将算法改写成计算机可以执行的程序。" ID="6">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(6）程序的测试证明算法正确以后，在将算法改写成程序的过程中，难免出现一些错误，囚此，需要对程序进行必要的测试。测试首先要建立抽样数据，根据抽样数据运行程序，若程序不能正确做出响应，则需要进行调试，找出问题所在，并进行修改。" ID="7">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(7）编写文档资料在设计软件尤其是大型软件时，为了使自己不会忘记当初的设想，并且能使其他人-7SUr-yn1、一71kl.J,7户i刊杯rG4I.l!65卫宝SI7fbl·下矛rLz.W-一口口:fid-A.1tvniA1读懂自己的程序，除了做好必要的注释外，像流程图、正确性证明、测试情况、输入／" ID="8">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="12" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="22" PhysicalPageNum="22"/>
      <Paragraph CONTEXT="1.数据结构是一个二元组（D,R)，其中D,R分别代表什么？" ID="1">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="2.判断题" ID="2">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）数据元素是数据的最小单位。（）C2）数据结构、数据元素、数据项在计算机中的映像（或表示）分别称为存储结构、结点、数据域。（）" ID="3">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）数据项是数据的基本单位。（）/A\另翁YKa'己iv叨lt目.4上*fl.挂.士均友洲示创早，子畏多户少r司配，毒叨右县，亡灰" ID="4">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）数据的逻辑结构是指各数据元素之间的逻辑关系，是用户按使用需要而建立的。（）" ID="5">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）数据的物理结构是指数据在计算机内实际的存储形式。（）" ID="6">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="（6）算法和程序没有区别，所以在数据结构中二者是通用的。（）" ID="7">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="3.简述数据的逻辑结构和数据的存储结构之间的联系。" ID="8">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="4.数据结构研究的主要内容有哪几方面？" ID="9">
        <fptr EndPN="00000022" StartPN="00000022"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)i二1;k二o:while(i＜二n-1){k二k+10*i;i" ID="10">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="11">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)i二1;k二0;n二100;do{k=k+10*i;i}while(i＝二n);" ID="12">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)i二1;j=0;while(i+j＜二n)if（1＞j）j＋＋；elsei" ID="13">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)x二n;n&gt;1Y二0;while(x(y+1)*(y+1y" ID="14">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="(5)m二91;n二loo:while(n&gt;0)if(m&gt;0){m二m-10;n一一；}elsem" ID="15">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="(6)for(i二1;i＜二n;ifor(j二1;ji;jfor(k二1；k（＝j；k＋＋）" ID="16">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="x" ID="17">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="6.设n为大于1的正整数，分析下列程序中的语句总的执行次数。Voidmat(intn)｛for(i二1;i＜二n;ifor(j=1;in;j{a[i][j」二0;for(k=1;i＜二n;k）" ID="18">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="19">
        <fptr EndPN="00000023" StartPN="00000023"/>
      </Paragraph>
      <Paragraph CONTEXT="7.算法与程序有何联系，又有何不同？" ID="20">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
      <Paragraph CONTEXT="8.什么是算法分析？通常从几个主要方面对算法进行分析？14" ID="21">
        <fptr EndPN="00000024" StartPN="00000024"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="在电子计算机发展的初期阶段，人们使用计算机的主要目的是处理数据，解决人们用手工或机械计算机难于胜任的数值计算一。当时所设计的操作对象都比较简单，不外乎是整型、实型和布尔型数据。以此为对象的程序设计称之为数值型程序设计，对应的软件或程序称之为数学软件。随着计算机应用领域的扩大和深入，解决非数值型问题越来越引起人们的关注。例如，银行业、电信业、工商企业等领域管理信息系统的建立，支持多媒体的资料查询、模式识别，图形化用户界面等，解决诸如此类问题使用的数学工具已经不再是分析数学及其计算方法，而是更多地用到离散数学和计算机的有关知识，所涉及的数据也越来越复杂。非数值计算问题的数据元素之间所具有的特定联系，已不能用分析数学的方程式来简单地描述，因而产生了“数据结构”这门学科。本章重点介绍：" ID="1">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
    <Paragraph CONTEXT="基本术语。" ID="2">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
    <Paragraph CONTEXT="算法。" ID="3">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
    <Paragraph CONTEXT="时间复杂度。" ID="4">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
    <Paragraph CONTEXT="算法的表述." ID="5">
      <fptr EndPN="00000011" StartPN="00000011"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="15" TITLE="第2章  线性表" TYPE="Chapter">
    <fptr LogicalPageNum="25" PhysicalPageNum="25"/>
      <div ORDERLABEL="15" TITLE="2.1  线性表的概念和基本操作" TYPE="Chapter">
      <fptr LogicalPageNum="25" PhysicalPageNum="25"/>
        <div ORDERLABEL="15" TITLE="2.1.1  线性表的定义" TYPE="Chapter">
        <fptr LogicalPageNum="25" PhysicalPageNum="25"/>
        <Paragraph CONTEXT="线性表（Linear1ist)：是n,0个具有相同特征的数据元素a.，aZ，…，气＿，，a。的一个有限序列。表中每个元素a‘在表中的位置仅取决于元素本身的序号i。当1&lt;ivt时，a‘的直接前驱为a.a，的直接后继为a。也就是说，除表中第一个元素a.与最后一个元素a。之外，其它每个元素a‘有且仅有一个直接前驱和一个直接后继。n为线性表的长度（ListLength)。当n=0时，称该线性表为空表（EmptyList)o只今1r;-石山珍大tit,生生X.e.st-封班；千月毕ir】产笋-2亡二玲诀+―r二支日n显然，这种结构的特点是数据元素之间存在着一对一的关系，即线性表中的元素在位置上是有序的，第i个元素a‘处在第i-1个元素a。的后面和第t+1个元素ai+：的前面。通常把具有这种特点的数据结构称为线性结构。反之，任何一个线性结构具有相同特性），都可以用线性表的形式表示出来，这里只要求按照元素的逻辑关系把它们顺序排列就可以了。任一个线性表可以用一个标识符来命名。例如，若用标识符List来表示一个线性List=(aa2,…,a-1,a。)线性表中的数据元素在不同情况下可能有不同的具体含义。数学中的数列就是一个线性表，如（19,25,18,32,7)，表中数据元素是十进制整常数。英文字母表（A,B,C,…,Z）也是一个线性表，其元素为单个的英文字母。在稍微复杂的线性表中，一个数据元素可以由若干个数据项组成。例如，一个数据文件可以是由若干条数据记录组成的线性表，表中的数据元素就是单个的数据记录，而主己翻才阮名口轰否下7d」李鱿二z二nr,引罕rya" ID="1">
          <fptr EndPN="00000026" StartPN="00000025"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，学生的学籍档案（见表2-1)中，每个学生的档案是一个数据元素，它由学号、姓名等数据项组成。表2-1学生学籍档案表9906002南晓夏6118788马子良·598779906003马子良·59877；92）……！…" ID="2">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="9例沁1321刘承军6489398关于线性表元素的含义还可以举出不少例子，但有一点是显然的，即同一线性表中的元素必宁具有相同特件.都属干同一元素类型。具有n个数据元素的线性表是一个数据结构Linear－－list＝（D，R）其中：D＝｛a‘la，〔elemtype，1‘1《n，n＞0｝" ID="3">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
        <Paragraph CONTEXT="R＝＝｛N｝N＝｛＜a‘，a‘＋，＞Ia‘，a‘＋.〔D，1‘1‘n-1｝对应的逻辑图如图2-1所示。④《）二K乡长乡申.二只亏" ID="4">
          <fptr EndPN="00000026" StartPN="00000026"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="17" TITLE="2.1.2  线性表的基本操作" TYPE="Chapter">
        <fptr LogicalPageNum="27" PhysicalPageNum="27"/>
        <Paragraph CONTEXT="线性表是一种最简单、最常用并且十分灵活的数据结构。通常情况下，其长度可以进行插入或删除等操作。归纳起来，线性表的基本操作有如下几种：·InitList(List)操作结果：创建一个空的线性表List·ListLength(List)初始条件：线性表List己存在。操作结果：返回List中数据元素的个数。·ListEmpty(List)初始条件：线性表List己存在。操作结果：若List为空表，则返回TRUE，否则返回FALSE.·GetElement(List,i)初始条件：线性表List己存在，1毛i（ListLength(List)操作结果：返回List中第i个数据元素的值。·LocateElement(List,x)初始条件：线性表List己存在，给定值z操作结果：若线性表List中存在和给定值x相等的元素，则返回该数据元素在List中的位置〔位序），否则返回值为0·PriorElement(List,x)初始条件：线性表List己存在，x为List中的一个数据元素。操作结果：若x不是第一个数据元素，则返回x的前驱，否则操作失败。·NextElement(List,x)初始条件：线性表List己存在，x为List中的一个数据元素。操作结果：若x不是最后一个数据元素，则返回x的后继，否则操作失败。·ListInsert(List,i,x)初始条件：线性表List己存在，1延i簇ListLength(List)+1.操作结果：在List中第i个位置之前插入新的数据元素x.、‘飞、。1“。，r二.‘：、·ListDelete初始条件：线性表List己存在且非空，1毛1蕊Lis血吃山〔List）。操作结果：删除List的第1个数据元素。·ClearList（List）初始条件：线性表List己存在。操作结果：将List置为空表。·ListTraverse（List）初始条件：线性表List己存在.由上面的基本操作还可以构成其他较为复杂的操作。例如，通过创建一个空线性表的操作与反复向表尾插入新的数据元素的操作可以建立一个线性表。同理，通过反复执行删除第i个元素的操作，可以删除表中从某个元素开始的连续若干个元素。不难想象，进行上述某些操作（如对线性表进行插入或删除操作）时，在某种存储结构下，会引起一系列数据元素的移动，尤其当线性表的长度很大时，这种移动可能更为显著。因此，线性表的存储结构选择不当，将会使实现这些操作的相应算法的时间、空间效率大大降低。" ID="1">
          <fptr EndPN="00000028" StartPN="00000027"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在本节中，我们将着重讨论线性表的表示方法和它的基本操作，特别强调了数据元素间的逻辑关系。算法是围绕着元素之间的逻辑关系而设计的，在一定程度上讲，掌握了元素之间的逻辑关系的变化，也就掌握了算法设计的思路。基本操作所涉及到的问题就是由于元素间的逻辑关系发生了变化，而在物理存储上如何体现这种变化。" ID="1">
        <fptr EndPN="00000025" StartPN="00000025"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="18" TITLE="2.2  线性表的顺序存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="28" PhysicalPageNum="28"/>
        <div ORDERLABEL="18" TITLE="2.2.1  数组——线性表的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="28" PhysicalPageNum="28"/>
        <Paragraph CONTEXT="在计算机内部可以采用不同方式来表示一个线性表，其中最简单的方式就是用一组体续的左袂鱼分格冲左袂蜂杜韦的戮了拓李干司毕土今色.专收获仑州份习匕山翻.妇良奋习毕＿2凡，以地址连续的存储单元依次存储线性表的数据元素。换言之，挨一个地依次存放在某个存储区域中，称这种存储结构为线性表的顺序存储结构，并称此时的线性表为顺序表，在高级程序设计语言中可用一维数组表示。假设线性表的每个数据元素占用k个存储单元，那么，在顺序存储结构中，线性表的第i+1个数据元素a;十，的存储位置与第i个数据元素系：乙口‘（久＋1）＝＝Loc（ai）＋k这里Loc(a;）通常被称为寻址函数，表示元素a‘的存储位置。若Loc(a,）为线性表的第一个元素的存储位置，那么，线性表的第i个数据元素a‘的存储位置为助c（a‘）＝＝Loc（al）＋（1-I)*k通常称Loc(a）为线性表的首地址或基地址。从线性表的这种机内表示方法可以看到，它是用数据元素在机内物理位置上的相邻乎齐福尺勤口教灵.云共安少1句瑞容电昌卜K\1公1〕'7C肖巴玄LI16戈/卜毅rJµ.T二是毕VI7Iry-t才‘.毛‘‘毛1左公RT.S1记1..i关系来表示数据元素之间逻辑上的相邻关系的。存储地址存储状态元萦在线性衰中的序号" ID="1">
          <fptr EndPN="00000029" StartPN="00000028"/>
        </Paragraph>
        <Paragraph CONTEXT="t.oc(a11+之！“！Local卜（十：，＊、卜玄一一｝万’｝，‘骊图2-2线性表的顺序存储结构示意图性表的顺序存储结构是一种随机存取的存储结构。由于数据元素之间的逻辑关系可以通过存储位置直接反映出来，顺序存储结构只需存放数据元素自身的信息，因此，存储密度大、空间利用率高是顺序存储结构的优点之一。另外，元素的位置可以用一个简单、直观的解析式表示出来。但这给线性表的插入和删除操作带来了不便：一些长度较大的线性表必须按最大需要的空间分配存储。这是线性表的顺序存储结构的缺点。尽管如此，较广泛的一种基木存储结构。由于程序设计语言中的一维数组在机内的表示也是顺序结构（有关多维数组的内容：第3章详细讨论。本书后面的不少算法中都借用一维数组这种数据类型描述线性表将在第3章详细讨论。的顺序存储结构），因此，线性表的顺序存储结构可以描述为：elem仁ypeA【1，.HAx］：／＊总共有MAx个存储单元，A〔1］存储第一个元素＊／intn：相应的存储映像如图2-2所示。" ID="2">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="19" TITLE="2.2.2  数组中基本操作的实现" TYPE="Chapter">
        <fptr LogicalPageNum="29" PhysicalPageNum="29"/>
        <Paragraph CONTEXT="‘下面先来看看两个关于线性表在顺序存储结构下操作的例子，一个是线性表的插入算法；另一个是线性表的删除算法。这两个算法都十分简单，注意观察数据元素之间的逻辑关系的变化。" ID="1">
          <fptr EndPN="00000029" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="1.插入（Insert）如果在长度为n的线性表A【1二」的第1个位置插入一个新的数据元素new－－data，如何实现该操作呢？我们来分析一「线性表中数据元素之间的逻辑关系的变化情况。因为在线性表的第1-1个数据元素与第1个数据元素之间插入一个新的数据元素，使得长度为n的线性表（a，，aZ，…，ai-1，ai，…，a。＿：，a，，）变成长度为。＋l的线性表(a1,aZ,…,anew_data,a…,a-1faR)因此，在进行具体插入动作之前，需要将线性表的第i个到第n个元素之间的所有元素依次向后移动一个位置（共移动n-i+1个元素），然后再将新的元素插入到第i个位置上，同时，修改线性表的长度为n+le" ID="2">
          <fptr EndPN="00000030" StartPN="00000029"/>
        </Paragraph>
        <Paragraph CONTEXT="算法步骤为：" ID="3">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)检查线性表的存储空间是否已被占满，若满，则进行“溢出”错误处理." ID="4">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)检查1值是否超出所允许的范围（(1&lt;i&lt;n+l)，若超出，则进行“超出范围”错误处理." ID="5">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)将线性表的第1个元素和它后面的所有元素均后移一个位1o" ID="6">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）将新元素写入到空出的第1个位五上.使线性表的长度增加1," ID="7">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法为：voidinsert(inti,intnew-data)／／一维数组a[1二max]中前n个分量上依次存放线性表中n个元素，max&gt;n，在第i个／／元素之前插入一个新的元素new_datao｛" ID="8">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="intj;" ID="9">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="if(Ci&lt;1)II(i&gt;n+1printf(&quot;Positiondoesno七exist\n^/／参数错误elsefor(j=n;ji;j一）a(j+1］二a[jl:/／元素后移a[i］二newdata;/／进行插入n二n十1;}/／表长增加1｝" ID="10">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="【例2-1)有一个线性表为List=(3,8,14,27,29,29,41,S0,62)当在第3个和第4个元素之间插入一个新的数据元素20时，插入前后所对应的存储结构如图2-3(a(b）和（c）所示（假定MAX取10)0即TB,14「Z729下Z94115062（目IJ丁8丁14-2729_29勺41TSOr_62（b）而le1aJzo｝z7习s9已se＿141」兰so_j62" ID="11">
          <fptr EndPN="00000030" StartPN="00000030"/>
        </Paragraph>
        <Paragraph CONTEXT="2.删除（Delete)如果删除长度为n的线性表A[1二〕的第i(1&lt;i簇n)个元素，只需将第i+1至第n个元素（共n-i个元素）依次向前移动一个位置，然后修改线性表的长度为n-1就可以了。" ID="12">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="算法步骤为：" ID="13">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)检查i值是否超出所允许的范围（1&lt;i&lt;n)，若超出，则进行“超出范围”错误处理。" ID="14">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)将线性表的第I个元素后面的所有元素均前移一个位置。" ID="15">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)使线性表的长度减to" ID="16">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法为" ID="17">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="voiddelete＿i(inti)／＊一维数组a[1二maxJ中依次存放线性表中n个元素，将通过移动删除第i个元素。，／｛" ID="18">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="intj;" ID="19">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="ifi&lt;1)II(i&gt;ngrin七f(&quot;Positiondoesnotexist\n&quot;/／参数错误else{for(j=i+1;jn:ja[j-lJ二a[jl:/／元素前移n=n-1;1/／表长减1｝" ID="20">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，有一个线性表为：List二（3,8,14,20,27,29,29,41,50,62)当删除第S个元素27后，删除前后所对应的存储结构如图2-4(a）和（(b）所示（假定MAX取10)0i2za68v89101319」14120127129129141150162(t)13丁-J1aIzoo`s91z9'1ai1`eorest-JJ伪）图2-4在顺序存储的线性表中进行删除的过程示惫图" ID="21">
          <fptr EndPN="00000031" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="3.查找（find)元素在线性表中的序号，或是找不到待查元素，即表中不存在其值等于给定值的数据元素。在以数组作存储结构的线性表中，上述第一种查找操作很容易实现，可以直接按序号i取得该元素。第二种操作则需要通过“查找”进行。“查找”的方法很多，我们将在第9章中详细讨论，在此介绍一种最简单的顺序查找的方法。假设给定值X，试在线性表A[1二max］中查找值为X的元素。简单的办法是：从第一个元素起，依次将元素和给定值比较，若相等，则查找过程结束，找到该元素在线性表中序号i；若X与表中n个元素都不相等，则说明表中不存在值为X的元素，返回信息“0&quot;o" ID="22">
          <fptr EndPN="00000032" StartPN="00000031"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法为" ID="23">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="int1ocate(in七x)／“一维数组a[1二max]依次存放线性表中n个元素，试在线性表中查找具有X值的元素，若ali卜x，1毛1蕊n，则找到该元素，返回函数值i：若a〔11笋x，1＝1，" ID="24">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="2,…，n，则找不到值为X的元素，返回函数值为Oo｛" ID="25">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="inti;i二1:i为扫描指示器，赋初值为1whilei&lt;n)(a[i]：二x顺序扫描直至找到值为x的元素或扫描到表尾" ID="26">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="i=i+1:" ID="27">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="if(a[i]＝二x)return(i/／找到值为x的元素elsereturn(0/／不存在值为x的元素｝" ID="28">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="22" TITLE="2.2.3  操作的时间分析" TYPE="Chapter">
        <fptr LogicalPageNum="32" PhysicalPageNum="32"/>
        <Paragraph CONTEXT="从上述实现操作的算法容易看出，在数组结构的线性表中，插入和删除元素时，其时间主要消耗在移动元素上。下面讨论插入算法的平均时间复杂度。此算法的时间复杂度主要由循环语句中的循，(r月f1r安ro7FG:hF!tc6'1Y#L_r7o'F,仄y/fe'6'T.fVt;4杜韦5!7裕F”右rTi,日环次数（即元素向后移动的次数）决定，与i值有关。当i=n+1时，元素移动的次数最少，为0次：当i二1时，元素移动次数最多，为n次。为不失一般性，设D为插入新元素于线性表第i个位置的概率（假定概最多，为n次。为不失一般性，设p‘为插入新元素于线性表第1个位置的概率（假定概率都相同），" ID="1">
          <fptr EndPN="00000032" StartPN="00000032"/>
        </Paragraph>
        <Paragraph CONTEXT="争伪一‘·‘，＝击争一‘·1）＝苦可见，在线性表的第1个位置插入一个新的数据元素的算法中，最好的情况是不移动任何元素，最坏的情况是移动了表中的所有元素，平均情况是移动表中的一半元素。因此，该算法的时间复杂度为O(n)o与插入算法类似，在长度为n的线性表中删除第i个数据元素需要移动其他元素的平均次数为因此，算法的平均时间复杂度也为O(n)" ID="2">
          <fptr EndPN="00000033" StartPN="00000032"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="存储线性表中的数据元素有不同的方法。本节所介绍的内容，即线性表的顺序存储结构是线性表的一种最简单的存储结构，其存储特点是：在物理内存中开辟一块连续的存储空间，让线性表的第一个元素存放在这个存储空间的第一个单元中，第二个元素存放在第二单元中，第三个元素存放在第三单元中，依此类推。这样，线性表的逻辑结构和物理存储位置完全一致。" ID="1">
        <fptr EndPN="00000028" StartPN="00000028"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="23" TITLE="2.3  线性表的链式存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="33" PhysicalPageNum="33"/>
        <div ORDERLABEL="23" TITLE="2.3.1  单链表和指针" TYPE="Chapter">
        <fptr LogicalPageNum="33" PhysicalPageNum="33"/>
        <Paragraph CONTEXT="线性表的链式存储结构是用一组任意的存储单元（可以是连续的，也可以是不连续来存储线性表的各个数据元素。为了表示每个元素与其直接后继元素之间的逻辑关的）系，每个元素除了需要存储自身的信息外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成了一个数据元素的存储结构，称为一个结点(node)（注意：每个结点占用的存储单元应该是连续的）。这样，每个结点包括两个于是，线性表的n个数据元素对应的n个结点通过链接方式链接成一个链表，即为线性表的链式存储结构。由于链表中每个链结点只有一个指针域，故又称为线性链表，或者单链表。" ID="1">
          <fptr EndPN="00000034" StartPN="00000033"/>
        </Paragraph>
        <Paragraph CONTEXT="具体地说，对于线性表通常把链表直观地表示成用箭头相链接的结点序列，如图2-5所示。IalI_I_IQ2I_I_tQ3I寸咔·一叫Qn｝nl整个线性链表可以由一个称为头结点指针的head来标明线性链表的首地址（即第一个链表结点的存储位置）。当链表为空时，有head=NULL。这样，线性链表可以由头结点指针唯一确定。因为链表中任意结点的存储地址都可以从head开始，经过对链表上述线性链表完整的表示应如图2-6wh示。石飞口d图z-6一个完整的线性链表示例用线性链表表示线性表时，数据元素之间的逻辑关系是通过链结点中的指针反映出k]i't''-6'3'-是c1/Pali&gt;格辈TG1`.lpdt$ir卜素Fl`R的ri/、3K#r#录ter-甘来的。也就是说，指针是数据元素之间逻辑关系的映像，逻辑上相邻的两个数据元素其物仰桥署不亚贵粕心R田汁＿砍神灿左右会姑约去非1165fAd1fSoi'i桩rt'qdt(甘介亢十之因此，称这种存储结构为非顺序映像或链式映像。其实，在大多" ID="2">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="数实际应用中，我们关心的是线性表中数据元素之间的逻辑关系，而不是每个数据元素" ID="3">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="在存储器中的实际位置。" ID="4">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="在高级程序设计语言中都是利用语言中的“指针型”数据类型来描述线性链表的。" ID="5">
          <fptr EndPN="00000034" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="例如，在C语言中，可以如下描述一个链表结点：structnode{datatypedata;｝：在用具体的程序设计语言进行程序设计时，通常可以用两种方法产生链结点：其一是调用系统中己有的动态存储分配函数（如C语言中的malloc(ptr，由系统动态分前一种方法产生的链表称为动态链示P所指结点中的数据域。P一＞next表示所指结点中的指针域，并指向其后继结点。指针变量只能做同类型的指针赋值与比较操作。当建立链表需要申请结点空间时，用C语言中的malloc(p）动态生成结点，并由P指向此结点；一F3p所指结点不再使用，可用free&lt;p）释放此结点空间。表2-2展示了若干种指针赋值语句以及这些语句执行前后指针值的变化状况。执行不同的操作语句，指针的变化是不同的，注意对比观察。一一.一一一操作内容执行操作的语句执行之前执行之后指针指向结“r=v～～'a.一今笼刀杏驴户～指针指“刀＝q一》Ijext目户万弓‘.小一杏曰饭尸申P＝q一》尹互亡工t" ID="6">
          <fptr EndPN="00000035" StartPN="00000034"/>
        </Paragraph>
        <Paragraph CONTEXT="指针移动尸＝p一＞nextes～万口一－～尸｝尸＝P一＞next一万曰一口今～钾万尸.链指针改变p一＞ne“二q汇嗽早H卫今" ID="7">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="一一心一一～········.－." ID="8">
          <fptr EndPN="00000035" StartPN="00000035"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="25" TITLE="2.3.2  单链表的基本操作" TYPE="Chapter">
        <fptr LogicalPageNum="35" PhysicalPageNum="35"/>
        <Paragraph CONTEXT="在线性表的链式存储结构中，逻辑上相邻的两个元素对应的存储位置是通过指针反映的，不要求物理上相邻。因此，在对线性表进行插入、删除操作时，只需修改相关链结点的指针域即可，既方便又省时。由于每个结点都设有一个指针域，因而在存储空间的开销上比顺序存储结构要付出较大的代价。下面我们将讨论，当以链表作存储结构时，如何实现线性表的基本操作。线性表的单链表存储结构描述如下：井defineLENsizeof（structnode）structnode｛25chardata;;tructnode*next:二ypedefstructnode*LZNK;SINKhead:charb,x:" ID="1">
          <fptr EndPN="00000036" StartPN="00000035"/>
        </Paragraph>
        <Paragraph CONTEXT="SINKp,q:" ID="2">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="Lnti,n:" ID="3">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="chara[MAX" ID="4">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="【.查找操作" ID="5">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="C1）按序号查找" ID="6">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="当线性表的元素用链表存储时，即使已知该元素在线性表中的相对位置（序号山，二匕‘二，如大改时二。任悠捅撬伫良具；古上江左砌于安而目能从桩弃的笆一个i)，也不能像用数组存储时那样简便地按序号i直接存取元素，而只能从链表的第一个。。＿.‘～一一.人声一L卜‘代1、1合古＝李咤尸不尸曰协右妇.声歹结点开始，顺着链一个结点一个结点地搜索，直至第1个结点。所以，链表不是随机存储结构。下面是给定元素序号，在链表中查找元素的算法。算法中指针P顺链扫描，k为计数器，在扫描过程中累计结点数。若链表不空，则P的初始值为表头，k的初始值为1；当P指向下一结点时，计数器k加1。由此，当k的值等于i时，指针P所指结点即" ID="7">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="为线性表中第i个结点。" ID="8">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法如下描述：" ID="9">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="voidget()" ID="10">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="11">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="intk;chareval;if(head＝二NULL)printfC`Thisisempty1istn&quot;else{p=head;k=1;whileC(k&lt;i)(p一＞next！二NULLtk二k+1;P=P一》next;〕if(k二二i)Ieval=p一》dataprintf(&quot;Element二％deval)" ID="12">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="e1sEprintf(&quot;Hasnottheelementn&quot;)2f" ID="13">
          <fptr EndPN="00000036" StartPN="00000036"/>
        </Paragraph>
        <Paragraph CONTEXT="）" ID="14">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法中while语句的终止条件是搜索到表尾或k&lt;i，其频度最多为i，它与被查找的位置有关。平均时间复杂度为口(n)o" ID="15">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）按值查找假若给定元素值，则需确定该元素结点在链表中的存储位置。同样，从第一个结点开始，指针每移动一步，" ID="16">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法如下描述：" ID="17">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="int1ocateO" ID="18">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="19">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="i二1:if(head＝二NULL){printf(&quot;Thisisempty1istn&quot;exit():" ID="20">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="P二head:while((p一＞data！二x)(p一＞next!=NULL)){P=P一＞next;i" ID="22">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｝if(p一＞data！二x){printf(&quot;Hasnottheelementn^return(0);｝" ID="23">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="else{printf(&quot;Hastheelementn&quot;return(i):｝" ID="24">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="｝该算法的平均时间复杂度为口Cn)o" ID="25">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="2.插入操作" ID="26">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）后插操作链表中插入一个元素比在数组中插入一个元素要简单，不需要移动元素，仅需要修改指针即可。假设在P指针所指结点之后插入一个元素值为x的结点，则首先需建立一个新结点，然后修改指针插入之。我们简称这种插入为“后插”。具体算法描述如下：" ID="27">
          <fptr EndPN="00000037" StartPN="00000037"/>
        </Paragraph>
        <Paragraph CONTEXT="voidinsert()" ID="28">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="29">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="LINKs;s二（structnodemalloc(LENs一＞data二x;s一》nex七二P一＞nextP一＞next二s;" ID="30">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法的平均时间复杂度为0（1。后插操作的前后链表状态变化如图2-7所示。图2-7后插操作示意图" ID="31">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）前插操作假设在P指针所指结点之前插入一个元素值为z的结点，同样需首先建立一个新结袱层德两粕亩华抖月今入于不日早七了德为。的前可牙廷占的华抖愉重一吐互确常甘下专tr点，然后修改相应指针插入之。但是，为了修改P的前驱结点的指针域，" ID="32">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="驱结点的位置9，一般情况卜，可从链表头指针起进行查找。我们简称这种插入为“前" ID="33">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="插”。" ID="34">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法如下描述：" ID="35">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="voidinsert()｛LINKs,q;" ID="36">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="s二（structnodemalloc(LENs一）data二x;q二head;$Picture[00000038\00000038_new\0030.jpg]Picture$while(q一＞next！二p)/＊查找q的位置＊／" ID="37">
          <fptr EndPN="00000038" StartPN="00000038"/>
        </Paragraph>
        <Paragraph CONTEXT="夏一＞next=s:" ID="38">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="；一＞next二p" ID="39">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="己然此算法的时间复杂度与位置p有关。由于前插时仍需查找前驱结点，在等概率假设下，算法的平均时间复杂度为口（的。算法中假定P指针所指结点不是链表中的第一个结点，则在“前插”时不需要修改表头指针。前插操作的前后链表状态变化如图2-8所示。一户下丑枢｝" ID="40">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="Cal" ID="41">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="尸在链表中删除一个结点，若己确定被删除结点在链表中的位置，则类似于插入操作，不需要移动元素，仅需要修改指针，同时将被删除结点“释放”即可。假设指针t135tfl71J.za’一fiI1X&quot;&quot;s口1e1FititiTp指向被删除的结点，指针9指向其前驱结点，描述：" ID="42">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="voiddeleteO" ID="43">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="44">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="LINKq:" ID="45">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="q二head;whiletq一＞next，二p)/＊查找q的位置‘／$Picture[00000039\00000039_new\0026.jpg]Picture$9=9一＞next;q一＞next二P一＞next;/＊将P从链表中摘下＊／freeCp/＊释放‘／〕算法的平均时间复杂度为0（t1)。删除操作的前后链表状态变化如图2-9所示" ID="46">
          <fptr EndPN="00000039" StartPN="00000039"/>
        </Paragraph>
        <Paragraph CONTEXT="－户呀函一冲" ID="47">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="下封乒丸牙" ID="48">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="下正万｛亚" ID="49">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="30" TITLE="2.3.3  链表的实现" TYPE="Chapter">
        <fptr LogicalPageNum="40" PhysicalPageNum="40"/>
        <Paragraph CONTEXT="对于线性表的数组存储结构，在高级语言编制的程序中，可借用一维数组来实现。那么，链表如何实现，即如何将线性表的元素存放在链表中呢？下面将讨论链表的动态生成。假设线性表中结点的数据类型是字符型，我们输入字符并以‘＃’为输入结束标志。动态地创建链表有如下两种方法。" ID="1">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="i.正序创建链表所谓正序创建链表是链表的逻辑顺序与输入的字符顺序相同。为建立链表，首先要为每个数据元素动态生成一个结点，然后通过指针将这些结点依次相链接。假使线性表中前i-1个元素己经存放在head为头指针的链表中，并且指针P指向该链表中最后一个结点，则读入线性表的第i个元素后，首先动态生成一个结点，其数据域存放字符型数据，然后插入在P结点之后，并令P指向新插入的结点。利用后插操作可以得到一个正序的链表。" ID="2">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="具体算法如下描述：" ID="3">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="voidcrtlinked()（／＊从键盘输入字符，当输入符号‘＃’为结束，／LINKs,p;" ID="4">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="charch;head二NULL:p二head:/建立空表，／scanf（·毛c·，＆ch）；／＊输入第一个数据元素＊／whileCch！二，＃’）｛s二（structnodemalloc(LENs一＞data=ch:if(head二二NULL)head二s;30" ID="5">
          <fptr EndPN="00000040" StartPN="00000040"/>
        </Paragraph>
        <Paragraph CONTEXT="elseP一）next二s;/＊插入＊／P二s:scanf（，’％c’’.＆ch）：／＊p指向最后一个结点‘／｝P一＞next二NULL;／去链表的最后一个结点指针域为空＊／｝算法的时间复杂度为O(n)o" ID="6">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="2.逆序创建链表逆序创建链表的逻辑顺序与输入的字符顺序相反。创建逆序链表借助“前插”操作。而最新插入的结点总是插在表头。假设线性链表的元素依次存放在一维数组A[1.川中，用逆序创建链表，要想得到与A[1二川顺序相同的元素，可以首先由数据域A[n],A[n-11,A[2］赋值，最后A[11赋值。具体算法如下描述：" ID="7">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="voidcrtlinked()" ID="8">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="9">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="LINKs;" ID="10">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="intch;head二NULL;/＊建立空表＊／i二n;while(i&gt;0){s二（s七ructnode*)malloc(LENs一＞data二a[is一》next二head:/＊前插操作＊／head二s:/*head指向链表头＊／i=i-1;" ID="11">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法的时间复杂度为口Cn)o以上两个算法的执行效果相同，只是后者从形式上看更为简洁。在不同的场合常常选用不同的创建链表的方法。例如，在以后章节中介绍的队列用正序创建链队，而堆栈则用逆序建立链栈。" ID="13">
          <fptr EndPN="00000041" StartPN="00000041"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="31" TITLE="2.3.4  单链表的其他操作" TYPE="Chapter">
        <fptr LogicalPageNum="41" PhysicalPageNum="41"/>
        <Paragraph CONTEXT="通过下面的几个例题，来看一下在以单链表作存储结构，如何根据不同的问题来实现不同的操作。【例2-3】以单链表作存储结构完成下列的操作。己知一个线性表中的元素按元素值非递减有序排列，利用线性表的基本操作设计算法，算法思想：由于表中元素按值非递减有序排列，则若有值相同的元素必为相邻的元素。由此，只要依次比较相邻的两个元素，若值相同，则删除其中一个。具体操作：顺序扫描线性表并比较相邻两个元素的值，若相等，则删除后继元素。假设以P表示当前被扫描的结点，则P一＞&gt;next为它的后继结点，若pdata=p一＞&gt;nextdata，则删除P一＞&gt;next所指结点。具体算法如下：voidpurge()" ID="1">
          <fptr EndPN="00000042" StartPN="00000041"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="2">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="LINKp,q:if(head!=NULL){P二head:while(p一＞next！二NULL){if(p一＞data！二P一＞next一＞data)" ID="3">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一＞next;else{" ID="4">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="4二P一＞next:" ID="5">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="P一＞next二q一＞next;" ID="6">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="free(q｝" ID="7">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="8">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="9">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="｝Head(a)" ID="10">
          <fptr EndPN="00000042" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)图20删除值相同的多余元素示意图图2-10所示为上述算法的实现过程。算法的时间复杂度为O(n)o算法思想：利用“前插”操作实现链表的逆置，假设把逆置后的链表看成是一个新建的链表，新建的链表中的结点取自原表，则逆置链表的操作可转化为建立链表的操作。扫描原表，依次将原表中结点逐个插入到逆置的新表的第一个结点之前，这个操作类似于逆序创建链表，" ID="11">
          <fptr EndPN="00000043" StartPN="00000042"/>
        </Paragraph>
        <Paragraph CONTEXT="算法如下。" ID="12">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="voidInverC)" ID="13">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="（" ID="14">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="LINKp,s;" ID="15">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="p=head一）next:head一＞next=NULL;whileCp！二NULL){s一＞next二head一＞next;" ID="16">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="head一＞next二s:｝" ID="17">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="｝L魂江子只of且～a口一～耸雏扫短－尼j飞召剧碱」" ID="18">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)逆置前的链表(b)逆置后的链表（(c）逆置过程中的链表算法的时间复杂度为口(n)o另外还有以下一些操作，具体算法请读者自己设计，这里不再说明。" ID="19">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)将两个线性链表联接成一个线性链表。" ID="20">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）删除线性链表中数据域值为item的所有结点。" ID="21">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）修改线性链表中数据域值为item的所有结点的数据域值。" ID="22">
          <fptr EndPN="00000043" StartPN="00000043"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="由上节的讨论中得知，线性表的顺序存储结构具有逻辑上相邻的两个数据元素在物理位置上也相邻的特点，因此，可以随机存取线性表中任意一个数据元素，并且数据元素的存储位置可以用一个简单直观的解析式表示。但从另一方面来看，这些特点使得线性表的插入和删除操作要移动大量元素，效率比较低。另外，这种存储结构要求占用连续的存储空间，存储分配只能预先进行（即所谓静态分配），而且必须按最大空间需求来分配。然而，估计最大需求空间不是一件容易的事情。另外，在操作过程中，当线性表的长度变化较大时，往往造成大量空间的浪费；如果插入操作超出了预先分配的存储范围，也很难进行存储空间的临时扩充。这一节里将讨论线性表的另一种存储结构―链式存储结构，简称线性链表。这种存储结构不要求逻辑上相邻的数据元素在物理位置上也相邻，仅用指针来表示数据元素之间的逻辑关系。在本书的后面几章里将会看到，链式存储结构不仅可以用来表示线性表，而且还可以用来表示各种非线性的" ID="1">
        <fptr EndPN="00000033" StartPN="00000033"/>
      </Paragraph>
      <Paragraph CONTEXT="瑕分j律麦出去妇去口云廿】互】生户通在链式存储结构不仅可以用来表示线性表，图等等。" ID="2">
        <fptr EndPN="00000033" StartPN="00000033"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="33" TITLE="2.4  循环链表及其操作" TYPE="Chapter">
      <fptr LogicalPageNum="43" PhysicalPageNum="43"/>
      <Paragraph CONTEXT="线性链表的缺点之一是无法从指定的链结点到达该结点的前驱结点，这可能会给某些实际应用带来一些不便。为了解决这样的问题，于是引入了线性表的另一种形式的链式存储结构，即循环链表。所谓循环链表就是链表中最后一个结点的指针域指向链表的第一个结点，整个链表形成一个环。这样，从链表中任一结点出发都可以找到其他结点。图2-12所示为一个空循环链表与一个非空循环链表。巨墅〕净卿甲口”一”马(b)图2-l2循环链表的示例有时候为了解决问题的方便或需要，在链表的第一个结点之前设置一个特殊结点，称之为头结点（见图2-13)。头结点的数据域可以不存放任何信息，也可以存放一些诸置。当线性表为空时，相应的循环链表并不为空链表，还有‘个头结点，·其指针域指向头结点本身，如图2-13所示。因此可以写出循环链表为空的条件：Headnext二Head要想对链表中的每个结点进行处理，只需设一个“扫描”指针ptr，令其初始值为头结点的存储位置（ptr=Head)，然后反复执行ptr=ptr一＞next)，直到ptrHead为止。循环链表的操作与前面讨论过的线性链表基本相同，只是算法中循环条件不是判断P或者P一＞next是否为NULL，而是判断它们是否等于头指针。［例2-5］在一个带头结点的循环链表中，查找一个数据为item的结点，当查找成" ID="1">
        <fptr EndPN="00000044" StartPN="00000043"/>
      </Paragraph>
      <Paragraph CONTEXT="功（即存在满足条件的结点）时，返回该结点的指针；否则返回NULLa" ID="2">
        <fptr EndPN="00000044" StartPN="00000044"/>
      </Paragraph>
      <Paragraph CONTEXT="算法如下：" ID="3">
        <fptr EndPN="00000044" StartPN="00000044"/>
      </Paragraph>
      <Paragraph CONTEXT="L工NKSearch(L工NKhead,elemtypeitem)｛P二head一＞next;while(p!=head){" ID="4">
        <fptr EndPN="00000044" StartPN="00000044"/>
      </Paragraph>
      <Paragraph CONTEXT="if(p一＞data二二item)re七urn(NULL)；/＊表中没有与给定值item相等的结点存在＊／｝下面的例子说明，在解决某些实际问题时，循环链表要比线性链表方便一些。【例2-6］约瑟夫问题：已知n个人（不妨以1,2,3,…,n代表）围坐在一张圆桌周围。现在从序号为k的人开始报数，数到m的那个人出列：它的下一个人又从1开始报数，数到m的那个人又出列；依此规则重复下去，直到圆桌周围的人全部出列。例如，当n=8,m=4,k=3时，出列的顺序依次为6,2,7,4,3,5,1,80很显然，可以利用一个循环链表来解决约瑟夫问题。圆桌旁某个人出列相当于从链表中删除一个结点。下面的算法假设圆桌周围还剩一个人时游戏结束。voidJOSEPHU(LINKhead,intmintmintk)｛" ID="5">
        <fptr EndPN="00000045" StartPN="00000044"/>
      </Paragraph>
      <Paragraph CONTEXT="LINKp;head二NULL;＊建立一个空表＊／for(i二1;i＜二n;i{P二（L工NK)malloc(LEN)；/＊申请一个新结点＊／P一＞data二i;if(head二二NULL)head二P:" ID="6">
        <fptr EndPN="00000045" StartPN="00000045"/>
      </Paragraph>
      <Paragraph CONTEXT="else4一＞next=p;4二P;" ID="7">
        <fptr EndPN="00000045" StartPN="00000045"/>
      </Paragraph>
      <Paragraph CONTEXT="｝P一＞next二head;以上是建立一个不带头结点的循环链表，／P二head;for(i二1;i＜二k-1;iP二P一＞next;p指向第一个出发结点＊／while(p一＞next!=NULL){for(i二1;i＜二m-1;iq指向第m-1个结点，P指向第m个结点＊／4二P;P二P一＞next;｝4一》next二P一＞next;/＊删除第m个结点＊／printf(p一＞data)；/‘输出一个序号＊／free(p)；/＊释放被删除的结点’／P二4一＞next;p指向新的出发结点女／｝printf(p一＞data)；/＊输出最后那个结点的序号＊／｝" ID="8">
        <fptr EndPN="00000046" StartPN="00000045"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="36" TITLE="2.5  双向链表及其操作" TYPE="Chapter">
      <fptr LogicalPageNum="46" PhysicalPageNum="46"/>
        <div ORDERLABEL="36" TITLE="2.5.1  双向链表的构造" TYPE="Chapter">
        <fptr LogicalPageNum="46" PhysicalPageNum="46"/>
        <Paragraph CONTEXT="双向链表（double1inked1ist·就是链表结点中除了数据域以外有两个指针域，其中之一指向结点的直接前驱结点，另一个指向结点的直接后继结点。每个结点的构造可以形象地描述如下：｝priorf-to.Inext_域指向直接前驱结点（称为前驱指针域），" ID="1">
          <fptr EndPN="00000046" StartPN="00000046"/>
        </Paragraph>
        <Paragraph CONTEXT="其中，prior域指向直接前驱结点（称为前驱指针域），next域指向直接后继结点（称为后继指针域）。双向链表的存储结构如下：typedefstructDulNode{elemtypedata;structDulNode*prior;structDulNode*next;}DulNode,*DulLink;与线性链表类似，双向链表可以是非循环线性的，也可以是循环线性的，有时也可以根据解决问题的需要在链表最前面附设一个头结点。下面是几种形式的双向链表。L王二且二粗二氏二.－：一不-I’1八｝Heald4图2-14不带头结点的双向循环链表有头结点的双向循环链表（图2一巧o价爆孜址肛：几·－川压五洲图2一巧带头结点的双向循环链表双向循环链表有一个固有特性。若P为指向双向链表中某结点的指针，则有：P一＞next一＞prior二二P二二P一＞prior一＞next" ID="2">
          <fptr EndPN="00000047" StartPN="00000046"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="37" TITLE="2.5.2  双向链表的插入与删除算法" TYPE="Chapter">
        <fptr LogicalPageNum="47" PhysicalPageNum="47"/>
        <Paragraph CONTEXT="双向链表的一些操作，如求链表的长度、检索链表的第i个结点等，仅涉及链表的一个方向，因此，这些操作对应的算法与线性链表的有关算法几乎没有差异。但是，在双向链表中插入一个新的结点或者删除双向链表中一个结点就不同了，因为需要修改两个方向的指针。下面分别加以讨论。" ID="1">
          <fptr EndPN="00000047" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）在带头结点的双向循环链表中，在数据域为b的结点右边插入一个数据为x的新结点算法的核心思想是：先从链表中找到满足条件的结点（由变量9指出）；申请一个新结点P，将数tx送到新结点的数据域，将指针9赋给新结点的左指针域prior，将4结点的直接后继结点的next赋给新结点的右指针域next；然后将新结点的P赋给4结点直接后继结点的左指针域；最后将P送4结点的右指针域。插入过程如图2-16所示。图2-l6双向链表的插入操作示意图具体算法如一下：voidInsert_Double(DulLinkhead,elelmtypeb,elemtypex)｛q二head一》nex七；while((q!=head)(q一＞data!=b!／寻找第一个满足条件的结点q=q一＞next;if(q二二head)printfNoFindb!;exitt);！‘无满足条件的结点存在‘／｝P二（DulLink)malloc(sizeofCDU1Node;P一＞data二x;" ID="2">
          <fptr EndPN="00000048" StartPN="00000047"/>
        </Paragraph>
        <Paragraph CONTEXT="P一＞prior=q;P一＞next二q一＞next;q一＞next一＞prior二P;q一＞next二P%" ID="3">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="4">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)从有头结点的双向循环链表中，删除数据域为z的结点算法思想为：先从链表中找到满足条件的结点（由变量4指出）；若9所指的结点不是头结点，则将结点4的直接后继结点的next赋给4结点直接前驱结月书J食书j闷女，吞士大下与，士幸.群r刀盯办士古6廿1.日井在八～奋士.片FS'七扣「共4Rk4士x二t匕.t-林器_域，并将q结点直接前驱结点的next赋给q结点直接后继结点的左指针域；然后释放结点q。voidDelete＿Double（Du1Linkhead，elemty不〕ex）｛" ID="5">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="q，head一＞next；while（（q！＝head）＆＆（q一＞data！二x））q二q一＞next；if（q＝＝head）｛printf（，’NoFindx：”）；" ID="6">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="exit（）；｝q一＞Prior一＞next二q一＞next；q一》nex七一＞Prior二q一＞Prior；" ID="7">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="free（q）；" ID="8">
          <fptr EndPN="00000048" StartPN="00000048"/>
        </Paragraph>
        <Paragraph CONTEXT="｝黔仑二几·石弃血一幸氏·－－－叫图2-l7双向链表删除时指针变化状况若链表中除了头结点之外只有一个结点9（见图2-18(a，那么，执行上面的算法之后链表的状态如图2-18(b)所示，此时结点9已不在链表中了。可以证明，上述两个算法的时间复杂度与线性链表的插入算法、删除算法一样，都是O(n)(n为循环链表的长度）。图2-18双向链表删除操作示意图" ID="9">
          <fptr EndPN="00000049" StartPN="00000048"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="相对线性链表来说，循环链表虽然有其优点，但尚感不足。在循环链表中仍然不能直接得到前驱结点数据，另外，当要删除链表中的一个结点时，仅给出该结点的指针还不行，还需要找到被删除结点的直接前驱结点，而要找到这个直接前驱结点，只有从表显然这是十分不方便的。为了克服这种单向性的缺点，可以利用双向链表。尤其对于那些需要经常沿任意一个方向移动的链表，双向链表更合适。双向链表也称作双链表。" ID="1">
        <fptr EndPN="00000046" StartPN="00000046"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="39" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="49" PhysicalPageNum="49"/>
      <Paragraph CONTEXT="1，判断题不需要付出很大的代价。因为平均每次操作只有大约一半的元素需要移动。" ID="1">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)由于顺序存储要求连续的存储区域，所以在存储管理上不够灵活。" ID="2">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)线性表中的元素可以是各种各样的，但同一线性表中的数据元素具有相同的特性，因此是属于同一数据对象。" ID="3">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(5)在线性表的顺序存储结构中，逻辑上相邻的两个元素，但在物理位置上并不一定相邻。" ID="4">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(6)在线性表的链式存储结构中，逻辑上相邻的元素在物理位置上不一定相邻。" ID="5">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(7）在单链表中，任何两个元素的存储位置之间都有固定的联系，因为可以从头结点进行查找任何一个元素。" ID="6">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(8）线性表的链式存储结构优于顺序存储结构。" ID="7">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Paragraph CONTEXT="(9)在线性表的顺序存储结构中，插入和删除元素时，移动元素的个数与该元" ID="8">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Paragraph>
      <Picture URL="00000049\00000049_new\0017.jpg">
        <fptr EndPN="00000049" StartPN="00000049"/>
      </Picture>
      <Paragraph CONTEXT="(10)线性表的链式存储结构的特点是，用一组任意的存储单元来存储线性表的数据元素。" ID="9">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="(11)在单链表中，要取得某个元素，只要知道该元素的指针即可，因此，单链表是随机存取的存储结构。" ID="10">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="(12）顺序存储方式只能用于存储线性结构。" ID="11">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="(13）顺序存储方式的优点是存储密度大，并且插入、删除操作效率高。" ID="12">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="14)链表的每个结点中都恰好包含一个指针。" ID="13">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="2.描述以下三个概念的区别：头指针，头结点，首结点（第一个元素结点）。" ID="14">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="3.线性表有两种存储结构：一是顺序表，二是链表。试问：" ID="15">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)两种存储表各有哪些主要优缺点？" ID="16">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)如果有n个线性表同时存在，并且在处理过程中，各表的长度会动态发生变化，线性表的总数也会自动地改变。在这种情况下，应该选用哪种存储结构？为什么？" ID="17">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)若线性表的总数基本稳定，并且很少进行插入和删除，但要求以最快的速度存取线性表中的元素，那么，应该采用哪种存储结构？为什么？" ID="18">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="4.在单链表和双向链表中，能否从当前结点出发访问到任何一个结点？" ID="19">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="5.判断带头结点的双向循环链表L是否对称相等的算法如下所示，请在算法中的＿处填上正确的语句。" ID="20">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="Zntdo(DulLinkshead)" ID="21">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="（" ID="22">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="J二FALSE;P二shead一＞next:q二shead一＞prior;while((p！二q)&amp;＆二）｛if&lt;p一＞da[a二9一＞data){一：" ID="23">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="一：" ID="24">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="25">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="26">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="j二TRUE;" ID="27">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="returnj;" ID="28">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="29">
        <fptr EndPN="00000050" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="6.指出以下算法中的错误和低效率之处，并将它改成一个正确高效的算法。Void.sfa(inta[MAXinti,intk,int1ast)｛／＊线性表中的元素存放在数组a[MAX」中.算法的功能是将数组a中从第工个元素起的k个元素删除＊／if((i&lt;0&gt;II(i&gt;las七一1)II(k&lt;0)II(last&gt;MAX))40printf(&quot;Argumentinvalid):elsefor(count二1:count＜二k:count{for(j二last:j＞二i;j一）" ID="30">
        <fptr EndPN="00000051" StartPN="00000050"/>
      </Paragraph>
      <Paragraph CONTEXT="a[j-1】二a[jl:last一；" ID="31">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="32">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="33">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="7.设计产生一个有两个结点的链表的算法，并且第一个结点中存放数值x，第二个结点中存放数值y,Head为头指针。" ID="34">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="8.设线性表存放在数组A[MAX]的前num个单元中，并且递增有序，试设计一个算法，将z插入到线性表的适当位置上，并保持线性表有序。在设计前请说明设计思想，最后说明所设计算法的时间复杂度。" ID="35">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="9.写出将单循环链表逆置的算法。" ID="36">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="10.给定一个不带头结点的单链表，试编写计算该单链表长度的算法。" ID="37">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="11.试编写一个算法，计算循环链表中的结点个数。" ID="38">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="12.对于线性表中的元素按照递增的顺序排列，并以带头结点的单链表作为存储结构。试设计一个算法，删除表中所有值大于；min，并且小于zmax的元素（若表中存在这样的元素）。" ID="39">
        <fptr EndPN="00000051" StartPN="00000051"/>
      </Paragraph>
      <Paragraph CONTEXT="13.已知循环链表中第一个结点的指针为Head。试写出删除并释放数据域为J泊勺所有结点的算法。原书空白页" ID="40">
        <fptr EndPN="00000052" StartPN="00000051"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="线性表是计算机程序设计中最常遇到的一种操作对象，也是数据结构中最简单、最重要的结构形式之一。实际上，线性表结构在程序设计语言和程序设计活动中大量使并不是陌生的概念。在这一章里，我们将从一个新的角度来更加系统地讨论它。本章重点介绍：" ID="1">
      <fptr EndPN="00000025" StartPN="00000025"/>
    </Paragraph>
    <Paragraph CONTEXT="顺序存储结构" ID="2">
      <fptr EndPN="00000025" StartPN="00000025"/>
    </Paragraph>
    <Paragraph CONTEXT="链式存储结构" ID="3">
      <fptr EndPN="00000025" StartPN="00000025"/>
    </Paragraph>
    <Paragraph CONTEXT="物理关系" ID="4">
      <fptr EndPN="00000025" StartPN="00000025"/>
    </Paragraph>
    <Paragraph CONTEXT="逻辑关系" ID="5">
      <fptr EndPN="00000025" StartPN="00000025"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="43" TITLE="第3章  堆栈和队列" TYPE="Chapter">
    <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
      <div ORDERLABEL="43" TITLE="3.1  堆栈的概念及操作" TYPE="Chapter">
      <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
        <div ORDERLABEL="43" TITLE="3.1.1  堆栈的定义" TYPE="Chapter">
        <fptr LogicalPageNum="53" PhysicalPageNum="53"/>
        <Paragraph CONTEXT="堆栈（Stack）又叫栈，它是一种操作受限制的线性表。其限制是仅允许在表的一端进行插入和删除操作。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新的数据元素又称之为进栈、入栈或压栈，它是把新的数据元素放到栈顶数据元素的上面，使之成为新的栈顶数据元素；从一个栈删除数据元素又称作出栈或退栈，它是把栈顶数据元素删除，使其相邻的元素成为新的栈顶数据元素。栈顶数据元素的位置由一个称为栈顶指针的变量（通常可以用Top表示）给出。当栈中没有元素时，称为空栈。根据堆栈的定义，每次删除的总是堆栈中当前栈顶数据元素，即最后进入堆栈的元素；而在进栈时，最先进入堆栈的元素一定在栈底，最后进栈的元素一定在栈顶。这就是堆栈的操作特点。由于这一特点也称堆栈是后进先出表(LastInFirstOut，简称LIFO表）。在日常生活中，有许多类似栈的例子，如洗盘子时，把洗干净的盘子一个接一个地向上放（相当于进栈），取用盘子时，则从上面一个接一个地向下拿（相当于出栈）。又后压入的先射出（相当于出栈）。假设栈S=(aaz,，an)，则称a，为栈底元素，a,，为栈顶元素。图3-1为栈的示意图。" ID="1">
          <fptr EndPN="00000054" StartPN="00000053"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="44" TITLE="3.1.2  堆栈的有关操作" TYPE="Chapter">
        <fptr LogicalPageNum="54" PhysicalPageNum="54"/>
        <Paragraph CONTEXT="堆栈的基本操作除了在栈顶进行插入和删除外，还有栈的初始化、判断空栈以及取栈顶元素等。堆栈的操作比较简单，通常有以下几种基本操作：Push(S,x)" ID="1">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：栈S己存在。操作结果：插入元素x为新的栈顶元素。尸op(S)初始条件：栈S已存在且非空。操作结果：删除S的栈顶元素。在实际应用中，被删除的元素往往是有用的，因此，在很多情况下，该函数返回栈顶元素，并从堆栈中删除它。Empty(S)" ID="2">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：栈S己存在。操作结果：若栈S为空栈，则返回TRUE，否则返回FAL5EoGetTop(S)" ID="3">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：栈S己存在。操作结果：取得栈S的栈顶元素。要注意区别Pop(S)和GetTop(S}操作。尸op(S)要修改栈顶指针，而GetTop(S)只取得栈S的栈顶元素而不修改栈顶指针的位置。Create(S)操作结果：构造一个空栈SeClearStack(S)" ID="4">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：栈S己存在。操作结果：将栈S置为空栈。44" ID="5">
          <fptr EndPN="00000054" StartPN="00000054"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="堆栈是一种十分重要的数据结构。对栈的操作要求“后进先出”。它的操作规则是以线性表某些操作为主，增加了特殊限定条件演化而来的。" ID="1">
        <fptr EndPN="00000053" StartPN="00000053"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="45" TITLE="3.2  堆栈的顺序存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="55" PhysicalPageNum="55"/>
      <Paragraph CONTEXT="堆栈属于线性表，因此，有关线性表的两种存储结构同样也适用于堆栈。最简单.的方法就是借助于一维数组来描述堆栈的顺序存储结构。堆栈的顺序存储结构是，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。不妨设描述堆栈顺序存储结构的一维数组为Stack[MAXJ。其中，Stack为堆栈的名称；数组的上界几夕:4X表示堆栈的最大容量。根据定义，再设置一个整型变量肠尸作为指出某一时刻堆栈栈顶元素的位置。当堆栈不空时，7之尽，的值就是数组某一元素的下标值：当堆栈为空时，有Top二一1。这样，Stack[01为第一个进入堆栈的元素，Stack[i-11为第l个进入堆栈的元素（当没有删除操作时），Stack[Top]为栈顶元素。由于堆栈是一个顺序存储结构，因此具有所谓的溢出（Overflow）现象。当堆栈中己经有MAX个元素时，如果再做进栈操作时则会产生溢出（通常称为上溢）；对栈进行出栈操作也会产生溢出（通常称为下溢）。为了避免溢出，在对堆栈进行进栈操作和进行出栈操作之前都应该分别测试堆栈是否己满或者是否己空。目to＿口eP-aEDCtC8BAA蔚" ID="1">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="图3-2栈顶指针和栈中元素之间的关系顺序存储结构所使用的结构类型可定义为：#defineMAX100＊栈的最大元素个数＊／structSgStack{" ID="2">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="elemtypeStack[MAXin七，op:/，取值范围为：一1二MAX-1｝；根据堆栈的操作和堆栈的顺序存储结构可写出相应的算法。设S为具有顺序存储结构的SgStack类型的一个栈，x为具有elemtype类型的一个数据元素，则堆栈的各种操作所对应算法如下：" ID="3">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="1.压栈（Push)算法" ID="4">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="算法步骤为：检查栈是否已满，若栈满，则进行“溢出”错误处理。将栈顶指针上移（即加1)0" ID="5">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="将新的数据元素赋给栈顶单元。" ID="6">
        <fptr EndPN="00000055" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="算法描述为：Push(SgStackS,elemtypex)｛／＊插入数据元素x为新的栈顶元素，／if(S.Top二二MAX-1){/＊检查栈是否己满＊／printf(&quot;Overflowexit():｝" ID="7">
        <fptr EndPN="00000056" StartPN="00000055"/>
      </Paragraph>
      <Paragraph CONTEXT="S.Top" ID="8">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="S.Stack[S.Top]二x;ReturnOK:｝" ID="9">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="2.出栈（Pop）算法" ID="10">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="算法步骤为：检查栈是否为空，若栈空，则进行“下溢”错误处理。将栈顶元素赋给某个变参X（若不需要保留，则可省去该步骤）。" ID="11">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）将栈顶指针下移（即减1)a算法描述为：Pop(SgStackS.elemtypex)｛／＊若栈不空，则删除S的栈顶元素，用X返回其值＊／if(S.Top二二一1){检查栈是否为空‘／printf(&quot;Underflow&quot;exit():｝x=S.Stack[S.Top" ID="12">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="S.Top一：ReturnOK;｝从算法可看出：原栈顶元素仍然存在，只不过栈顶指针不再指向它，而是指向了它的下面的元素。" ID="13">
        <fptr EndPN="00000056" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="3.取得栈顶元素（GetTop）的算法算法步骤为：检查栈是否为空，若栈空，则进行“下溢”错误处理；算法描述为：GetTop(SgStackS)｛／＊若栈不空，则返回S的栈顶元素‘／if(S.Top二二一1)i/＊检查栈是否为空‘／printf(&quot;Underflow&quot;46exitl);｝x二S.Stack[S.TopReturnx:" ID="14">
        <fptr EndPN="00000057" StartPN="00000056"/>
      </Paragraph>
      <Paragraph CONTEXT="｝注意：在这个算法中栈顶指针保持不变。" ID="15">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="4.置空栈（C1earStack）算法此算法很简单，只需将栈顶指针赋值为一1即可。算法描述为：Clears仁ack(SgStackS)｛／‘若栈不空，则将其置空＊／if(S.Top＝二一1)(/‘检查栈是否己经为空＊／printf('AlreadyEmptyStack!“exit():｝" ID="16">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="S.Top二一1;ReturnOK;｝" ID="17">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="5.判断栈是否为空栈（Empty）的算法算法描述为：Empty(SgStackS)｛／，若栈不空，返回错误信息‘／if(S.Top二二一1)/＊检查栈是否为空＊／returnTRUE;elsereturnFALSE;）栈的各种算法都不需要进行元素的比较和移动，所以其时间复杂度均为口(1" ID="18">
        <fptr EndPN="00000057" StartPN="00000057"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="47" TITLE="3.3  堆栈的链式存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="57" PhysicalPageNum="57"/>
      <Paragraph CONTEXT="堆栈的链式存储结构，有时又称为链接栈或链栈，就是用一个线性链表来实现一个堆栈结构。栈中每个元素用一个链结点表示，同时，Top)，指示当前栈顶元素所在结点的存储位置。当栈为空时，有Top=NULL。图3-3就是top图3-3链栈的示意图用线性链表表示的堆栈，链表中不必设置头结点，链表的第一个结点就是堆栈的栈顶元素所在的结点，最先进栈的元素所在的结点一定是链表的最后一个结点。根据堆栈的定义，在链栈中插入一个新的元素，实际上相当于在该链表的第一个结点之前插入一个新结点；同时，删除链栈的栈顶元素，实际上就是删除链表的第一个结点。因此，只耍把线性链表的头指针定义为栈顶指针，并且限定只能在链表表头进行插入、删除操作，这个链表就成了链栈。由于采用了链式存储结构，就不必事先声明一块存储区作为堆栈的存储空间，所以不会有栈满而产生溢出的问题。另外，在一些实际问题中，若不知道或者难以估计将要进栈的元素的最大数量时，应该采用链栈。下面是链栈的插入与删除算法。图3-4和图3-5分别是插入和删除算法的示意图。" ID="1">
        <fptr EndPN="00000058" StartPN="00000057"/>
      </Paragraph>
      <Paragraph CONTEXT="6.压栈（Push)算法" ID="2">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="算法步骤为：" ID="3">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="申请一个新结点。" ID="4">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="将新结点插入链表的最前面。算法描述为：Push_Link_Stack(NodeTop,elemtypex)｛／＊插入数据元素x为新的栈顶元素，／P二（Node）工nalloc(LEN" ID="5">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="P一＞data二x;" ID="6">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="P一＞nex七二Top;" ID="7">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="Top二P%" ID="8">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="ReturnOK;" ID="9">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="图3-4插入新元素后的链栈" ID="10">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="7.出栈（POP）算法算法步骤为：C1)检查栈是否为空，若栈空，则进行“溢出”错误处理。" ID="11">
        <fptr EndPN="00000058" StartPN="00000058"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)删除栈顶元素，修改和讨旨针。" ID="12">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)释放被删结点。" ID="13">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="算法描述为：Pop_Link_Stack(NodeTop.elemtypex)｛／＊若栈不空，则删除栈顶元素，用X返回其值，／主f(Top二二NULL){/＊检查栈是否为空＊／printf(&quot;Overflow&quot;exit():" ID="14">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="15">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="else{p=Top;x二Top一＞data;Top二Top一＞nex七；Free(p);ReturnOK:｝" ID="16">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
      <Paragraph CONTEXT="｝top图3-5删除栈顶元素后的链栈" ID="17">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="49" TITLE="3.4  堆栈的应用举例" TYPE="Chapter">
      <fptr LogicalPageNum="59" PhysicalPageNum="59"/>
        <div ORDERLABEL="49" TITLE="3.4.1  算术表达式的求值" TYPE="Chapter">
        <fptr LogicalPageNum="59" PhysicalPageNum="59"/>
        <Paragraph CONTEXT="在程序设计中，算术表达式通常是由算术操作符、操作数和括号构成，算术操作符大多含有十、一、＊、／等四则运算，括号有左右圆括号（），这些统称为算符，操作数可例如，＃3＊（4＋8）12-5＃就是一个完整的算术表达式。算术表达式求解的关键问题是确定操作符的优先顺序。我们知道，四则运算的优先规则是：" ID="1">
          <fptr EndPN="00000060" StartPN="00000059"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)先括号内，后括号外。" ID="2">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）先乘除，后加减。" ID="3">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)同级运算从左到右。根据这一运算规则，规定算符优先规则：假设B：、4：分别为两个操作符，用＞、＝、＜关系操作符表示算符之间的优先关系：" ID="4">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="B，&gt;62，B，优先级高于Bz优先级。" ID="5">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="B,二B2,B。优先级等于B,优先级。6i&lt;Bz,B，优先级低于BZ优先级。算符优先法则在计算机中可以用一个二维数组表示，表3-1表示算符间的优先关系。‘）’与‘（’之间无优先关系。算法思想：具体做法是设两个堆栈，一个是操作数栈O尸DS，另一个是操作符栈OPS，分别存放操作数与操作符。首先将标志‘＃’进操作符栈OPS的栈底，按照后进先出的原则进行：" ID="6">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)遇到操作数，进操作数份砚舜戈，计算机继续扫描下一符号。" ID="7">
          <fptr EndPN="00000060" StartPN="00000060"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)遇到操作特时，须将此操作fi优先级与OPS栈顶操作行优先级比较。若栈顶元素优先级低则进OPS栈，继续扫描下一符号。若栈顶元素优先级高，则操作符栈OPS栈顶元素出栈，形成一个操作码B，同时，操作数栈O尸DS栈顶元素两次出栈，形成两个操作数“，b，计算机对操作数与操作码完成一次操作操作，即aBb。其操作结果存放在操作数OPDS栈中，作为一次操作的中间结果进口尸DS栈。若与OPS栈栈顶元素优先级相等则栈顶元素出栈。当遇到栈顶元素是‘＃’时，表示整个操作结束，否则，继续扫描下一符号。算符优先算法在实现时，考虑到四则运算中有除法‘／’，中间结果可能含小数点，因此，设操作数栈是一个实数栈。为简化编程的复杂性，假使输入的算术表达式是正确合法的，并且操作数为一位数字，如果操作数是多位数字时，则需将输入的字符串转化50为整数形式，不能简单地减去‘o'。算法的具体描述见本章附录。" ID="8">
          <fptr EndPN="00000061" StartPN="00000060"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="51" TITLE="3.4.2  在递归问题中的应用" TYPE="Chapter">
        <fptr LogicalPageNum="61" PhysicalPageNum="61"/>
        <Paragraph CONTEXT="递归算法是数据结构中最富有表现力和技巧性的问题之一。许多类型的问题可以用递归算法描述。常见的数学递推公式可以直接写成递归形式的算法；用递归方式定义的数据结构，例如：二叉树、）’一‘义表的操作用递归描述，浓缩而简练：很多算法，例如：二分查找，快速排序等用递归算法构造程序，易于宏观把握程序的全局。然而，递归算法也是技巧性颇高的一种算法技术，其关键点是递归调用与返回时各种参量的变化及其相互作用。数学中常常利用递归手段来定义一些概念，最简单的例子就是求阶乘的运算。n的n!=n刀一1)!（规定：0！二1)为了定义n的阶乘，必须先定义（(n-1)的阶乘；为了定义（(n-1)的阶乘，又必须先定义（1-2)的阶乘……这种用自身的简单情况来定义自己的方式就是一个递归定义过程。以n二3为例，求3！的过程可以描述如一F:" ID="1">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="i3!" ID="2">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="②" ID="3">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="⑥" ID="4">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="Q3!二3*2!2！二2*1!1！二1*0!0!=11！二1*1二1" ID="5">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="2！二2＊1二2" ID="6">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="=3*2二6" ID="7">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="对于每个正整数而言，其阶乘的值取决于另一个数的阶乘的值。" ID="8">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="在算法设计过程中，把一个通过算法调用语句直接或者间接调用自己的算法称为递" ID="9">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="归算法。调用自己的语句可出现一次，也可出现多次。" ID="10">
          <fptr EndPN="00000061" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="一个递归定义必须具有确切的含义。也就是说，递归定义必须一步比一步简单，最后有终结，不能无限制地循环下去。过程中最简单的那一步成为递归出口，它本身不再使用递归的定义。如上所见，一个递归函数大都包含一F面几项内容：首先是递归调用语句，如fact（。一1)；其次是基值的判断，如n二＝0即为基值，它保证了递归可以终止，满足基值条件后的计算return1，一般称为最终计算；再次是调用之后的返回处理。如return(nfact。一1，是返回之后要进行的工作，往往又涉及到若千计算。递归实现的过程如下：首先，函数每一次调用自己，实际上是同样函数的再一次执行。所不同的是参数n在不断减1，向基值靠拢，直至达到基值状态0，完成最终计算。其次，调用返回时，有明确的返回点，即调用的一F一条语句。为了正确执行调用与返回，在执行调用时必须先保留现场，暂存返回地址和下一层参数。不难理解，在一系列调用过程中.最后暂存的现场数据，返回时最先取出使用。因此保留现场的任务理应采用堆栈结构来完成。往深一层的调用对应着一次进栈操作，每次返回到上一层对应着一次退栈操作。" ID="11">
          <fptr EndPN="00000062" StartPN="00000061"/>
        </Paragraph>
        <Paragraph CONTEXT="下面是一个求组合数嵘的算法示例。我们知道，Cnm的递推公式为Cn_Cn＿，+Cn-I+n+n-Im-1，注意到C.mm二r,c&quot;m二1，递归算法为：" ID="12">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="intComb(intm,intn)" ID="13">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="14">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="if(m二二nIIn二二0)" ID="15">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="return1;" ID="16">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn(Comb(m-1,n｝十Comb(m-1,n-1));｝" ID="17">
          <fptr EndPN="00000062" StartPN="00000062"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="堆栈是计算机科学中很重要、也是应用很广泛的数据结构之一。例如，在编译和运行程序的过程中，就需要利用堆栈进行语法检查（如检查括号是否配对）、表达式求值、实现递归过程与函数调用等。用" ID="1">
        <fptr EndPN="00000059" StartPN="00000059"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="52" TITLE="3.5  队列的概念及操作" TYPE="Chapter">
      <fptr LogicalPageNum="62" PhysicalPageNum="62"/>
        <div ORDERLABEL="52" TITLE="3.5.1  队列的定义" TYPE="Chapter">
        <fptr LogicalPageNum="62" PhysicalPageNum="62"/>
        <Paragraph CONTEXT="数据结构中定义的队列与日常生活中的排队是一致的。例如，在银行排队等待取款，在公共汽车站排队等车等，都是“先来先服务”。新来的成员总是加入队尾，每次离开的成员总是队头上的成员，即入队在对队尾进行，而出队在队头进行。队列（Queue）是限定只能在表的一端进行插入操作，作的线性表。表中允许插入的一端叫做队尾（Rear，允许删除的一端叫做队头(Front)。队列的插入操作有时也简称进队或入队，删除操作有时也简称出队。向队列中插入新的元素，则该元素就成为新的队尾元素；从队列中删除元素，其后继元素则成52为新的队头元素。由于队列的插入和删除分别在表的两端进行，所以要删除的元素是队列中最先进入的元素，因此又把队列称作先进先出（FirstInFirstOut，简称FIFO）表。假设Q二（(aa2,a）为一个队结构，那么队头元素为a,，队尾元素为a，o" ID="1">
          <fptr EndPN="00000063" StartPN="00000062"/>
        </Paragraph>
        <Paragraph CONTEXT="a,raZrra。的顺序入队的，退出该队列也只能按照这个次序进行。也就是说，只有在a,sazs…，a都已经出队后，a。才能出队。队列和堆栈一样，也是一个动态结构，" ID="2">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="53" TITLE="3.5.2  队列的有关操作" TYPE="Chapter">
        <fptr LogicalPageNum="63" PhysicalPageNum="63"/>
        <Paragraph CONTEXT="与堆栈类似，队列的操作可以归纳为以下几种：.Insert(Q,x)初始条件：队列Q己存在。操作结果：插入元素x为Q的新的队尾元素。队尾的位置由Rear指出。·Delete(Q)初始条件：队列Q己存在且非空。操作结果：删除P(i勺队头元素。队头的位置由Front指出·Empty(Q)初始条件：队列Q己存在。操作结果：若队列Q为空.则返回TRUE，否则返回FALSEo.GetFront(Q)初始条件：队列Q已存在。操作结果：取得队列Q的队头元素。要注意区别Delete(Q）和GetFront(Q）操作。Delete(Q）要修改队头指针。·Create(Q)操作结果：构造一个空队列Q·ClearQueue(Q)初始条件：队列Q已存在。操作结果：将队列Q置为空队列。" ID="1">
          <fptr EndPN="00000063" StartPN="00000063"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="队列是另外一种十分重要的数据结构。对队列的操作要求“先进先出”。它的操作规则同样也是由线性表某些操作，增加了特殊限定条件演化而来的。" ID="1">
        <fptr EndPN="00000062" StartPN="00000062"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="53" TITLE="3.6  队列的顺序存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="63" PhysicalPageNum="63"/>
      <Paragraph CONTEXT="由于队列也是一种线性表，因此，可以用一维数组来描述队列的顺序存储结构。队列比堆栈的顺序存储结构稍微复杂一点：除了定义一维数组Queue[MAX」来存放队列的元素以外，同时还需要设置两个变量front和rear以分别指出队头元素与队尾元素的位置。为了在设计算法上方便以及算法本身的简单，约定：队头指针front指出实际队头元素所在位置的前一个位置，顺序存储结构所使用的结构类型可定义为：#defineMAX100:/＊队列的最大元素个数＊／struc七SgQueue{elemtypeQueue[MAXintfront,rear:/＊取值范围为：一1二MAX-1｝；初始化时，front=rea；二一1。测试一个队列是否为空的条件是front=二rear。图3-7展示了在顺序存储结构中，队列中的元素和队头指针front、队尾指针rear的变化过程。图3-7顺序结构队列的头、尾指针设Q为具有顺序存储结构的SgQueue类型的一个队列，x为具有elemtype类型的" ID="1">
        <fptr EndPN="00000064" StartPN="00000063"/>
      </Paragraph>
      <Paragraph CONTEXT="1.插入操作（进队）算法" ID="2">
        <fptr EndPN="00000064" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="算法描述为：Insert(SgQueueQ,elemtypex)｛／＊插入数据元素x为新的队尾元素＊／if(Q.rear二二MAX-1){/＊检查队列是否已满‘／54printf(&quot;Overflow&quot;exit():" ID="3">
        <fptr EndPN="00000065" StartPN="00000064"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="4">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.rear十＊；" ID="5">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.Queue[Q.rearJ=x;returnOK;" ID="6">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝进队列之前，必须先检测队列是否已满。若队列已满则需要给出相应的溢出信息；否则，将队尾指针增1，然后将新的数据元素X插入到当前队尾指针所指的位置。" ID="7">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="2.删除操作（出队）算法算法描述为：Delete(SgQueueQ,elemtypex)｛／＊删除队头数据元素并保存在x中，／ifCQ.front二二Q.rear)，检查队列是否为空＊／" ID="8">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(&quot;Underflow&quot;" ID="9">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="exit();｝" ID="10">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.frontX二Q.Queue[Q.frontJreturnOK;" ID="11">
        <fptr EndPN="00000065" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="｝删除队头元素之前，必须先检测队列是否为空。若空则需要给出相应的处理信息；否则，删除队头元素（队头指针增1)。如果需要，可以把被删除的元素保存在一个变量中。应该说明，所谓删除，并不是把队列头部元素从原存储位置上物理删除，只是将队列头部指针指向队尾方向移动一个位置，这样，原来那个队列头元素就不再认为包含在队列中了。在队列的插入算法中，若Queue[OJ-Queue[max-11均有元素，再进行插入操作就会溢出。由于每次删除的总是队列头部元素.而桶入操作又怠存队犀讲行，队利的动产生溢出。态变化犹如使整个队列向上移动。当队尾指针rearmax-1时，再做插入操作就会产生溢出，而实际上这时队列还有许多空的位置。因此，这种溢出称为假溢出。为了解决假溢出问题，可能的做法是，每次删除队列头一个元素后，把整个队列往下（往前）移动一个位置。这样，删除算法就可以修改为下面的形式：Delete(SgQueueQ,elemtypex)｛／＊删除队头数据元素并保存在x中＊／if(Q.rear二二一1)＊检查队列是否为空＊／printf(^Underflow&quot;）" ID="12">
        <fptr EndPN="00000066" StartPN="00000065"/>
      </Paragraph>
      <Paragraph CONTEXT="X二Q.Queue[01;for(i二0;i＜二rear-2;i" ID="13">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.Queue[i］二Q.Queueli＋1」；rear二rear-1" ID="14">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="returnOK;" ID="15">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="｝算法中队头指针就用不着了，因为按这种方法，队头元素的位置总是在队列前端。很显然，这个算法似乎不太可取，因为若队列中已有1000(）个元素，为了删除队头元素，需要移动其他9999个元素。一个巧妙的做法是，如果把队列设想成头尾相联的循环表，使得空间重复使用，问题便得到解决。这种队列通常称为循环队列。当然，这也会带来其他需要加以处理的问利用数学中的求模操作（％），就会使这种循环队列的操作变得简单容易了。当队列的第二ax-1个位置被占用以后，只要队列前面还有可用空间，新的元素加入图3-8循环队列示意图这样，插入算法中修改队尾指针的语句就可以写成" ID="16">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="if（Q.rear二二max-1）" ID="17">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.rear二0；" ID="18">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="EISe" ID="19">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.rear＋＋；若修改后的队尾指针满足Q－rear二＝Qfront，那么就真的要产生溢出了。修改队尾指针的语句若采用求模操作（％），则可以改成如下赋值语句的形式" ID="20">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.rear＝（Q.rear＋1）％max同样，在删除算法中也会有Qjh，nt＝（Q.front＋1）％max" ID="21">
        <fptr EndPN="00000066" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="3.循环队列的插入操作（进队）算法算法描述为：工nsertCY（SqQueueQ，elemtypex）（／＊插入数据元素X为新的循环队列队尾元素＊／ifQ.rear十1)$MAX二二Q.front{!／检查循环队列是否已满printf(&quot;Overflow&quot;exits):" ID="22">
        <fptr EndPN="00000067" StartPN="00000066"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="23">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.Y-ear=(Q.rear+1)％MAX;" ID="24">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.Queue[Q.rearJ二x;returnOK;" ID="25">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="｝4循环队列的删除操作（出队）算法算法描述为：DeleteCY(SgQueueQ.elemtypex)｛／＊删除循环队列中由fron七指出的队头元素，并保存在x中‘／if(Q.front二二Q.rear）｛／＊检查循环队列是否为空‘／printf(&quot;Underflow&quot;exit();" ID="26">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="27">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="Q.fron七二（Q.front+1)％MAX;X二Q.Queue[Q.frontJ;returnOK;" ID="28">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="｝在上述两个不同的算法中，测试循环队列“满”和“空”的条件都是rear二front.这样会产生混乱吗？仔细分析就会发现，只有当rear加1以后从“后面”赶上来，并等于front时才是循环队列“满”的情况，其余情况下的front=rear均表示循环队列“空”。应该说明的还有一点，此时循环队列的满，实际上还有一个空位置（仅一个），但借此能区别“上溢”与“下溢”。当然，循环队列并不一定是唯一的解决方法。" ID="29">
        <fptr EndPN="00000067" StartPN="00000067"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="57" TITLE="3.7  队列的链式存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="67" PhysicalPageNum="67"/>
      <Paragraph CONTEXT="据结构来说，采用链式存储结构比采用顺序存储结构更有利。队列就属于这样一种数据结构。队列的链式存储结构就是用一个线性链表来表示队列，简称链队列。具体地说，把线性链表的头指针定义为队头指针front，在链表最后结点建立指针rear作为队尾指针，并且限定只能在链头进行删除，在链尾进行插入。这个线性链表就构成一个链队列。与顺序存储结构队列小同的另一点是，与队尾结点，即它们分别给出了实际队头元素与实际队尾元素所在链结点的存储地址。57图3-9就是链队列的一般形式。平哑殴一’一掣显然，检测链式存储结构下队列是否为空的条件为front二＝NULL。实际上，在链队列中插入一个新的数据元素就是在链表的表尾结点后添加一个新结点，而删除一个元素的操作就是在删除链表的第一个结点。下面给出链队列的插入与删除操作的算法。" ID="1">
        <fptr EndPN="00000068" StartPN="00000067"/>
      </Paragraph>
      <Paragraph CONTEXT="1.链队列的插入操作（进队）算法算法描述如F（图3-10是插入操作的示意图.）：工nsert_Link_Queue(Nodefront,Noderear,elemtypex)｛／＊插入数据元素x为新的队尾元素，／if(!(p=(Nodemalloc(sizeof(Node／＊检查是否申请成功＊／printf(&quot;NoNode&quot;exit();" ID="2">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="3">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="P一＞data二x;" ID="4">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="P一＞next二NULL;if(front二二NULL){front=p;rear=p;}插入空队的情况‘／else{" ID="5">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="rear一＞next二P.rear=p;" ID="6">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="〕／＊插入非空队的情况＊／returnOK;｝" ID="7">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="罕何皿仁加月广" ID="8">
        <fptr EndPN="00000068" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="58和链栈一样，对链队列做插入操作一般不会产生溢出，除非己无可用空间。" ID="9">
        <fptr EndPN="00000069" StartPN="00000068"/>
      </Paragraph>
      <Paragraph CONTEXT="2.链队列的删除操作（出队）算法算法描述为：Delete_Link_Queue(Noderear,Nodefrontelemtypex)｛／‘删除链队列的队头元素，井保存在x中，／if(front二＝NULL)(检查链队列是'i为空＊／printf(&quot;Empty:&quot;exit():}else{P二fron七；front二front一＞next;X二P一＞data;free(p):｝returnOK;｝图3-11是删除操作的示意图。" ID="10">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="59" TITLE="3.8  综合实例——算符优先算法" TYPE="Chapter">
      <fptr LogicalPageNum="69" PhysicalPageNum="69"/>
      <Paragraph CONTEXT="#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#defineFALSE0#defineTRUE1#defineMAx10floaopds[MAXcharopslMAx7;inttopd二0;inttop二C;" ID="1">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="charsymb;" ID="2">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="59" ID="3">
        <fptr EndPN="00000069" StartPN="00000069"/>
      </Paragraph>
      <Paragraph CONTEXT="voidmainO" ID="4">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="5">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="charsy;" ID="6">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="floata,b;printf(nPleaseinputexpresionend):\n&quot;);push＿ops（’＃’）；" ID="7">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="symb二getcharO;while((symb！二’＃’11（oPs［toP］！二’＃’））｛if((symb！二’＋’）＆＆（sylllb！二’一’）＆＆（syn、b！＝‘＊’〕＆＆(symb！二’／’）＆＆｛syl们上〕！二‘(')(symb！二’）’）＆＆(symb！二’＃’）＆＆（symb！二“））｛push_opds(symb);sym上〕二ge七char();｝" ID="8">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="else{switch(relation(ops[topsymb)){case':push_ops(symbj;/＊栈顶元素优先权低，／symb二getchar();break;case。二。：sy二pop＿。p引）；／＊与栈顶元素优先权相等＊／symb二getchar();break;case':sy二pop＿。ps（）；／＊栈顶元素优先权高＊／b二pop_opds();a二pop_opds();topdopds[topd］二operate(a,sy,b);break;case’‘：printf{&quot;error\n&quot;);｝" ID="9">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="10">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="｝printf(&quot;Theresult二％1.2fopds[topdJ);｝" ID="11">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="voidpush_opds(charch)" ID="12">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="13">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="intch-i;" ID="14">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="ch＿i二ch一’0';" ID="15">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="opdstopd］二ch_i;" ID="16">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="60" ID="17">
        <fptr EndPN="00000070" StartPN="00000070"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="18">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="floatpop_opds()" ID="19">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="20">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="topd一；returnopds[topd+11,｝voidpush_ops(charch)｛opstopd］二ch;｝" ID="21">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="charpop_opsl)" ID="22">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="23">
        <fptr EndPN="00000071" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="top一一；returnops[top+11;｝charrelation(charsyml,charsym2)／‘功能：返回两个算符的优先级关系‘／｛inti,ind[21;charchl[21;charre(71[7」二（＞＜＜＜＞＞’，chI[01二syml;chl{11二sym2;for(i二0;i＜二1;i{switch(chl[i])｛case':ind[i］二0;break;case’一’：ind(i]二1;break;case'*':ind[i]=2;break;case'/':ind[i]二3;break;case’(':ind[i]二4;break;case')'：ind[i］二5;break;case:ind[i]二6;break;default：printf(&quot;error\n&quot;);return('0')}" ID="24">
        <fptr EndPN="00000072" StartPN="00000071"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="25">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="return(re{ind[01ind[111);" ID="26">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="｝floatoperate(floata,charsym,floatb)／＊返回第一参数与第三参数在第二参数的作用结果，即a.。,b四则操作的结果＊／｛" ID="27">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="floatre;" ID="28">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="swi七ch(sym)" ID="29">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="｛case'：re二a+b;break;case’一’：re二a-b;break;case'：re=a*b;break;case'/':re二a/b;break;default:printf(&quot;error\n&quot;);return(0);" ID="30">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="31">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="工eturnre;" ID="32">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
      <Paragraph CONTEXT="｝利用该算法对算术表达式37-2)求值，栈的变化如下表所示。表3-2栈的变化图步骤OPS栈OPDS栈输入字符主要操作1#3*(7-2)#Push_opds(’3，)2#3*(7-2）＃内sh＿ops（‘.＊1）3#*3&lt;7-2)#Push_ops(1(，)4#*(37-2)#Push_opds(r7，)5#*(37-2)#Push_ops(一，）-2）＃6#*（一372)#Push_opds(’2，)7#（一37z)#operate(7,一1，2)产不‘jJ，井FoP＿oPs七J9＃＊35＃0伴rate（3，1一，5）开operate（」，－10＃15＃Retum（0冈stto冈1）" ID="33">
        <fptr EndPN="00000072" StartPN="00000072"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="63" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="73" PhysicalPageNum="73"/>
      <Paragraph CONTEXT="1.试分别说明堆栈和队列之间的共同点与不同点。" ID="1">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="2.若一个栈的输入序列为1,2,3,…,n时，输出序列的第一个元素是n，则第i个输出元素是什么？" ID="2">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="3.设有一个堆栈，元素进栈的次序为A.B.C.D.E。试问能否得到出栈序列：" ID="3">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)C,E,A,B,D(2)C,B,A,D,EC3)D,C,A,B.E&lt;4)A,C,B.E,D&lt;5)A.B,C,D,E(6)E.A,B.C,D若能，请写出具体的压栈与出栈操作。" ID="4">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="4.指出下面的函数执行outser(5)和outser(6)时分别输出的结果voidoutser(intn)（" ID="5">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCn&gt;0){" ID="6">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="outser(n-2)" ID="7">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="printfCn):" ID="8">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="9">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="10">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="5.试说明下述操作的结果" ID="11">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)POP(PUSH(STACK,xo" ID="12">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)PUSH(STACK,POP(STACKo" ID="13">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)PUSH(STACK,POP(PUSH(STACK,xo6已知Ackerman函数的定义如下：" ID="14">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="11，.、.（m-1，Ackerman（m，n-1））当m护0，n护0时试写出递归算法。" ID="15">
        <fptr EndPN="00000073" StartPN="00000073"/>
      </Paragraph>
      <Paragraph CONTEXT="7.假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不原书空白页" ID="16">
        <fptr EndPN="00000074" StartPN="00000073"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="堆栈和队列在程序设计中应用的十分广泛，可以用来存放许多中间的数据。在编译系统、操作系统等系统软件设计以及递归问题处理等方面都需要使用堆栈或者队列。tkf仑干nR1XiI妻flF几奋七‘kl-4士i卫幽任;ih产卜签srl;汉1Sr母,k七i3'r1左b‘旺f不+去最itR人biltN堆栈和队列都属于线性结构，是两种特殊的线性表。其特殊性在于堆栈和队列的有关操作只是一般线性表中有关操作的一个子集，因此又称堆栈和队列是两种操作上受到某些限制的线性表，或称堆栈和队列为限定性的数据结构。" ID="1">
      <fptr EndPN="00000053" StartPN="00000053"/>
    </Paragraph>
    <Paragraph CONTEXT="本章重点介绍：" ID="2">
      <fptr EndPN="00000053" StartPN="00000053"/>
    </Paragraph>
    <Paragraph CONTEXT="堆栈的顺序存储结构" ID="3">
      <fptr EndPN="00000053" StartPN="00000053"/>
    </Paragraph>
    <Paragraph CONTEXT="堆栈与递归" ID="4">
      <fptr EndPN="00000053" StartPN="00000053"/>
    </Paragraph>
    <Paragraph CONTEXT="队列的顺序存储结构" ID="5">
      <fptr EndPN="00000053" StartPN="00000053"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="65" TITLE="第4章  数组" TYPE="Chapter">
    <fptr LogicalPageNum="75" PhysicalPageNum="75"/>
      <div ORDERLABEL="65" TITLE="4.1  数组的定义和操作" TYPE="Chapter">
      <fptr LogicalPageNum="75" PhysicalPageNum="75"/>
      <Paragraph CONTEXT="人们常把数组定义为“一个连续的存储单元的集合”，但是这种说法并未涉及到数组的本质。数组应该是下标（index）与值（value）组成的偶对的有序集合。这样来描述，就确定了数组的一个卜标总有一个相应的数值与之对应的关系。当然，也可以说数组是有限个同类型数据元素组成的序列。由于这种位置上的有序性是一种线性关系，所以，数组的逻辑结构是一种线性结构。从下面讨论有关数组的基本操作中也可以看到，数组是一个定长的线性表。在C语言中，一维数组类型的定义为：elemtypearray[nelemtype为C语言允许的类型＊／其中i是下标，表示array中所含值的个数。注意，在C语言中，所有的数组都把零当作第1个元素的下标。C语言中允许有多维数组。多维数组最简单的形式是二维数组。一个二维数组实质上是一个一维数组表。为说明一个大小为.M*N的二维数组sword，应这样写：elemtype[word[MN一般情况下，数组没有插入、删除操作，因此，数组的规模是固定的。数组的操作有以下几种：给出一组下标，检索对应数组下标的相应元素。检索具有某种性质的元素。给定一组下标，存取或修改相应元素的值。" ID="1">
        <fptr EndPN="00000075" StartPN="00000075"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="66" TITLE="4.2  数组的顺序存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="76" PhysicalPageNum="76"/>
      <Paragraph CONTEXT="由于对数组不进行插入和删除操作，一旦定义了一个数组，其结构中的数据元素的个数与各个元素之间的相互关系不再发生变化。因此，数组的存储结构一般都采用顺序分配方式。这样，数组中的元素在位置上是顺序排列的，即第i个元素排列在第i-i个元素的后面和第i+1个元素的前面，其排列关系是一种线性关系。所以，数组的逻辑结构是一种线性结构，可用二元组表示为：array=(A,R)其中：A={a;IO（i月n-1，a;Edataobject}R={row}row=&lt;a;，a&gt;IO毛i&lt;n-2,a;，aIEA}对应的图形如图4-1所示。莎（）一眨）（）.一④数组的存储结构是一种顺序存储结构，即在存储空间上，数组的第i+l个元素紧接着存储在第i个元素的存储位置的后面。这样，数组元素之间的线性关系通过顺序存储的方式很自然地反映出来。数组的存储结构可用图4-2表示。存储地址存储空闻元袂序另加：。！云！器俪＊、卜一誉一」base+langth1＋1由于数组中的每个元素都具有相同的类型，所以在存储空间上都占有相同的字节数地址）用助。（ai＿，）来表示，则第1＋l个元素的存储地址为：助c（a，）＝助c（a卜1）＋length若设bas已为数组存储空间的起始地址，即第一个元素a。的存储地址，则数组中任" ID="1">
        <fptr EndPN="00000076" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="意元素a。的存储地址为：Loc（ai）＝base＋1＊length66这样，只要给出‘F标t就可以立即计算出a，的存储地址，所以可随机地访问数组中的任一元素，；手且其访问时间均相同。在多维数组中，元素之间是有规则的排列。元素的位置一般由下标所决定。通常我们以二维数组作为多维数组的代表来讨论。例如，二维数组a[mn)可以表示为：Iao.oao.l····ao,n-｝aL0aLl’一“Ln-I一“二一。“一”一“r-1L&quot;一，.0an一：，……“。一！山一＿a〔）.1al.a＝｛久＿曰……an-LI··…‘数组a的逻辑结构是一种嵌套的线性结构，即首先把它看作是按行号（即第一维下标）排列的具有m个元素的线性结构。其中第1个元素ai＿，为对应的第1-1行，然后再把ai：看作是按列号（即第二维一F标）排列的具有n个元素的线性结构，其中的第j个元素为如，一，。与此相应，数组a的存储结构也是嵌套的顺序存储结构，即第1＋1行元行元索的存储位置的后面，而每一行中的所有元素则按照列号从小到大的顺序依次存储.假定存储数组a的起始地址（也即a（j.0的地址）用base表示，每个元素占用的字节数用length表示，则任一行ai＿1所占用的存储字节数为n＊length。其起始地址（即该行第一个元素久＿，.‘，的存储地址）为ba3’。＋（1-1）＊n＊Iength。该行中任一元素ai-1，.。的存储地址为：第二1行图4-3一：维数组的存储结构示意图的数组tl:reea" ID="2">
        <fptr EndPN="00000078" StartPN="00000076"/>
      </Paragraph>
      <Paragraph CONTEXT="elemtypethreea[srnJ[n" ID="3">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="其中任一元素的存储地址为：Loc（a，一！，＊一，）=base+(i-1)＊m＊n*length+(j-1)＊n＊1ength" ID="4">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
      <Paragraph CONTEXT="+(k-1)*length需要指出的是，有的计算机程序设计语言的数组定义和存储分配与C语言不同，例如FORTRAN语言。" ID="5">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="68" TITLE="4.3  特殊矩阵的压缩存储" TYPE="Chapter">
      <fptr LogicalPageNum="78" PhysicalPageNum="78"/>
        <div ORDERLABEL="68" TITLE="4.3.1  对称矩阵的压缩存储" TYPE="Chapter">
        <fptr LogicalPageNum="78" PhysicalPageNum="78"/>
        <Paragraph CONTEXT="若一个n阶矩阵A的元素满足性质" ID="1">
          <fptr EndPN="00000078" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="a=a;0&lt;i,j&lt;n-1则称该矩阵为对称矩阵。n阶对称矩阵中几乎有一半的元素是相同的，因此，不必为每个矩阵元素都分配存储单元.只需为每一对对称元素分配一个存储单元即可。这样，n阶对称矩阵的矛个元素就压缩到（n＊（n＋1））／2个元素的存储单元中。为不失一般性，我们以行序为主序方式存储对称矩阵下三角型（包括主对角线元素）的元素为例来讲述。设一维数组fa【n＊（n＋1）／21作为n阶对称矩阵A的存储结构，那么，当A中任意68一个元素a：与.fa[k]之间存在者如下对应关系时，则有a1.，一，=fa[k]o(ii+1)" ID="2">
          <fptr EndPN="00000079" StartPN="00000078"/>
        </Paragraph>
        <Paragraph CONTEXT="lJ*j+1),l2当ij时" ID="3">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="k=当i&lt;j时也就是说，对任意一组下标值（i-1,j-t)均可以在fa中找到矩阵A的元素a;一，.j一！；反之，对所有k二0，1，2，…，（n＊（n＋1）12）…，&lt;i-1,,rl)。为此，称fa仁n＊（n＋l）12伪n阶对称矩阵A的压缩存储。如图4-4所示。1-ao.oIal.01at.111aoI、一i.一：｝012”一1)12n(n+12k二图4-4对称f阵的压缩存储这种压缩存储的方式同样也适用于三角矩阵。" ID="4">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="69" TITLE="4.3.2  对角矩阵的压缩存储" TYPE="Chapter">
        <fptr LogicalPageNum="79" PhysicalPageNum="79"/>
        <Paragraph CONTEXT="即除了主对角线上和直接在主对角线上、下方若干条对角线上的元素之外，其余元素均｝U2一“2一“2，3" ID="1">
          <fptr EndPN="00000079" StartPN="00000079"/>
        </Paragraph>
        <Paragraph CONTEXT="｝“，·，“，·‘＿｝｝“‘·‘“‘·，｝La5.4U5,5JA｝｝“1·。aZJaZ.2a2，3日‘r，则有a，一，一，f[kl。%1.f，[3，2-2］为对角矩阵的压缩存储，如图4-6所示。！ao.oI.，'fao｛a工，ialp2I’f.ai.1f”1an-I.n.Il012342't+3n-3图4-6对角知阵的t缩存储上面讨论的儿种特殊矩阵中，非0元素的分布都具有明显的规律，因而都可以被压缩存储到一个一维数组中，并能够确定这些矩阵的每个非0元素在一维数组中的存储位置。但是，对于那些非0元素在矩阵中的分布没有规律的特殊矩阵（如稀疏矩阵），则" ID="2">
          <fptr EndPN="00000080" StartPN="00000079"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在科学与工程计算问题中常常涉及到矩阵运算。一个m行n列的矩阵共有。*n个矩阵元素，若m二n，则称该矩阵为n阶方阵。本节中我们主要了解矩阵在计算机内的有效存储方法和对应的各种操作。在程序设计语言中不提供矩阵运算的各种功能。一般情况下，人们在利用程序设计语言编程时，很自然地就会将矩阵的元素存储在一个数组中。由于这种方法可以随机访问每一个元素，因而能够容易地实现矩阵的各种运算。在对矩阵进行处理时，常出现一些阶数很高的特殊矩阵，其特殊性在于矩阵中往往有许多值相同的元素或者0元素。我们称具有许多相同元素或者0元素分布有一定规律的矩阵为特殊矩阵，而称具有较多0元素的矩阵为稀疏矩阵。如果采用前面提到的方法，必然会浪费大量的存储空间来存放实际上不必要的元素。为了节省存储，可以对这所谓压缩存储就是为多个值相同的元素只分配一个存储空间，对0元素不分配存储空间。例如，一个1000x1000的矩阵中有800个非0元素，只需给这800个元素分配存储空间就可以了。下面就这两类矩阵来分别讨论它们的压缩存储方法。" ID="1">
        <fptr EndPN="00000078" StartPN="00000078"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="70" TITLE="4.4  稀疏矩阵的表示法" TYPE="Chapter">
      <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
        <div ORDERLABEL="70" TITLE="4.4.1  三元组表示法" TYPE="Chapter">
        <fptr LogicalPageNum="80" PhysicalPageNum="80"/>
        <Paragraph CONTEXT="对于稀疏矩阵中的每个非0元素，可用它所在的行号、列号以及元素值这三元组(i,j，a）来表示，若把所有的三元组先按照行号从小到大的顺序，同一行再按照列一号从小到大的顺序进行排列，则就构成了一个表示稀疏矩阵的三元组线性表。图4-7(a）和（b）分别为一个稀疏矩阵M和它所对应的.三元组线性表。" ID="1">
          <fptr EndPN="00000080" StartPN="00000080"/>
        </Paragraph>
        <Paragraph CONTEXT="U.0.3(0&gt;3,5(1.2，一2(2.0,1(2.2,4(2,4,6(4.2，一17" ID="2">
          <fptr EndPN="00000080" StartPN="00000080"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="71" TITLE="4.1.2  稀疏矩阵的顺序存储" TYPE="Chapter">
        <fptr LogicalPageNum="81" PhysicalPageNum="81"/>
        <Paragraph CONTEXT="稀疏矩阵的顺序存储就是对其相应的三元组线性表进行顺序存储。设一个稀疏矩阵具有m行和n列，其非零元素的个数为t，并假定非零元素均为整型数，则它的顺序存储结构可定义为：intspmatrix[MAX31;其中常量人夕乃义应大于等于稀疏矩阵中非零元素的个数t，具体值由用户决定。在被定义的三列二维数组空间中，从第一行开始依次存放三元组线性表中的每个元素，使得每行的三个单元分别存放同一个三元组中的行号、列号及元素值，第0行的三个单元用来分别存放稀疏矩阵的行数。、列数n和非零元素的个数to例如，对于上面的稀疏矩阵M，若采用具有spmatrix类型的数组A来存储（假定取MAX=7)，则存储映像如图4-8所示。" ID="1">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="71" TITLE="4.1.3  稀疏矩阵的链式存储" TYPE="Chapter">
        <fptr LogicalPageNum="81" PhysicalPageNum="81"/>
        <Paragraph CONTEXT="稀疏矩阵的链式存储就是对其相应的三元组线性表进行链式存储。一卜面介绍两种链式存储的方法。" ID="1">
          <fptr EndPN="00000081" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="i.带行指针的链式存储在这种链式存储中，需要把具有一相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表，每个三元组结点的类型可定义为：structmatnode{introw,col;elemtypeval;structmatnode*next;｝；其中row,col,val域分别存储三元组中的行号、列号和元素值，next域存储指向本行下一个结点的指针，当然对本行的最后一个结点来说，其next域的值为空。在这种链式存储中，还需要定义一个行指针数组，该数组中的第i个单元用来存储合疏矩阵中第i行所对应的单链表的表头指针。行指针数组的类型可定义为：ructmatnode*vectype[MAX]红中常量MAX表示稀疏矩阵中的行数。i如，对于上面的稀疏矩阵M,它所对应的带行指针的链式存祥参不’口卿、4-y。）所示。若使每一行单链表都带有附加表头结点，则对应的图形如图4一，、田肌履一‘" ID="2">
          <fptr EndPN="00000082" StartPN="00000081"/>
        </Paragraph>
        <Paragraph CONTEXT="！" ID="3">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="；" ID="4">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="〕" ID="5">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="(a)" ID="6">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="t" ID="7">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="三" ID="8">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="；" ID="9">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="5" ID="10">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="(b)" ID="11">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Paragraph CONTEXT="图4-9带行指针的链式存储结构" ID="12">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Paragraph>
        <Picture URL="00000082\00000082_new\0020.jpg">
          <fptr EndPN="00000082" StartPN="00000082"/>
        </Picture>
        <Paragraph CONTEXT="＿‘＿一，＿，～卜，二曰＿‘军品的心方段享由寸,Eiti干n一劝IfYl.精c甲，NxC丁rr二巾.、不三元组结点既处于同一行的单链表中，又处于同一列的单链表中，即处的行单链表和列单链表的交点处。在十字链表存储中，每个结点的类型可定义为：structcrossnodeIintrow,col$Picture[00000082\00000082_new\0027.jpg]Picture$elemtypevalstructcrossnode*down.*right飞其中down域用来存储指向本列一「一个结点的指针，right域用来存储指向本打卜－个姑点的指针-f面的稀疏矩阵M来说，其十字链表表示如图4-1。所示7$Picture[00000083\00000083_new\0001.jpg]Picture$图a-o稀疏知阵的十字链式存储结构" ID="13">
          <fptr EndPN="00000083" StartPN="00000082"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="73" TITLE="4.1.4  稀疏矩阵的运算" TYPE="Chapter">
        <fptr LogicalPageNum="83" PhysicalPageNum="83"/>
        <Paragraph CONTEXT="这里只讨论稀疏矩阵的转置操作。设一个稀疏矩阵M如图4-8(a)所示，它的顺序存储表示为图4-9的形式。M的转置矩阵N和它的顺序存储表示（假定用具有spmatrix类型的数组Ba，存储），如图411(a)不p(b）所示。，＝to000N=刀口5" ID="1">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="D" ID="2">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="l" ID="3">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="2" ID="4">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="3" ID="5">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="4" ID="6">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="5" ID="7">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="6" ID="8">
          <fptr EndPN="00000083" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="7图4-11稀疏矩阵N和对应的顺序存储结构数组B中三元组排列的顺序是以稀疏矩阵N中元素的行号（即对应M中的列号）从小到大的顺序，若行号相同再以列号（即对应M中的行号）从小到大的顺序排列的。r面根据已知数组A求B来讨论进行稀疏矩阵转置运算的两种方法。第一种方法n'对数组A进行n次扫描（(n为M的列数，即N的行数）才能完成。具体的说，第一次扫描把第二列中其值等于0（即列号为0)所在的三元组（即对应N中第一行非零元素所构成的三元组）按照从上到下（即行号从小到大）的顺序写入到数组B中，第二次扫描把第二列中其值等于1（即列号为1)所在的三元组（即对应N中第二行非零元素所构成的三元组）按照从上到下的顺序接着写入到数组B中，依此类推。具体算法描述为：" ID="9">
          <fptr EndPN="00000084" StartPN="00000083"/>
        </Paragraph>
        <Paragraph CONTEXT="TransMatrix(A,B)" ID="10">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="｛m二A[01[01:n二A(01[11:七二A[01[2J;／＊用m,n，七分别暂存M的行数、列数和非零元素的个数‘／B〔01【0］＝n：B10］【11二m:B[oJ[21＝t:／＊分别置N的行数、列数和非零元素的个数为n,m和七＊／if(t二二0)returnFALSE;零矩阵不必运算，直接返回＊／4二。；／‘用q指示数组B的行下标，初值为。，／for(col二0:coln-1:col／，用col指示待扫描的M的列号.即N的行号＊／for(p二0;p＜二t-1;p／＊用P指示数组A中待扫描的行号‘／if(A[pJ[1］二二col){B[q][0］二A[p][11:B[41[0］二A[p][11:B[q][0】二A[p][11;4十十：" ID="11">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="12">
          <fptr EndPN="00000084" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="｝此算法的运行时间主要取决于双重循环，故算法的时间复杂度为0(n*t)，即同M的列数与非零元素的个数的乘积成正比。第二种方法只需要对数组A进行两次扫描，第一次扫描统计出M中每一列（即对应N中每一行）非零元素的个数，由此求出每一列的第一个非零元素（即对应.N中每一行的第一个非零元素）在数组B中应有的位置，第二次扫描把数组A中的每一个三元组写入到数组B中确定的位置上。设col表示M中的列号（即对应N中的行号），num和pot均表示具有n(n为M中的列数，即N中的行数）个分量的向量，num向量的第col分量（即num[co门）用来统计第col列中的非零元素的个数，pot向量的第col分量（即pot[cof])用来指向第col74列的F一个非零元素在数组B中的存储位置（即行号），显然pot向:的第col分量的初始值（即第col列的第一个非零元素在数组B中的存储位置）应由下式计算：(pot[01=1(1Scol5n-1)根据上面的数组A，得到，rum向量的各分量值和pot向量的各分量初始值如F表4-1所示。表4-1nu。向量和por向量的初始值Col072345Num[col]203110" ID="13">
          <fptr EndPN="00000085" StartPN="00000084"/>
        </Paragraph>
        <Paragraph CONTEXT="尸。t[c·olJ133678" ID="14">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="采用第二种方法的算法描述为：FastTransMatrix(A,B)｛m二A[Ol[01;n=A[01[11;t二A[01(21;／＊用m,n,仁分别暂存M的行数、列数和非零元素的个数‘／B[01[01=n;B[01[1」二m;B[01[2〕二t;／＊分别置N的行数、列数和非零元素的个数为n,m和七＊／if仁二二0)re七urnFALSE;零矩阵不必运算，直接返回＊／for(col=0;col＜二n-l;col" ID="15">
          <fptr EndPN="00000085" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="num[co1J二。；／＊对num向量中的每个分量赋初值。，／for(i二0;i＜二t-1;inum[A[ill]／＊第一次扫描数组A，统计出M中每一列非零元素的个数＊／Po匕［01二0;for(col二1;col＜二n-1;colpot[col]二pot[col-11+num[col-11;／＊求出M中侮一列的第一个非零元素在数组B中的存储位置＊／for(i二0;i＜二七一1;{／＊对数组A进行第二次扫描＊／col二A[i][11;q二pot[col／＊将A中第i个三元组的列号赋给col，将该三元组在数组B中对应的存储位置赋给qpot[col／＊使pot[col〕指向第col列的下一个非零元素在数组s中对应的行号*｝" ID="16">
          <fptr EndPN="00000086" StartPN="00000085"/>
        </Paragraph>
        <Paragraph CONTEXT="｝此算法的运行时间主要取决于4个并列的单循环，算法的时间复杂度为O(n+t)，显然，它比第一种算法的时间复杂度要好得多。因此，通常把此算法称作为快速转置算法。" ID="17">
          <fptr EndPN="00000086" StartPN="00000086"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在计算机中，存储矩阵的一般方法是采用二维数组，其优点是可以随机地访问每一个元素，因而容易实现矩阵的各种运算。但当一个矩阵中非零元素的个数远远少于零元素的个数时，这种矩阵称之为稀疏矩阵。一般情况下，当非零元素的个数只占矩阵元素总数的25%30%，或低于这个百分数时，就可以把这个矩阵看做是稀疏矩阵。在存储稀疏矩阵时，为了节省存储单元，很自然的是只存储非零元素。但由于非零元素在矩阵中的分布一般是没有规律的，因此，在存储非零元素的同时，还必须存储适当的辅助信息。在本节中我们主要学习采用三元组表示法和十字链表表示法的压缩存储。" ID="1">
        <fptr EndPN="00000080" StartPN="00000080"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="76" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="86" PhysicalPageNum="86"/>
      <Paragraph CONTEXT="1.设！一个10X10的对称矩阵A，采用压缩存储方式，以行序为土序，ao,i，为第一个元素，其存储地址为1，每个元素占1个地址空间，则a7.4的地址是多少？" ID="1">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="2.一个NXN的对称矩阵，如果以行或列为主序存入内存，需要多少个存储单元？" ID="2">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="3.试叙述一维数组与有序表的异同。" ID="3">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="4.用三元组表示下面稀疏矩阵的转置矩阵：" ID="4">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="L00oso" ID="5">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="M＝" ID="6">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="01100130008000000-90000" ID="7">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="6.试用十字链表来表示习题4的稀疏矩阵M。" ID="8">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="7.假定数组A［川的n（n＞0）个元素中有多个零元素。试写出一个算法，将A中所有非零元素依次移到A的前端。" ID="9">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="8.试写出一个判别表达式中括号‘（’和‘）’，是否配对的算法。" ID="10">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="9.已知A［n］为整数型数组，试写出实现下列操作的递归算法：" ID="11">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）求数组八中的最大整数。" ID="12">
        <fptr EndPN="00000086" StartPN="00000086"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="儿乎所有的程序设计语言都允许用数组来描述数据，数组已经成了我们十分熟悉的jk#rtfL3fE开dt二考汁冰仗关山少(r#君rLkftf3!tlf1左.3'a1R.i'N]田一4Ert9平堪官ffl!t一种数据类型。在讨论各种数据结构的顺序存储空间时，存储结构。本章将简单讨论二维数组的逻辑结构及其存储方式，另外还得讨论几种特殊" ID="1">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
    <Paragraph CONTEXT="矩阵的压缩存储以及相应的算法。" ID="2">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
    <Paragraph CONTEXT="本章重点介绍：" ID="3">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
    <Paragraph CONTEXT="数组的顺序存储结构。" ID="4">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
    <Paragraph CONTEXT="矩阵的压缩存储。" ID="5">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
    <Paragraph CONTEXT="三元组表示法." ID="6">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
    <Paragraph CONTEXT="十字链表表示法。" ID="7">
      <fptr EndPN="00000075" StartPN="00000075"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="77" TITLE="第5章  字符串" TYPE="Chapter">
    <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
      <div ORDERLABEL="77" TITLE="5.1  字符串的概念和基本操作" TYPE="Chapter">
      <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
        <div ORDERLABEL="77" TITLE="5.1.1  字符串的定义" TYPE="Chapter">
        <fptr LogicalPageNum="87" PhysicalPageNum="87"/>
        <Paragraph CONTEXT="字符串（string)（或称串）是由n(n）0)个字符组成的有限序列。通常记作：其中，S为字符串名（也称串变量）：单引号作为字符串的起止定界符，它是不属于字符串本身的字符：单引号之间的字符序列为串值；a;(lci&lt;n)表示字符串中的第i个字符，n表示字符串中字符的个数，称为字符串的长度：当n=0时，表示一个空串，即串中不含任何字符；当n=1时，表示只含一个字符的串，相当于C语言中的一个字符型数据，一般语言规定，n最大不允许超过2550下面给出一些字符串的例子。" ID="1">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)A=Thisisastring.'" ID="2">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)Bab-c'" ID="3">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)Cy4'" ID="4">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="(4)D这是一个字符串’" ID="5">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="(5)E" ID="6">
          <fptr EndPN="00000087" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="(6)F这几个字符串的长度分别为：17,6,2,14,0和40这里有两点需要说明：①串值必须用一对单引号括起来（如同C语言中用一对双引号括起来一样），但" ID="7">
          <fptr EndPN="00000088" StartPN="00000087"/>
        </Paragraph>
        <Paragraph CONTEXT="只是为了避免串值与串名或者变量名相混淆而己。例如" ID="8">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="xl二’123'" ID="9">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="Y1=123说明X1为字符串名，其类型为字符型，串值为123;Yl是整数类型的变量，其值为整数1230X1和Y1数据类型不相同。又例如：" ID="10">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="s1二’xyz'" ID="11">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
        <Paragraph CONTEXT="S2=xyz说明S1为字符串名，其串值为XyZ;s2和XyZ是相同类型的变量。②要注意由一个或多个空格符所组成的字符串与空串的区别。空串的含义是其本身不包含任何字符，即它的长度为0；而前者是由空格字符组成的非空串，其长度是空格字符的个数。另外，还有几个有关字符串的概念，在设计算法时经常要用到。我们把字符串s中的任意个连续的字符所组成的子序列T称为S的子串，而把S称为T的主串。字符在字符序列中的序号称为该字符的位置；而子串在主串中的位置，是指在主串中第一次出现的子串的第一个字符在主串中的位置来表示。两个字符串相等的充分必要条件是参加比较的两个字符串长度相同，而且对应位置上的字符也相同。" ID="12">
          <fptr EndPN="00000088" StartPN="00000088"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="78" TITLE="5.1.2  字符串的基本操作" TYPE="Chapter">
        <fptr LogicalPageNum="88" PhysicalPageNum="88"/>
        <Paragraph CONTEXT="从字符串的定义来看，字符串属于数据元素类型为字符的一种线性表，因此对线性表的一切操作都能够对字符串进行。下面给出一些字符串的基本操作。·Assign(T,chs)/给字符串变量赋值＊／初始条件：chs是字符串常量操作结果：将ch：的值赋给TConcat(U,S1,S2)/＊两个字符串联接＊／初始条件：S1和S2是两个字符串操作结果：si和s2联接生成新串U·Length(S)/＊求字符串的长度★／初始条件：S是字符串操作结果：返回S的元素个数，即长度Substring(Sub,S,pos,1en)/＊求子串＊／初始条件：S是字符串，1（pos毛Length(S）且。glen&lt;Length(S)-pos+1操作结果：用Sub返回串S的第pos个开始长度为len的子串78Indez(S,T)/求子串在主串中的位置＊／初始条件：S和T是字符串，T是非空串操作结果：若主串S中存在和串T值相同的一子串，则返回它在主串S中第一次出现的位置；否则函数值为0Replace(S,T,V)/字符串替换＊／初始条件：S.T.V是字符串，T是非空表操作结果：用V替换主串S中出现的所有与T相等的子串copy(sI,sz)/＊串的复制＊／初始条件：si和s是字符串操作结果：将st的值复制到s2Insert(S,pos,T)/＊字符串的插入＊／初始条件：S和T是字符串，1蕊pos延Length(S)+1操作结果：在S的第pos个位置之前插入TDelete(S,pos,1en)/＊串的删除＊／初始条件：S是字符串，t&lt;pos（Length(S）一len+1操作结果：从串S中删除第pos个字符起长度为len的子串Compare(S,T)/＊字符串的比较＊／初始条件：S和T是字符串操作结果：若S&gt;T，则返回值＞0：若S二T，则返回值二0；若S&lt;T，则返回值＜0在上述的基本操作中，Assign,Compare.Length.Concat和Substring这5种操作是字符串类型的最小操作子集。即：这些操作不可能利用其他字符串操作来实现，反之，其他字符串操作均可在这个最小操作子集上实现。上述操作中Concat.Substring、Index和Replace的意义，可通过下面的例子予以说明：若SchinaTinpos=2,1en=3,VbeijingS1intelS2microsoft则：Concat(U,Sl,S2）二，in七elmicrosoft'Substring(Sub,S,pos,ten）二’hin'Index(S,T,pos）二3Replace(S,T,V）二’chbeijinga'" ID="1">
          <fptr EndPN="00000089" StartPN="00000088"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="本节所给出的有关字符串的概念，以及所涉及到的有关基本术语，是正确掌握和理解字符串的存储结构和一些基本算法的基础。" ID="1">
        <fptr EndPN="00000087" StartPN="00000087"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="79" TITLE="5.2  字符串的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="89" PhysicalPageNum="89"/>
        <div ORDERLABEL="80" TITLE="5.2.1  字符串的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="90" PhysicalPageNum="90"/>
        <Paragraph CONTEXT="由串的递归定义可知，串仍然是一种线性结构，因此，可采用顺序存储结构来存储出日n田＿4日翻卜石目本夕丰配浮节云扛苗不井了声启要虫才古白台乡竺夕车1尧万fl.右二虫ft!tIlfdif讲于:甚4士tt,字符串，即用一组地址连续的存储单元存储串值的字符序列。在串的顺序存储结构中，按照预先定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如‘卜描述顺序存储结构：#defineMaxS七ringLength255/＊在255以内任意定义最大串长＊／typedefunsignedcharGString[MaxStringLength+l0号单元存放串的长度串的实际长度可在预定义长度的范围内随意取值，超出预定义长度的串值则被舍去，称之为“截断”。对串长有两种表示方法：一种是如上述定义描述的那样，采用固定长度。以下标为存储单元存放串的实际长冷：另一种是设置长冷指针。存串佰后而增加一个不计入0的存储单元存放串的实际长度；另一种是设置长度指针。串长的结束标一记字符，如在C语言中以“\0”表示串值的终结。长为隐含值，显然不便于进行某些串操作。" ID="1">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="本节主要讨论固定长度顺序存储。为了更好地理解一些算法，现给出一个例子以说" ID="2">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="明有关的概念。假设有：charstrl[12J,str2[111;charstrou七【81;若分别通过输入语句把字符串‘China163'、'E-mailbox’和‘International’赋给变量，trl,str2和、trout，则它们的存储结构如图5-1所示。012345678910111(8)ICfh1r1n1a1116131str1012345678910" ID="3">
          <fptr EndPN="00000090" StartPN="00000090"/>
        </Paragraph>
        <Paragraph CONTEXT="s1r2其中下标为0的存储单元存放的是字符串的长度，在图中为括号中的数值。如果字符串的长度大于存储空间的单元个数，则发生“截断”现象。在后面算法设计时，如出现该现象，则做“溢出”处理。" ID="4">
          <fptr EndPN="00000091" StartPN="00000090"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="81" TITLE="5.2.2  字符串的链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="91" PhysicalPageNum="91"/>
        <Paragraph CONTEXT="串值的存储也可以采用链式存储结构，即用不带头结点的线性链表存储。串的链式存储结构是将存储空间分成一系列大小相同的结点，每个结点的构造为：" ID="1">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="IData｛二ext其中，Data域存放字符；next域存放指向下一个结点的指针。这样，一个串就可以用一个线性链表来表示。在串的链表结构中常常涉及到结点的大小，即结点的Data域存放字符的个数。通常情况下，结点的大小为4或1。当结点的大小为4时（有时称这种链表为块链），串所占用的结点中最后那个结点的Data域可能没有全部占满，这是，不足的位置均补上不属于字符集中的特殊字符，如符号中。图5-2所示是结点大小为4和1时的两个链表，串为‘MicrosoftWord'o" ID="2">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="加留匕州可不日斗叫祠不石阵一何祠不卜不洞不祠从翻" ID="3">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="－·－－－···.一坐囚图5-2串的链式存储结构示例字符串的链式存储结构描述如一F：#defineB1ockSize4/＊定义块大小＊／" ID="4">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="structChunk{" ID="5">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="charch[B1ockSize" ID="6">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
        <Paragraph CONTEXT="structChunk*next;｝；对采用链式存储结构的串进行插入和删除操作十分方便，只要相应地修改链结点的指针就可以实现。结点大小为1的链表，虽然存储开销稍大一些，但形式简单，更便于进行插入和删除操作。有时在链表的最前面设置一个头结点，头结点的数据域中存放串的长度。这样可能会给操作带来一些方便。在串的链式存储结构中，除了可用结点大小相同的定长结点链表外，还可以采用结点大小不固定的变长结点链表，这要根据问题来确定。其实，串的链式存储结构不如顺" ID="7">
          <fptr EndPN="00000091" StartPN="00000091"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在大多数非数值处理的程序中，串是一种操作对象。和程序中出现的其他变量一样，可以给串一个变量名，操作时可以通过串变量名访问串值。语言中（如c语言）通常将串定义为字符型数组，通过串名可以直接访问到串值。这种情况下，串值的存储分配是在编译时（预先分配存储空间）进行的，即所谓的静态存储分配。另一种情况就是串值的动态存储分配。另一方面，从串的定义可以看到，串仍然是一种线性结构。因此，线性表的顺序分配方式与动态分配方式对串也是适用的。但是要注意，对串进行某种操作之前，要根据不同情况对串选择合适的存储结构。例如，对串的插入和删除操作，采用顺序存储结构储结构较简单，但要访问一组连续的字符，采用顺序存储结构又要比采用链式存储结构更方便。" ID="1">
        <fptr EndPN="00000090" StartPN="00000089"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="82" TITLE="5.3  字符串操作的实现" TYPE="Chapter">
      <fptr LogicalPageNum="92" PhysicalPageNum="92"/>
      <Paragraph CONTEXT="由于字符串具有多种数据类型的特点，所以字符串的操作非常丰富，F面仅对字符串在顺序存储结构下的一些基本操作进行讨论。" ID="1">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="1.字符串的联结（Concat)算法voidConcat(GStr-ingT,GStringS1,GStringS2)／＊字符串T是Sl联结s2.得到的＊／｛if(S1[0卜S2[O]&gt;MaxStringLength)／＊若两字符串的长度之和大于最大允许的长度，则进行“溢出”处理＊／printf(&quot;Overflow&quot;);for(i=1;i＜二51101；1＋＋）／＊将S1字符串传送给TT[i］二S1[ifor(i二1;i＜二52〔0］；1＋＋）T[S1[Oi〕二S2[i/＊将S2字符串传送给TT[0〕二S1[0］十S2[01;/＊修改字符串T的长度＊／｝" ID="2">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="2.求子串（Substring）算法voidSubstring(GStringSub,GStringS,intpos,int1en)／＊将字符串S从第pos个字符开始，连续len个字符复制到Sub中＊／1廷pos工,ength(S)，O蕊lenSLength(5）一pos+1｛if(pos&lt;1IIpos&gt;S[01II1en＜0曰len&gt;S(0】一pos+1)／＊超出允许范围，进行“超出范围”处理＊／printf(&quot;OutOfRange&quot;);for(i二1;立＜二len;i/＊将S中指定的子串传送给Sub5ub[i」二S[pos+i-11;Sub[0］二len;/＊将子串长度len赋给Sub｝" ID="3">
        <fptr EndPN="00000092" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="3.删除子串（Delete）算法voidDelete(GStri.ngS,intpos,int1en)／＊将字符串S从第pos个字符开始删除len个字符＊／1夏pos毛Length(S）一len+1（if(pos+len-1&gt;S[01)／，超出允许范围，进行“超出范围”处理＊／printf(&quot;Overflow^);82for(i二pos+len;i＜二5【01；1＋＋）／＊将被删除子串后面的所有字符依次前移len个位置‘／S(i-len〕二s[iJ;S[0］二S[0］一Ien;/＊字符串S的长度减少len｝" ID="4">
        <fptr EndPN="00000093" StartPN="00000092"/>
      </Paragraph>
      <Paragraph CONTEXT="4.插入子串（Insert）算法voidInsert(GStringS.intpos,GStringT)／＊在S的第pos个位置之前插入T,1蕊pos（Leng[ath(S）十1（if（05＞5［0］＋1曰pos&lt;1II't[01+S[OJ&gt;MaxStringLength)／＊若两字符串的长度之和大于最大允许的长度，或pos的值不合法，则进行“不能插入”处理＊／printf(&quot;Can't工nsert);for(i二S[OJ;ipos;i一）／＊从第pos个位置起空出连续T[01个位置＊／S[T[01+i］二S[ifor(i=I;i＜二T［0］；1＋＋）S[pos+i-1J二T[i/＊将T字符串写到S中空出的位置＿*/S[01十＝T(01;/＊修改字符串S的长度，／）" ID="5">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="5.求子串位置的算法int工ndex(GStringS.GStringT)／，若主串S中存在和串T值相同的子串，则返回它在主串J中第一次出现的位置；否则函数值为。＊／" ID="6">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="｛1二1;/＊对S扫描时，1是下标，指示S中第1个元素＊／j二1;/＊对T扫描时，j是下标，指示T中第j个元素＊／while((i＜=S[01)(j＜二T[01))if(S[i]二二t[j]){/＊继续使指针分别指向下一个字符，／i/" ID="7">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="〕＋＋；" ID="8">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="｝else{/‘使j重新指向T的第一个字符＊／i=i-j+2;" ID="9">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="j=1;" ID="10">
        <fptr EndPN="00000093" StartPN="00000093"/>
      </Paragraph>
      <Paragraph CONTEXT="）if（j＞T［0］）return(i-T[01)；S中存在T，返回起始位置＊／elsereturn(0)；S中不存在，。返回。值＊／｝" ID="11">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="84" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="94" PhysicalPageNum="94"/>
      <Paragraph CONTEXT="1.试回答空串与空格串有何区别？" ID="1">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="2.两个字符串相等的条件是什么？" ID="2">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="3.设a,b,c,d,e,f都是字符串名，a=`Thisisabook.b=`EsearecS'o求：d=Concat(Substring(a,L2),b),e=Concat(Substring(a,10,5),c),f=Concat(d,e)" ID="3">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="4.己知‘＝‘（xyz）＊’，t＝‘（x＋y）＊y’。试利用连接、求子串和置换等基本操作，将、转化为t，将t转化为：。" ID="4">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
      <Paragraph CONTEXT="5.利用字符串的基本操作，编写从串、中删除和串t相同的子串的算法。84" ID="5">
        <fptr EndPN="00000094" StartPN="00000094"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="现在，计算机已经应用于各个领域，它的应用主要是解决一些非数值计算问题，而这些问题所涉及到的主要操作对象就是字符串数据。在早期的程序设计语言中，字符串是作为输入和输出的常量出现的。随着计算机的不断发展和应用，字符串已经作为一种变量类型出现在程序设计语言中，同时也产生了一系列关于字符串的操作，并建立了一组字符串操作的基本函数。本章主要讨论字符串的一些基本概念和其存储结构，同时也讨论了儿种最基木的字符串处理的算法。" ID="1">
      <fptr EndPN="00000087" StartPN="00000087"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="85" TITLE="第6章  广义表" TYPE="Chapter">
    <fptr LogicalPageNum="95" PhysicalPageNum="95"/>
      <div ORDERLABEL="85" TITLE="6.1  广义表的定义" TYPE="Chapter">
      <fptr LogicalPageNum="95" PhysicalPageNum="95"/>
      <Paragraph CONTEXT="我们已经知道，在一个线性表A＝（a！，aZ，…，氏，）中，每个数据元素a;(l蕊i&lt;n)只限于是结构上不可再分割的原子元素，而不能是其他情况。如果放宽这个限制，允许表中的元素既可以是原子元素，也可以是另一个表，则称这样的表A为广义表。其中，A为广义表的名字；n为广义表的长度：不是原子元素的那些元素称为子表。下面给出广义表的定义。广义表（(list）是n(n,0)个元素的一个序列，当n=0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象（这种元素被称作原子元素），也可以是由原子元素组成的表（这种元素被称作子表或表元素）。显然，广义表的定义是递归的，即表中允许嵌套表，广义表是一种递归的数据结构。设a，为广义表的第i个元素，则广义表的一般表示为：其中n表示广义表的长度，即广义表中所含元素的个数，n&gt;Oo同线性表一样，也可以用一个标识符来命名一个广义表，如用LIST来命名l;面的广义表，则表示为：LIST=(aaZ,…，a…’,a，：)，为了把原子元素与表元素区别开来，在广义表的讨论中，为了把原子元素与表元素区别开来，一般用小写字母表示原子元素，用大写字母表示表。A=()，A是长度为零的空表。B=(e)，B是一个长度为1并且元素为原子元素的广义表（实际上就是前面讨论过的一般线性表）。C=(a,(b,c))，C是长度为2的广义表，其元素分别为原子元素与表元素（(b,c)oD=(A,B,CD是一个长度为3的广义表，其3个元素均为表元素。显然，若将各表元素代入以后可得到E_(a,E）是一个长度为2的递归广义表，相当于E＝（a，（a，（a，…）））。从上面几个例子可以得到以下的结论：" ID="1">
        <fptr EndPN="00000096" StartPN="00000095"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)广义表的元素可以是表元素，而表元素的元素还可以是表元素……因此，I‘义表是多层次结构。" ID="2">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）一个广义表可以为其他广义表所共享。例如，在D二（A,B,C）中，" ID="3">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="A.B.C就是D的表元素。" ID="4">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)广义表可以是递归的。还有一点应该注意，上面的例子中A二（）是个无任何元素的空表：但是，S=(A）则不是空表，它有一个元素，只不过这个元素是个空表而己。因此，A的长度为0；而S的长度为la若把每个广义表的名字（若有的话）写在广义表的前面，则上面的5个广义表可相应地表示为：" ID="5">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="A()" ID="6">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="B(e)" ID="7">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="C(a,(b,c))D（A（），B（e），C（a，（b，c）））E(a,E(a,E(a,E(a,…))))若用圆圈和方框分别表示表元素和原子元素，并用连线把广义表和它的元素（元素r十1头谁于二仁w二」（占c.一奋一、上云，＋咬七L，、1，md.二丫卜i.曰ainr一户，二上，占人下石IT丫之二象，，二二1i（丁石：结点应在其表结点的下方）连接起来，则可以得到一个广义表的图形表示法。如上面5" ID="8">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="个广义表的图形表示如图6-1所示。" ID="9">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="E丫昌者从瞬分·图6-1广义表的图形表示从图6-1可以看出：广义表的图形表示像倒着画的一棵树，树根结点代表整个广义表，各层结点代表相应的子表，树叶结点代表原子元素或空表。广交夫的深庶（denth）.早指广女夯中所含袄县的暴一女个扮." ID="10">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
      <Paragraph CONTEXT="广义表的深度（dePth），是指广义表中所含括号的最大个数，是广义表的一种度" ID="11">
        <fptr EndPN="00000096" StartPN="00000096"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="87" TITLE="6.2  广义表的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="97" PhysicalPageNum="97"/>
      <Paragraph CONTEXT="由于r‘义表是一种递归的数据结构，表中的元素可以是原子元素，也可以是子表，J-是，很难为每个广义表分配一片固定大小的存储空间。因此，难以用顺序存储结构来表示广义表。常用的方法是模仿线性链表的链式存储结构来存储一个］‘义表，厂‘义表中的每个元素由一个结点表示。由于广义表的元素有原子元素与表元素之分，故结点的结构设计为：" ID="1">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="其中tag为标志位，有J’表示该结点为表结点In二共乡占,盾_rag一）。表示该结点为原子结点，当tag=1时，info域存放相应子表第一个元素对应的结点的地址；next域存放本元素同层的下一个元素所在结点的地址，当本元素为所在层的最后一个元素时，next域为NULLo根据分析，广义表中的结点类型可定义为：structGenealNode{主nttag;/＊取值。1structGenealNode*next;switch(tag){case0:(elemtypedata)/＊原子元素＊／case1:(structGenealNode*sublist)/＊子表＊／" ID="2">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝若按照这样的方法进行存储的话，对于上节所列举的几个广义表，其存储结构如图" ID="3">
        <fptr EndPN="00000097" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="6-2所示。扭耳不祠若把整个广义表也同样用一个表结点来表示的话，则应在每个广义表的表头结点（即表中第一个结点）之前增加一个表结点（称此表结点为附加表头结点），此表结点的：ublist域指向表头结点，next指针域为空，表头指针则指向这个表结点，例如，若在广义表A.B,C,D和E的表头结点之前增加这样的表结点，则对应的示意图如图6-3所示。" ID="4">
        <fptr EndPN="00000098" StartPN="00000097"/>
      </Paragraph>
      <Paragraph CONTEXT="A二NULL" ID="5">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="石" ID="6">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="）一刁再" ID="7">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="图6-3带附加表头结点的广义表的链式存储结构可以看出，这种存储方法的表头指针均指向一个表节点，表结点的艺叼勿域指向广义表的第一个元素所在的结点，而next域总是空。这种带附加表头结点的广义表表示，将使广义表的某些操作比较方便。" ID="8">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="88" TITLE="6.3  广义表的操作" TYPE="Chapter">
      <fptr LogicalPageNum="98" PhysicalPageNum="98"/>
      <Paragraph CONTEXT="广义表的操作主要有求广义表的长度和深度，向广义表插入元素和从广义表中查找或删除元素，建立广义表的存储结构，打印广义表等等。由于）’义表是一种递归的数据结构，所以对广义表的操作一般采用递归的算法。全面介绍广义表的各种操作的算法，超出了本课程的教学内容，这里仅讨论比较简单的求广义表深度的算法。广义表深度的递归定义是它等于所有子表中表的最大深度加1。设dep表示任意一个子表的深度，max表示所有子表中表的最大深度，depth表示广义表的深度，则有：若一个表中不包含任何子表时，其深度为1，所以max的初始值为Oo设is是。tructGenealNod。类型的一个指针，开始时指向一个广义表的第一个结点，则求一个广义表深度的递归算法如下：intdepth(strictGenealNode*ls)｛" ID="1">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="ifCls二二NULL)return(1)：/＊空表＊／$Picture[00000098\00000098_new\0015.jpg]Picture$if(ls一＞七ag！二0)" ID="2">
        <fptr EndPN="00000098" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="88return(0)；原子元素max二0;‘给max赋初始值0*iwhile&lt;ls！二NULL){if(ls一＞tag二二1){dep二depth(lssublist)；/＊递归求出子表的深度，／if(dep&gt;max)" ID="3">
        <fptr EndPN="00000099" StartPN="00000098"/>
      </Paragraph>
      <Paragraph CONTEXT="max=dep;/＊使二ax始终为所求过的子表深度中的最大值‘／）" ID="4">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="1。二is一＞next;使is指向同一层下一个结点（后继结点）＊／｝reurn(max+1);）土述算法的执行过程实质上是遍历广‘义表的过程.在遍历中首先求得各子表的深度，然后综合得到广义表的深度。" ID="5">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="89" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="99" PhysicalPageNum="99"/>
      <Paragraph CONTEXT="1.判断题" ID="1">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）厂一义表是由零或多个原子或子表所组成的有限序列，所以广义表可能为空表。" ID="2">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）线性表可以看成是广义表的特例，如果广义表中的每个元素都是原子元素，则广义表便成为线性表。" ID="3">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="2.画出下列每个‘义表的图形表示A=(x,v,z)" ID="4">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="B=(x,(v,z))" ID="5">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="C=(x,(y,(z)))D=cx,cy,cZ,x,cy,cz)))))" ID="6">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="3.什么是广义表？请对下面给出的广义表设计一种存储结构（先说明结点的组成以及各成分的意义，然后画出该广义表的存储结构）C=(A,B)B二（A,y)A=(x,L)L=(a,b)其中a,b,x,y为原子元素。" ID="7">
        <fptr EndPN="00000099" StartPN="00000099"/>
      </Paragraph>
      <Paragraph CONTEXT="4.画出卜列每个广义表的链式存储结构a=cx,y,z)B=ccx,y),cy,z))c=(x,(y,(z,(y))))D=(x,(y,(z,&lt;)，(x,(z)))))原书空白页" ID="8">
        <fptr EndPN="00000100" StartPN="00000099"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="］’一义表是线性表的一种推）它是一种广泛应用于人土智能等领域内的重要数据结构。厂一义表也称为列表或者简称为表。" ID="1">
      <fptr EndPN="00000095" StartPN="00000095"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="91" TITLE="第7章  树与二叉树" TYPE="Chapter">
    <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
      <div ORDERLABEL="91" TITLE="7.1  树的概念" TYPE="Chapter">
      <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
        <div ORDERLABEL="91" TITLE="7.1.1  树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="101" PhysicalPageNum="101"/>
        <Paragraph CONTEXT="树（(tree)是n(n.0）个结点的有限集合（若用T来表示这个集合）。在一棵树中满足如下两个条件：有且仅有一个特殊的称为根的结点.J」‘入占‘去丰＿卜二，.，、J‘＿＿＿了＿＿、八、洲入若1叮妇，，长谜诀，侧岛.找目佳‘之、" ID="1">
          <fptr EndPN="00000101" StartPN="00000101"/>
        </Paragraph>
        <Paragraph CONTEXT="其余的结点可分jjm(m&gt;0）个互不相交的有限集合，其中每个集合又都是一裸树，并称其为根的子树.其中，n=0的树称为空树。显然，树是递归定义的，即在树的定义中又用到了树的概念。它刻画了树的固有特性。树的递归定义，将为以后实现树的各种运算提供方便。图7-1(a)就是一棵树T，它由根结点A和两棵子树T,和TZ（分别对应图7-1(b）和7-1(c)）所组成；T，又有它的根结点B和三棵子树TT,：和T13（分别对成，每棵子树的根结点分别为H和I;T,由它的根结点C和一棵子树所组成，该子树也只含有一个根结点G，不可再分。" ID="2">
          <fptr EndPN="00000102" StartPN="00000101"/>
        </Paragraph>
        <Picture URL="00000102\00000102_new\0008.jpg">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Picture>
        <Picture URL="00000102\00000102_new\0010.jpg">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Picture>
        <Paragraph CONTEXT="几" ID="3">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="odbo图7-l树的结构示意图在一棵树中，结点被定义为它的每个子树的根结点的前驱，而它的每个子树的根结" ID="4">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="点就成为它的后继。tree=(D,R)D＝｛a‘11蕊1毛n0，n为树中结点数，a;Eelemtype}R二｛r}当n&gt;0（即非空树）时，关系；应满足下列条件：" ID="5">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)有且仅有一个结点没有前驱，该结点被称为树的根。" ID="6">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="(2)除树根结点外，其余每个结点有且仅有一个前驱结点。&lt;3）包括树根结点在内的每个结点，可以有任意多个（含0个）后继。对应图7-1(a）所示的树T，若采用二元组表示，则结点的集合D和D上二元关系r分别为：D={A,B,C,D,E,F,G,H,I}r＝｛＜A，B＞，＜滩，（卜，＜召，D＞，＜刀，石卜，&lt;B,F&lt;C,G&lt;E,H&lt;E,I&gt;}其中结点A无前驱结点，被称为树的根结点；其余每个结点有且仅有一个前驱结点；在所有结点中，B结点有3个后继结点，A结点和E结点分别有2个后继结点，C结点有1个后继结点，其余结点皆无后继结点。树结构广泛存在于现实生活中。【例7-1)可把人类的家族关系看作为一棵树，树中的结点为家属成员的姓名及相关信息，树中的关系为父子关系，即父亲是儿子的前驱，儿子是父亲的后继。图7-2Ca)就是一棵家族树，张大有两个儿于张二一和张二二，张二一又有三个儿子张三" ID="7">
          <fptr EndPN="00000102" StartPN="00000102"/>
        </Paragraph>
        <Paragraph CONTEXT="一、张三二和张三三。［例7-2】可把一个算术表达式表示成一棵树，运算符作为根结点，它的前后两个运算对象分别作为根的左右两棵子树。如把算术表达式表示成树，则如图7-2(b）所示。" ID="8">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="效(a)(b)" ID="9">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="93" TITLE="7.1.2  树的逻辑表示法" TYPE="Chapter">
        <fptr LogicalPageNum="103" PhysicalPageNum="103"/>
        <Paragraph CONTEXT="树的逻辑表示方法有多种，但是不管采用哪种表示方法，都应该能够正确地表达出树中数据元素之I'7的层次关系。下面介绍几种常见的逻辑表示方法。" ID="1">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="t，树型结构表示法如图7-i所示。这种表示方法使用比较普遍，因为它很形象、直观。本书中都采用古件官早田一樱俪｝署的树（姗用存卜.t什存一F、央齐采树刑结构＿一个圆圈夫这种方法。它是用一棵倒置的树（树根在上，树叶在下）来表示树型结构。一个圆圈表$Picture[00000103\00000103_new\0007.jpg]Picture$示一个结点，圆圈内的符号代表该结点的数据信息，结点之间的关系通过连线表示。虽$Picture[00000103\00000103_new\0009.jpg]Picture$然每条连线不再有箭头（即方向），但它是有方向的，隐含着自卜而下的方向性，即连线上方的结点为连线F方的结点的直接前驱结点，连线下方的结点为连线上方结点的直" ID="2">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="接后继结点。" ID="3">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="2.文氏图表示法也称集合图表示法。以图7-1所示的树为例，其文氏图表示如图7-3(a)所示。" ID="4">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="3.凹入表示方法图7-1所示的树，若采用凹入表示，如图7-3(b)所示。" ID="5">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Paragraph CONTEXT="4.嵌套括号表示法" ID="6">
          <fptr EndPN="00000103" StartPN="00000103"/>
        </Paragraph>
        <Picture URL="00000104\00000104_new\0001.jpg">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Picture>
        <Picture URL="00000104\00000104_new\0002.jpg">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Picture>
      </div>
        <div ORDERLABEL="94" TITLE="7.1.3  树的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="104" PhysicalPageNum="104"/>
        <Paragraph CONTEXT="在叙述树型结构时，人们往往使用人类家族关系的称谓。把结点的子树的根结点称为该结点的孩子〔child)，而该结点就是其孩子结点的双亲（parent)。于是，具有同一双亲的各结点称之为兄弟（brother）结点。点的子孙结点，而某结点的祖先结点则被定义为从树的根结点到该结点的分支上经过的所有结点。图7-1(a）所示的树中，结点B,C是结点A的孩子，D.E.F是结点B的孩子；E是H,I的双亲；D.E,F之间为兄弟关系：D,E,F.H,1是结点B的子孙结点；结点H的祖先结点有E.B,Ao结点的度（degree)：结点拥有的子树数目称为该结点的度。例如，图7-1&lt;a）所示的树中，A的度为2,B的度为3,C的度为1,····树的度：树中各结点的度的最大值被定义为该树的度。图7-1(a)中树的度为30叶子结点：度为零的结点称为叶子结点或终端结点，简称叶结点。叶子结点没有子孙结点。分支结点：度不为零的结点称为分支结点或非终端结点。除根结点之外的分支结点称为内部结点。结点的层次：从根结点开始，根结点为第一层，根结点的孩子为第二层……若某结点在第i层，则其孩子结点（若有的话）在第i+1层。树的深度（deep)：树中结点的最大层数被定义为该树的深度或高度。图7-1&lt;a)所示的树的深度为40有序树：若树中子树的相对次序不能随意变换，则称该树为有序树，即从左至右，根的最左边的子树为第一子树，其次为第二子树，第三子树……否则，该树为无序树。例如，图7-4中所给出的T)和TZ，根据无序树的概念，表示同一棵树；若按有序树的概念，则它们表示两棵不同的树。森林：m&gt;0棵不相交的树的集合被称为森林或树林。对树中每个分支结点来说，其子树的集合就是一个森林。" ID="1">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="94" ID="2">
          <fptr EndPN="00000104" StartPN="00000104"/>
        </Paragraph>
        <Paragraph CONTEXT="爪‘／早心、仅歼也必必汾澎勺必图7-4有序树和无序树" ID="3">
          <fptr EndPN="00000105" StartPN="00000105"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="95" TITLE="7.1.4  树的基本操作" TYPE="Chapter">
        <fptr LogicalPageNum="105" PhysicalPageNum="105"/>
        <Paragraph CONTEXT="有关树的基本操作可以归纳如下：InitTree(T)操作结果：构造空树TClearTree(T)初始条件：树T存在操作结果：将树T清为空树ClearTree(T)初始条件：树T存在操作结果：将树T清为空树TreeEmpty(T)初始条件：树T存在操作结果：若T为空树，返回TRUE，否则返回FALSETreeDepth(T)初始条件：树T存在操作结果：返回树T的深度Root&lt;T)初始条件：树T存在操作结果：返回树T的根Value(T,i)初始条件：树T存在，i是T中某个结点操作结果：返回i结点的值Parent(T,cur)初始条件：树T存在，cur是T中某个结点操作结果：若cu；是T的非根结点，则返回它的双亲，否则函数值为“空”LeftChild(T,cur)RightSibling(T,cur)初始条件：树T存在，cur是T中某个结点躁作结果：若cu；有右兄弟，则返回它的右兄弟，否则函数值为“空”InsertChild(T,p,i,c)初始条件：树T存在，P指向T中某个结点，1ci〔P所指结点的度＋+1，非空树c与T不相交操作结果：插入。为T中P所指的第i棵子树DeleteChild(T,p,i)初始条件：树T存在，P指向T中某个结点，1&lt;i毛p指结点的度操作结果：删除T中P所指结点的第i棵子树Traverse(T)" ID="1">
          <fptr EndPN="00000106" StartPN="00000105"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：树T存在操作结果：遍历树T，即按照某个次序依次访问树中各个结点且仅访问一次" ID="2">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="对树的递归定义的深刻理解，是学习好后续内容的基础。本节中还对树的表示和一些重要的基本概念给予了详细的阐述。通过对本节内容的学习，能够较全面地了解树的" ID="1">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
      <Paragraph CONTEXT="全貌和特征。" ID="2">
        <fptr EndPN="00000101" StartPN="00000101"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="96" TITLE="7.2  二叉树" TYPE="Chapter">
      <fptr LogicalPageNum="106" PhysicalPageNum="106"/>
        <div ORDERLABEL="96" TITLE="7.2.1  二叉树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="106" PhysicalPageNum="106"/>
        <Paragraph CONTEXT="二叉树（BinaryTree）是指树中结点的度不大于z的有序树。它是一种最简单、而且最重要的树。二叉树的递归定义为：" ID="1">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)二叉树或者是一棵空树；" ID="2">
          <fptr EndPN="00000106" StartPN="00000106"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）或者是一棵由一个根结点和两棵互不相交的，分别称作根的左子树和右子树所组成的非空树；&lt;3)左子树和右子树又同样都是二叉树。根据二叉树的定义，二叉树的基本形态如图7-5所示。，O日图7-5.二叉树的基本形态前面有关树的名词术语对于二叉树都适用。图7-6就是一棵二叉树Bit，它由根结点A和左子树BIt！和右子树Blt：所组成。Bit,又由根结点B和左子树Bit（只含有根结点D)、右子树Bit,（为空树）所组成；对＿厂＿只叮呵户在二叉树中，每个结点的左子树的根结点被称之为左孩子（Leftchild)，右子树的根结点被称之为右孩子（Rightchild)。如在图7-6的Bit二叉树中，A结点的左孩子为B结点，右孩子为C结点；B结点的左孩子为D结点，右孩子为空，或者说没有右孩子：C结点的左孩子为E结点，右孩子为F结点：F结点左孩子为G，右孩子为空。" ID="3">
          <fptr EndPN="00000107" StartPN="00000106"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="97" TITLE="7.2.2  二叉树的基本操作" TYPE="Chapter">
        <fptr LogicalPageNum="107" PhysicalPageNum="107"/>
        <Paragraph CONTEXT="与前面讨论过的树的基本操作类似，二叉树的基本操作有如下一些：Initial(BT)" ID="1">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="操作结果：构造空二叉树BT" ID="2">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="Depth(BT)" ID="3">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：二叉树BT存在操作结果：返回二叉树BT的深度Root(BT)" ID="4">
          <fptr EndPN="00000107" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：二叉树BT存在操作结果：返回二又树BT的根Parent(BT,x)初始条件：二叉树BT存在，x是BT中某个结点操作结果：返回z的双亲结点，否则函数值为“空”LChild(BT&gt;z)初始条件：二叉树BT存在，x是T中某个结点操作结果：若x是BT的非叶子结点，则返回它的最左孩子，否则函数值为“空”RSibling(BT&gt;x)初始条件：二叉树BT存在，x是T中某个结点操作结果：若x有右兄弟，则返回它的右兄弟，否则函数值为“空”InsertChild(BT,p&gt;LR,c)初始条件：二叉树BT存在，P指向BT中某个结点，LR为0或1，非空二叉树c与BT不相交，且右子树为空操作结果：根据LR为0或1，插入。为BT中P所指结点的左子树或右子树。P所指结点的原有左子树或右子树则成为c的右子树DeleteChild(BT&gt;p,i)初始条件：二叉树BT存在，P指向B&quot;T中某个结点，GR为。或1操作结果：根据LR为0或1，删除T中P所指结点的左子树或右子树Traverse(BT)" ID="5">
          <fptr EndPN="00000108" StartPN="00000107"/>
        </Paragraph>
        <Paragraph CONTEXT="初始条件：二叉树BT存在操作结果：遍历二叉树BT，即按照某个次序依次访问树中各个结点且仅访问一次" ID="6">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="98" TITLE="7.2.3  二叉树的性质" TYPE="Chapter">
        <fptr LogicalPageNum="108" PhysicalPageNum="108"/>
        <Paragraph CONTEXT="二叉树具有下列重要性质：性质1：二叉树上第i层上至多有z一，个结点（i&gt;1)下面分i=1和c&gt;1两种情况讨论：当i=1时，2i一’二2°=1，因为二叉树的第一层上只有一个结点（即根结点），故命题成立。当i&gt;1时，假定第i-1层上的结点数至多有2‘一，’一=2z个，根据二叉树的定义，每个结点至多有两个孩子，所以第i层上的结点数至多为第i-1层上结点数的2倍，亦即2X2z=2,一，，得到第i层上的结点数至多为2'一’，命题成立。性质2：深度为h的二叉树至多有2h-1个结点显然，当深度为h的二叉树上每一层都达到最多结点数时，它们的和才能最大，即整个二叉树才具有最多结点数。" ID="1">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="艺2‘一，＝2。＋2’＋2’＋…＋2‘一’=2‘一‘r二1故命题正确。在一棵二叉树中，当第i层的结点数为2'一，个时，则称该层的结点数是满的，当树中的每一层都满时，则称此树为满二叉树。由性质2可知，深度为h的满二叉树中的结点数为2h-1个。图7-7(a）为一棵深度为4的满二叉树，其结点数为15。图中每个结点的值是用" ID="2">
          <fptr EndPN="00000108" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="该结点的编号来表示的，编号从树根为1开始，按照层数从小到大、同一层从左到右的$Picture[00000109\00000109_new\0001.jpg]Picture$几几几几汀议叮劝$Picture[00000109\00000109_new\0005.jpg]Picture$（b）图7-7满二叉树和完全二义树在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干个结点，则称此树为完全二叉树。由此可知，满二叉树是完全二叉树的特例。图7-7(b）为一棵完全二叉树，与等高度的满二叉树相比，它在最后一层的右边缺少了3个结点。对于一棵完全二叉树，若按照满二叉树的同样方法对结点进行编号后，则得到F列性质30性质3：对完全二叉树中编号为i的结点（(l簇i蕊n,n,l,n为结点数）有：cl)若，&lt;Ln/2J，则编号为1的结点为分支结点，否则为叶子结点。c2）若n为奇数，则每个分支结点都既有左孩子，又有右孩子；若n为偶数，则编号最大的分支结点（编号为n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。" ID="3">
          <fptr EndPN="00000109" StartPN="00000108"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）若编号为i的结点有左孩子，则左孩子结点的编号为2i,；各编号为i的结点有右孩子，则右孩子结点的编号为2i+10" ID="4">
          <fptr EndPN="00000109" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）除树根结点外，若一个结点的编号为i，则它的双亲结点的编号为LI/2J，也就是说，当i为偶数时，对应为左孩子，其双亲结点的编号当i为奇数时，对应为右孩子，其双亲结点的编号为（i-1)/20在图7-7(b）的完全二叉树中，每个结点内的数字为该结点的编号。因树中结点数n=12，所以编号小于等于6的结点为分支结点，大于6的结点为叶子结点。因n=12为偶数，所以编号为6的结点只有左孩子12，没有右孩子，其余分支结点（即编号15的结点）左、右孩子都有。对于编号为2的结点来说，它的左孩子是编号为4的结性质4：具有。个（n&gt;0)结点的完全二叉树的深度为clogz(n十1或LlogZrtJ+1证明：设所求完全二叉树的深度为h，由完全二叉树的定义可知，它的前h-1层都是满的，最后一层可以满，也可以不满，由此得出如下不等式：" ID="5">
          <fptr EndPN="00000110" StartPN="00000109"/>
        </Paragraph>
        <Paragraph CONTEXT="2i-1&lt;n&lt;2h-1可变换为：2&quot;一，&lt;n十1&lt;2r'取对数后得到：h-1＜1092（。＋1）簇h即log,(n1)毛h&lt;logz(n-1)+1因h只能取整数，所以h二｝log2(n+1)完全二叉树的深度和结点数。的关系，还可以表示为：取对数后得到：h-1&lt;log,n&lt;h即login&lt;h&lt;log,n+1得h=LlognJ+1在一棵二叉树中，若除最后一层外，其余层都是满的，则称该树为理想平衡树。显然，理想平衡树包含满二叉树和完全二叉树。完全二叉树中深度h和结点数n之间的关系，在理想平衡树中同样成立。图7-8(a）就是一个理想平衡树，但它不是完全二叉树；图7-8(b)不是一棵理想平衡树，因它的最后两层都未满。飞飞多犷晶图7-8理想;衡树和非理想平衡树100" ID="6">
          <fptr EndPN="00000110" StartPN="00000110"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在树型结构中，有一类简单而又重要的树，它的每个结点最多只有两棵子树。这种树被称为二叉树。在二叉树中严格区分结点的左、右孩子，其次序不能随意颠倒；否则，就变成另一棵二叉树了。二叉树是有序树。" ID="1">
        <fptr EndPN="00000106" StartPN="00000106"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="101" TITLE="7.3  二叉树的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="111" PhysicalPageNum="111"/>
        <div ORDERLABEL="101" TITLE="7.3.1  二叉树的顺序存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="111" PhysicalPageNum="111"/>
        <Paragraph CONTEXT="顺序存储是用一组连续的存储单元存储二叉树的数据元素。因此，必须把二叉树中的所有一结点安排成一个适当的线性序列，使得结点在这个序列中的相互位置能反映出结点之间的逻辑关系。从树根起，自上而下，每层自左至右地给所有结点编号，就能得到一个足以反映整个二叉树结构的线性序列，如图7-9(a）所示。(a)" ID="1">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Paragraph CONTEXT="IA181cIoIFI’FIGIHI，IJIKILI（b）根据完全二叉树的特性，结点在数组中的相对位置蕴含着结点之间的关系。即完全一万树由廷XfiPir良万I见1月石wn4出X-YPaltk'格辈玄rliF{u?lcw今一o由成右廷因此可将完全二叉树中所有结点按编号顺序依次存储在一个数组bt[n］中，这样，无须附加任何信息就能在这种顺序存储结构里找到每个结点的双亲和孩子。例如图7-9(b)中是图7-9(a)所示的完全bt[5］的双亲是bt[21，其左、右孩子分别是bt[10］和bt[111o显然，顺序存储结构对完全二叉树而言，即简单又节省存储空间。但是，对于一般" ID="2">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Paragraph>
        <Picture URL="00000111\00000111_new\0021.jpg">
          <fptr EndPN="00000111" StartPN="00000111"/>
        </Picture>
        <Paragraph CONTEXT="二叉树的顺序存储，为了能用结点在数组中的相对位置来表示结点之间的逻辑关系，也／0＼～$Picture[00000112\00000112_new\0002.jpg]Picture$风产一0(a)I’AI’B”IGIai：一｝。’1o1。I。1F｝G(b)图7一沁二义树的顺序存储结构" ID="3">
          <fptr EndPN="00000112" StartPN="00000111"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="102" TITLE="7.3.2  二叉树的链式存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="112" PhysicalPageNum="112"/>
        <Paragraph CONTEXT="在二叉树的链式存储方法中，根据描述信息的不同可以采用如下两种表示法：" ID="1">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="i.二叉链表法由于顺序存储结构适用于完全二叉树，但对于一般二叉树而言，需要浪费太多的存" ID="2">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="储空间。并且若需要经常插入和删除树中结点时，顺序存储方式更不可取。因此，存储二叉树的最自然的方法是二叉链表法。结点结构中包含3个域：数据域和左、右指针" ID="3">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="(c）是二叉树图7-11(b）的二叉链表存储结构。" ID="4">
          <fptr EndPN="00000112" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="I!child1data1rchild乳(b)(c)图中lchild为左指针域，指向结点的左子树根；rchild为右指针域，指向结点的右子树根。相应的类型说明为：" ID="5">
          <fptr EndPN="00000113" StartPN="00000112"/>
        </Paragraph>
        <Paragraph CONTEXT="structBTNode{" ID="6">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="elemtypedata;structBTNode*lchild,*rchild＊左、右指针＊／｝在含有n个结点的二叉链表中，总共有2n个指针域，除了根结点以外，其余n-1个结点都占一个域，故还有n+1个空指针域。" ID="7">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="2.三叉链表法上述有关二叉树的存储方法，便于从根往叶子结点方向查找，但不便于从下往上查找。为适应这种需要，在二叉链表的结点中，增加一个指向其双亲的指针域。使二叉链相应的类型说明为：structBTNode{" ID="8">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="elemtypedata;structBTNode*lchild,*rchild;/＊左、右指针＊／structBTNode*parent;/＊指向双亲的指针＊／）其存储结构如图7-12(a)所示，其中图7-l2&lt;c）是二叉树图7-12(b）的三叉链表存储结构。1rcn;td一，aI’parent｝二。。｝巍" ID="9">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
        <Paragraph CONTEXT="(b)图7-12义链表存储结构（。）结点结构（b)二叉树（(c）三义链表存储结构" ID="10">
          <fptr EndPN="00000113" StartPN="00000113"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="同线性表一样，二叉树也有顺序和链式两种存储结构。卜面我们来看一下这两种结构的形式。" ID="1">
        <fptr EndPN="00000111" StartPN="00000111"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="104" TITLE="7.4  二叉树的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <div ORDERLABEL="104" TITLE="7.4.1  遍历的概念" TYPE="Chapter">
        <fptr LogicalPageNum="114" PhysicalPageNum="114"/>
        <Paragraph CONTEXT="遍历是对树的一种最基本的操作。遍历二叉树是指沿着某条搜索路径周游二叉树，对二又树中每个结点访问一次并且仅访问一次。遍历二叉树的目的在于得到二叉树中各!rf.L.ft！，＿于r1,41.M1-IIRS良_,（面打」k44H1-fth-7云a+4.1N.fL1A拓万李sfL丈;二翌二以,上p才牟夭卜z田书》tri七r,结点的一种线性顺序，使非线性的二叉树线性化，道，遍历一个线性结构很容易，只须从开始结点出发顺序扫描每个结点即可。但是二叉树是一个非线性结构，每个结点可以有二个后继结点，要得到树中各结点的一种线性排列，就不那么容易。因此需要寻找一种规律来系统地访问树中各结点。由二叉树的递归定义可知：一棵非空二叉树是由根结点、左子树、右子树三个基本部分组成的。因此遍历一棵非空二叉树的问题可以分解为对根结点、左子树和右子树的遍历问题。如果我们分别用D.L.R表示对根结点、左子树和右子树的遍历，则对一棵二叉树可得到6种遍历组合：DLR.LDR,LRD,DRL,RDL,RLD。若限定先左后右进行遍历，则只有3种遍历。即：DLR,LDR,LRD分别称为先根次序遍历（前序）、中根次序遍历（中序）和后根次序遍历（后序）。显而易见，二叉树的结构是递归定义的，则对二叉树的操作用递归描述更直接、更" ID="1">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="清楚。由此可得到3种遍历的递归定义：" ID="2">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="1.前序遍历二又树若二叉树非空，则依次进行如下操作：" ID="3">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="访问根结点。" ID="4">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="前序遍历左子树。" ID="5">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="前序遍历右子树。" ID="6">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="2.中序遍历二叉树若二叉树非空，则依次进行如下操作：" ID="7">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="中序遍历左子树。" ID="8">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="访问根结点。" ID="9">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="中序遍历右子树。" ID="10">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="3.后序遍历二叉树若二又树非空，则依次进行如下操作：" ID="11">
          <fptr EndPN="00000114" StartPN="00000114"/>
        </Paragraph>
        <Paragraph CONTEXT="后序遍历左子树‘" ID="12">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="后序遍历右子树。" ID="13">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="访问根结点。【例7-3】对于图7-13的二叉树，写出其前、中、后序遍历的序列。其前、中、后序遍历的序列如下：前序遍历：A.B.D.F,G.C.E.H中序遍历：B,F.D.G.A.C.H,E后序遍历：F,G,D,B.H,E,C.A。图7-13＿又树示例最早提出遍历问题是对存储在计算机中的表达式求值。例如：(u+b*c）一dle。表结点。图7-to表达式的树形图" ID="14">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="当我们对此二叉树进行前、中、后序遍历时，便可获得表达式的前序、中序、后序" ID="15">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="书写形式：" ID="16">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
        <Paragraph CONTEXT="前序：一十a*bc/de中序：a+b*c-d/e后序：abc＊十de/-其中中序形式是算术表达式的通常形式，只是没有括号。算术表达式的后序形式也" ID="17">
          <fptr EndPN="00000115" StartPN="00000115"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="106" TITLE="7.4.2  遍历的算法" TYPE="Chapter">
        <fptr LogicalPageNum="116" PhysicalPageNum="116"/>
        <Paragraph CONTEXT="；面所描述的算法，都是以.二又链表作为存储结构。.前序遍历算法voidpreorder(structBTNode*bt)bt开始指向根结点，／.f(bt！二NULL)printf(bt一＞data)；/＊访问根结点＊／preorder(b仁一＞lchild);/‘前序遍历左子树＊／preorder(bt一，rchild)；前序遍历右子树‘／｝》" ID="1">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="2.中序遍历算法：" ID="2">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="voidinorder(structBTNode*bt)f*b℃开始指向根结点，／｛if(bt！二NULL)inorder(btlchild)；I*中序遍历左子树＊／printf(bt一＞data)；/＊访问根结点＊／inorder(bt一＞zchild)；f*中序遍历右子树＊／｝｝" ID="3">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="3.后序遍历算法" ID="4">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="voidpostorder(structBTNode*bt)／，b七开始指向根结点＊／｛if(btNULL)postorder(bt一＞lchild)；/’后序遍历左子树‘脚postorder(bt一＞rchild)；/＊后序遍历右子树＊矛printf(bt一＞data)；1*访问根结点’在这3种遍历算法中，访问根结点的具体操作可根据具体应用情况而定，这里暂垃输出根结点的值代之" ID="5">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="1a" ID="6">
          <fptr EndPN="00000116" StartPN="00000116"/>
        </Paragraph>
        <Paragraph CONTEXT="4.建立二叉树算法voidcreate_tree(structBTNode*bt)／＊按照先序次序输入二叉树中结点的值（一个字符），‘林’字符表示空树‘／｛" ID="7">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="scanfch);" ID="8">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="if(ch二二‘＃‘）" ID="9">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="bt二BULL;" ID="10">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="else{bt二（structBTNodemalloc(sizeof(structBTNode;if(!bt)exit(Fail!);bt一＞data二ch;/，生成根结点‘／create_tree(bt一＞lchild)；/＊构造左子树＊／create_tree(bt一＞rchild)；/＊构造左子树＊／｝" ID="11">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="｝例如，按照下列次序顺序读入字符：ABCDE#G##F###可建立图7一巧所示的二叉树。" ID="12">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="5.二叉树深度算法二叉树的深度为二叉树中结点层次的最大值。即结点的层次自根结点起递推。设根,一Pf.奋大X6rr右'1.PfF!t占占亦,J－,尽_niprCl;;tert结点为第一层的结点，所有h层的结点的左右孩子结点在历计算二叉树中每个结点的层次，其中最大值即为二叉树的深度。下面给出前序遍历求二叉树的深度递归算法。intTreeDepth（structBTNode＊bt）" ID="13">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="｛" ID="14">
          <fptr EndPN="00000117" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="inthl，hr，max；if（bt！＝NULL）｛hl二TreeDep七h（bt一）lehild）：max二hl&gt;hr?hl:hr;" ID="15">
          <fptr EndPN="00000118" StartPN="00000117"/>
        </Paragraph>
        <Paragraph CONTEXT="reCurn&lt;max+1);" ID="16">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="elsereturn(0);" ID="18">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="19">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在实际应用问题中，常常需要按一定顺序对树中每个结点逐个进行访问一次，查找具有某一特点的结点，然后对这些满足条件的结点进行处理，这种操作就是树的遍历或周游。一次完整的遍历，把树中结点数据信息人为地转变成一个线性序列。简言之，树的遍历就是按照一定的规则将树中所有结点的数据信息排列成一个线性序列。" ID="1">
        <fptr EndPN="00000114" StartPN="00000114"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="108" TITLE="7.5  线索二叉树" TYPE="Chapter">
      <fptr LogicalPageNum="118" PhysicalPageNum="118"/>
        <div ORDERLABEL="108" TITLE="7.5.1  二叉树的线索化" TYPE="Chapter">
        <fptr LogicalPageNum="118" PhysicalPageNum="118"/>
        <Paragraph CONTEXT="遍历二叉树的实质是把一个非线性结构进行线性化。对二叉树进行某种遍历得到的结点序列，可以看作为一个线性表，在该线性表中，除第一个结点外，每个结点有且仅有一个前驱，除最后一个结点外，每个结点有且仅有一个后继。对于一棵具有，：个结点的二叉树，对应的二叉链表中共有Z：个指针域，其中（n-" ID="1">
          <fptr EndPN="00000118" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="1）个用于指向除树根结点的其余（Cn-1&gt;个结点，另有（n+1）个指针域空着。若把每个结点中空着左指针域和右指针域用于分别指向某种遍历次序的前驱结点和后继结点，则在遍历这种二叉树时，可由此信息直接找到在该遍历次序卜的前驱结点或后继结点，从而加速了遍历速度，显然要比递归遍历快得多。这种在结点的空指针域中存放的该结点在某次遍历次序下的前驱结点或后继结点的指针叫做线索（thread，其中在空的左指针域中存放的指向其前驱结点的指针叫做左线索，在空的右指针域中存放的指向其后继结点的指针叫做右线索。对一棵二叉树中的所有结点的空指针域按照某种遍历次序加线索的过程叫做线索化，被线索化了的二叉树称作线索二叉树。图7-16是中序线索二叉树的例子。108图7-15(b）就是对图7一巧(a)的二叉树加中序线索而得到的中序线索二叉树。在一个线索二叉树中，为了区别每个结点的左、右指针域所存放的是孩子指针一，还是线索，必须在结点结构中增加两个线索标志域，一个是左线索标志域，假定用Itug4之二二二口＿曰一去.乙.F=声夹；+Y二aP/F已，[mil‘--」三二二i_不日＿_a.i口团'IIn刁iihf'f,II1v表示，另一个是右线索标志域，假定用：tag表示。Itag和rtag均只需取两种值，别其对应的指针域保存的是孩子指针，还是线索，假定取0和1两种值，并定义如卜：" ID="2">
          <fptr EndPN="00000119" StartPN="00000118"/>
        </Paragraph>
        <Paragraph CONTEXT="folchild域指示结点的左孩子“ag＝、1城搭采姑占的苗r旦反" ID="3">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="rchild域指示结点的前驱forchild域指示结点的右孩子rlag劝1脚挤拾示然占的后燃" ID="4">
          <fptr EndPN="00000119" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="rchild域指示结点的后继增加线索标志域后的结点结构为：｝‘ch“d｛.‘tag｝data｝厂‘a。｝rch“d｛这种结点类型和相应的指针类型可定义为：5七ructTHNode｛elemtypedata；intltag，rtag；／去取值为。或1去／struc七THNode＊Ichild，＊rchild；／＊左、右指针＊／｝；图7-17就是图7-16的中序线索二叉树的链式存储映像，即中序线索链表。程，只不过在访问根结点时，不是简单地打印根结点的值，而是对指针域为空的结点加线索，具体做法是：" ID="5">
          <fptr EndPN="00000120" StartPN="00000119"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)若前驱结点不为空，或者说根结点不是序列中的第一个结点，同时前驱结点的右线索标志域为1（表示此结点的右指针域为空）时，则将根结点的指针域给前驱结点的右指针域，即给前驱结点加右线索。" ID="6">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）若根结点的左指针域为空，则将左线索标志域置为1，同时把前驱结点的指针域给根结点的左指针域，即给根结点加左线索。" ID="7">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）若根结点的右指针域为空，则将右线索标志域置为1，以便当访问到下一个（即后继）结点时，给它加右线索。" ID="8">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）将根结点指针赋给保存前驱结点指针的变量，以便当访问下一个结点时，此根结点成为前驱结点。为了记下遍历过程中访问结点的先后次序，设指针pre始终指向刚刚访问过的结点，指针th；指向当前访问的结点，初始时指向待线索化的二叉树的根结点，则pre指向th；的前驱。下面给出对二叉树进行中序线索化的算法，述：voidInThread(structTHNode*thr)｛if(thr!=NULL){对非空树进行线索化＊／工nThread(thr一＞lchild)；/＊左子树线索化＊／①if！七hrlchild){/＊前驱线索＊／②thr一＞ltag二1;thr一＞lchild二pre;｝if(!pre一＞rchild){/＊后继线索‘／pre一＞rtag二1;pre一＞rchild二thr;｝pre二thr;/＊保证pre指向七hr的前驱，／③工nThreadCthr一＞rchild)；/＊右子树线索化＊／④｝" ID="9">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
        <Paragraph CONTEXT="｝在上面对二叉树进行中序线索化的算法中，若把①语句移到③和④语句之间，则得到前序线索化的算法，所建立的线索为前序线索；若把④语句移到①和②语句之间，则得到后继序线索化的算法，所建立的线索为后序线索。110" ID="10">
          <fptr EndPN="00000120" StartPN="00000120"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="111" TITLE="7.5.2  利用线索进行遍历" TYPE="Chapter">
        <fptr LogicalPageNum="121" PhysicalPageNum="121"/>
        <Paragraph CONTEXT="在线索树上进行遍历，只要先找到序列中的第一个结点，然后依次找结点后继，直至其后继为空时为止。我们以中序线索为例来具体讨论这个问题。假设P指针指向中序线索二叉树的一个结点，如何寻找n的中序后继结点？它分为两种情况：(L)若P的右线索标志域为1，则表明P一＞rchild为右线索，它直接指向P的中序后继结点。&lt;2)若P的右线索标志域为。，则表明P一＞rchild指向右孩子结点。根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第·个结点，即右子树中最左下的结点。因此从P的右孩子开始，沿左指针往下查找，直到找到一个没有左孩子（即左线索标志域为1)的结点为止，该结点是P的右子树中最左下的结点，它就是P的中序后继结点。例如在图7-2(b）中，为找结点＊的中序后继结点，首先沿右指针找到其右子树的根结点“一”，然后顺其左指针往下直至其左标志域为1的结点，即为结点＊的后继结点，在图中是结点co根据以上分析，给出在中序线索二叉树上求结点P的中序后继结点的算法如下：structTHNode*Inorder_next(structTHNode*p)｛" ID="1">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p一＞rtag二二1)recur工：&lt;p一＞工child);else{P二P一＞rchild;while(p一＞ltag＝二0)" ID="2">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="P二P一＞lchild;return(p);）" ID="3">
          <fptr EndPN="00000121" StartPN="00000121"/>
        </Paragraph>
        <Paragraph CONTEXT="｝有了求中序后继结点的算法，就不难写出在中序线索二叉树上进行中序遍历的算法。此算法可叙述为：首先从根结点起沿左指针往下查找，直到找到一个左线索标志域为1的结点。该结点的左指针域为空，它就是整个中序序列的第一个结点；然后打印该结点，并利用上述求中序后继结点的算法得到下一个结点，依次进行下去，直到中序后继结点为空。设thr为结构。tructTHNode类型的指针变量，初始时指向一棵中序线索二叉树的根结点，则对此树进行中序遍历的算法和描述为：voidThinorder(s七ructTHNode*thr)｛ifCthr：二NULL){while(thr一＞ltag＝二O)七hr二thr一）·lchild;do{printf(thr一＞da七a);thr＝工norder_next(thr);}while(thr！二ruLL);｝以上讨论的几种二叉树操作的算法都是按一定的次序访问所有的结点，并且在访问每个结点时只是做些简单地操作，所以其时间复杂度为O(n)。虽然在访问每个结点时有一个按照某种次序的查找过程，在查找过程中需要同一些结点进行比较，但访问所有结点的总的比较次数不会超过2n次（即树中n个结点所含的指针数量），故不会因此增加每个算法的时间复杂度。每个递归算法的空间复杂度视二叉树的具体形态而定，若为理想平衡树，或接近理想平衡树，则空间复杂度为。(login)，若退化为单支树（最坏的情况），则空间复杂度为O(n)a" ID="4">
          <fptr EndPN="00000122" StartPN="00000121"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="按照某种遍历方式对二叉树进行遍历，可以把二叉树中所有结点排列为一个线性序列。但是，二叉树中每个结点在这个序列中的直接前驱结点和直接后继结点是什么，在二叉树的存储结构中并没有反映出来，只有在对二叉树遍历的动态过程中才能够得到这些信息。线索二叉树就是研究在静态下，如何得到有关这样的信息口线索二叉树将为二叉树的遍历提供许多便利。" ID="1">
        <fptr EndPN="00000118" StartPN="00000118"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="112" TITLE="7.6  二叉排序树" TYPE="Chapter">
      <fptr LogicalPageNum="122" PhysicalPageNum="122"/>
        <div ORDERLABEL="112" TITLE="7.6.1  二叉排序树的定义" TYPE="Chapter">
        <fptr LogicalPageNum="122" PhysicalPageNum="122"/>
        <Paragraph CONTEXT="二叉排序树（BinarySortTree）又称二叉查找树，它或者是一棵空树，或者是一棵具有如下特性的非空二叉树：" ID="1">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)若它的左子树非空，则左子树上所有结点的值均小于根结点的值。" ID="2">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）若它的右子树非空，则右子树上所有结点的值均大于〔若允许具有相同的值的结点存在，则大于等于）根结点的值。" ID="3">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="(3）它的左、左子树本身又各是一棵二叉排序树。由二叉排序树的定义可知，在一棵非空的二叉排序树中，其结点的值是按照左子树、根和右子树有序的次序排列的，所以，对它进行中序遍历得到的结点序列是一个有序序列。图7-18就是一棵二叉排序树，树中每个结点的值都大于它的左子树中所有结点的值，而小于它的右子树中所有结点的值。" ID="4">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="112" ID="5">
          <fptr EndPN="00000122" StartPN="00000122"/>
        </Paragraph>
        <Paragraph CONTEXT="／习一＼＿卿－一曰" ID="6">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="叮只势品总益图7-is排序树示意图对此树进行中序遍历得到的结点序列为：" ID="7">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="11,16,19,22,23,25,46,50,68可见，此序列是一个有序序列。" ID="8">
          <fptr EndPN="00000123" StartPN="00000123"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="113" TITLE="7.6.2  二叉排序树的查找" TYPE="Chapter">
        <fptr LogicalPageNum="123" PhysicalPageNum="123"/>
        <Paragraph CONTEXT="根据二叉排序树的定义，查找结点的值与给定值x相等的过程为：若二叉排序树为空，则表明查找失败，返回空值。若给定值K等于根结点的值，则表明查找成功，返回指向根结点的指fit.若给定值K小于根结点的值，则继续在根的左子树中查找.若给定值K大于根结点的值，则继续在根的右子树中查找。显然，这是一个递归查找过程。设bst为具有structBTNode类型的一个指针，初始时指向一棵二叉排序树的根结点，K为待查结点的值，则二叉排序树查找的递归算法描述如下：structBTPdode*Search(structBTNode*bst,elemtypeK)｛if((bs七二＝NULL)II(bst一＞data二二K));＊查找结束＊／return(bst);elseif(K&lt;bst一＞data)/‘在左子树中继续查找‘／return(Search(bst一＞lchild,K));else/＊在右子树中继续Vii'找，／return(Search(bst一＞rchild,K));｝由于此递归算法中的递归调用属于末尾递归（即递归调用语句是函数最后一条可执行语句）的调用，每次递归调用返回值也是重复的，同时每次递归调用返回后的退栈信structBTNOde*FSearch(structBTNode*bst,elemtypeK)P为活动指针，查找成功时，返回P指针＊／｛" ID="1">
          <fptr EndPN="00000124" StartPN="00000123"/>
        </Paragraph>
        <Paragraph CONTEXT="P二bst;" ID="2">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="while(p！二NULL){if(p一＞data二二K)查找成功＊／return&lt;p);elseif(K&lt;p一＞data)/＊在左子树中继续查找‘／P二P一＞lchild;else/＊在右子树中继续查找＊／P二P一＞rchild;" ID="3">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="｝re七urn(NULL)；/＊查找失败，／｝例如，对图7-18的二叉排序树查找值为22的结点时，首先用22同根结点25进行比较，因22&lt;25，所以向25的左子树继续查找；再用22同当前根结点16进行比较，因22&gt;16，所以向16的右子树继续查找；当用22同当前根22进行比较，因相等，所以返回该结点的指针，整个查找过程就此结束。若从图7-18中再查找值为45的结点，其查找过程为：首先用45同根结点25进行比较，因为45&gt;25，所以向25的右子树继续查找；再用45同当前根结点46进行比较，因45&lt;46，所以向46的左子树继续查找，此时左子树为空，所以返回空指针，表明查找失败，整个查找过程就此结束。在二叉排序树上进行查找的过程中，给定值K同结点比较的次数最少为一次（即树根结点就是待查的结点），最多为树的深度，所以平均查找次数要小于等于树的深度，理论上己经证明，平均查找次数（即平均查找长度）为1-41og,n。若二叉排序树是理想平衡树或接近理想平衡数，则进行查找的时间复杂度可表示为O(1og2n)，若在二叉排序树上查找比在有序单链表上进行查找的时间复杂度口(n)要好得多，这正是构造二叉排序树的优点之一，因此，也常把二叉排序树称作二叉查找树。" ID="4">
          <fptr EndPN="00000124" StartPN="00000124"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="114" TITLE="7.6.3  二叉排序树的插入和生成" TYPE="Chapter">
        <fptr LogicalPageNum="124" PhysicalPageNum="124"/>
        <Paragraph CONTEXT="假定在以bst为树根指针的二叉排序树上插入由指针变量：所指向的结点，根据二叉排序树的定义，其插入过程为：若二叉排序树为空，则将，结点作为根结点插入；否则，若，结点的值小于根结点的值，则将：结点插入到根的左子树上，若：结点的值大于等于（若不容许具有相同值的结点存在，则对等于情况应作单独处理）根结点的值，则将：结点插入到根的右子树上。显然插入过程是递归的，对应的递归算法描述为：114voidInsert_dg(structBTNode*bst,structBTNode*s)〔" ID="1">
          <fptr EndPN="00000125" StartPN="00000124"/>
        </Paragraph>
        <Paragraph CONTEXT="if(bst二二NULL)" ID="2">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="bst二s;elseif(s一＞data&lt;bst一＞data)Insert_dg(bst一＞lchild,s);else工nsert_dg(bst一＞rchild,s);｝同二叉排序树的递归查找算法一样，此算法也属于末尾递归的调用，所以为了消除末尾递归，减少算法运行的时间和空间，也可以编写出对应的非递归算法（注意：消除末尾递归不需要使用堆栈）。非递归算法的插入过程，需要先查找插入位置，然后再进行插入。查找插入位置从根节点开始，若根指针为空，则根结点就是、的插入位置，否则，若，结点的值小于根结点的值，则沿着根的左指针在左子树上继续查找插入位置，若s结点的值大于等于根结点的值，则沿着根的右指针在右子树上继续查找插入位置，当查找到一个R结点的左指针或右指针为空时，则该位置就是结点的插入位置。则将s赋给bst，作为树根结点，否则，将s赋给4结点的左指针域或右指针域，作为9的左孩子或右孩子。插入算法描述如下：voidInsert(s七ructBTNode*bst,structBTNode*s)｛q指向P的双亲结点，初始时为空＊／while(p!=NULL){if(s一＞data＜p一＞data){q=P;P二P一＞lchild;" ID="3">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="4">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="else{q=P%P二P一＞rchild;" ID="5">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="if(bst二二NULL)bst二s;elseif(s一＞data&lt;q一＞data)" ID="8">
          <fptr EndPN="00000125" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="q一＞lchild二s;4I一＞rchild二s）利用二叉排序树的插入算法，可以很容易地写出生成一棵具有。个结点的二叉排序树的算法‘" ID="9">
          <fptr EndPN="00000126" StartPN="00000125"/>
        </Paragraph>
        <Paragraph CONTEXT="具体生成算法描述为：voidCrea七（structBTNode*bst,intn)｛" ID="10">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="bst二NULL;for(i二1;i＜二n;i{scanfx)；/＊读入一个数据元素＊／5二（structBTNodemalloc(sizeoF(structBTNode));s一＞data二x;s一＞lchild二NULL;一》rchild二NULL;工nser七（b5七，5）；／＊将s结点插入bs七树中＊／｝" ID="11">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="｝假定待建立二叉排序树的一组元素为例：按照上述算法，每插入一个结点后得到的二叉排序树如图7-19所示。O／seso/\只产了了沟公“、砂(a)(b)(t7(d)风＿／户、兮曰叮、卿" ID="12">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="妙⑦勺／澎(e)/。了势’。歼沙" ID="13">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
        <Paragraph CONTEXT="澎百澎i团(h)" ID="14">
          <fptr EndPN="00000126" StartPN="00000126"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="117" TITLE="7.6.4  二叉排序树中结点的删除" TYPE="Chapter">
        <fptr LogicalPageNum="127" PhysicalPageNum="127"/>
        <Paragraph CONTEXT="二叉排序树的删除比插入要复杂一些，因为被插入的结点都是被链接到树中的叶子1-flr7nX,C.Flk十不云歌寺配.夕仁云考1升1台补月一；t5T:L`x士F7taFrflfFi:t&quot;4士.kii'olfi%毅左t食f结点上，因而不会破坏树的结构，也就是一说，不会破坏树中原有结点之间的链接关系。从二叉排序树上删除结点则不同，它可能删除的是叶子结点，也可能删除的是分支结点，当删除分支结点时，就破坏了原有结点之间的链接关系，需要重新修改指针，使得删除后仍为一棵二叉排序树。下面结合图7-20(a)所示的二叉排序树（该树中结点的值为字母，它们按对应的" ID="1">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="ASCII码值有序），现分3种情况说明删除结点的操作：／只＿歼只" ID="2">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="00议门决两匀‘诊口、Jbd盯河饰可减只吸卜卜爪卜d澎‘（c》(d)图7-20叉排序树的删除" ID="3">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)删除叶子结点此种删除操作很简单，只要将其双亲结点链接到它的指针去掉（即置为空）即可。如删除（a)树中叶子结点A时，把D结点的左指针域置空即可；删除叶子结点W时，把S结点的右指针域置空即可。" ID="4">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）删除单支结点这种删除操作也比较简单，因为该结点只有左子树或右子树一支，也就是说，其后" ID="5">
          <fptr EndPN="00000127" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="继只有一个左孩子或右孩子。删除该结点时，只要将后继指针链接到它所在的链接位置即可。如删除（(a）树中单支结点G时，将G的左指针赋给D结点的右指针域即可：删除单支结点M时，将M的右指针赋给乙结点的右指针域即可；删除这两个结点后，抠结点必是它的左子树中“最右下”的一个右指针为空（左指针域可能为空，也可能不1空）的结点，如图（a)树中双支结点D的中序前驱为A结点，双支结点乙中序前驱勺G结点，然后把它的左子树链接到它所在的链接位置。如在图（a)树中删除双支结;sD时，则首先把D的右子树链接到A结点的右指针域，然后把D的左子树链接到L的左指针域，删除D结点后得到的二叉排序树如图7-20(c)所示。这种方法往往容易嘈加树的深度，使树的结构变坏，所以通常采用下面介绍的第二种方法。删除双支结点的第二种方法是：首先把它的中序前驱结点的值赋给该结点的值域，伍肖品南肖箭n陌仕占旧韦亡的由良前听廷占的六华料城先牢.所以只蓉把中然后再删除它的中序前驱结点，因为它的中序前驱结点的右指针域为空，序前驱结点的左指针链接到中序前驱结点所在的链接位置即可。如删除图（a)树中双支结点D时，则首先把它的中序前驱结点A的值赋给结点D结点的值域，然后把A结点的左指针（此时为空）链接到D结点的左指针域，删除D结点后得到的二又排序树仍是如同（(c）所示。又如，若从〔a)树中删除根结点L，因L是双支结点，所以首先把它的中序前驱结点G的值赋给L结点的值域，然后把G结点的左指针（此时指向F结点）链接到D结点的右指针域，删除L结点后得到的二叉排序树如图（d)所示。要从一棵树根指针为bst的二叉排序树上删除其值为给定值K的一个结点，首先要把它查找出来，然后再根据以上分析过程进行删除。二叉排序树的删除算法描述如下：voidDelete(structBTNode*bst,elemtypeK)｛4指向P的前驱t,点，初始时为空‘／whileCp！二NULL){/＊查找被删除的结点＊／if(K二=p一＞data)exit();elseif(K&lt;p一＞data){q=P；P=P一＞lchild;" ID="6">
          <fptr EndPN="00000128" StartPN="00000127"/>
        </Paragraph>
        <Paragraph CONTEXT="}else{" ID="7">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="4=P;P二P一＞rchild;" ID="8">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="｝｝if(p二二NULL){查找失败，没有可删除的结点，停止运行’／" ID="9">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(&quot;Nofind);" ID="10">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="exit();｝else{J*分三种不同情况删除，／if((p一＞lchild＝二NULL)Cp一＞rchild＝二NULL))" ID="11">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="if(p二二bs七〕bst=NULL;elseif(p二二q一＞lchild)9一＞lchild二NULL" ID="12">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="e1sE" ID="13">
          <fptr EndPN="00000128" StartPN="00000128"/>
        </Paragraph>
        <Paragraph CONTEXT="1一＞rchild=NULL;lseif((p一＞lchild二二NULL)II(p一＞rchild二二NULL)).f(pbst)-f&lt;p一》lchild二二NULL)bs七二P一＞rchild;elsebst=p一＞lchild;else{/＊分四种情况删除非根的单支结点‘／if((p二二9一＞lchild)(p一＞lchild！二NULL))q一＞lchild二P一＞lchild;elseif((p＝二4一＞lchild)k&amp;(p一＞rchild！二NULL))q一＞lchild=p一＞rchild;elseif((p二二q一＞rchild)(p一＞lchild！二NULL))4一＞rchild二P一＞lchild;elseif((pq一＞rchild)(p一》rchild！二NULL))q一＞rchild二P一＞rchild;｝elseif((p一＞lchild！二NULL)(p一＞rchild！二NULL)){r二P;s=P一＞lchild;s指向P的左子树的根结点：r指向s的前驱结点‘／while(s一＞rchild！二NULL)查找P的中序前驱结点＊／r=s;" ID="14">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="s二s一＞rchild;" ID="15">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="｝P一＞data=s一》data;s结点的值赋给P结点＊／if(r＝二P)／＊删除单支结点s，使它的左子树链接到它所在的链接位置＊／P一＞lchild=s一＞lchild;elser一＞rchild二s一》lchild;｝" ID="16">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="17">
          <fptr EndPN="00000129" StartPN="00000129"/>
        </Paragraph>
        <Paragraph CONTEXT="｝从上面算法可以看出，删除双支结点实际上包括两次查找过程，第一次查找出待删除的双支结点，第二次查处出它的中序前驱结点，因中序前驱结点至多只含有左分支，所以用删除此结点来代替删除其双支结点《二叉排序树插入算法的运行时间主要花在查找插入位置上，同样，二叉排序树删除算法的运行时间也主要花在查找待删除的结点上，所以它们的时间复杂度同查找算法一样，与二叉排序树的深度成正比。当二叉排序树是理想平衡树（最好情况）时，其时间复杂度为O(1ogin)变为一棵单支树（最坏情况）时，其时间复杂度为O(n),平均情况可大致表示为O(1ogin)。我们知道，在线性表（无论是采用顺序存储的顺序表，还是链式存储的单链表）上做同样插入和删除运算的时间复杂度为O(n)，因此，若需要经常对数据元素做插入和删除操作的话，则组织成二叉排序树的结构比组织成线性表的结构更有效。" ID="18">
          <fptr EndPN="00000130" StartPN="00000129"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="二叉树结构可以用来解决计算机领域中的各类实际问题。例如，在排序、检索、数据库管理系统以及人工智能等许多领域，二叉树都有着广泛的应用。作为二叉树的应用之一，本节介绍二叉排序树。顾名思义，二叉排序树可以用于排序，也可以用于检索（或称查找）。利用二叉排序树可以大大提高检索的效率。" ID="1">
        <fptr EndPN="00000122" StartPN="00000122"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="120" TITLE="7.7  哈夫曼树" TYPE="Chapter">
      <fptr LogicalPageNum="130" PhysicalPageNum="130"/>
        <div ORDERLABEL="120" TITLE="7.7.1  哈夫曼树的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="130" PhysicalPageNum="130"/>
        <Paragraph CONTEXT="1.路径和路径长度若在一棵树中存在着一个结点序列kkZ，…,k;，使得k，是ki.，的双亲（1.1)，则称此结点序列是从k，到k;的路径，因树中每个结点只有一个双亲结点，所以它也是这两个结点之间的唯一路径。从k。到气所经过的分支数称为这两点之间的路径长度，它等于路径上的结点数减la" ID="1">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="2.结点的权和带权路径长度在许多应用中，常常将树中的结点赋给一个有着某种意义的数，我们称此数为该结点的权。结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积。" ID="2">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="3.树的带权路径长度树的带权路径长度定义为树中所有叶子结点的带权路径长度之和，通常记为：i=1协沪乙＝" ID="3">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="其中r表示叶子结点的数目，w，和1‘分别表示叶子结点k，的权值和根到k‘之间的路径长度。" ID="4">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Paragraph CONTEXT="4.哈夫曼树哈夫曼（Huffman）树又称最优二叉树，它是n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树。因为构造这种树的算法最早是由哈夫曼于1952年提出的，所以被称之为哈夫曼树。例如，有4个叶子结点a,b,c,d，分别带权为9.4.5,2，由它们构成的3棵" ID="5">
          <fptr EndPN="00000130" StartPN="00000130"/>
        </Paragraph>
        <Picture URL="00000131\00000131_new\0001.jpg">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Picture>
        <Paragraph CONTEXT="。卜尹、。灯，一瓜2叮皿议。。只、必诌必勺0(b)(c)图7-23由四个叶结点构成的三棵不同的带权二义树每一棵二叉树的带权路径长度WPL分别为：(a)WPL=9x2+4x2+5x2+2x2=40(b)WPL=4x1+2x2+5x3+9x3=50(c)WPL=9x1+5x2+4x2+2x3=37其中（。）树的WPL最小，稍后便知，此树就是哈夫曼树。" ID="6">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="121" TITLE="7.7.2  哈夫曼树的构造" TYPE="Chapter">
        <fptr LogicalPageNum="131" PhysicalPageNum="131"/>
        <Paragraph CONTEXT="构造最优二叉树的算法是由哈夫曼提出的，所以称之为哈夫曼算法，具体叙述如下：" ID="1">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="(1)根据与n个权值｛w,，wZ,w｝对应的n个结点构成n棵二叉树的森林F＝｛T！，兀，…，Tn｝，其中每棵二叉树T;(l蕊i〔n)都只有一个权值为w‘的根结点，其左、右子树均为空。" ID="2">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）在森林F中选出两棵根结点的权值最小的树作为一棵新的左、右子树，且置新树的附加根结点的权值为其左、右子树上根结点的权值之和。t3)从F中删除这两棵树，同时把新树加入中。" ID="3">
          <fptr EndPN="00000131" StartPN="00000131"/>
        </Paragraph>
        <Paragraph CONTEXT="(4）重复（(2）和（3)，直到F中只含有一棵树为止，此树便是哈夫曼树。假定仍然采用图7-21中的4个带权叶子结点来构造一棵哈夫曼树，按照上述算(a)b）其中（d）树就是最后生成的哈夫曼树，它的带权路径长度为37，因此，图7-21(c）树是一棵哈夫曼树。" ID="4">
          <fptr EndPN="00000132" StartPN="00000131"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="122" TITLE="7.7.3  哈夫曼编码" TYPE="Chapter">
        <fptr LogicalPageNum="132" PhysicalPageNum="132"/>
        <Paragraph CONTEXT="哈夫曼树的应用很广泛，哈夫曼编码就是其中的一种，下面给予简要介绍。在电报通讯中，电文是以二进制的o.1序列传送的。在发送端需要将电文中的字符序列转换成二进制的o.1序列（即编码），在接收端又需要把接收的o,1序列转换成对应的字符序列（即译码）。最简单的二进制编码方式是等长编码。例如，假定电文中只使用A.B.C.D," ID="1">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="E.F这6种字符，若进行等长编码，它们分别需要3位二进制字符，可依次编码为000,010,011,100.101。若用这6个字符作为6个叶子结点，生成一棵二叉树，一让该二叉树中每个分支结点的左、右分支分别用0和1编码，从树根结点到每个叶子结点的路径上所经分支的0.1编码序列应等于该叶子结点的二进制编码，则对应的编码二叉树如图7-23所示。通常，电文中每个字符出现的频率（即次数）一般是不同的。假定在一份电文中，这6个字符的出现频率依次为：4,2.6.8.3,2，则电文被编码后的总长度L可由下式计算：" ID="2">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="飞" ID="3">
          <fptr EndPN="00000132" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="八艺c;1;子二t乙＝其中n表示电文中使用的字符种数，c‘和l;分别表示对应字符k，在电文中出现的频率和编码长度。结合上面的例子，可求出L为：F艺(c;x3）=3xf＝1乙＝艺（c‘x3）＝3x（4＋2＋6＋8＋3＋2）＝75性。假设用0表示字符D，用01表示字符C，则当接收到编码串…卜·，并译到字符0时，是立即译出对应的字符D，还是接着与下一个字符1一起译为对应的字符C，这就产生于二义性。因此，若对某一字符集进行不等长编码，编码都不能是其他字符编码的前缀。符合此要求的编码叫做前缀编码。显然等长编码是前缀编码，这从等长编码所对应的编码二叉树也可直观地看出，任一叶子结点都不可能是其他叶子结点的前驱，也就是说，只有当一个结点是另一个结点的前驱时，该结点的字符编码才一会是另一个结点的字符编码的前缀。为了使不等长编码为前缀编码，可用该字符集中的每个字符作为叶子结点生成一棵编码二叉树，为了获得传送电文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，求出此树的最小带权路径长度就等于求出了传送电文的最短长度。因此，求传送电文的最短长度问题就转化为求由字符集中的所有字符作为叶子结点，由字符的出现频率作为其权值所产生的哈夫曼树的问题。根据上面所讨论的例子，生成的编码哈夫曼树如图7-24所示。由编码哈夫曼树得到的字符编码称作哈夫曼编码。在图7-24中，A,B,C,D,E.F这6个字符的哈夫曼编码依次为：00.1110,O1.10.110.1111。电文的最短传送长度为：" ID="4">
          <fptr EndPN="00000133" StartPN="00000132"/>
        </Paragraph>
        <Paragraph CONTEXT="6" ID="5">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
        <Paragraph CONTEXT="艺w，l.L=WP乙＝=4x2-2x4-6x2-f8x2+3x3+2x4=61显然，这比等长编码所得到的传送总长度75要小。" ID="6">
          <fptr EndPN="00000133" StartPN="00000133"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="哈夫曼树是一类带权的路径长度最短的一棵二叉树，在许多领域有着广泛的应用。" ID="1">
        <fptr EndPN="00000130" StartPN="00000130"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="123" TITLE="7.8  树和森林" TYPE="Chapter">
      <fptr LogicalPageNum="133" PhysicalPageNum="133"/>
        <div ORDERLABEL="124" TITLE="7.8.1  树的存储结构" TYPE="Chapter">
        <fptr LogicalPageNum="134" PhysicalPageNum="134"/>
        <Paragraph CONTEXT="假设有一个棵如图7-2s所示的树。这里介绍3种常用的表示方法。" ID="1">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Picture URL="00000134\00000134_new\0005.jpg">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Picture>
        <Paragraph CONTEXT="1.双亲表示法在树中，每个结点的双亲是唯一的。利用这一性质，可在存储结点信息的同时，为每个结点增加一个描述其双亲的信息parent，就可唯一地表示任何一棵树。可以按层次用一片连续的空间来存储树的结点。" ID="2">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="#defineMaxSize20" ID="3">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="structTreeNode{" ID="4">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="elemtypedata;" ID="5">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="intparent;" ID="6">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="｝七ree[MaxSize图7-25中树的双亲表示法如图7-26所示。显然，双亲表示法便于向双亲方向查找。I734S67891011图，一26树的双亲表示法" ID="7">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="2.孩子表示法由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一颗子树的根结点。但是这种存储方式操作不方便。如果将每个结点。而n个头指针又组成一个线性表，为了便于查找，选用数组表示。这种存储结构形式说明如下：" ID="8">
          <fptr EndPN="00000134" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="structTreeNode{lem匕ypedata;structTreeNode*next;｝；" ID="9">
          <fptr EndPN="00000135" StartPN="00000134"/>
        </Paragraph>
        <Paragraph CONTEXT="structTnode{°lemtypedata;structTreeNode*head;}tree[MaxSize图7-25中树的孩子表示法如图7-27所示。显然，孩子表示法便于查找孩子，而不适用于双向方向的查找。" ID="10">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="3.孩子兄弟表示法在树的各种存储结构中，最常用的是孩子兄弟表示法。此方法又称作二叉树表示法。即以二叉链表作树的存储结构。链表中结点的两个指针域分别指向结点的第一个孩子结点和下一个兄弟结点。" ID="11">
          <fptr EndPN="00000135" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="structNode{elemtypedata;structTreeNodechild，sibling;｝；图7-25中树的孩子兄弟表示法如图7-28所示。利用这种存储结构便于实现各种数据的操作。$Picture[00000135\00000135_new\0022.jpg]Picture$在此值得注意的是：树的二叉链表表示法与二又树的二叉链表表示法，虽然名称不同，但是存储表示是唯一对应的，如图7-29所示。营" ID="12">
          <fptr EndPN="00000136" StartPN="00000135"/>
        </Paragraph>
        <Paragraph CONTEXT="一叭、图7-29树的两种表示法的对应关系由此可见，一棵树可唯一地转换成一棵二叉树。也就是说，以二叉链表作为存储结构，可推导出树与二叉树之间的确定对应关系。" ID="13">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="126" TITLE="7.8.2  二叉树与树、森林之间的转换" TYPE="Chapter">
        <fptr LogicalPageNum="136" PhysicalPageNum="136"/>
        <Picture URL="00000136\00000136_new\0001.jpg">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Picture>
        <Picture URL="00000136\00000136_new\0002.jpg">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Picture>
        <Paragraph CONTEXT="从树的二叉链表表示的定义可知，任何一棵与树对应的二叉树，其右子树必为空。若把森林中第二棵树的根结点看成是第一颗树的根结点的兄弟，则同样可导出森林和二" ID="1">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="叉树的对应关系。" ID="2">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="i.森林转换成二叉树如果F={TTZ,，T｝是森林，则可按如下规则转换成一棵二叉树B=(Root,LB,RB)&lt;1）若F为空，即，=0，则B为空树." ID="3">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）若F非空，即m$0，则B的根Root即为森林中第一棵树的根RooT(T,);…，…，" ID="4">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="2.二叉树转换成森林如果B二｛Root,LB,RB｝是一棵二叉树，则可按如下规则转换成森林F={T" ID="5">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="几，…，几｝：" ID="6">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="(1）若B为空，则F为空." ID="7">
          <fptr EndPN="00000136" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）若B非空，则F中第一裸树T，的根RooT(T,）即为二又树的根Root;T.中根结点的子树森林F,是由B的左子树LB转换而成森林；F中除T：之外其余树组成的森林F一（Tz,T,…，T｝是由B的右子树RB转换而成的森林." ID="8">
          <fptr EndPN="00000137" StartPN="00000136"/>
        </Paragraph>
        <Paragraph CONTEXT="，从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作也可以转换成二叉树的操作来实现。例如图7-30展示了森林与二叉树之间的对应关系。0诊" ID="9">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Paragraph>
        <Picture URL="00000137\00000137_new\0014.jpg">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Picture>
        <Picture URL="00000137\00000137_new\0017.jpg">
          <fptr EndPN="00000137" StartPN="00000137"/>
        </Picture>
      </div>
      <Paragraph CONTEXT="这里所说的树是指度大于3的树。树与森林在计算机内有许多种表示方法。至于究竟选择哪一种方法来存储树的结士亘五avlh十么廿应出娜1书廿扦利一乃剑嵘知】配1拐塑矛仁又屯书吞.李田uBRis12=i右会～'幼'RTi主At构，主要取决于要对树结构进行什么类型的操作。这样，才能如实地表现一棵树。" ID="1">
        <fptr EndPN="00000134" StartPN="00000133"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="127" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="137" PhysicalPageNum="137"/>
      <Paragraph CONTEXT="1.判断题" ID="1">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="（1)二义树是树的特殊例子。（2树和二叉树之间最主要的差别是：二叉树的结点的子树要区分为左子树和右子树，即使结点只有一棵子树的情况下，也要明确指出该子树是左子树还是右子树。" ID="2">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）由树转换成二叉树，其根结点的右子树总是空的。" ID="3">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）若有一个结点是某二叉树子树的中序遍历序列中的最后一个结点，则它必是该子树的前序遍历序列中的最后一个结点。" ID="4">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Picture URL="00000137\00000137_new\0009.jpg">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Picture>
      <Paragraph CONTEXT="(5)若有一个结点是某二叉树子树的前序遍历序列中的最后一个结点，则它必是该子树的中序遍历序列中的最后一个结点。" ID="5">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="(6）若有一个叶子是某二叉树子树的中序遍历序列中的最后一个结点，则它必" ID="6">
        <fptr EndPN="00000137" StartPN="00000137"/>
      </Paragraph>
      <Paragraph CONTEXT="(7）若有一个叶子是某二叉树子树的前序遍历序列中的最后一个结点，则它必是该子树的中序遍历序列中的最后一个结点。" ID="7">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="(8）二叉树中，具有两个孩子的结点，在中序遍历序列中，它的后继结点最多只能有一个孩子结点。" ID="8">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="(9）二叉树中，只有一个孩子的结点，在中序遍历序列中，它没有后继孩子结点。" ID="9">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="(10)中序线索二叉树的优点之一是便于在中序下查找前驱结点和后继结点。(ll)哈夫曼树是带权路径长度最短的树，路径f:权值较大的结点离根较近。" ID="10">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="(12)中序遍历二叉排序树的结点，就可以得到排好序的结点序列。" ID="11">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="(13)二叉排序树的任何子树都是二叉排序树。" ID="12">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="2.假设结点X有左孩子结点Y口右孩子结点Z，用3种基本遍历方法得到的遍历序列中X）是Y的前驱，X）是Z的后继，YC）是Z的前驱。①一定②不③不一定" ID="13">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="3.如果结点A有3个兄弟，而且B是A的双亲结点，试问B的度是多少。" ID="14">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="4.一棵度为2的树与一棵二叉树有什么区别？" ID="15">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="5.请分别画出具有3个结点的树和具有3个结点的二叉树的所有形态。" ID="16">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="6.请分别列出下图所示的二叉树的所有叶子结点与非叶子结点，并分别指出各结点的度数以及所在的层次数。" ID="17">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="7.深度为k的二叉树第1层（irk)的结点总数应该是多少？" ID="18">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="g.深度为k的二叉树的结点总数是多少？" ID="19">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="9.若一棵具有n个结点的左子树采用二叉链表存储结构。试问：该二叉树所有结点中，共有多少空指针域？写出推导过程。" ID="20">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="10.己知某二叉树的前序遍历序列为" ID="21">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="A,B,D.E,G,C.F,H.LJ中序遍历序列为" ID="22">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="D,B,G.E,A.H,F,I,J.C128" ID="23">
        <fptr EndPN="00000138" StartPN="00000138"/>
      </Paragraph>
      <Paragraph CONTEXT="请画出该二叉树。" ID="24">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="11，已知某二叉树的前序遍历序列为A.B,C。试问：有儿种不同的.二义树可以得到这一遍历结果。" ID="25">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="12.具有n个叶子结点的哈夫曼树共有多少个结点？写出推导过程。" ID="26">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="13.给定一组权值为W二｛14,16.8,3,25,5}。试构造出相应的哈夫曼树，并计算其带权的路径长度汗凡。" ID="27">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="14.对于F图所示的树，分别用下列表示法画出它的存储结构（存储表示）：" ID="28">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)双亲表示法" ID="29">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）孩子表示法" ID="30">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）孩子兄弟表示法" ID="31">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="叮" ID="32">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="IS.设二叉树BT的存储结构如下：" ID="33">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="其中BT为树根结点的指针。" ID="34">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)画出二叉树BT的逻辑结构；&lt;2）写出按先、中、后序遍历该二叉树所得到的结点序列；&lt;3）画出二叉树BT的后序线索化树。" ID="35">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="16.给定一组元素为｛14,16,8,3,25,5,18,20}。试按照排列顺序，构造出相应的二叉排序树。" ID="36">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Paragraph CONTEXT="17.己知～一棵二叉排序树如r图所示，若依次删除99.24,92,50结点，试分别画出每删除一个结点后得到的二叉排序树。" ID="37">
        <fptr EndPN="00000139" StartPN="00000139"/>
      </Paragraph>
      <Picture URL="00000140\00000140_new\0001.jpg">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Picture>
      <Paragraph CONTEXT="18.试写出在二叉排序树上进行查找值为x的结点的算法，并要求当查找不成功时，插入值为x的新结点。" ID="38">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="19.试写出前序遍历二叉树的递归和非递归算法。" ID="39">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
      <Paragraph CONTEXT="20.己知二叉树采用二又链表存储结构，指向根结点的指针为Root。试写出一个非递归算法，统计出该二叉树共有多少个叶子结点。130" ID="40">
        <fptr EndPN="00000140" StartPN="00000140"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="在前面的章节中所讨论的几种数据结构都属于线性结构。而在实际中，有许多问题若采用了非线性结构来表示，则会显得更加明确和方便。所谓非线性结构是指在该类结构中至少存在一个数据元素有两个或两个以上的直接前驱（或直接后继）元素。树型结构就是其中一类十分重要的非线性结构，它可以用来描述客观世界中广泛存在的、呈现层次结构的关系。在计算机科学中，树型结构为计算机应用中出现的具有层次关系和分支关系的数据，提供了一种自然的表示。例如：在数据库系统中，用树来组织信息。在编译程序中，可以用树来表示源程序的语法结构。同样，树型结构也广泛应用于人工智能和算法分析中。我们称树型结构中的一个数据元素为一个结点，结点之间的关系称为分支。" ID="1">
      <fptr EndPN="00000101" StartPN="00000101"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="131" TITLE="第8章  图" TYPE="Chapter">
    <fptr LogicalPageNum="141" PhysicalPageNum="141"/>
      <div ORDERLABEL="131" TITLE="8.1  图的基本概念" TYPE="Chapter">
      <fptr LogicalPageNum="141" PhysicalPageNum="141"/>
        <div ORDERLABEL="131" TITLE="8.1.1  图的定义" TYPE="Chapter">
        <fptr LogicalPageNum="141" PhysicalPageNum="141"/>
        <Paragraph CONTEXT="G二（V,E)其中V是顶点（vertex)的有限非空集合，E是V中顶点偶对的有限集合，这些顶点偶对称为边（edge)。通常，V(G）和E(G）分别表示图G的顶点集合和边集合。E(G）也可以为空集，若E(G）为空，则图G只有顶点而没有边。" ID="1">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="r,r1.p才弓r矛,二1二r-I田v+rrn+zz土口、行曰JI、1州卜二二.v-r_，i.fr.i1、一用以表示一条无向边，例如，（v‘，vj），表示顶点v.与vj的一条无向边。显然（v百，vj）和（v‘，巧）所代表的是同一条边。汁11.，f」.＿洲人点含苗二工二.巴，1万1－t十丁决；J二翻幸仁2、卜一止击J七2、石r，一r-V（G，）＝｛v、，、，2，v3，v4｝E（G，）二｛（v！，vZ），（v，，v3），（v！，v4），（vZ，v3），（v3，v4）｝若图G中表示边的顶点偶对是有序的，则称G为有向图（digraph）。有向图中的边又称为弧（arc）。用一对尖括号把有序偶对括起来，表示一条有向边。例如：＜v‘，vj）" ID="2">
          <fptr EndPN="00000141" StartPN="00000141"/>
        </Paragraph>
        <Paragraph CONTEXT="vcc,）二｛vvz,vv4}FtG1）二｛（VJfVJ）r＜Vl,Vg）,＜V,V3）,（。jrV.｝,（VqrV11’若‘、·，）或＜ti'j，'＞是EG的边、。注卜、、4、、一二一ra。、a_、.AiL;二｝。若（石：，了、）或（、，一）不是：（G卜1边若（vi，vj）或（‘，1，vj）图8-1有向图与无向图" ID="3">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="132" TITLE="8.1.2  图的基本术语" TYPE="Chapter">
        <fptr LogicalPageNum="142" PhysicalPageNum="142"/>
        <Paragraph CONTEXT="1.稀疏图与稠密图具有n个顶点的无向图，其边的最大数目是n（n-1）／2。我们把有n（n-1）12条边的无向图，称为无向完全图；具有n个顶点的有向图，其边的最大数目是n（n-1）。我们把有n（n-1）条边的有向图，称为有向完全图。在n个顶点的图中，当边数。＜nlogZn、于" ID="1">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="护3丫，G3G4图8-2无向完全图和稀疏图" ID="2">
          <fptr EndPN="00000142" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="2.权与网在实际应用中，图的边往往与具有一定意义的数相关，即每一条边附有一个对应的S护y／一一它＿，，一们＿$Picture[00000143\00000143_new\0003.jpg]Picture$厂一狡" ID="3">
          <fptr EndPN="00000143" StartPN="00000142"/>
        </Paragraph>
        <Paragraph CONTEXT="i-广戈，6f卜气厂1；\6Z" ID="4">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="＼一｝、、＼＼「又｝／六＼｝／$Picture[00000143\00000143_new\0008.jpg]Picture$6厂＼GyG6图8-3尤向带权图和有一向带权图" ID="5">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="假设有两个图G二（V,E）和图G’＝（丫，尸），若满足条件：V(GcV(G)，并且E(GcE(G)，则称G'为G的子图。图8-4所示即为图8-1G,的子图。己图s-4G、图的f图i;例" ID="6">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="4.邻接点在图G中，若（(vv）是E(G）中的一条边，则称顶点v；和v是互为邻接点。" ID="7">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="5.路径与回路在图G中从顶点V，到顶点V。的一条路径是指顶点序列（v，vi，v;z，一V;n,Vy)，且（Vl，,V;(V;1,V;Z)，一（Vvv）属于E(G)·如果G是有向图，则路径也" ID="8">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="由E(G）中的边＜vv&gt;，&lt;v,viz&gt;，一＜v,v4＞组成。路径的长度是指在这条路径上边的数目。在一条路径中，其余顶点都不同的路径，称为简单路径。第一个顶点和最后一个顶点相同的简单路径称为回路或环。" ID="9">
          <fptr EndPN="00000143" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="6.连通图在无向图中，若从V，到V有路径，则称v‘和V是连通的。若V(G）中的每一对不同顶点V‘和V都连通，则称G是连通图，在无向图G中，极大的连通子图，称为连通分量。／一＼，／一一＼.（官一$Picture[00000144\00000144_new\0004.jpg]Picture$$Picture[00000144\00000144_new\0005.jpg]Picture$(a)(h)(c)(d)图8-5无向图及其连通分量鸽｛／／／汾、（幻〔b）（c）‘母图S-6有向图及其强连通分量" ID="10">
          <fptr EndPN="00000144" StartPN="00000143"/>
        </Paragraph>
        <Paragraph CONTEXT="7.生成树$Picture[00000144\00000144_new\0017.jpg]Picture$$Picture[00000144\00000144_new\0018.jpg]Picture$一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有构成一棵树的n-1条边。如果在一棵生成树上添加一个条边，必定构成一个环；因为这条边使得它依附的那两个顶点之间有了第2条路径。一棵有n个顶点的生成树有且仅有n-1条边，如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1条边，则一定有环。但有，有n-1条边的图不一定都是生成树。沪／尹一＼＼" ID="11">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="-(e)(b)图8-7无向图及其生成树" ID="12">
          <fptr EndPN="00000144" StartPN="00000144"/>
        </Paragraph>
        <Paragraph CONTEXT="8.度、入度和出度在无向图中，顶点所具有的边的数目称为该顶点的度。在有向图中，以某顶点为头（终点）的边的数目，称为该顶点的入度。以某顶点为尾（始点）的边的数目，称为该134顶点的出度。一个顶点的入度与出度的和为该顶点的度。假设无向连通图G中有n个顶点，e条边，每个顶点的度为di(lcicn)，则2i" ID="13">
          <fptr EndPN="00000145" StartPN="00000144"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="135" TITLE="8.1.3  图的基本操作" TYPE="Chapter">
        <fptr LogicalPageNum="145" PhysicalPageNum="145"/>
        <Paragraph CONTEXT="有关图的基本操作可以归纳如下：LocateVex(G,v初始条件：图G存在操作结果：若G中存在顶点v，则返回该顶点在图中的位置：否则返回其他信息。GetVex(G,i)初始条件：图G存在操作结果：返回图G中第i个顶点：若i&gt;图中顶点数，返回OoFirstAdj(G,v)初始条件：图G存在操作结果：返回图G中v的第一个邻接点：若v没有邻接点或图G无顶点则返回OoNextAdj(G,v,w)初始条件：图G存在，、为图G中顶点v的某个邻接点操作结果：返回w的下一个邻接点：若w是v的最后一个邻接点，则返回OaAddVez(G,v)初始条件：图G存在操作结果：在图G添加一个顶点v，使其为图G的第n+1个顶点。·AddArc(G,v,w）或AddEdge(G,v,w)初始条件：图G存在操作结果：在图G中增加一条弧或边（v,w)oDeleteVex(G,v)初始条件：图G存在操作结果：从图G中删除顶点，以及与v相关联的所有的边或弧。·DeleteA二（C,v,w）或DeleteEdge(G,v,w)初始条件：图G存在操作结果：从图G中删除弧＜&lt;v,x或边＜&lt;v,xoCreateGraph(G,V,E)初始条件：V是顶点集合，E是边集合" ID="1">
          <fptr EndPN="00000145" StartPN="00000145"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="本节将介绍图的一些基本概念，以加深读者对图结构的理解。" ID="1">
        <fptr EndPN="00000141" StartPN="00000141"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="136" TITLE="8.2  图的存储结构" TYPE="Chapter">
      <fptr LogicalPageNum="146" PhysicalPageNum="146"/>
        <div ORDERLABEL="136" TITLE="8.2.1  邻接矩阵(数组)" TYPE="Chapter">
        <fptr LogicalPageNum="146" PhysicalPageNum="146"/>
        <Paragraph CONTEXT="邻接矩阵是表示顶点之间相邻关系的矩阵。设G二（V,E）是具有nil个顶点的图，则G的邻接矩阵具有如下性质的n阶方阵：｛‘若‘'·i）或·tiv＞是E(c}边In李岑1、，，，、曰Uz、，、，、月屯，经孔rl了二h」宁，1＞丁wl］若‘·‘，·，，或＜·‘，·，＞〔E（G）1八石1拿＿＿11‘云1，其他其中w。表示边上的权值，，表示一个计算机允许的大于所有边上权值的数。如图8-8中所示，带权图的邻接矩阵根据使用需要可分别表示为A3和A4。0“·4“｛八4＝｝7·8的“·4用邻接矩阵表示法表示图，除了存储用于表示顶点间相邻关系的邻接矩阵外，通常还需要用一个数组来存储顶点的信息。由此可得到数组表示法的形式说明如卜：#defineMAXS工ZE20图的最人顶i个数＊／bitadj二atrix[MAXSIZE1[MAXS工ZEJ;/＊图的邻接阵，值为1或。＊／intfloatadjnetwork[MAXSIZEJ[MAXSIZE1:/＊网的邻接矩阵，权值为整数e土emtypeVertex[MAXSIZEJ;/＊存放顶点信*/借助于邻接矩阵，容易判定任意两个顶点之间是否有边（或弧）相连，并容易求得各个顶点的度。对于无向图，顶点v。的度是邻接矩阵中第i行（或第i列）的元素之和，即" ID="1">
          <fptr EndPN="00000147" StartPN="00000146"/>
        </Paragraph>
        <Paragraph CONTEXT="TD（v;）一乏A［iL］对于有向图，第i行的元素之和为顶点v，的出度OD(v;)，第J列的元素之和为顶" ID="2">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="点v的入度ID(v。顶点v，的度为" ID="3">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="7’D（v，）＝OD（v，）＋ID（v，）" ID="4">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="137" TITLE="8.2.2  邻接表" TYPE="Chapter">
        <fptr LogicalPageNum="147" PhysicalPageNum="147"/>
        <Paragraph CONTEXT="邻接表是图的种链式存储结构，在邻接表中，对图中每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点v‘的边（对有向图是以顶点v。为尾的弧）。每个结点由两个域组成：(1)顶点域，ex，用以指示与顶点，‘邻接的点的序号;(2)指针域next，用以指向依附于顶点v，的下一条边所应的的结点。如果用邻接表存放网的信息，以便随机访问任一顶点的链表。例如：G：和G：的邻接表分别如图8-9(a）和图8-9(b）所示。在图8-9(b）中头结点内的数" ID="1">
          <fptr EndPN="00000147" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="为出度。c的c,值得注意的是，一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一。这是因为在邻接表表示中，各边表结点的链接次序取决于建立邻接表的算法以及它的输入次序，也就是说，在邻接表的每个线性链表中，各结点的顺序是任意的。对于无向图来说，各顶点对应的线性链表的结点数（不含表头结点）等于该顶点的度数；但对于有向图，线性链表中的结点数只等于相应的顶点的“出度”数，因为一个线性链表对应原邻接矩阵的一行。如要计算有向图中某顶点的“入度”数，则需对整个邻接表的各线性链表扫视一遍，查看有多少与该顶点标号相应的结点，但这样求入度不对应有一个线性链表，但链表的每一结点却是表示原邻接矩阵中该顶点的列中每个非零元素，例如由图8-1中G：的邻接矩阵A：得到逆邻接表如图8-10所示，从逆邻接表表示每个顶点的入度就方便多了" ID="2">
          <fptr EndPN="00000148" StartPN="00000147"/>
        </Paragraph>
        <Paragraph CONTEXT="一个图的邻接表存储结构可说明如下：structarcnode{/＊链表结点＊／主ntadjvex;/＊邻接点域＊／structarcnode*next:/＊链域＊／｝；structvexnode{/＊表头结点＊／intvertex;/＊顶点信息＊／structarcnode*firstarc;" ID="3">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="｝：" ID="4">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="s七ructvexnodeadjlist[MAXS工ZE在一个有n个顶点e条边的无向图中，由邻接表的定义可知：邻接表中有n个表头结点（每个结点占邻接数组中的一个分量）和2e个链表结点。类似地，有n个顶点。条边的有向图，有n个表头结点和e个链表结点。因此，邻接表的空间复杂度为S(n,e）二O(n+e)。从时间上看，用邻接表存储图结构，可以提高扫描效率。此存储方式适用于以顶点为主的扫描算法。" ID="5">
          <fptr EndPN="00000148" StartPN="00000148"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="138" TITLE="8.2.3  邻接多重表" TYPE="Chapter">
        <fptr LogicalPageNum="148" PhysicalPageNum="148"/>
        <Paragraph CONTEXT="邻接多重表是无向图的另一种链式存储结构。提出邻接多重表的原因是，因为它能138够提供更为方便的边处理信息。在无向图的邻接表中每一条边（VV）有两个结点，分别在第1个和第j个链表中，这给某些图的操作带来不便。例如，检测某条边是否被访问过，则需要同时找到表示一条边的两上结点，而这两个结点又不在同一个单链表中，故不方便。如果用邻接多重表表示一个图，处理上述问题就容易多了。在邻接多重表中，图的每条边只用一个结点表示，不过这个结点包括5个域：其中，mark为标志域，可用以标记该条边是否被搜索过；v‘和v为该边依附的两个顶点在图中的位置，v;next指向下一条依附于顶点v‘的边；vnext指向一1顶点V的边。每一个顶点也用一个结点表示，其中，data域存储和该顶点相关的信息，firstedg。域指示第一条依附于该顶点的边。如图8-11所示为无向图G，的邻接多重表。在邻接多重表上，各种基本操作的实现与邻接表相似，邻接多重表的类型说明如下：" ID="1">
          <fptr EndPN="00000149" StartPN="00000148"/>
        </Paragraph>
        <Paragraph CONTEXT="structmenode{intmark;/＊取值。或1in七vv;/＊顶点序号’／structmenodev;next.vjnext;｝：" ID="2">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
        <Paragraph CONTEXT="structvexnode{elemtypedata;structmenode*firstedge;｝；structvexnodeadjmu.list[MAXSIZE" ID="3">
          <fptr EndPN="00000149" StartPN="00000149"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="140" TITLE="8.2.4  邻接表的生成算法" TYPE="Chapter">
        <fptr LogicalPageNum="150" PhysicalPageNum="150"/>
        <Paragraph CONTEXT="图的邻接表表示，对于图中边的增删，图的遍历和求图的最小生成树等问题的求解是很方便的，卜面讨论邻接表的生成算法。算法思想：输入图的逻辑结构信息，即：由键盘输入每条边的顶点对（(i,j)。若图是n个顶点e条边，r点存储在vexnode类型的链表中，同时，adjlist[n+11（假设0单元不用）作为n个链表的表头数组。根据顶点对（(i.j)动态生成两个结点i和j，分别插入到第i个和第j个链表的表头后面。图的邻接表生成算法描述如下：voidCreateGraph(structvexnodeadjlist(n))（for1k=1;k＜二n:k)adjlist[k].firstarc二NULL;scanfi,&amp;j输入一顶点对＊／whilei0)(j：二0)){s=(s七rustarcnodemalloc(sizeof(structarcnodes一＞next二adjlist[i].firstarc:adjlist[i].firstarc=s;s一＞adjvex＝j：／＊在第i个链表中插入jk点＊／s二（structarcnodemalloc(sizeof(structarcnode)s一＞next二adjlist[j].firstarc:adjlist[j].firstarc二。：s一＞&gt;adjvex二is在第j个链表中插入iy点＊／scanfi.&amp;j/＊读入F'rti点对＊／）" ID="1">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
        <Paragraph CONTEXT="｝算法的C语言程序实现参见后面的程序‘" ID="2">
          <fptr EndPN="00000150" StartPN="00000150"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="在计算机中，有多种方法存储图的信息，由于图的结构复杂，使用r一‘泛，一般应根据实际的应用，选择适合的表示方法。常用的图的存储结构有邻接矩阵、邻接多重表和邻接表，卜面分别讨论这3种存储结构。" ID="1">
        <fptr EndPN="00000146" StartPN="00000146"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="140" TITLE="8.3  图的遍历" TYPE="Chapter">
      <fptr LogicalPageNum="150" PhysicalPageNum="150"/>
        <div ORDERLABEL="141" TITLE="8.3.1  DFS和BFS的基本思想" TYPE="Chapter">
        <fptr LogicalPageNum="151" PhysicalPageNum="151"/>
        <Paragraph CONTEXT="深度优先搜索法DFS(DepthFirstSearch）的基本思想，是从图c中某个顶点v发，先访问vo，然后再选择一个与v,，相邻且没有被访问过的顶点v，访问，再从v，出发，选择一个与v、相邻且未被访问的顶点v访问……依次继续。如果当前被访问顶点的所有邻接顶点都己被访问，则回退到己被访问的顶点序列中，最后一个尚未被访问的相邻顶点的顶点w，从w出发按同样方法向前遍历，直到图中所有顶点都被访问。用深度优先搜索法遍历图8-12，首先从顶点v,开始，则一种可能的顶点访问顺序为：VlrVZrVyrVNrVSrVqrV6.V与DFS相对应的广度优先算法BFS(BreadthFirstSearch）的基本思想，是从图G中某一顶点v，出发，首先访问vo，然后访问与v，相邻的所有未被访问过的顶点vzr…r1n：再依次访问与，.rV7rrVm相邻且未被访问的所有顶点，依次继续，1到图中所有顶点都被访问。{821*度优先搜索法遍历图用广度优先搜索法遍历图g-13，首先从顶点，1开始，则一种可能的顶点访问顺序为：VlrvasV3rvarv5rvbrv7rvg图x-l3ItEf优先搜索法遍Uit'假定图G二（v,E）是一个连通的无向图，从任何顶点出发都可以访问图的每个顶点。在这一过程中。图G的边被分成两个集合T和B,T为遍历过程中走过的边的集合，B为其余的边的集合，即E二TUB。显然，图G‘二（V,T)是图G的一个子图，称之为G的生成树。如果用深度优先搜索遍历，则G’称为深度优先生成树；若用广度优先搜索遍历，则G‘称为广度优先生成树。图8-12所示中加粗边及点组成了一棵深度优先生成树，图8-13所示中加粗边及点组成了一棵广度优先生成树。" ID="1">
          <fptr EndPN="00000152" StartPN="00000151"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="142" TITLE="8.3.2  DFS和BFS算法" TYPE="Chapter">
        <fptr LogicalPageNum="152" PhysicalPageNum="152"/>
        <Paragraph CONTEXT="前面己给出了深度优先搜索DFS和广度优先搜索BFS的基本思想，下面我们讨论这两种搜索的算法实现。" ID="1">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="1.深度优先搜索为了实现DFS，首先确定图的存储结构。这里假设是以邻接表的方法存储，为了标志图中顶点的访问情况，需要设置一个访问标志数组visited[n]，初值为False，每当访问到某个顶点时，其相应的值变为Ture。具体的DFS算法实现描述如下：voiddfs(structvexnodeadjlist[nintv;)｛" ID="2">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="visited[v;〕二True;" ID="3">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(v;p=adjlist[v.firstarc;/＊取v：的边表头指针＊／while(p：二NULL){依次搜索v、的邻接点＊／if(visited[p一＞vertex〕二二False)dfs(p,vertex/＊从v、的未曾访问过的邻接点出发进行dfs＊／P二P一＞nex七；／‘找v：的下一个邻接点＊／｝" ID="4">
          <fptr EndPN="00000152" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="｝对图进行深度优先搜索得到的顶点序列为DFS序列。一个图的DFS序列不一定唯一，它与算法、图的存储结构以及初始出发点有关。在DFS算法中，当从v，出发搜索时，在邻接表的第i个单链表中，从表头开始选择一F一个未曾访问过的邻接点，作为新的出发点，若这种邻接点多于一个.靠近表头的那一个。图8-14是DFS(adjlist[51,2）的邻接表。142$Picture[00000153\00000153_new\0001.jpg]Picture$$Picture[00000153\00000153_new\0002.jpg]Picture$一日visifed图8-l4DFS(adjlist[5I.2）的邻接表在该存储结构上执行DFS算法的过程如下：设初始出发点是vZ，则DFSCadjlist" ID="5">
          <fptr EndPN="00000153" StartPN="00000152"/>
        </Paragraph>
        <Paragraph CONTEXT="[51,2）的执行结果是访问vz，赋值visited[21=True，从v：搜索到表头adjlistvt，因v，未曾访问过，则调用DFS(adjlist[51,1)osr[51,1)，首先访问vZ，因其己被访问过，继续搜索v：后面的vs，则ist[51,5)；由adjlist[vs］访问v4。由于v；的2个邻接点都被访I'p]调用。那（adjlist［5］，5）；由adjlist〔vs］访问v4。由于v；的过，回溯到vs；阳vs的两个邻接点同样被访问过，回溯到vl，而，！的3个邻接点都被访问过，回溯到，2，访问v3，则调用DFs（adjlist【5］，3）。此时，visited向量中的所有值均为True，沿搜索路线将途中所有第一次经过的顶点列表，即得到图8-14的DFS序列为：vZ，vl，vs，v4，v3。对于有n个顶点e条边的连通图，算法DFS需递归调用n次，在每次递归调用时，除访问顶点及做标记外，主要时间耗费在从顶点出发搜索它的所有邻接点。用邻接表表示图时，搜索n个顶点的所有邻接点即为对各边表结点扫描一遍，故算法DFS的时间复杂度为口（e），空间复杂度为口（n）。" ID="6">
          <fptr EndPN="00000153" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="2.广度优先搜索广度优先搜索算法BFS的假设条件与DFS相似。首先确定图是以邻接表方式存储，为了标志顶点的访问情况，要设置一个访问标志数组，isited［川，初值为False，每当访问到某个顶点时，给其赋值为True。由广度优先搜索的算法思想，BFS的算法描述如下：voidbfs（structvexnodeadjlist〔n］，intvi）｛visited［v、］＝True；printf（vJ）：／＊访问初始顶点＊／rear二1：front＝0；cq［rear］二v、；／＊己经访问过的初始顶点入队＊／while（front！＝rear）｛／＊队列不空时＊／front二（front＋1）％m：v＝cq【fron七〕：／＊按照访问次序依次出队＊／if(visi仁ed[p一＞vertex」二二False){visited[p一＞vertex]二True;printf(p一＞vertex):访问该点并使之入队＊／rear二〔rear+l)$m;cq[rear」二P一＞vertex;｝" ID="7">
          <fptr EndPN="00000154" StartPN="00000153"/>
        </Paragraph>
        <Paragraph CONTEXT="P。P一＞next:/＊找V的下一个邻接点＊／｝" ID="8">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="9">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="｝对图进行广度优先搜索得到的顶点序列为BFS序列。一个图的BFS序列也不一定唯一，这与DFS序列相似。现举一例说明，假如有图8-15所示的存储结构。一日" ID="10">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="6‘图s一巧厂度优先搜索邻接表广度优先搜索BFS(adjlist[61r2)的执行过程为：首先访问出发点vz，并将顶点v：的序号2入队，第1个出队的元素是2，从v：出发搜索到的2个邻接点依次是v,和vs，对它们进行访问并将其序号入队。第2个出队的元素是1，从，1出发搜索到的邻接点依是v2rv3和Vq，对其中未曾访问过的顶点V：和V；进行访问并将其序号入队。第3个出队的元素是5，从v，出发搜索到的邻接点均被访问过，不做处理，第4个出队的元素是3，从v;出发搜索到的邻接点v，rvs均被访问过，小作处理，第5个出队的元素是" ID="11">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="4，从v；出发搜索的邻接点V6未被访问过，6入队。当6出队以后，队列为空，搜索过程结宋，由此得金JBFS1列是：VZrV.rVSrV;rVqrVbo同样，如果图是以邻接矩阵形式存储，得到相应的算法如下：voidBFS1(bitadjmatrix[n][n]rintv：)｛front=0;rear二0:/＊队初始化＊／frintf(v;visited[v;〕二True;/＊访问lJ始顶点＊／AddQueue(cqrv;/＊初始顶点入队＊／if(front!=rear){/＊队不空时＊／DelQueue(cq,v;/＊按访问次离依次出队＊／for(k二1;k＜二n;k" ID="12">
          <fptr EndPN="00000154" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="144ifadjmatrix[i][k］二二1)(visited[k］二二False{printf(vHvisited[k］二True;AddQueue(cq,v、/访问该点并使之入对＊／｝" ID="13">
          <fptr EndPN="00000155" StartPN="00000154"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="14">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="｝对于有n个顶点。条边的连通图，因为每个顶点均入队一次，所以算法BFS和BFS1的外循环次数为n，算法BFS的内循环次数取决于各顶点的边表结点个数，内循环执行的总次数是边表结点的总数2e，故算法BFS的时间复杂度是O(e)。算法BFS1故算法BFS1的时间复杂度为O(nZ)o算法BFS和BFS1所用的辅助空间是队列和标志位数组，故它们的空间复杂度为O(n)。用C语言实现创建图并进行DFS和BFS的程序如下。一个简单的C语言程序如下：#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#defineN20#definetrue1#definefalse0typedefstructnode{intvex;structnode*next;}GRAPH;" ID="15">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="GRAPHadjlist(NJ;" ID="16">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="intvisited[N" ID="17">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="intv,num,i;voidcreat(GRAPHadjlist[N]){GRAPH*s;" ID="18">
          <fptr EndPN="00000155" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="inti,j,k;printf(&quot;pleaseinputnumberofvex20):\n&quot;);scanf(d&quot;num);printf(&quot;pleaseinputedge(i,j):\n&quot;);fork=l;knum;k{adjlist[kI.vex二O;adjlist[kI.next二NULLscanf(&quot;％d％d&quot;ij);while((i！二0j！二0)){adjlist(iI.vexadjlist[jI.vexs=(GRAPHmalloc(sizeof(GRAPH));S一＞vex=i;s一＞next二adjlist[jI.next;adjlist[jl.next二s;s=(GRAPHmalloc(si2eof(GRAPH));s一＞vex二〕；s一＞next=adjlist[iI.next;adjlist[iI.next=s;scanf(d$d&quot;ij);｝" ID="19">
          <fptr EndPN="00000156" StartPN="00000155"/>
        </Paragraph>
        <Paragraph CONTEXT="｝voiddfs(GRAPHadjlist[Nintv){GRAPH*p;visited[v]二TRUE;printf(dv);P二adjlist(vI.next;while(p！二NULL){if(visited[p一＞vexFALSE)dfs(adjlist,p一＞vex);P=P一＞next;" ID="20">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="21">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="｝voidbfs(GRAPHadjlist[Nintv)(GRAPH*p;intfront,rear,cp[Nvisited[v］二TRUE;printf(dv);rear=l;front=O;cp[rearv;while(front!=rear){frontfront+lnum;v=cp[frontp=adjlist[vI.next;while(p!=NULL){if(visited[P一＞vexFALSE){visited[p一＞vexTRUE;printf(d&quot;,p一＞vexrear二（rear+lnum;cp[rearp一＞vex;｝" ID="22">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="P二P一＞next;" ID="23">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="146" ID="24">
          <fptr EndPN="00000156" StartPN="00000156"/>
        </Paragraph>
        <Paragraph CONTEXT="卜" ID="25">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="26">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="main()" ID="27">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="(GRAPH*p;" ID="28">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="printf(ncreatgraph－一edgen&quot;);creat(adjlist);for(i二l;i＜二num;i{printf(ndegofv$d:$d,i,adjlist[iI.vex);p=adjlist[iI.next;while(p!=NULL){printf(’一＞％d&quot;,p一＞vex);p=p一＞next｝printf(nPleaseinputstart-vexdfsn&quot;);scant(&quot;％d&quot;v);for(i=l;iN;ivisited[iFALSE;printf(°printGraphdfs:&quot;);dfs(adjlist,v);printf(&quot;\nPleaseinputstart-vexbfsn&quot;);scanf（”％d.，＆v）；for(i二1;i‘二N;ivisited[iFALSE;printf(&quot;PrintGraphbfs:&quot;);bfs(adjlist,v);｝运行结果：" ID="29">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="Creategraph－一edge;Pleaseinputnum208Pleaseinputedge(i,j" ID="30">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="I.213" ID="31">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="24" ID="32">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="25" ID="33">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="36" ID="34">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="37" ID="35">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="48" ID="36">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="58" ID="37">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="E7" ID="38">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="00" ID="39">
          <fptr EndPN="00000157" StartPN="00000157"/>
        </Paragraph>
        <Paragraph CONTEXT="147Pleaseinputstart-vexdfs;几PrintGraphdfs:13762584Pleasenputstart-vexbfs:1PrintGraphbfs:13276548" ID="40">
          <fptr EndPN="00000158" StartPN="00000157"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="148" TITLE="8.3.3  非连通图的遍历" TYPE="Chapter">
        <fptr LogicalPageNum="158" PhysicalPageNum="158"/>
        <Paragraph CONTEXT="对于连通图，从图中任一顶点出发用DFS或BFS遍历图，可以访问到图的所有顶点，即连通图中任意两个顶点间都存在路径。而对于非连通图，在连通分量中的任意一对顶点之间存在路径，可是若顶点v、和v处于图的不同连通分量之中，则图中就没有从v‘到v的路径。所以从图中某个顶点v。出发遍历图，只能访问到包含顶点v。的那个;全;苗式羊-门dJ白翻6丁;占ni-i-1T.31I4'Iflt;；苗t.羊-1昏dtYtT-ti,X基于此原因考虑，对于非连通图，过，则说明该点已落在图中某个已求得的连通分量上。若未曾访问过，则从该顶点出发若未曾访问过，则从该顶点出发非连通图的遍历算法描述如下：voidcomponent(graph)｛for(i二1;i＜二n;iif(vis主ted[v;〕二一false)dfs(graph.v／’或bfs(graph,v:*/｝在此算法中调用DFS与BFS均可。若算法component只调用了一次DFS（或" ID="1">
          <fptr EndPN="00000158" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT="5了二°圣均3若执行component算法时，分别调用了BFS(v,).BFS(v.BFS(v4)，输出的3.vvii,VVV," ID="2">
          <fptr EndPN="00000159" StartPN="00000158"/>
        </Paragraph>
        <Paragraph CONTEXT=".VZ,v5,V" ID="3">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT=".Vq,Vg,V7,V,3,Vy算法component的时间复杂度为。(7100" ID="4">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="u,士匕wr曰＿1、1卜J斗之入rz毛自r以上讨论的各种遍历算法虽然是以无向图为例，但对于有向图也同样适用。" ID="5">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="149" TITLE="8.3.4  DFS和BFS算法的应用" TYPE="Chapter">
        <fptr LogicalPageNum="159" PhysicalPageNum="159"/>
        <Paragraph CONTEXT="以DFS和BFS算法为框架可以派生出许多实用的算法，下面从两个例子来说明DFS和BFS的应用。" ID="1">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="1.用BFS算法构造图的一裸生成树首先确定树的数据结构。由于树可以看成是图的特例，这里采用邻接表存放生成树。由广度优先搜索可以得到一棵广度优先生成树。因此，在算法BFS中只需修改部分内容即可得到一种求生成树的算法。具体作法：在算法BFS中，若当前出队的元素是V,，待入队的元素是Vr则V，是已访问过的顶点，V是待访问而未曾访问过的、邻接于v，的顶点。因而只要在BFS算法的IF子句中，加入动态申请结点，分别插入在相应" ID="2">
          <fptr EndPN="00000159" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="的链表中。算法如下：intv;)adjlist为无向图邻接表，Tlist为广度优先生成树的邻接表，Vi为出发点‘／for(k=1;k＜二n;kTlist[kI.firstarc=NULL;/＊初始化＊／v主sited[v=True;fron七＝0;rear二1;/，访问初始顶点，／cq[rear]=v已经访问过的初始顶点入队‘／while(front!=rear){/＊队＃U不空时＊／front=(front+l)％m:v二cq[front/“按照访问次序依次出队‘／p=adjlist[v].firstarc;/＊找v的邻接点＊／while(p!=NULL){if(!v主sited[p一＞vertex{visited[p一＞vertex」二True;rear=(rear+l)％m;s二（structvexnode＊)malloc(sizeof(structvexnode));s一＞next二Tlist(v].firstarc，建立生成树的边的结点‘／Tlist[v].firstarc二s;s一＞vertex二P一＞vertex;｝" ID="3">
          <fptr EndPN="00000160" StartPN="00000159"/>
        </Paragraph>
        <Paragraph CONTEXT="P=P一＞next;" ID="4">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="5">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="6">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="7">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="2.用DFS算法在无向图中找一个环以邻接表为图的存储结构，利用深度优先搜索算法DFS在无向图中找一个环。算法的基本思想是，从给定点v＊出发进行深度优先搜索，在搜索过程中判别当前访问的顶点是否是V4，若是，则找到了一条回路，否则继续搜索。依据此算法思想只需若是，则找到了一条回路，否则继续搜索。依据此算法思想只需(l)另设一个顺序栈cycle，用来记载构成回路的顶点序列，把访问顶点的操作改为将当前访问的顶点入栈。相应地，若从某一顶点出发搜索完再回溯，则做退栈操作，即删去栈cycle顶端的顶点。" ID="8">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="(2）显然，要找到的回路应排除vk,v,v＊的特例，即要求回路的路径长度大于" ID="9">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="1.口声子r业d口d曰7成刊》万irtarra+rua,门hrtA-xrr产另日." ID="10">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="2，因此在判别是否找到回路时，" ID="11">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="(3)算法的目标是找到回路，在找到回路后则结束遍历，故需设置一个布尔变量found，其初值为false，找到回路后置为trueo具体算法描述如下：voidDFSFindCycle(intv,inti,intfound)" ID="12">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="cycle[1二n+11,i二l,found二false;v二v，从v。点出发‘／" ID="13">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="｛visited[v]=true;cycle[i]=v;P二adjlist[v].firstarc:while((p！二NULL)(!found){ifp一＞vexv。)(i&gt;2{/＊找到路径长大于2的回路’／found二true;" ID="14">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="cycle[i+l]=v" ID="15">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="printeycle(i｝else{if(!visited[p一＞vex" ID="16">
          <fptr EndPN="00000160" StartPN="00000160"/>
        </Paragraph>
        <Paragraph CONTEXT="P二A一＞nex七" ID="17">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="图8-17所示的无向图执行上述算法，找到的通过顶点vZ的回路为，z,v3,vvi" ID="18">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
        <Paragraph CONTEXT="vza执仃过程中[1搜索结束后的栈cycle状态如图8-17&lt;b)所示‘妙‘］c〕于(a)(b)(c)图8-17深度优先搜索求环小意图" ID="19">
          <fptr EndPN="00000161" StartPN="00000161"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="和树的遍历类似，图的遍历也是从某个顶点出发，沿着某条路径对图中所有顶点访问一遍。若给定一个无向图G＝（V，E）。vi是顶点集合V&lt;G）中的任一顶点。当G是若从v。出发，沿着G中的某些边可以访问到图中的所有顶点，并且每个顶点仅被访问一次，则这个过程叫图的遍历〔TraversingGraph)。图的遍历算法，是求解图的其他问题的基础。图的遍历比树的遍历复杂。由于图中可能存在回路，故在访问了某个顶点后，有可140能沿着一条回路再次访问到一个被访问过的顶点。因此，在图的遍历过程中，需要标记每个被访问过的顶点，以免多次访问该顶点。图的遍历方法有两种：深度优先搜索法（DFS)和广度优先搜索法（BFS)。卜面分别从搜索的基本思想、算法以及算法的应用角度来讨论。" ID="1">
        <fptr EndPN="00000151" StartPN="00000150"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="151" TITLE="8.4  网的最小生成树" TYPE="Chapter">
      <fptr LogicalPageNum="161" PhysicalPageNum="161"/>
      <Paragraph CONTEXT="在前面我们已经给出图的生成树的概念。这里来讨论生成树的应用。假设，要在n个居民点之间铺设煤气管道。由于，在每个居民点与其余n-1个居民点之间都可能铺设煤气管道。因此，在n个活民点之间，最多可能铺设n(n-1)/2条煤气管道。然而，连通n个居民点之间的管道网络，最少需要n-1条管道。也就是说，只需要n-1条管道线路就可以把n个居民点间的煤气管道连通。另外，还需进一步考虑铺设每一条管道要付出的经济代价。这就提出了一个优选问题。亦即如何在n(n-1)/2条可能的线路中，优选n-1条线路，构成一个煤气管道网络，从而既能连通n个居民$Picture[00000161\00000161_new\0008.jpg]Picture$$Picture[00000161\00000161_new\0009.jpg]Picture$点，又能使总的花费代价最小。解决上述问题的数学模型就是求图中网的最小生成树问题。把居民点看作图的顶点，把居民点之间的煤气管道看作边，而把铺设各条线路的代A/c士口屏井吞八卜目rl；内八4书之斗去狭吝声，小人排txc.r口曰片，～L份人一人一L介一价当作权赋给相应的边，这样，便构成一个带权的图，即网。对于一个有n个顶点的网可以生成许多互不相同的生成树，每一棵生成树都是一个可行的铺设方案。现在的问题是应如何寻求一棵所有边的权的总和最小的生成树。如何构造这种网的最小生成树呢？下面给出这样一种解法：已知一个网，将网中的边按其权值由小到大的次序顺序选取，若选某边后不形成回路，则将其保留作为树的一条边，若选某边后形成回路，则将其舍弃，以后也不再考虑，如此依次进行，到选够，一1条边即得到最小生成树。现以图8-18(a)为例说明此算法。EV表示的，且数组中各边是按权值由小到大的次序排列，如图8-18(b(c)所示。COS7[PYj1Q.尸」［万护［川.凡」$Picture[00000162\00000162_new\0002.jpg]Picture$151611011111411日119121127133,尸犷朴｝号｛考44｝246511we15cnacoc君叮习·pl“1”1“1“1，1‘1口1O1孟1O1" ID="1">
        <fptr EndPN="00000162" StartPN="00000161"/>
      </Paragraph>
      <Paragraph CONTEXT="卫牡幻.P" ID="2">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="（c〕" ID="3">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="《习图8-18网的最小生成树按权值由小到大选取各边就是在数组中按下标K由1到en（图中边数）的次序选取。选前2条边（2，3），（2，4）时均无问题，保留作为树的边；到第3条边（4，3）时将与已保留的边形成回路，故将其舍去。同样继续这样分析，保留（2，6）。舍去（6，4）。保留（5，7），（1，5），（1，6），此时，保留的边数己够（n-1）＝6条边，此时必定将7个顶点全部互相连通了，后面剩下的边（1，2），（5，6）就不必再考虑了。最后得到的最小生成树如图8-17（a）中加粗边所示，其各边权值总和等于80，由离散数学中的图论可以证明，这就是最小生成树了，其权值最小。时，其最小生成树可能有不同的选取方案。实现此算法的关键是，在选取某条边时，应判断是否与己保留的边形成回路，这可用将各顶点划分为集合的办法解决。假设数组tog［1二n］作为顶点集合划分的标志，初佑先0＿六管件的场扦；寸积由当成件丽占早舟主涌的曲！炊粕俞抬署的1当所选顶点u，v是连通的，则将相应位置的tag［连通的点，在初期分别属于不同的集合，赋予不同的数tag【v〕赋予相同的数字，而不连通的点，在初期分别属于不同的集合，字，一旦两个不同的连通分支连通了，则修改tag的值，字。我们以图8-17为例来具体说明。首先选（2，3）（2，4）边，由于是连通的，并且不出现回路。tag［2〕＝1，tag「3〕二tag「4］＝l是同一个集合A；选（6，2）边与A集合连通，tag「6」＝l，再选（5，7）一与集合A不连通，tag〔5」二tag〔7卜2，构成另一个集合B。选（1，5）边与集合B连通，tag［1卜2，此时，集合A＝｛2，3，4，6），集合B＝｛2，7，1｝，当选（l，6）边时，（l，6）与集合A，集合B都连通，并且两个顶点分别属于两个不同的集合A、B，这使得集合A与集合B通过边（1，6）连通。修改集合B中tag的值为1，即将集合B并入集合A。边为n-1条，这就是一棵最小生成树。根据集合标志数组tag的变化过程，很容易判断，选择一条新的边是否构成回路。和tag【vj相同并且均不等于。时，即u、？已“、v后即形成回路，不能选。而当tag［“〕共tag可以选并且不形成回路，说明“、" ID="4">
        <fptr EndPN="00000162" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="分别属于两个不同的集合，此时选择“、v可以将含u假设算法中用到的数据是经过处理的，各参数的含义为：COST[1二川[1二n]是带权数组，用来存放网中顶点之间的权。EV[‘二n(n一，”按权从刁、到大存放排序后的顶点对，即EV[K1·尸！中存放一个顶点，边的另一个顶点存放在EV[KI.P：之中。Tag[ln]：顶点集合划分标志数组。Enu,nn：当前生成树的边数。5材：当前权累计和。网的最小生成树算法描述如下：voidmintree(intCOST&gt;intEV)｛" ID="5">
        <fptr EndPN="00000163" StartPN="00000162"/>
      </Paragraph>
      <Paragraph CONTEXT="工ni七ial(tag民、＝。：sM二。：／＊诸参数初始化＊／k二1;/＊边数累计＊／whi1eEb＜二n-1)(k＜二n{u＝Ev［k〕.P：；v二Ev［k〕。PZ：／＊选一对顶点（u,v)FindCu,T/＊找到含顶点u的集合TFind(v,W/，找到含顶点v的集合Wif(T！二rq){printf(u,v氏浏、十十：／＊最小生成树增加一条边，／SM二sM＋cosT〔u，v〕；MergeCT,W/＊选u,v不会形成环，合并T,W集合，并修改tag｝k十＋：／，找下一条边＊／｝" ID="6">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="iftEiume&lt;n-1)printf(&quot;Thereisnotamintreeelse" ID="7">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(SM" ID="8">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
      <Paragraph CONTEXT="）由算法可知图g-ig的最小生成树的结果是：(2,3(2,4(2,6(5,7(1,5(1,6)0" ID="9">
        <fptr EndPN="00000163" StartPN="00000163"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="154" TITLE="8.5  最短路径" TYPE="Chapter">
      <fptr LogicalPageNum="164" PhysicalPageNum="164"/>
      <Paragraph CONTEXT="在一个赋权有向图上寻找最短路径问题，也是图应用的一个重要问题。假定图8-19中的有向图‘_(V,E）是一个航空图，V的每一顶点表示一个城市，E中的每条弧、～w表示从城市v到城市w的航线，弧vow上的标号代表从v城飞到w城所需要的时间。要寻找由该航空图上一给定城市到另一城市所需要的最短飞行时间，下面，我们讨论求解单源最短路径问题的贪心算法，该算法也称之为戴克斯特拉(Dijkstra）算法。设有向图G二（V,E)，其中，V=CL2,…,n)。用cost表示G的邻接矩阵，cost[i1[j]表示有向边（CL,J)的权，若不存在有向边（(I,f)，则COSt[i1[J]的权为无限大（。）。令S是一个集合，其中的每个元素表示一个顶点，从源点到这些顶点的最短距离己经求出。令顶点v为源点，集合S的初态只包含顶点数组dist记录从源点到其他各顶点当前的最短距离，其初值为dist[i1=cost[vo1[i]，其中i=2,…," ID="1">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="n。从S之外的顶点集合V-S中选出一个顶点w，使dist[w」的值最小。于是，从源点到达w只通过S中的顶点，我们把w加入集合So个顶点，的距离：从原来的disc[v］和dist[w1+cost[w1[v］中选择较小的值作为新的dist[v1。重复上述过程，直到S中包含V的全部顶点。到V中其余各顶点的最短路径。对图8-19所示的带权有向图，应用Dijkstra算法，从源点v：出发到达各顶点的最短路径如图8-20所示。" ID="2">
        <fptr EndPN="00000164" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="as／一刃一＼(a)(b)图8-19求解单源最短路径问题示意图图8-20最k径对图8-19的具体执行过程为：初始时，S={2dist[11_，,dist[31=15,dirt[41_co,dist[51=10&gt;dist[61_。第一遍处理时，w=2使dist[5］最小，于是把5加入S。然后，调整dist中从源点到其余各顶点的距离：dist[3」二15，为次小，将3力［1入Sodist[41=cost[21[31+cost[31[41=15+15=30，经中间点3oS={2,5,3,4}，同理，dist[11=cost[21[31+cost[31[11=35,S={2,5,3,4,1}，由于2没有一条到6的路径，由此我们给出最短路径算法描述如一下：voidshortpath(cost(1,distpathS,v｛for(w二1：w＜＝n；w＋＋）（dist[w〕二cost[v[w];/＊最短路径初始化值＊／if(cost[v[w]&lt;max)path[w]=vpath记载当前最短路径＊／｝S二〔vVnum二1;到达点集合S和到达点S个数初值＊／while(Vnum&lt;n-1){/＊最后一点己无选择余地，／Wm二max;u二v;for(w二1;w＜二n;w{if!w工Ns）＆＆（dis七［w」＜wm））｛u二w;Wm二dist〔w〕：｝／＊找最小dist[w]S二S+[uVnumu为找到最短路径的终点＊／for(w二1;w＜二n;wif(!wINS)(dist[u]+cost[u][w]&lt;dist[wdist[w］二dist[u]+cost[u](w];/＊调整非S集path[w〕二u;/‘调整非S集各点最短路径＊／｝" ID="3">
        <fptr EndPN="00000165" StartPN="00000164"/>
      </Paragraph>
      <Paragraph CONTEXT="Vnum" ID="4">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="5">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="｝voidPrintPath(dist[1,path[J,S,v。，)｛" ID="6">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="for(i二1;i＜二n;i" ID="7">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="if(iINS){" ID="8">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="k二i;" ID="9">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="while(k!=v){" ID="10">
        <fptr EndPN="00000165" StartPN="00000165"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(k);k二path[k]；/＊通过找前趋点，反向输出最短路径‘／｝" ID="11">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(k" ID="12">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(dist[i;" ID="13">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="14">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="else{" ID="15">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(i,v" ID="16">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="printf(`max')," ID="17">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="18">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="｝容易看出，算法shortpath的时间复杂度为O&lt;n，空间复杂度为O(n)a" ID="19">
        <fptr EndPN="00000166" StartPN="00000166"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="156" TITLE="8.6  拓扑排序" TYPE="Chapter">
      <fptr LogicalPageNum="166" PhysicalPageNum="166"/>
      <Paragraph CONTEXT="在现代化管理中，人们常用图来描述和分析一项工程的计划和实施过程：在学校接触最多的是教学计划及课程的安排与实施。众所周知，一个大的工程常常被划分成许多小的子工程，这些子工程被称为活动（activity)。显然，只要依次完成这些子程序，整个工程也就完成了。例如，假设计算机专业的学生，必须学完如表8-1所示的课程才能毕业。表8-1计算机专业学生必修课程课程缩写课程名称先修课程导论计算机导沦无线代线性代数无离散离散数学导论、线代PASCALPASCAL语言程序设计导论CC语言程序设it'PASCAL汇编汇编语言程序设计导论DS数据结构PASCAL,C、离散CS编译原理汇编、DSDB数据库DSOS操作系统汇编、DS在这种情况下，工程就是完成给定的学习计划，而活动就是学习一门课程。有些课程是基础课，不需要先修其他课程，如“计算机导论”。还有一些课程则必须在先学完某些先修课程之后才一能开始学习，如要学习“操作系统”之前，必须先修“数据结构”和“汇编语言”。也就是说，某课程的先修课程是学习该课程的先决条件，于是，先决条件定义了各课程之间的先后关系。确定这种先后关系，对于当前实行“学分制”大学教学，学生有目的的选课是一｝·分有意义的。课程之间的先后关系可以用有向图表示。如图s-21所示。" ID="1">
        <fptr EndPN="00000167" StartPN="00000166"/>
      </Paragraph>
      <Paragraph CONTEXT="／尹J图8-21学生选课的先后关系AOVfw9图g-21中，顶点表示课程，有向边表示先决条件，即当且仅当图中边＜&lt;l,J＞表示l课程是了课程的先决条件。一般情况下，这样的有向图可以用来表示某工程的施工图，或产品的生产流程图，或某系统的执行流程图，有向边则表示子工程或子系统之间的优先关系。我们把顶点表示活动，边表示活动间的先后关系的有向图称为顶点活动的网(ActivityOnVertexnetwork)，简称为AOV网，图8-21就是表S-1的AOV网。在网中，若从顶点i到顶点j有一条有向路径，则称i是的前驱，J是i的后继；若（i,j)是网中一条弧，则i是J的直接前趋，j是i的直接后继。拓扑排序（TopologicalSort）是对AOV网构造一个线性序列：（.二v····v、v.二），使所有优先关系＜vv，在序列中得以体现，即V‘排在V之前。即V，和Vk.V＊和1之,原没有弧，但经拓扑排序之后，V‘和Vk.V＊和v之间形成了一个有序的路径。V;LV、之前，V＊在V之前，把具有上述特性的我们来讨论拓扑排序的性质。其一：拓扑有序序列不一定唯一性（见图8-22所示）。" ID="2">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT="图a-zaAov网%r意图" ID="3">
        <fptr EndPN="00000167" StartPN="00000167"/>
      </Paragraph>
      <Paragraph CONTEXT=".、）1，vs，v6，vZ，v4，v，，、，3，vs" ID="4">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT=".Vp,VI,VZ,VV7,Vq,V，,Vt" ID="5">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="其二：AOV网不一定都有拓扑序列。在AOV网中，任何部分的子图不能有回路，是AOV网存在拓扑序列的前提。因为存在回路，意味着某项活动应以自己为先决条件。显然，这是不可能的。我们称在AOV网中存在回路的现象为死锁现象，它将使程序的流程出现一个死循环。判断AOV网中是否存在有向回路，也就是判断AOV网所描述的工程是否可行，即AOV网中是否有拓扑有序序列存在。对AOV网进行拓扑排序的方法和步骤如F:&lt;1)在网中选一个没有前驱顶点的点，且输出。" ID="6">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)从网中删去该顶点，且删去以该顶点为尾的所有有向边。" ID="7">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）重复执行上述步骤。最后的结果是：全部顶点都输出了。或网中剩余的顶点中有前驱顶点，不能再继续执行了，前一种情况说明工程是可行的，后一种情况则说明网中有回路，工程是不可行的。例如，按上述方法构造图8-22的AOV网的拓扑有序序列，具体实施步骤如图8-230" ID="8">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="几目〔句" ID="9">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="O" ID="10">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="（动0000o一一刃0000ielf!11t1(1J下面用邻接表作AOV网的存储结构，讨论拓扑排序算法的实现。为了便于考察每个顶点的入度，在邻接表的每个分量中增设一个入度域，以指示各个顶点当前的入度值。每个顶点的入度域的初值，" ID="11">
        <fptr EndPN="00000168" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="158$Picture[00000169\00000169_new\0001.jpg]Picture$首先，选取没有前驱顶点Vfl，输出Vg，然后将弧＜VKrVr&gt;.&lt;VgrV;＞从网中删去，得图8-24(a)。这时V，没有前驱，选取V，并输出同样删去＜VIrV2&gt;、&lt;VI,Vq&lt;v-V：&gt;·&lt;VlrVg＞四条弧，得到图8-24(h)。依此方法选，。并且输出，删除＜" ID="12">
        <fptr EndPN="00000169" StartPN="00000168"/>
      </Paragraph>
      <Paragraph CONTEXT="v。,vq&gt;,&lt;y6,y5&gt;，得到图8-24(c)。再选v,，删除＜vZrvq＞得图8-24(d)。选，7r删除＜v：,vg&gt;.&lt;v7rvs＞得到图8-24(e)。选vq,vvs，最后形成一个拓扑有序序列：VgrVlrVbrVZrV7ryqrVgrVS在算法中找入度为零的顶点，只要对邻接表中的入度域扫描，查看哪个顶点的入度，月floff'.l日哭，了桩亿雷有妇拢裕一令毅E}h方11117rhTrXiAIh委't!iTdSk'觉亡;3i;j=rat为零即可。但为了避免重复扫描，扑排序之前，只需对邻接表扫描一遍，将所有入度为零的顶点序号，都存入这个辅助空间，以后每次选入度为零的顶点，就可直接从这个辅助空间中取之。同时，在拓扑排序过程中，一旦出现新的入度为零的顶点，也存入这个辅助空间。利用入度值为一1代替册I！除，而且可以不破坏原来的AOV网。这里需要说明的是，存放入度为零的辅助空间，是利用入度是零的入度域存放链指针。为减少查找，把入度为零的顶点串链起来，供挑选使用，Ghead是此链的链首，拓扑排序算法的描述如下：voidtopsoxt(adjlist(1)｛Ghead=0:m二0:m记录顶点个数，／for(i=1;i＜二n;iif(adjlist[iI.vex二二0)tadjlist(il.vex=Ghead／建立入度为零的顶点链，链头为Ghead" ID="13">
        <fptr EndPN="00000169" StartPN="00000169"/>
      </Paragraph>
      <Paragraph CONTEXT="Ghead二i;｝orhile(Ghead0)j=Ghead:q=adjlist[jJ.nex七；printf(jm二m+1;输出入度不零的项点：并累计一计数‘／while（q！二P1ULL){" ID="14">
        <fptr EndPN="00000170" StartPN="00000169"/>
      </Paragraph>
      <Paragraph CONTEXT="k二q一＞vex;adjlistkJ.vex二adjlis七［kI.vex-1;&lt;j,k&gt;为弧，J输出后k顶点入度减1if(adjlist[kJ.vex二二0)adjlistlkI.vex二Ghead;Ghead二k;新入度为零顶点入链＊／）q二q一）next:/＊找F一条弧，／｝" ID="15">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="16">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="if(m&lt;n)printf(&quot;Thenetworkhasacycle);｝分析上述算法，设AOV有n个顶点和。条边，初始建立入度为0的顶点链并打印输出，执行时间为O(n)；排序过程中，若AOV网无回路，修改入度时间和每一边表结点被检查，执行时间是O(n+e)。所以，总的时间复杂度为O(n+e" ID="17">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="160" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="170" PhysicalPageNum="170"/>
      <Paragraph CONTEXT="1.判断题" ID="1">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)用邻接矩阵表示法存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中结点个数有关，而与图的边数无关。" ID="2">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)邻接表只能用于有向图的存储，而邻接矩阵对于有向图和无向图的存储都适用。" ID="3">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）任何有向网络（AOV网）拓扑排序的结果是唯一的。" ID="4">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）有回路的图不能进行拓扑排序。" ID="5">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(5)存储无向图的邻接矩阵是对称的，因此只要存储邻接矩阵的下（或上）三角部分就可以了。" ID="6">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(6）连通分量是无向图中的极小连通子图。" ID="7">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="(7)强连通分量是有向图中的极大强连通子图。" ID="8">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="2.设无向图G中顶点数为n，则图G最少有（）条边，最多有（）条边。若G为有向图，有n个顶点，则图G最少有（）条边，最多有（）条边。具有n个顶点的无向完全图，边的总数为（）条，而在n个顶点的有向完全图中，边的总数为（）条。" ID="9">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="160" ID="10">
        <fptr EndPN="00000170" StartPN="00000170"/>
      </Paragraph>
      <Paragraph CONTEXT="3.己知有向图G如一F所示。" ID="11">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)分别给出每个顶点的入度与出度。" ID="12">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）画出相应的邻接矩阵。" ID="13">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）画出相应的邻接表。" ID="14">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)画出相应的逆邻接表。&lt;5）画出强连通分量。" ID="15">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="4.已知无向图G如下所示。" ID="16">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）画出相应的邻接矩阵：" ID="17">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）画出相应的邻接表。" ID="18">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="5.证明：n个顶点的无向完全图的边数为n(n-1)/20" ID="19">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Picture URL="00000171\00000171_new\0013.jpg">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Picture>
      <Paragraph CONTEXT="6.设无向图G如下所示。" ID="20">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）画出相应的邻接矩阵。" ID="21">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）画出相应的邻接表。" ID="22">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）画出相应的邻接多重表。" ID="23">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）从A出发的“深度优先”遍历序列。" ID="24">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）从A出发的“广度优先”遍历序列。" ID="25">
        <fptr EndPN="00000171" StartPN="00000171"/>
      </Paragraph>
      <Picture URL="00000172\00000172_new\0001.jpg">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Picture>
      <Paragraph CONTEXT="7.对于n个顶点的无向图，采用邻接矩阵表示，回答下列有关问题：:1)图中有多少条边？:2)任意两个顶点i和是否有边相连？" ID="26">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）任意一个顶点的度是多少？" ID="27">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="3.试画出下图所示的有向图，从顶点A出发的" ID="28">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）广度优先生成树：" ID="29">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）深度优先生成树。" ID="30">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="9.已知某图G的邻接矩阵为01l001" ID="31">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）由邻接矩阵画出相应的图G‘" ID="32">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Paragraph>
      <Picture URL="00000172\00000172_new\0021.jpg">
        <fptr EndPN="00000172" StartPN="00000172"/>
      </Picture>
      <Paragraph CONTEXT="（2）再画出图G的邻接多重表.$Picture[00000173\00000173_new\0001.jpg]Picture$（］）画出图G的一十字链表结构；" ID="33">
        <fptr EndPN="00000173" StartPN="00000172"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）写出图G的两个拓扑序列。" ID="34">
        <fptr EndPN="00000173" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="11.试指出下图中从顶点A到顶点C的最短路径。原书空白页第rJ章查找查找（Search）又称为检索，是数据结构中最常用的基本操作之一。查找就是在某种数据结构中找出满足给定条件的结点。若从数据结构中找到满足条件的结点，则称查找成功，否则称查找不成功。查找通常是在查找表中进行的，一个查找表（SearchTable)是指由同一类J的数据元素（或记录）组成的集合。每个记录可以由一个或多个数据项构成。用以区别查找表中各个记录的数据项称为关键字（Key)，由于同一查找表可以具有不同的作用，到底选择记录中那个数据项作为关键字，只能根据具体情况而定，本章只研究基于关键字值的查找。在日常生活中，“查找”的事情经常发生，例如，为了获得某单位的电话号码，需查找电话号码簿；为了了解某英文单词的词意，需要查找英文字典等等。在计算机中，查找主要分为静态查找、动态查找和散列查找。静态查找（StaticSearch）主要是指查询某个“特定的”数据元素是否在查找表中，或检索某个“特定的”数据元素的各种属性；动态查找（DynamicSearch）是指在查找过程中，同时插入查找表中不存在数据元素，或者从查找表中删除己存在的某个数据元素；散列查找则是利用哈希（Hash)函数，通过计算求取待查元素的存储地址。由此可见，用于查找的方法很多，那么，衡量一个查找算法的好坏标准是什么？通常用算法的乎均查找长度（AverageSearchLength，简记ASL）来表示，即确定某个元素在结构中的位置所进行的比较次数的期望值，作为判断查找算法效率的重要指标。设某数据结构一共有n个元素，则查找此结构中某一元素的平均查找长度为：艺P;C;理二1ASL=其中，尸，为查找第1个元素的概率，C，为找到第i个元素所需的比较次数。" ID="35">
        <fptr EndPN="00000175" StartPN="00000173"/>
      </Paragraph>
      <Paragraph CONTEXT="本章将介绍几种基本的查找方法：顺序查找、二分查找、分块查找和Hash查找及二叉排序查找等。" ID="36">
        <fptr EndPN="00000175" StartPN="00000175"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="图是比树更常见的非线性数据结构。关于对图的研究与应用，越来越受到人们的重视。一方面在于许多问题直接与图有关，例如网络分析，交通运输、管理与集成电路的淆一乃屯鳖甲＿－亡二下‘布，六心二斤弓夕口；卜下二.七1日tiJ.nEAPl4rL‘口」fFil，一LIvmi，L1.L－一～扮，布线等等：另一方面有许多实际问题，如果间接地用图来表示，处理起来比较方便，例如工作的分配，工程进度的安排、课程表的制订，关系数据库的设计等等。由于这些技术领域，都把图结构作为解决问题的主要数学手段使用，因此，如何在计算机中表示和处理图结构，就是计算机科学需研究的一项重要课题。" ID="1">
      <fptr EndPN="00000141" StartPN="00000141"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="165" TITLE="第9章  查找" TYPE="Chapter">
    <fptr LogicalPageNum="0" PhysicalPageNum="0"/>
      <div ORDERLABEL="165" TITLE="9.1  顺序查找" TYPE="Chapter">
      <fptr LogicalPageNum="175" PhysicalPageNum="175"/>
      <Paragraph CONTEXT="顺序查找又叫线性查找，这是一种最简单的查找方法。顾名思义，这种方法是从表于K的结点，则查找失败。顺序查找方法既适用于线性表的顺序存储结构，也适用于线性表的动态存储结构，在此我们给出以数组作为存储结构的顺序查找。StructSSTableElemtypekey;/＊关键字项＊／／＊其他项＊／｝；intsequen-search(StructSSTabler[n+11,elemtypeK)｛r[01.key二K:设置监视哨‘／i二n;/＊指示器变量赋初值‘／while(r[i].key！二K)i一；" ID="1">
        <fptr EndPN="00000176" StartPN="00000175"/>
      </Paragraph>
      <Paragraph CONTEXT="if(i二二0)printf('SearchUnsuccessful!&quot;else" ID="2">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="returni;" ID="3">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="｝算法中监视哨r[01的作用是为了在WHILE循环中，省去每次判定防止下标越界的条件i.l，从而节省比较的时间。当i=0，这意味着查找失败。如果查找由前端开始找起，则“监视哨”应设置在；[n+11处。说明：在本章中，顺序表均采用数组存储.为了表述方便，0号单元不用或作特殊处理，如上述算法中，r(01设置为监视哨，数据元素从1号单元开始存储.算法分析，对于含有n个结点的线性表，结点的查找在等概率的前提下，即P1，对成功的查找，平均查找长度ASL为：月" ID="4">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="艺p;xC;" ID="5">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="1=iASL=＿工" ID="6">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="(n+(n-1）＋…＋1）1＊C二n-i+1*l" ID="7">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="n12" ID="8">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
      <Paragraph CONTEXT="(n+1)" ID="9">
        <fptr EndPN="00000176" StartPN="00000176"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="167" TITLE="9.2  二分查找" TYPE="Chapter">
      <fptr LogicalPageNum="177" PhysicalPageNum="177"/>
      <Paragraph CONTEXT="二分查找（BinarySearch）也叫折半查找，是一种效率较高的线性有序表的查找方法。顾名思义，该方法是将表一分为二，查找可不必从表的一端开始逐个比较，而采用跳跃的方式，从表的中间开始查找。这里需要强调的是：要进行二分查找，线性表中结点必须己按关键字值递增（或递减）次序排列，并且线性表应采用顺序存储结构。1的单元，第1个数据元素存放在下标为1的单元）是一个递增有序的线性表，中间位置的数据元素的关键字为；［mid〕又即。这里，用tow和hlgh分别指示待查元素所在范围的下界和上界，m边指示中间位置，即胡id＝L（Iow＋high）／2」。二分法查找的过程是：先用给定值K与线性表中间位置的关键字r〔m必〕.切相比较，若相等，即天二二；〔m“」切，则查找成功。否则这个中间把线性表分成两个子衣：【1二itl－l］和：〔mid＋l二1：］，进一步分析给定值K.与中间位置结点的大小关系，如果天心.〔mid〕.ke，，说明二分查找应继续在前半区间；〔1二mid－l］中继续进行，也就是说被查结点有可能在表的前半部，如果心戏爪润滋说明二分查找应在后半区间；【m诀1二司中进行，即被查结点有可能在表的后半部，这样经过一次关键字比较，就缩小一半的查找区间，如止幻进行下去，直到找到K值或表中不存在K值" ID="1">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="为止。假设被查找的有序表中关键字序列为：（05，07，11，13，19，21，38，54，71，74，80，88，90，91，98）当给定K值为71时，10、，＝l，high二15，则mid＝8。进行二分查找的过程为：［050711131921385471748088909198〕tt全10甲刃jdhj劝由于K＞；【mid〕.key，故在右边子表继续查找，此时Iow月，high＝7，则mid＝4［71748088909198］ttt了。甲耐dhj动" ID="2">
        <fptr EndPN="00000177" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="同样分析，由于K＜：【mid〕虎即10罕耐dhigh由于K二二r[mid].key，所以查找成功。上述二分查找过程算法如下：intBinarySearch(structSSTablest[n+1J,elemtypeK)（low二1;high二n;‘1确定区间＊／while(low＜二high){mid二（low+high)/2:if(K二二s七［midkey)/＊找到待查元素＊／returnmid;elseif(K&lt;st[m主d].key)/＊继续在前半区[i]进行查找＊／high=mid-1:" ID="3">
        <fptr EndPN="00000178" StartPN="00000177"/>
      </Paragraph>
      <Paragraph CONTEXT="elselow二mid+1;/＊继续在后半区间进行查找＊／｝" ID="4">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="return0;" ID="5">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="｝现在来分析二分查找的算法，二分查找过程可用二叉树来描述。我们把当前查找区间的中间位置上的关键字作为根结点，前半区间和后半区间中的关键字分别作为根的左子树和右子树，由此得到描述二分查找的判定树。上例中具有13个关键字的判定树如图9-1所示。由前述可知：要在表中找到71，需要经过的结点有54.88,74，最后到71，共比较四次。由此可见，二分查找的过程，恰好是走了一条从判定树的根结点到被查结点的一条路径，而比较的次数恰好是树的深度。我们借助于二叉判定树，很容易求得二分查找的平均查找长度。假设表长为。，树的深度h=1og2(n+1)，所以平均查找长度ASL二yPic＝立叉jxZj‘（按层深统计比较次数，展开有：" ID="6">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="168" ID="7">
        <fptr EndPN="00000178" StartPN="00000178"/>
      </Paragraph>
      <Paragraph CONTEXT="nXASL=1+2X2+3X2z+…+hX2一‘①" ID="8">
        <fptr EndPN="00000179" StartPN="00000179"/>
      </Paragraph>
      <Paragraph CONTEXT="、＿＿、／，.2.Iv，3。…，‘丫，内r泛、玩XASL二2＋2X22＋3X23＋’二＋hXZI，②式一①式，得到二2人X（h-1）＋1在满二叉树时n＝Zh-1，h＝109（n＋1）最后得出ASL＝―tog扭＋l）一1八n较大时常写为ASL二109（n＋1）一1一个简单的二分查找的C语言程序如下所示。＃include＜stdio.h＞林defineMAX续0＃define七ruel＃definefa1SeDintk，n；" ID="9">
        <fptr EndPN="00000179" StartPN="00000179"/>
      </Paragraph>
      <Paragraph CONTEXT="int10w，mid，hiqh：intsucCeSS：intr［MAx］：" ID="10">
        <fptr EndPN="00000179" StartPN="00000179"/>
      </Paragraph>
      <Paragraph CONTEXT="voidinPut＿int（）｛inti：Printf（’‘pleaseiripu仁num（int）；’‘）：scanf（“％d。，＆n）：printf（“Pleaseinputinteger：“）；for（1二1；1＜＝n：1＋＋）scanf（，飞d二，＆r〔1］）；priritf（‘pleaseinputsearch（KE丫）二’）；scanf（“％d’·，＆k）：｝.－一－一－一－一－一－－，J－－勺－－‘一－－，.一一－.，.‘－－.十－一－门，一－一一－－一一－－一" ID="11">
        <fptr EndPN="00000179" StartPN="00000179"/>
      </Paragraph>
      <Paragraph CONTEXT="、voidPrint＿int（）｛inti：printf（”outputresul七：’）：for（1二1；1＜二n：1＋＋）voidbinsearch()｛success二false;low=1:high二n;while((low＜二high)(!success)){mid二（low+high)/2;if(k二二r[mid" ID="12">
        <fptr EndPN="00000180" StartPN="00000179"/>
      </Paragraph>
      <Paragraph CONTEXT="success=true:elseif(k&lt;r[mid" ID="13">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="high二mid-1:elseif(k&gt;r[mid" ID="14">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="low=mid+1;｝" ID="15">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="｝voidmain()｛" ID="16">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="input_int(print,intbinsearchO:printf(^KEY2d^,kif(success)printf(&quot;searchSUCCESS!\n&quot;elseprin七f('searchfail!\n&quot;｝运行结果：" ID="17">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="Pleaseinputnum(int):5Pleaseinputinteger:47111828Pleaseinputsearch(KEY）二11Outputresult:47111828KEY=11searchSUCCESS!" ID="18">
        <fptr EndPN="00000180" StartPN="00000180"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="170" TITLE="9.3  分块查找" TYPE="Chapter">
      <fptr LogicalPageNum="180" PhysicalPageNum="180"/>
      <Paragraph CONTEXT="分块查找又称索引顺序查找，它是一种性能介于顺序查找和二分查找之间的查找方»o式。分块查找要求把线性表分成若干块，每块中的元素存储顺序是任意的，但块与块之间必须按关键字人小有序，即前一块中的最大关键字值小于后一块中最小关键字值。此外，还需要建立一个索引表，索引表中的一项对应线性表的一块，索引项包括两项内容：关键字项（其值为相应块的最大关键字值）和项指针（存放指向本块第一个元素的指针）。显然索引表是按关键字值递增顺序排列的有序表。满足上述条件的线性表称为分块有序表。例如，线性表中的关键字为：(09,22.12,14,35,42,44,38,48,60,58,47,78,80,77.82)，则可将其分成四块，如图9-2所示。同时，在索引表中记录每一块的起止地址，如图9-3所示。" ID="1">
        <fptr EndPN="00000181" StartPN="00000180"/>
      </Paragraph>
      <Paragraph CONTEXT="：隆姆耸日" ID="2">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="IGW" ID="3">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="）J，9为分块查找法的查找过程分为两步进行。一首先确定待查找的元素属于哪一块，即查找其所在的块，然后在块内查找该元素，由于索引表是递增有序的，采用二分查找法进行；而块内元素个数较少，采用顺序法在块内查找，不会对执行速度有太大影响。例如：若给定值k=S8，到第三块中查找。因为44&lt;58&lt;60，它借于二、三块之间，即大于第.二块的最大值44，并且小于第三块的最大值60，进一步在线性表的下标为[9二121之间查找k值。" ID="4">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="分块查找的算法如下：" ID="5">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="structZndexeeTable" ID="6">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="elemtyF〕ekey:" ID="7">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="it1ow:" ID="8">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="intr,igY" ID="9">
        <fptr EndPN="00000181" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="｝；／＊存放块的索引表＊／int.Blocks^·_rch(structSSTatlebs[n+lj,structIndex_TableIr;de，.lbr,r,elemtypeK)了‘分块杏找，介找成功后返回K在线性表中的序号，查找不成功时，返回ot*/｛ilow=1:ihigh二bn;found二FALSE;/＊二分查找索引表‘／while(Glow＜二ihigh)&amp;＆(!found{imid二（ilow+ihigh)/2:if(K二二工ndex[imid].keys{ihigh二imid-1;found二TRUE:" ID="10">
        <fptr EndPN="00000182" StartPN="00000181"/>
      </Paragraph>
      <Paragraph CONTEXT="｝elseif(K&lt;Index[i二id].key)ihigh=irnid-1;elseif(K＞工ndex[imid].key)ilow二imid+l;｝IFGlow&lt;bn){K小于表内最大值＊／s＝工ndex[ilow].low;/＊索引表中定块始址＊／h二工ndex［土工ow].high;/＊索引表中定块未地址＊，｝／＊在块内顺序查找，s,h分别为下界和＿L界，／wh立les&lt;h)(bs[s].key！二Ks二s+1;if(bs[s].key二二K)return(i)；/＊查找成功＊／elsereturn(O/‘查找不成功‘／｝由于分块查找实际上是进行了两次查找过程，则整个算法的平均查找长度是两次查找的平均查找长度之和。若以二分法查找块，以顺序法查找表，则分块查找的一平均查找长度为：ASLnIk=ASLh+ASL假设线性表中有n个元素，将其分割成bn块，每块包含：个元素，即bn二n/s。如果每个元素的查找概率相等，则每块的查找概率为1/bn，块内每个元素的查找概率为1/soASLk七logZ(bn+1）一1+(s+1)/2尧log,.&lt;n/s+l)+s12若以顺序查找确定块，则分块查找的平均查找长度为：ASLn(bn+l)/2+(s+1)/2＝（‘2＋2‘＋n）／25172由此可见，分块查找算法的效率介于顺序查找和二分查找之间。" ID="11">
        <fptr EndPN="00000183" StartPN="00000182"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="173" TITLE="9.4  树表的查找" TYPE="Chapter">
      <fptr LogicalPageNum="183" PhysicalPageNum="183"/>
      <Paragraph CONTEXT="前面讨论的查找方法主要适用于具有固定大小的表，这类查找属于静态查找，如果表的大小可以变化，即能在其上方便地进行插入或删除元素，则应寻求相应的动态查找算法。树表的查找就属于动态查找。" ID="1">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="i.二叉排序树回顾己经讨论过的二叉排序树，它是由一个相互间可进行比较的数据序列构造得到fl：一l7flk，立f7-i业%Yfai:iJU111St全.1\7.IfR；(Y士些ririi下=币1丢复r.于1布r'寻-的。在二叉排序树上进行插入或删除，由二叉排序树的定义可知，二叉排序树本身也可以看成是一个有序的结构，因此在二叉排序树上进行查找，与二分查找类似，都是一个逐步缩小查找范围的过程。若查找成功，是从根结点出发，走一条从根到待查结点的路径：若查找不成功，则是从根结点出发，走一条从根到某个叶子结点的路径。二叉排序树的查找过程，实质上也是二叉排序树的插入过程，找不到则插入其中。假设以二叉链表作为二叉排序树的存储结构，其定义与算法如下：" ID="2">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="structBSNodeelemtypekey;structBSNode*lchild,*rchild;/＊左、右指针＊／｝；structBSNode*Search-bstree(structBSNoderoot,elem七ypeK)／，在根指针为roo七的二叉排序树上查找关键字等于K的结点，若存在，则返回指向该结点的指针；否则，生成新结点并插入到二叉排序树中。，／" ID="3">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="（P二root;while(p！二NULL)查找，A是查找指针，q跟随其后为插入服务，／" ID="4">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="if(K&lt;p一＞key)" ID="5">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="q二p：" ID="6">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="P二P一＞lchild;｝elseif(K＝二P一＞key)return(p)；/＊查找成功‘／elseif(K&gt;p一＞key)" ID="7">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="q=P" ID="8">
        <fptr EndPN="00000183" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="P二P一》rchild;｝＊查找不成功，生成新结点并插入到二叉排序树中＊／；一＞key二K;；一＞lchild二NULL:s一》rchiI.d二NULL:f(root二二NULL)" ID="9">
        <fptr EndPN="00000184" StartPN="00000183"/>
      </Paragraph>
      <Paragraph CONTEXT="o。匕＝s:＊空树，直接插入＊／elseif(K&lt;q一＞key)" ID="10">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="x一＞lchild二s:" ID="11">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="=1seif(K&gt;q一＞key)" ID="12">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="江一＞rchild二s;" ID="13">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="｝在一般情况下，此算法的时间复杂度为。(login)，但在某个确定的问题中，ASL与树的形状有关。对于含有同样一组结点的表，由于结点插入的先后次序不同，所构成的二叉排序树的形态和深度也不同。容易看出：在二叉排序树上进行查找时的平均查找长度和二叉排序树的深度及形态有关，图9-4所示的树是按照如下插入次序构成的：40,17,57,09,53,22,89.28,15,45。其平均查找长度ASL六(1*1+2*2+3＊4+4*3，二2.9图9-4生成的二义排序树图9-5所示的树是按照如下插入次序构成的：15,57,09,53,89,45,40,28,22,17，其平均查找长度，SLi(1*1+2*2+3*2+4*1+5*1+6*1+7*1+8*1)X4.1由此可以得出这样的结论：‘二叉排序树在动态查找与构造时，由于输入顺序的差别，使得二叉树的形状不一样，平均查找长度AS乙差别也很大。为了得到较好的平均查找长度ASL，需对二叉排序树进行分析。从图9-4和图9-5这两棵形状不同的排序树能直观看到，如果在关键字不断插入过td:kzFhhl7G.lUfiL,S.St4_t=kWtirf，,nds7Eiz4扮杯Ft3stt协h.fv加婴rh千fi入程中，使树的形状始终保持比较匀称，则平均查找长度相对较小；反之，如果由于插入一系列的关键字而使二叉排序树沿某一分支增长，则平均查找长度相对就大。因此，我" ID="14">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="们希望二叉排序树在构造过程中，始终保持比较匀称的树形。这就引出了一个新的概念" ID="15">
        <fptr EndPN="00000184" StartPN="00000184"/>
      </Paragraph>
      <Paragraph CONTEXT="澎’" ID="16">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="／必’尸’" ID="17">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="O。图9-5生成的另一形状二：又排序树2平衡二叉树平衡二叉树（BalancedBinaryTree）又称AVL树。其定义为：对于二叉树中的每个结点，其左子树深度为h，右子树深度为hH，若｝hL-hRI毛1，则称该二叉树为平衡二叉树，反之称为不平衡二叉树。我们把二叉树中每个结点的左子树的深度，减去右子树的深度（h-hR）定义为该结点的平衡因子（BalanceFactor)，因此，平衡二叉树中" ID="18">
        <fptr EndPN="00000185" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="1,0，一1。当一棵二义树是1「衡二叉树时，其平均查找长度ASL较小。图9-4是一棵平衡二叉树，而图9-5是一棵不平衡二叉树。在图9-4和图9-5中，每个结点旁边的数字为该结点的平衡因子。我们在构造二叉排序树的过程中，希望在动态查找过程中永远保持其平衡性（均称性），以便获得较好的ASL，但又不能限制输入的次序，只能改造二叉排序树，即动态调整二叉排序树。在构造平衡的二叉排序树过程中，每当插入一个结点时，首先检查是否因插入而破坏了这种平衡性，若是，则找出其最小不平衡子树，在保持排序树性能不变的前提下，调整树中各结点间的连接关系，以达到新的平衡。一般情况下，假设由于在二叉排序树上，插入结点而失去平衡的最小子树的根结点为A，则失去平衡后进行调整的规律，可归纳为下列4种情况：$Picture[00000186\00000186_new\0001.jpg]Picture$、飞八$Picture[00000186\00000186_new\0004.jpg]Picture$$Picture[00000186\00000186_new\0005.jpg]Picture$、." ID="19">
        <fptr EndPN="00000186" StartPN="00000185"/>
      </Paragraph>
      <Paragraph CONTEXT="囚（心插入前（b〕插入后（日调整后图9-6LL?if9？操作示:e:图图9-6(a）为插入前的平衡子树，B。,B＊和A＊的子树高度均为h(h&gt;0，若h，则它们均为空树）,A结点和B结点的平衡因子分别为1和。。(b）为在B的左子树BL上插入一个新结点，使以A为根的子树成为最小不平衡子树的情况。(C)子树的情况，调整规则是：将A的左子树B向右上旋转代替A成为根结点，将A结点向右F旋转成为B的右子树的根结点，而B的原右子树B；则作为A结点的左子树。此调整过程需要修改三个指针，如图（c)中的箭头所示：&lt;1)将原来指向A结点的指针修改为指向结点B;(2）将B的右指针修改为指向结点A;(3)将A的左指针修改为指向B的原右子树的根结点。另外，还需要修改A和B结点的平衡因子。过调整后仍然保持了二叉排序树的性质不变。IO7J轰LT7刑i1#5tft!TrCi/、ibbd甘rLli其中图（a)、图（(b)、图（(c）为一个例子，此处A结点为15,B结点为8,BL,BR,A。均为空树；图（d)、图（e)、图（f)为另一个例子，" ID="20">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="此处A结点为50,B结点为45,B,BR,A，分别为只含有一个结点的子树。气、气、斌尸一诊户一移九、爸" ID="21">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="：／" ID="22">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="日of（aswvcep拉入3后c调整后" ID="23">
        <fptr EndPN="00000186" StartPN="00000186"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)LR型平衡旋转由于在A结点的左（Left）子树（假定用B表示）的右（Right）子树日亩入结点，使A的衡因f&quot;由1增.2而失去平衡，需进行两次旋转操作：先逆时针、后顺时针。调整过程如图9-8所示。今几月飞＠插入前（b〕插入后〔。）调整后图9-SLR'操作小N.M.图图9-8(a）为插入前的平衡子树，B：和A；子树的高度均为h(h&gt;0)，C,和C；子树的高度均为h-1，若h=0，则B：,CCR,A，均为空树，并且C结点也不存在：或者说C结点是将要被插入的新结点。插入前A结点和B结点的平衡因子分别为1和0,若C结点存在，则平衡因子为0。图9-8(b）为在B结点的右子树上插入一个新结点（当h=0时，则为C结点，否则为C的左子树或右子树上带阴影的结点，图中给出在左子树C上插入的情况，若在右子树CR上插入，情况类似），使得以A为根的子树成此处A结点和B结点的平衡因子是按照相反的方向变化的，而不像LL调整操作那样，都是按照同一个方向变化的。图9-8(c）为调整后的情况，调整规则是：将A的左孩子的右子树的根结点C提升到A结点的位置。将B结点作为C结点的左子树的根结点，而C结点的原左子树C：则作为B结点的右子树。将A结点作为C的右子树的根结点，而C结点的原右子树则作为A结点的左子树。此调整过程要比LL复杂，需要修改5个指针，如图9-8(c）中的箭头所示。从图9-8中可以看出，调整前后对应的中序序列相同，即为BBC,CCRAAR，只是链接次序不同，但没有影响其二叉排序树的性质。图9-9是LR调整操作的两个实例，其中图（(a)、图（(b)、图（(c）为一个例子，此处A结点为9,B结点为3,C结点为6,C是新插入的结点，BL,s^R,A；均为空树；图（d)、图（e)、图（f)为另一个例子，此处A结点为85,B结点为74,C$Picture[00000187\00000187_new\0027.jpg]Picture$$Picture[00000188\00000188_new\0001.jpg]Picture$a" ID="24">
        <fptr EndPN="00000188" StartPN="00000187"/>
      </Paragraph>
      <Paragraph CONTEXT="弋" ID="25">
        <fptr EndPN="00000188" StartPN="00000188"/>
      </Paragraph>
      <Paragraph CONTEXT="户’自（心伪）（‘）尸流了八护$Picture[00000188\00000188_new\0008.jpg]Picture$$Picture[00000188\00000188_new\0009.jpg]Picture$$Picture[00000188\00000188_new\0010.jpg]Picture$（句（.）（0]9-9LR{调整实例" ID="26">
        <fptr EndPN="00000188" StartPN="00000188"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)RR型平衡旋转由于在A的右（Right）子树（假定用B表示）的右（Right）子树上插入结点，使A的平衡因子由一1减至一2而失去平衡，需进行一次逆时针旋转操作，调整过程如图9-10所示。图9-10(a）为插入前的平衡子树，A：,B：,BR子树的高度相同，均为h(h）0)，A结点和B结点的平衡因子分别为一1和。。图9-10(b)为在B结点的右子树BR上插入一个新结点，使以A为根的子树成为最小不平衡子树的情况。图9-10(c)为调整后重新恢复平衡的情况，调整规则是：将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树B则作为A结点的右子树。此调整过程同LL形调整过程对称，要修改的3个指针如图9-10(c)中的箭头所示。白八自＠插入前（b〕插入后（c）调整后9-l0RR！调整操作小意图" ID="27">
        <fptr EndPN="00000188" StartPN="00000188"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)RL平衡旋转由于在A的右（Right）子树的左（Left）子树上插入结点，使得A的平衡因子由一1减至一2而失去平衡，需进行两次旋转操作：先顺时针，后逆时针。调整过程如图9-11所示，它同LR型调整过程对称。" ID="28">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="侧雨。减、日句－J目esJ种.种刁尸戒／声‘卜～一图9-I1RL'1调整操作示意图在上述的每一种调整操作中，以A为根的最小不平衡子树的高度在插入结点前和调整后相同，即为h+2。所以，对除了此子树之外的其余所有结点的不平衡性不会产生影响，即原有的平衡因子不变，故按照上述方法将最小不平衡子树调整为平衡子树后，整个二叉排序树就成为了一棵新的平衡树。【例9-11设有一组关键字为(46,1S,20,35,28,58,18,50,54)试构造一棵平衡的二叉排序树。生成过程如图9-12所示。" ID="29">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Picture URL="00000189\00000189_new\0019.jpg">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Picture>
      <Picture URL="00000189\00000189_new\0020.jpg">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Picture>
      <Paragraph CONTEXT="，护Q澎必勺澎$Picture[00000189\00000189_new\0024.jpg]Picture$l(b)(r)LR'ASF贝贝奴或趁" ID="30">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="必勺必汾风只" ID="31">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="界" ID="32">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="，、" ID="33">
        <fptr EndPN="00000189" StartPN="00000189"/>
      </Paragraph>
      <Paragraph CONTEXT="扬彝在二叉排序树的插入和删除操作中，采用平衡树的优点是：使树的结构较好，从而提高查找运算的速度。缺点是：使插入和删除操作变得复杂化，从而降低它们的运算速度，这是因为，在每次操作中，不仅要进行插入和删除结点，小不平衡子树，若存在，则需要对最小不平衡子树中有关指针进行修改。因此，采用平衡树，适合于那种二叉排序树建立后，就很少进行插入和删除操作，而主要是查找的应用场合。" ID="34">
        <fptr EndPN="00000190" StartPN="00000189"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="180" TITLE="9.5  哈希表查找" TYPE="Chapter">
      <fptr LogicalPageNum="190" PhysicalPageNum="190"/>
        <div ORDERLABEL="180" TITLE="9.5.1  哈希表" TYPE="Chapter">
        <fptr LogicalPageNum="190" PhysicalPageNum="190"/>
        <Paragraph CONTEXT="查找是通过对元素的关键字值进行某种运算后，直接求得元素在线性表中的地址（位置）。这是由关键字到地址的直接转换方法，而不需反复比较。因此，其查找时间与计算地址的函数有关。假设table是一个包含n个元素的线性表，R‘为表中的某个元素（(1&lt;i&lt;nkey‘是其关键字值，若在关键字值kev，与元素R‘的地址（即在线性表中的位置）之间建立某Addr(R=H(key;)其中，Addr&lt;R;）为R‘的地址，H(key;）称为哈希（Hash）函数。可见，哈希函数在哈希表查找中是一｝一分重要的，我们首先研究如何构成哈希表。【例9二2］假定一个线性表为S={18,75,60,43,54,90,67,46}将其存储到数组Hs[131中，如图9-13所示。R｝154143118131146160158175I190图9-13哈希表Hs]131" ID="1">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="若哈希函数定义为H(key)=key%13，则查找过程就是一个求H(key）值的过" ID="2">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="程，如查找75" ID="3">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="H(75)=75%13=10" ID="4">
          <fptr EndPN="00000190" StartPN="00000190"/>
        </Paragraph>
        <Paragraph CONTEXT="H(90)=90h13=12说明Hs[12］存放着90。若根据哈希函数，把元素存放到线性表中相应的位置上，这样形成的表便称为哈希表，哈希表也叫散列表。同样，构造哈希表的过程也叫地址散列。哈希表的查找是以同样的方式进行的。若某个哈希函数对于不同的关键字值key，和key,，得到相同的散列地址，即H(key,）二H(key,)，这种现象称为冲突，例如：H(54)=H(67)=2说明54与67在存放时发生冲突，即54和67都应该存放到Hs[21中。这就需要有办法来处理冲突，发生冲突的关键字对该哈希函数H(key）来说称为同义词。解决冲突即为对应到同一地址的多个同义词安排存储位置，因此，在选定哈希函数时应考虑避免产生冲突，也就是说，一个好的哈希函数能将关键字值均匀地分布在整个地址空间，使产生冲突机会尽量少，同时选定一个解决冲突的方法，即对同义词再次找一个空间地址，存放该元素。综上所述，哈希表是根据设定的哈希函数和解决冲突的方法，为组元素建立一张表，每个元素在表中的位置依赖于设定的哈希函数和解决冲突的方法。" ID="5">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="181" TITLE="9.5.2  哈希函数的构造方法" TYPE="Chapter">
        <fptr LogicalPageNum="191" PhysicalPageNum="191"/>
        <Paragraph CONTEXT="构造哈希函数的方法很多，这里介绍几种常用的。" ID="1">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="1.直接地址法哈希函数H对于关键字是数字类型的元素，直接利用关键字求得哈希地址。在使用时，为了使哈希地址与存储空间吻合，可以调整常数a和Co" ID="2">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="2.数字分析法假设有一组关键字，每个关键字由‘位数字组成，如KiK…K。数字选择法是从中提取数字分布比较均匀的若干位作为哈希地址。例如有一组由9位数字组成的关键字，如下所示：" ID="3">
          <fptr EndPN="00000191" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="K,KtlK,KnKSK4K,KK,H(Key)Key,592422291922XeyZ542813678813Xey,5422Z81712L8Xeyti592389671389Keys592541577591Xeyti542885376885Xey542192551192由数字分析可见，KK,K,三位数字对Key，来t5是相同的，所以取数字相同少的三位凡凡凡为哈希地址。该方法的使用必须事先知道关键字的组成情况。例如，邮政编码100048，前2位表示省市，中间2位是县地，最后2位是支局；如身份证号码110106480723172前6位是省市地区和区县，中间6位是此人的出生年月，后面2位是派出所，最后1位数字是表示性别。在此种情况下就可以用数字分析法确定哈希函数。" ID="4">
          <fptr EndPN="00000192" StartPN="00000191"/>
        </Paragraph>
        <Paragraph CONTEXT="3.平方取中法有时一组关键字在每一位上某些数字的重复频度都很高，例如下列一组关键字(0100,1100,1200,1160,2060,2061,2163,2261,2262)，无法使用数字选择法得到较均匀的哈希函数。平方取中法是：首先求关键字的平方值，通过平方扩大差别，然后再选取中间的儿位或其组合作为哈希地址。如上述这组关键字对表长为1000的哈希地址如一卜所示。keyKeys/l(Ke.v)010000100000101100121000021012001440000-940116013456003452060424360024320614247721247216346785696782261511212111222625116644116此种方法常常在关键字位数少，而相同的位多时使用。" ID="5">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="4.折叠法与移位法有时关键字值含位数较多，则可将关键字值从某些地方断开，分成几段，其中有一段的长度等于地址的位数，把其余折叠加到它的上面，若头上有进位，则把进位去掉，分段方法不同，折叠的方法也不同，由此得到不同的哈希地址。例如Key=12360324711202065，哈希表长为1000，则此关键字分成三位一段，在此舍去最低的两位分别进行移位折叠叠加和边界折叠叠加，求得哈希地址为105和" ID="6">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="907，如图9-14所示。此种方法将所有关键字位中的信息全利用上了。地址是几位，即按几位分段。该方法适用于关键字位数较长的情况。" ID="7">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="5.除留余数法除留余数法是以对关键字取模作为哈希函数，即H(Key)=Key%P其中，尸必须是小于或等于表长的质数或不会小于20的质数因子的合数。如例9-1所不。" ID="8">
          <fptr EndPN="00000192" StartPN="00000192"/>
        </Paragraph>
        <Paragraph CONTEXT="182Key！173‘口31247I!I2！D703h盆r,113荔寸访石寸》v锰月306" ID="9">
          <fptr EndPN="00000193" StartPN="00000192"/>
        </Paragraph>
        <Picture URL="00000193\00000193_new\0007.jpg">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Picture>
        <Paragraph CONTEXT="尸吮萝劫岁移位法：173603747112+0201105图9-14折叠法与移位法" ID="10">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
      </div>
        <div ORDERLABEL="183" TITLE="9.5.3  冲突解决的方法" TYPE="Chapter">
        <fptr LogicalPageNum="193" PhysicalPageNum="193"/>
        <Paragraph CONTEXT="假设哈希表的地址范围为。一m-i，冲突是指由关键字得到的哈希地址为j(Ojm-1)的位置上已有关键字记录，则“处理冲突”就是为该关键字的记录找到另一个空的哈希地址。在处理冲突的过程中可能得到一个地址序列私1＝l，2，…，k（拭任［0，m－11)。即在处理哈希地址的冲突时，若得到的另一个哈希地址H。仍然发生冲突，则再求下一个地址H7，若仍然冲突，再求得H,。依此类推，直至不发生冲突为止。解决冲突的方法有两大类：开放地址法和链地址法。" ID="1">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="1.开放地址法开放地址法又分为线性探测再散列、二次探测再散列和随机探测再散列。假设哈希表大小为T[m]，哈希函数为H(Key)，那么线性探测再散列解决冲突求“下一个”地址的公式是：" ID="2">
          <fptr EndPN="00000193" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="H,二H(Key)Hi＋，＝（私＋l）％m其中i=1,2,二次探测再散列解决冲突求“下一个’，地址的公式是：同哈希地址的关键字存放在同一个链表中，称为同义词链表。通常把具有相同哈希地址的关键字都存放在一个同义词链表中，有m个哈希地址就有m个链表，同时用数组r[m］存放各个链表的头指针，凡是哈希地址为1的记录都以结点方式插入到以t[i]为头指针的单链表中，如图9一巧所示。总之，哈希表的建表过程与查找过程所经历的冲突情况是一致的，只是建表时把一个关键字通过哈希函数和解决冲突安排在一个空档位置上，而查找时，是对一个给定的值诵1寸哈杀雨教和粉到褪冲冲卒的卞件‘柿但草小精署卜的羊键空竺干公空的佰哈希算法如下：voidHashSearchCStructSSTableT[melemtypeK)T(0m-1)为表空间，H(K）为哈希函数，G(j）为解决冲突函数的一般关系，／｛d二H(Kj二0;successful=FALSE;do{if(T[d].key二二K){successful=TRUE;" ID="3">
          <fptr EndPN="00000194" StartPN="00000193"/>
        </Paragraph>
        <Paragraph CONTEXT="return(d｝elseif(T[d].Key二＝中){T[d].key二K:/找不到则插入＊／$Picture[00000194\00000194_new\0021.jpg]Picture$Successful=TRUE;" ID="4">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="｝" ID="5">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="ELSE{i十十；d二（H(K)+G(j)％m)；/＊解决冲突＊／｝}while(!successful)" ID="6">
          <fptr EndPN="00000194" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="｝其中，G(i)为线性探测或二次探测或随机探测。" ID="7">
          <fptr EndPN="00000195" StartPN="00000194"/>
        </Paragraph>
        <Paragraph CONTEXT="3.哈希表举例" ID="8">
          <fptr EndPN="00000195" StartPN="00000195"/>
        </Paragraph>
        <Paragraph CONTEXT="［例9-31设有一组关键字（n=12)(19,O1,23,14,55,20,84,27,68,11,10,77)假设哈希表的空间大小为19（即m二19)，哈希函数H(key）二Key%13，若有冲突，试分别用线性探测、二次探测、随机探测和链地址法解决冲突。由哈希函数H(key）二Key%13，可以计算出各个关键字的哈希地址，若有冲突，按照用线性探测、二次探测、随机探测进行解决，得到如图9-16所示的哈希表。012345678910L112131dIS161718H：一（HI19(271011141551681841191201110123111177tb）二次探测0123456789101112131415161718L68下一｝514匕习19120〔二】84T23111,L77110一］：二＿I_127f-I3L121L211123R:3,54,11,36.19,28,’二‘二$Picture[00000196\00000196_new\0001.jpg]Picture$比较次数:123ASL链地址＝1/12(1*7+2*4+3*1)=1.5ASL顺序查找＝（12＋l）12＝6.5ASL折·f`找＝1092（12＋1）·1＝2.7由此可得结论，即使有冲突，哈希表法仍比其他查找方法的时间复杂度好。哈希查找法虽然造表费些时间，但效率相当好。在哈希法中随机探测解决冲突，效果会更好一些。" ID="9">
          <fptr EndPN="00000196" StartPN="00000195"/>
        </Paragraph>
      </div>
      <Paragraph CONTEXT="到目前为止，我们所讨论的静态查找与动态查找的共同特点是：为了找到表中的某个元素或结点，都要经过一系列的比较后，才能确定待查元素在表中的位置，其查找所需时间总是与比较次数有关。本节将讨论另一类查找方法―哈希表查找。" ID="1">
        <fptr EndPN="00000190" StartPN="00000190"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="186" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="196" PhysicalPageNum="196"/>
      <Paragraph CONTEXT="1.判断题" ID="1">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)二叉排序树的查找和折半查找时间的性能相同。" ID="2">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)哈希表的查找效率主要取决于哈希表造表时选取的哈希函数和处理冲突的方法。" ID="3">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）任意一个二叉排序树的平均查找时间，都小于用顺序查找法查找同样结点的线性表的平均查找时间。" ID="4">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)虽然输入元素的次序不一样，但是生成的二叉排序树却是一样的。" ID="5">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="(5）采用分块查找方法，既能实现线性表所希望的较快的查找速度，又能适应动态变化的需要。" ID="6">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="2.试分别画出在线性表（16,4,9,12,21,1)中进行折半查找，以查找关键字分别等于12,1和15的过程。" ID="7">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="3.设单链表的结点是按照关键字从小到大排列的，试写出对该链表的查找算法，并说明是否可以采用折半查找。" ID="8">
        <fptr EndPN="00000196" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="186.设哈希表的表长。=14，哈希函数H(k）二k%11。表中已有4个兀系,uu泪二次探测再散列处理冲突，关键字为49的元素的存储地址是（）。0I2345b7E910111213！lII15f3BI61'B41I｛＿i,i1二设有一组关键字（(72,35,124,153,84,57)，需插入到表长为12[37'布" ID="9">
        <fptr EndPN="00000197" StartPN="00000196"/>
      </Paragraph>
      <Paragraph CONTEXT="令中。" ID="10">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="1)试设计一个适当的哈希函数。:2）用设计的哈希函数将关键字插入到哈希表。画出建好的哈希表结构（假定毛线性探测法解决冲突）。" ID="11">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="6，设KKZ,K，是三个不同的关键字，且KKz&lt;K。试按照同的J人PI1津立相应的二叉排序树。" ID="12">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="7.已知长度为12的表为｛Jan,Feb&gt;Mar,Apr,May,June,July,Aug,Sep,(pct.Nov,Dec}o" ID="13">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)试按表中元素的次序依次插入一棵初始为空的二叉排序树，请U出插入完成后的二叉排序树，并求查找成功的平均查找长度。" ID="14">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)若对表中元素先进行排序后构成有序表，再对该有序表进仃折半食找，水查找成功的平均查找长度。" ID="15">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)按表中元素的顺序构造一棵平衡二叉树（AVL树）。" ID="16">
        <fptr EndPN="00000197" StartPN="00000197"/>
      </Paragraph>
      <Paragraph CONTEXT="8.设哈希函数为H（k）＝＝（3＊k）％11，用线性探测再散列法处理冲突。对于FJ关键字序列构造一个哈希空间为0-10，表长为11的哈希表。并求ASLo原书空白页" ID="17">
        <fptr EndPN="00000198" StartPN="00000197"/>
      </Paragraph>
    </div>
    </div>
    <div ORDERLABEL="189" TITLE="第10章  排序" TYPE="Chapter">
    <fptr LogicalPageNum="199" PhysicalPageNum="199"/>
      <div ORDERLABEL="189" TITLE="10.1  排序的概念" TYPE="Chapter">
      <fptr LogicalPageNum="199" PhysicalPageNum="199"/>
      <Paragraph CONTEXT="排序（Sorting）就是把一组杂乱无章的记录（数据元素），按其个域的值（该值也的递增（即由小到大）或递减（即由大到小）的次序排列起来，使其具有一定的顺序。对排序而言，如果不作特殊说明，是指按照递增的次序排列。例如，设有一组记录（r1，几，…，‘），其关键字为（(kkz,kn)，排序是通过算法重新构造一种排列方法（(rj，,r;z，一rj。),使其关键字呈如下关系：" ID="1">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="k.l&lt;k&lt;kIf2jn，其中Jl，J2，一jn任｛l，2，…，n｝。更为通俗地说法是，以关号或大于号，或小于号，但在一个算法中应使用一种确切的含义。如果待排序的文件中，存在多个关键字或排序码值相等的记录，例如：在（(rrz,一‘有k;二kj(ij)。排序前为（.一r;rj,二）)o而排序后，这些记即仍为（.一r;rj,则称这种排序方法是稳定的，否则称这种排序方法为不稳定的，排序结果为（一rjr.o由于文件的大小n不同，使得排序过程中涉及的存储器不同。当n较小（一般小于" ID="2">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="104）时，全部排序可以放在内存中完成，不涉及外存的排序方法称为内排；当n较大时，排序过程中需要与外设打交道，也就是说排序不仅需要内存，而且还要使用外存时，称这种排序为外排。排序的方法很多，排序算法的衡量标准有：元素或记录的比较时间、移动时间，这是从时间复杂度分析；还有空间复杂度，即元素占用的辅助空间数量。通常，在排序的过程中需要进行下列两种基本操作：" ID="3">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）比较两个关键字的大小。" ID="4">
        <fptr EndPN="00000199" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)将记录从一个位置移动到另外一个位置.待排序的记录序列可以有若干种存储方式，在本书中，假定待排序的一组记录存放在地址连续的一组存储单元上，且为了讨论方便，设待排序的关键字均为整数。即在以后讨论的大部分算法中，待排序记录的数据类型设为：#defineMAXSZZE20/＊顺序表的最大长度＊，structRtype{/＊记录类型＊／intkey;/‘关键字项＊／／‘其它数据项‘／｝：" ID="5">
        <fptr EndPN="00000200" StartPN="00000199"/>
      </Paragraph>
      <Paragraph CONTEXT="typedefstructstructRtyper(MAXSIZE+l);r[01闲置或用作哨兵单元＊／in七length;/＊顺序表长度＊／}Sglist;/＊顺序表类型＊／" ID="6">
        <fptr EndPN="00000200" StartPN="00000200"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="190" TITLE="10.2  插入排序" TYPE="Chapter">
      <fptr LogicalPageNum="200" PhysicalPageNum="200"/>
      <Paragraph CONTEXT="在排序中，我们经常会遇到一个名词：一趟。所谓一趟是指在排序过程中，恢复一个记录有序性的操作。整个排序过程可以说是：一趟排序的多次重复。插入排序的基本思想是：每一趟将一个待排序的记录，按其关键字值的大小插到己直到全部插入完成。假设记录存放在1二length]（表示第一个记录存放在下标为1的单元，第1个记录存放在下标为1的单元）之中，r[1二l-1】是已排好序的记录；l二length]是没排序的记录。插入排序对未排序中的{t7插入到r[1二i-I]之中，使r[1二i]成为有序，[l的插入过程就是完成排序中的一趟。随着有序区的不断扩大，使r[1二length]全部有序。插入排序算法描述如下：voidInsertSort(Sglist1ist)" ID="1">
        <fptr EndPN="00000200" StartPN="00000200"/>
      </Paragraph>
      <Paragraph CONTEXT="／＊对顺序表作插入排序，／｛for(i二2;i&lt;list.length;i{list.r[O]二list.r［1］：／＊r［01是监视哨＊／j二1十1;while(list.r[0I.key&lt;1ist.r[j).key){list.r[j+1］二list.r［j］；／＊记录后移＊／" ID="2">
        <fptr EndPN="00000200" StartPN="00000200"/>
      </Paragraph>
      <Paragraph CONTEXT="〕～一：｝list.r[j+1］二list.r【0］；／＊插入到合适位置＊／" ID="3">
        <fptr EndPN="00000200" StartPN="00000200"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝算法中引进附加记录r[01作为监视哨，监视着WHILE循环是否越界，这种做法可以大大节省循环的测试时间。利用上述算法对下列数据进行插入排序的过程如图10-1所示。[19;O1231719,55R4151(19,)[01231&quot;719558415j(0119;)[23171ti.5581151(0119.231[1719.5584151(O11719,)[1955841S1(O11719,1923)[5584151(011719,19.&quot;l355)(84151(O11719;19235584)[151(O1151719..i923S584)其中（.二）为有序区，］为无序区。19。和19：表示排序值相等的两个不同记录。插入排序的算法分析如「：每一趟的具体移动操作次数不好确定，用数学期望值的平均状况估计为.jl2=(i-1)/2。所以T(rz，一菩12“一‘，一1n2，卜‘2T（；：）＝生（。’一。）一。（。，）4若排序时间复杂度T(n)=O(，i，该算法为低级排序算法。可见插入排序为低级排序。显然，如果原始记录已按关键字有序排列，将会使插入排序呈现最好状态‘总的比此时总的比较次数最大Cl,lp、和总的移动次数也取最大值M,a，为：" ID="4">
        <fptr EndPN="00000201" StartPN="00000200"/>
      </Paragraph>
      <Paragraph CONTEXT="（粤(n一‘n+2)" ID="5">
        <fptr EndPN="00000201" StartPN="00000201"/>
      </Paragraph>
      <Paragraph CONTEXT="C,IIUY'(2+，一1)=1(I：一1。十4)六Z呱二、＝" ID="6">
        <fptr EndPN="00000201" StartPN="00000201"/>
      </Paragraph>
      <Paragraph CONTEXT="可见T（n）＝口（，：2），但是在具体执行中，时间消耗取决于数据的分布情况，即：有序时好，逆序时恶化。" ID="7">
        <fptr EndPN="00000201" StartPN="00000201"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="191" TITLE="10.3  快速排序" TYPE="Chapter">
      <fptr LogicalPageNum="201" PhysicalPageNum="201"/>
      <Paragraph CONTEXT="t.冒泡排序冒泡排序（BubbleSort）也称为起泡排序，它的操作是：通过无序区中相邻记录关键字间的比较和位置的交换，使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。算法思想是：从最下面的记录开始，对每两个相邻的关键字进行比较，且使关键字到达最上端，接着，再在剩下的记录中找关键字最小的记录，并把它换在第二个位置上。依此类推，一直到所有记录都有序为止。起泡排序算法描述如下：voidBubbleSort(sglist1ist)｛for(i二1:i&lt;Iist.length-1;ifor(j=1ist.length;j&gt;i+1;j一）if(list.r[jI.key&lt;Iist.r[j-11.key）｛／＊比较＊／w二list.r[jlist.r[j】二lis七.r[j-11;list.r(j-11=w:" ID="1">
        <fptr EndPN="00000202" StartPN="00000202"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="2">
        <fptr EndPN="00000202" StartPN="00000202"/>
      </Paragraph>
      <Paragraph CONTEXT="｝利用此算法对序列：C19O1,23,14,55,192,84,27,68)进行起泡排序过程如下如图10-2所示。" ID="3">
        <fptr EndPN="00000202" StartPN="00000202"/>
      </Paragraph>
      <Paragraph CONTEXT="J.、JJ，J钾、目尸、，尸、沪、产、ofofofofofofofofof1414141414141414141911911911911911411911912319Z19Z19,19,1921921921919,2323232323232323552727272727272727275555555555555555846868686868686868" ID="4">
        <fptr EndPN="00000202" StartPN="00000202"/>
      </Paragraph>
      <Paragraph CONTEXT="68848484$4$4°°484甘了，，，曰份、丫枯～丫、沪、尸一一「U.，二－－：‘月卜‘‘‘.曰于一、曰矛图10-2起泡排序示意图算法分析，起泡排序与插入排序一样，对不同组的记录所需进行的关键字之间的比较次数为夸n(n一‘，，移动次数为号n(n一‘，，时间复杂度为O(nZ)o起泡排序是一种稳定的排序方法。" ID="5">
        <fptr EndPN="00000203" StartPN="00000202"/>
      </Paragraph>
      <Paragraph CONTEXT="2.快速排序快速排序（QuickSort）是由起泡排序改进而得的，它的基本思想是：在待排序的n个记录中任取一个记录（通常取第一个记录，该记录称为基准记录），把该记录放入某个位置后，整个表被此记录分割成两部分。所有关键字比该记录关键字小的，均放置在其前一部分，所有比它大的，均放置在其后一部分，并把该记录排在这两部分的中间，这个过程称作一趟快速排序。之后对所分的两部分分别重复上述过程，直至每部分「力口右‘一洲卜书刀书否从，，卜代孰刁行.全.令二么东一宪肖配，夕J；月1才古习落汉，一才、；井履毕侧七2‘之壬白hr场爵d女才落内只有一个记录为止。简而言之，每一趟的结果，一分为二，对子表按递归方式继续这种划分，直至划分的子表长为1为止。一趟快速排序采用从两头向中间扫描的办法，同时交换与基准记录逆序的记录。具体作法是：设两个指示器L和j，它们的初值分别为指向无序区中第一个和最后一个记录。假设无序区中记录为（rlu］，rlu＋11，…，rlv］），则i的初值为“,j的初值为，，首先将r[u]移至变量x中作为基准，令j自v起向左扫描直至r[jJ.key&lt;x.key时，将r[j］移至i所指的位置上，然后令i自i+1起向右扫描且至r[iI.key&gt;x.key时，的位置上，依次重复，直至i=j，此时所有rls］（s＝＝u，u＋1，…，1-1)的关键字都小于" ID="6">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="x.key，而所有rltl（叼＋l，j＋2，…，。）的关键字必大于z.key，则可将x中的记录移至i所指位置r[i]，它将无序中的记录分割成二i-11和r[i+1二v]，以便分别进行排序。快速排序的算法描述如下：" ID="7">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="voidQuickPass(sglist1ist.intu,intv)" ID="8">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="｛i二u;二v；x＝list.r［1］：do{" ID="9">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="while{(x.key＜二list.r[jI.key)(j&gt;i))j二j-1;if(j&gt;i){" ID="10">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="list.r[i]二list.r[ji二i+1｝" ID="11">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="while((x.key＞二list.r[iI.key)(i&lt;ji二i+1;if(i&lt;j){" ID="12">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="list.r[j」二list.r[i]" ID="13">
        <fptr EndPN="00000203" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="j二j-1isrr[i)二X;/辅助单Jl;中的记求一次性到位，／｝voidQuickSort(sqI.isT.List,irltLinth)〔" ID="14">
        <fptr EndPN="00000204" StartPN="00000203"/>
      </Paragraph>
      <Paragraph CONTEXT="if(1&lt;h){QickFass(list,h,ii,J合位a由i给出＊／QickFassist,1,i-1QickFass(list&gt;i+1.h｝" ID="15">
        <fptr EndPN="00000204" StartPN="00000204"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="16">
        <fptr EndPN="00000204" StartPN="00000204"/>
      </Paragraph>
      <Paragraph CONTEXT="例如，有以下数据序列：(28,19,27,4956,12,10.4925,20,50)对其进行一趟快速排序过程如下：丫””56Iztoas:252n5D回2’。‘入’5留192T49,5u!2!049=2524SG20!92749：56!21049=252850今今升。9：5。，：：。、、2。囱，。a9国" ID="17">
        <fptr EndPN="00000204" StartPN="00000204"/>
      </Paragraph>
      <Paragraph CONTEXT="个召25.25今少回[23192749140121049,2`20501(20192%2siU1212S1[49,4049,501[1219101r20)(25271(2L[49;40491`Oi" ID="18">
        <fptr EndPN="00000205" StartPN="00000204"/>
      </Paragraph>
      <Paragraph CONTEXT="[10)(12)(191(2i)(2S271r23)[49,40491s01(1011'[101(20)[25271i28j(49,40491501r1012192U)[2?11J(28)9。40491sU](101219202i)[271(28)[49,40491501(101219202172E)[49,IU491s01(10121920zs27zs}(ao](49[aso](101219201s27&quot;t84049,1[491s01(101219202527284049,491)[501(IO1219202s27284049;491s01图10-4快速排序全过pia实例由上述实例可见，关键字49，经排序后被排到了49：的前边，因此，快速排序是不稳定的排序算法。通常情况下，快速排序有非常好的时间复杂度，它优.J几各种算法。其平均时间复杂度为O(nlnn)。但是在原始数据有序的情况下，此算法就蜕化为起泡排序O&lt;n'。原因是没有产生将表一分为二的效果，分而治之的预期目的未达到，故而算法恶化。为避免恶化可以改造原始数据的分布，具体办法是：侮趟取“头中尾”三个元素，将三者值居中的放置在第一位，然后开始＿}几述的一趟算法。实际操作时，需具体问题具体分析，对数据分布进行研究，以决定是否进行上述措拖‘，在进行快速排序时，有一两点需要注意：" ID="19">
        <fptr EndPN="00000205" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)当递归算法执行比较慢时，可转成非递归形式。" ID="20">
        <fptr EndPN="00000205" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)1i记录个数n很小时，用快速排序算法并不合算，一般当n&gt;20以上时，才-有考虑的必要。快速排序一趟的算法很有用。例如，利用此思想可以方便地实现划分正负数的操作。如把一7,8,13,27，一14,38，一12，一55,42，一31的正数和负数分开，附加一个首元素0，经过快速排序一趟后，负数在左，正数在右。一个简单的快速排序的C语言实现程序如下。#include&lt;st.dio.h" ID="21">
        <fptr EndPN="00000205" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="#defineMe'X40" ID="22">
        <fptr EndPN="00000205" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="inti.1,n;" ID="23">
        <fptr EndPN="00000205" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="int1,h,x;" ID="24">
        <fptr EndPN="00000205" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="intr(MAX：一一－一一一一一一～一－一～～一一～一一－一－一～一·－－－一一“·一一～～一一一voidinput_int()｛" ID="25">
        <fptr EndPN="00000206" StartPN="00000205"/>
      </Paragraph>
      <Paragraph CONTEXT="in七i;printf(&quot;PleaseinputnumCint&quot;scanf(&quot;％d&amp;nprintf(&quot;Pleaseinputintegerfor(i二1;i＜二n;iscanf(d&amp;r[i]｝；－一～－一一一一－－一一一－一～一一～－－一一－－－一一－－－～－～～－－－－一～－－－voidprin七n七（）(in七i;printf(&quot;OutputresultforCi二1；1＜＝n；1＋＋）printf(&quot;％4d&quot;,r[i]printf(&quot;\n&quot;｝：－一一－一一一～－一～一－－－一～一～一～一～～一一～一一一～－～一一－－一一－一～一一voidquksort(int，inth,intr[MAX])｛" ID="26">
        <fptr EndPN="00000206" StartPN="00000206"/>
      </Paragraph>
      <Paragraph CONTEXT="if(1&lt;h){i=1;j=h;x二r[iprint_int();do(whiler[jx)Ci&lt;jj二j-1;if（1＜j）｛r［11二r［j］：1＝1＋1｝：whiler[ix)(i&lt;ji=i+1;ifCi&lt;j){r[j］二r[ij二j-1;}}while(i&lt;jr[ix;qukpass(r.1.h,iqudsort(1,i-1,rquksor七〔i+1,h,r｝" ID="27">
        <fptr EndPN="00000206" StartPN="00000206"/>
      </Paragraph>
      <Paragraph CONTEXT="｝：一～－一～－－一～一一～～一～－一一一－－～～一一－－一一～－－一一－－－－一一－－－－－－－一voidmain()" ID="28">
        <fptr EndPN="00000206" StartPN="00000206"/>
      </Paragraph>
      <Paragraph CONTEXT="｛" ID="29">
        <fptr EndPN="00000206" StartPN="00000206"/>
      </Paragraph>
      <Paragraph CONTEXT="input_int(printf(&quot;inputfinish\n&quot;);196qudsort(1,n,r);print_int();" ID="30">
        <fptr EndPN="00000207" StartPN="00000206"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="31">
        <fptr EndPN="00000207" StartPN="00000207"/>
      </Paragraph>
      <Paragraph CONTEXT="程序运行结果为：Pleaseinputnum(int10Pleaseinputinteger:67354629354087672356Outputresult:23293535404656676787" ID="32">
        <fptr EndPN="00000207" StartPN="00000207"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="197" TITLE="10.4  选择排序" TYPE="Chapter">
      <fptr LogicalPageNum="207" PhysicalPageNum="207"/>
      <Paragraph CONTEXT="选择排序（selectionsort）的基本思想是：每一趟在n-1＋1（1＝1，2，…，n-1）个记录中选取关键字最小的记录作为有序序列的第i个记录。常见的有三种方法。" ID="1">
        <fptr EndPN="00000207" StartPN="00000207"/>
      </Paragraph>
      <Paragraph CONTEXT="1.简单选择排序简单选择排序的基本思想是：每一趟排序在n-i+1Ci=1,2,…,n-1)个记录中选并和第i个记录交换。其算法描述如下：voidSelectionSort(Sglist1ist)｛for(i二1;i＜二n-1;i{k=isfor(j=i+1;jn;jif(list.r[jI.key&lt;1is七.r(kI.key)k二j:/＊用K指出每一趟在无序区段的最小元素，／w二list.r(iJ;list.r[i]=1ist.r[klist.r(k」二w;｝" ID="2">
        <fptr EndPN="00000207" StartPN="00000207"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="3">
        <fptr EndPN="00000207" StartPN="00000207"/>
      </Paragraph>
      <Paragraph CONTEXT="算法分析：T(n)_(n-1)+(n-2…+1=0(n2)显然，此算法并不太好。有一个问题，值得读者思考：从n个元素中找最小的比较次做相应的改进，可以减少比较的次数。避免重复操作树形选择排序就是改进方法之－" ID="4">
        <fptr EndPN="00000208" StartPN="00000207"/>
      </Paragraph>
      <Paragraph CONTEXT="2.树型选择排序树型选择排序的算法思想：先把待排序的n个记录的关键字两两进行比较，取出较然后。：［：）个较刁、者。1IZI小者。然后在｝母｝个较小者中，一再用同样的方法比较选出每对，。的较小者，如此反复，直至选出最小关键字的记录为止。j以用一棵树表示序列：1901,23,27,55,19：，84,14,68。这一排序中第一趟取最小的过程，如图105所示。l'1to-5具体操作是，树中的叶子结点代表待排序一记录的关键字。＿L面一层分支结点是叶子结点或卜层分支结点两两比较取较小值的结果。依次类推，树根表示最后选择出来的最小关键字。一卜一步在选择次小关键字时，只需将原叶子结点中的最小关键笋改为co，重复上次的比较方法即可得到次小关键字……在树型选择排序的过程中，被选中II.hW_一全由at=fJ根的比较过程。因此，其‘if一’.复杂度为“(nlog;nGC.I'Al!-a,Yc于拿faklf-iFrfrY.rv7x'tr_4E3仁奎瑟t&gt;tinx幻bl.f!1了r.农扛空二了tti;fit1.ii-卜irLr1si卜。、h比简单选择排序减少了比较次数。果，具体实现有困难。因此，树型选择排序不是用来排序而是用来证明某些问题。" ID="5">
        <fptr EndPN="00000208" StartPN="00000208"/>
      </Paragraph>
      <Paragraph CONTEXT="3.堆排序堆排序（HeapSort）是对树型选择排序做出了某些改进，使总的比较次数达到树型选择排序的水平，而额外辅助空间只需一个记录大小。堆排序是在排序过程中，将数组中存储的数据看成是一棵完全二叉树，利用完全二义树中双亲结点和小孩结点之间的内在关系来选择关键字最小的记录。具体做法是：把待排序的表的关键-存放在数组t{1二length]之中，将；看作一棵二叉树，每个结点表示一个记录，源表的第一个记录r(1】作为二叉树的恨，以下各记录r21ength]依次逐层从左到右顺序排列，构虑一赵到兰：才、一可去对走￡六‘妇：津；J二砂内扣老六分之曰r，，,，一，。＿＿.＿＿＿.入.。$Picture[00000208\00000208_new\0027.jpg]Picture$$Picture[00000208\00000208_new\0028.jpg]Picture$成一棵完全几叉树，任意结点{r的左孩子是术11，对这棵完全二叉树的结点进行调整，使各结点的关键字值满足下列两个条件：List.rli〕，key粗115七.rIZ主〕.keyList.r汇1］.key成1主st.r〔2主＋1］.杖ey键字R小，这种堆也称为“小根堆”，如图10-6所示。如果各结点的关键字满足：1ist.r[iI.key）ist.r[2ikeylist.r[ij.key）iist.r[2i十11.key这种堆被称为“人根堆”，如图10-6所示。“人根堆”的根结点的关键字最大，其根结点也称为堆顶元索。12斗45亏7‘矿J假堆示恩图《幼大根堆示惫困图U-6大报堆与小根堆示例图当把二叉树转换成“大根堆”后，堆顶元素最大，把堆顶元素输出，并把堆底换到二叉树的根上。输出堆顶元素暂存在刚刚换到堆顶的元素原来位置上。然后，再重新调整二叉树的结点，使其成为堆。依此类推，输出堆顶元素，而后再重新恢复堆，两类操作交替进行，直至全部结点输出为止。催月L序的羊淤早灼书努栩，D、xl" ID="6">
        <fptr EndPN="00000209" StartPN="00000208"/>
      </Paragraph>
      <Paragraph CONTEXT="R.w.FLoyd提出了称为“筛选”的算法建堆：假若完全二又树的某一个结点1对于它的左子树、右子树己是堆，就需将r【21］.ke夕与代21＋l］.key之中的最大者，与；［i］.kex比较，若，·［i］.key小则交换，这有可能破坏下一级的堆。于是继续采用.上述方法构造下一级的堆。直到完全二叉树中结点1构成堆为止。1＝｛鲤｝至反复，。用上述思想建堆。大者“‘" ID="7">
        <fptr EndPN="00000209" StartPN="00000209"/>
      </Paragraph>
      <Paragraph CONTEXT="12！对于任意一棵完全二叉树，从1＝｝二：子二｝到，，反复利用上述思想建堆。大者“上浮”，小者被“筛选”下去。筛选算法描述如一F：、，oidHedpsif七（sqlisLheap，in七5，intm）／＊5为调整点序号，m为区间上界＊／｛1二5；j二2＊1：x二heap.r【1］；while（j＜二m〕｛heap.rli〕二heap.r[jJ;i二〕：J二2*i:/＊孩子与双亲换位，并继续往下调整‘／｝" ID="8">
        <fptr EndPN="00000210" StartPN="00000209"/>
      </Paragraph>
      <Paragraph CONTEXT="elsej二m+1:/＊强制跳出WH工LE｝heap.rlil＝x／＊辅助单元中的记录一次性入位＊／｝假设原表的关键字为（19O1,23,14,35,192，84,27,68)的数组在建堆过程中的状态变化如图10-7所示。1Z7466789凡巴业魁尘望井生习贝囚趁岁巴兰当上习魁贤竺望要川初建堆时是整体调整，而恢复堆最多是从根到叶子的局部调整。有了初建堆的筛选算法，利用此算法，将已有堆中的根与最后一个叶子交换，进一步恢复堆，直到一棵树只剩一个根为止。这就是堆排序的全部过程。" ID="9">
        <fptr EndPN="00000211" StartPN="00000210"/>
      </Paragraph>
      <Paragraph CONTEXT="堆排序算法描述如下：" ID="10">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
      <Paragraph CONTEXT="voidHeapSort(Sglisth)" ID="11">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
      <Paragraph CONTEXT="｛for(s二h.length/2:s＞二1;s一）LZJ调整，建立初始堆＊／for（5二h.lenqth；5＞＝2；5一）｛" ID="12">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
      <Paragraph CONTEXT="w＝h.r〔5］：" ID="13">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
      <Paragraph CONTEXT="h.r〔51＝h.r〔1」；" ID="14">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
      <Paragraph CONTEXT="h.r〔1］二w：／＊根和最后一片叶子互换＊／Heapsift（h，1，5-1）；／＊针对根调整为堆＊／" ID="15">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
      <Paragraph CONTEXT="｝｝对于上述一组数据，其堆排序过程如图10-8所示。［1910123143519，842768」［846523273519：1910114」初始堆［683523271419：19101］（84）84什1咤【352723011419：191」（6884）68村01【2719123011419，」（356884）35＋＋19：汇2319119，01］4J（27356884）27“19【1911419201｝（2327356884）23ot4【011419，」（1912327356884）19什01【0114」（19219：2327356884）19＋＋01（0114192土912327356884）1咤什01图1压8堆排序过程中数据变化情况堆排序的一个突出优点是：在空间方面很节约，只需要存放一个记录的辅助空间。所以称为原地排序。然而堆排序是一种不稳定的排序方法。堆排序的算法时间是由建立初始" ID="16">
        <fptr EndPN="00000211" StartPN="00000211"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="202" TITLE="10.5  归并排序" TYPE="Chapter">
      <fptr LogicalPageNum="212" PhysicalPageNum="212"/>
      <Paragraph CONTEXT="归并排序（MergingSort）就是将两个或两个以上的有序表合并成一个有序表的过程。设有两个有序关键字表s(18,25,37,42s(20.33,40)。同时将s，和sz存储在数组r[1二71中，s,放在r[1二，sZ放在r[5二71，现要归并到一维数组r2(1二之只要依次比较这两个有序表中相应记录关键字，按照“取小”到r2之中即可。r2(kmin{r[iI.key,r[jI.key}其中i初值为1;j初值为5;k是r2的下标。归并过程前后如图10-9所示。" ID="1">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="(18253742)(203340)" ID="2">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="(18202533374042)" ID="3">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="图10-9归井过riY图其算法描述如一下：voidMergingCSglistsr[I.Sqlistr2inti,intm,intri)／＊将有序的sr[i二m]及sr[m+1二n]，归并后置于r2(i二n]｛k=isj=m+1;k是r2的指示器，i为sl的指示器，jjs的指示器whilei＜二m)(j＜二n{if(sr[i].key＜二sr[jkey){r2(k]二srtil:i二i+1;" ID="4">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="）" ID="5">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="elser2[k」二sr[jj二j+1;" ID="6">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="｝" ID="7">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="k二k+1:" ID="8">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="｝if（1＞m）／＊51结束＊／white(j＜二n){r2(k］二sr[jJ二j+1:k二k十1:/‘将s7.复制到r2｝" ID="9">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="else" ID="10">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="202" ID="11">
        <fptr EndPN="00000212" StartPN="00000212"/>
      </Paragraph>
      <Paragraph CONTEXT="w.i1FCj二re,){〕一[k」二sr[ii=i+1:k二k+I/＊将sl复制到r2｝" ID="12">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="｝在归并过程中，表：i;1s：被遍历一遍，表中每一项都被复制一次。因此，归并的代价t两个表的长度和成正比。其算法的时间复杂度为O&lt;n)。归并排序也可以用如卜递归算法描述为：voidMergeSortSglistsrSglisttrlints,int.t将st[s二t]归并排序为trl[s二ttr2(。二t]为辅助空间“／｛" ID="13">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="主f(s＝二七）" ID="14">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="trl[s]sr[s" ID="15">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="elset" ID="16">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="m二（s+t/1:／＊将sr[s二t]平分为sr[s二m]和sr[m+1二t]MergeSortisr.tr2.s,m／＊递归地将。r(s二m]归并为有序的trZ〔5，.m］‘／MergeSort（sr.tr2.m+1.t.1＊递归地将sr[m斗1二tj归并为有序的tr2[m+1二t]Mergicig(t2.trl,s.m,t)／，将七j-2[s二m]和tr2[m二t1t井tJ七rl[s二t]｝｝" ID="17">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="此算法的时间复杂度为O&lt;nlog2n)。由于在归并排序过程中，主要操作是有次序地复制记录，因此它是一种稳定的排序算法。但它在归并过程中需要O(n）级的辅助空间，这是它的不足之处。" ID="18">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="203" TITLE="10.6  小结" TYPE="Chapter">
      <fptr LogicalPageNum="213" PhysicalPageNum="213"/>
      <Paragraph CONTEXT="1.方法比较" ID="1">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Paragraph CONTEXT="综合比较本章内讨论的各种内部排序方法，其性能比较如图ioo所示。203" ID="2">
        <fptr EndPN="00000213" StartPN="00000213"/>
      </Paragraph>
      <Picture URL="00000214\00000214_new\0001.jpg">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Picture>
      <Paragraph CONTEXT="图io-io内部排序性能比较从图10-10可以看出，各种排序方法各有优缺点。因此在不同的情况下可选择不同的方法。通常应考虑的因素有：" ID="3">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="待排序的记录个数no" ID="4">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="记录本身的大小。" ID="5">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="关键字的分布情况。对排序稳定性的要求和语言工具的条件等。图10-11是排序时间的某次测试情况：（时间单位：毫秒ms)" ID="6">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="图to-i时间测试比较表" ID="7">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="2，各种方法间的内部关系前面提到的几种排序方法，虽然算法不同，但彼此之间有其内在联系，较好的算法往往是由一些简单算法演化而来的。插入排序的主要操作是移动，经过采用分而治之演化快速排" ID="8">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="与之相对应的是分配、收集思想的基数排序。" ID="9">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Paragraph>
      <Picture URL="00000214\00000214_new\0022.jpg">
        <fptr EndPN="00000214" StartPN="00000214"/>
      </Picture>
    </div>
      <div ORDERLABEL="204" TITLE="习题" TYPE="Chapter">
      <fptr LogicalPageNum="214" PhysicalPageNum="214"/>
      <Paragraph CONTEXT="1.判断题间，这是影响时间复杂度的主要因素。" ID="1">
        <fptr EndPN="00000215" StartPN="00000214"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）对于n个记录的线性表进行冒泡排序，所需要的平均时间是O(nlog,n)o对于n个记录的线性表进行冒泡排序，" ID="2">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="(4）对于n个记录的线性表进行冒泡排序，所需要的平均时间是口（n）。" ID="3">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）对于n个记录的线性表进行冒泡排序，在最坏情况下所需要的时间是0（nZ）。" ID="4">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（6）对于n个记录的线性表进行快速排序，所需要的平均时间是0（nlogZn）。对于n个记录的线性表进行快速排序，" ID="5">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（7）对于n个记录的线性表进行快速排序，所需要的额外空间是口（n）。" ID="6">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（8）对于n个记录的线性表进行快速排序，在最坏情况下所需要的时间是0（nZ）。" ID="7">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（9）堆排序所需的时间与待排序的元素个数无关。" ID="8">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（10）堆中所有非终端结点的值均小于或等于（大于或等于）左右子树的值。" ID="9">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="2.填空题" ID="10">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）对n个不同的关键字进行冒泡排序，在（）情况一下比较的次数最少，其比较次数为（）；在（）情况下比较的次数最多，其比较次数为（）。" ID="11">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）快速排序法在（）情况下最不利于发挥其长处；在（）情况下最易" ID="12">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）将5个不同的数据进行排序，至少需要比较（）次，至多需要比较（）次。" ID="13">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（4）设关键字序列为：3、7、6、9、8、1、4、5、2。进行排序的最少交换次数是（）。" ID="14">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（5）堆的形状是一棵（）树。" ID="15">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（6）就平均时间而言，（）排序最好。" ID="16">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="3.什么是排序方法的稳定性和不稳定性？选择排序是否稳定？为什么？" ID="17">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="4.给出一组关键字（19，01，26，92，87，11，43，87，21），分别采用下列排" ID="18">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="序方法排序，试列出每一趟排序后关键字的排列次序，并统计每趟排序所进行的关键字" ID="19">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="比较次数。" ID="20">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）冒泡排序" ID="21">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（2）快速排序（飞、件丰易月卜良" ID="22">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）" ID="23">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="5.快速排序算法是否稳定？请说明理由。" ID="24">
        <fptr EndPN="00000215" StartPN="00000215"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)1.100,85,40,77,80,60,66,98,82,10,20)" ID="25">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)(10,20,40,60,66,77,80,82,85,98,100)" ID="26">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="7.设有5000个无序的元素，希望用最快速度挑选出其中前10个最大的元素。试问采用什么排序方法最好？为什么？" ID="27">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="8.给出n个学生的考试成绩表，每个数据元素由姓名和分数组成，试设计一个算法：" ID="28">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="(1）按照分数高低次声挤，打印出每个学生在考试中获得的名次（分数相同的为同一名次）。" ID="29">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)按照名次列出侮个学生的姓名和分数。206" ID="30">
        <fptr EndPN="00000216" StartPN="00000216"/>
      </Paragraph>
    </div>
    <Paragraph CONTEXT="排序是数据处理中经常使用的一种重要操作。也是人们研究时间较长的一类问题。据早期文献记载，在数据处理中.计算机大约用30％以上的时间从事排序工作，有时甚至更多。对排序算法分析的研究也推动了计算机的发展。目前已有上百种排序方法，但尚未有一个最理想的算法。" ID="1">
      <fptr EndPN="00000199" StartPN="00000199"/>
    </Paragraph>
  </div>
    <div ORDERLABEL="207" TITLE="实验指导书" TYPE="Chapter">
    <fptr LogicalPageNum="217" PhysicalPageNum="217"/>
      <div ORDERLABEL="207" TITLE="实验一  顺序表的插入与删除" TYPE="Chapter">
      <fptr LogicalPageNum="217" PhysicalPageNum="217"/>
      <Paragraph CONTEXT="【实验目的与要求】" ID="1">
        <fptr EndPN="00000217" StartPN="00000217"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)掌握顺序表的操作特点，即元素的移动。" ID="2">
        <fptr EndPN="00000217" StartPN="00000217"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)熟练掌握顺序表的插入操作特点。" ID="3">
        <fptr EndPN="00000217" StartPN="00000217"/>
      </Paragraph>
      <Paragraph CONTEXT="l'l,Lf'#IIIi1序丰1!tGNl6i.1/F占" ID="4">
        <fptr EndPN="00000217" StartPN="00000217"/>
      </Paragraph>
      <Paragraph CONTEXT="（3）【实验内容】设计算法，实现在顺序存储结构上，元素的插入与删除。具体实现的要求是：从键盘输入8个整数，依次存放在数组serARRA耳101中，并输出.从键盘输入1个整数，存放在第1（l《1‘10）个位置上，输出数组SerARRA耳10］，" ID="5">
        <fptr EndPN="00000217" StartPN="00000217"/>
      </Paragraph>
      <Paragraph CONTEXT="删除第‘（1‘1‘10）个位置上的元素，输出数组serARRA班10］，观察输出结果.编程提示：" ID="6">
        <fptr EndPN="00000217" StartPN="00000217"/>
      </Paragraph>
      <Paragraph CONTEXT="（1）对于插入操作，首先要找到插入的位置，然后将该单元及其以后的数据全部元素全部前移一个单元" ID="7">
        <fptr EndPN="00000218" StartPN="00000217"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="208" TITLE="实验二  单链表的插入与删除" TYPE="Chapter">
      <fptr LogicalPageNum="218" PhysicalPageNum="218"/>
      <Paragraph CONTEXT="【实验目的与要求】" ID="1">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)掌握线性链表的操作特点，即指针是逻辑关系的映像。" ID="2">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="r，、食么乡左尹当，书灵干卜幼〔；白二月J苗幸大目匕占口，辛.含十" ID="3">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)" ID="4">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)熟练掌握单链表的插入操作特点，即指针赋值的先后次序。" ID="5">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(4)熟练掌握单链表的删除操作特点，即指针赋值的先后次序。【实验内容】设计算法，实现在链式存储结构上，链表的产生以及元素的插入与删除。具体实现的要求是：从键盘输入8个整数，动态产生带头结点的单链表，并输出结点值。从键盘输入1个整数，存放在第i(1&lt;i《10）个位置上，输出单链表的结点值，观察输出结果.删除第i(1‘i610）个位置上的元素，输出单链表的结点值，观察输出" ID="6">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="结果。编程提示：" ID="7">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)对于动态产生带头结点的单链表的方法，可参考课本中提到的两种算法。C2)对于插入操作，首先要找到插入的位置（用指针表示），然后对结点的next指针域赋值，注意赋值的次序。对干WHI[k.首牛街亚粉驹房" ID="8">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)对于删除操作，首先也要找到被删除元素的位置（用指针表示），然后对结点" ID="9">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="的next指针域赋值，并释放结点。" ID="10">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="208" TITLE="实验三  堆栈的操作" TYPE="Chapter">
      <fptr LogicalPageNum="218" PhysicalPageNum="218"/>
      <Paragraph CONTEXT="【实验目的与要求】" ID="1">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)掌握堆栈的操作特点，即栈顶指针指向最后一个数据元素。" ID="2">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）熟练掌握压栈操作。" ID="3">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）熟练掌握出栈操作。【实验内容】设有二个栈S：和Sz，都采用顺序表示，并且共享一个存储区域V[n]。为了尽量利" ID="4">
        <fptr EndPN="00000218" StartPN="00000218"/>
      </Paragraph>
      <Paragraph CONTEXT="栈和出栈算法。" ID="5">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Picture URL="00000219\00000219_new\0002.jpg">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Picture>
      <Paragraph CONTEXT="尹" ID="6">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="具体实现的要求是：设n=8，从键盘输入8个整数，存放在S,或S：的栈空间上，并输出S,和Sz的元素值。从键盘输入1个整数，存放在S;(i=1或i=2)栈上，观察输出信息。删除S;(i=1或i=2）栈的元素，输出S：和S：的元素值。编程提示：" ID="7">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)要实现此算法，应将两个栈迎面增长，只有当两个栈顶相遇时才会溢出，另外用一个变量i(i=1或i=2)来表示对栈S：和SZ操作。" ID="8">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)进行压栈和出栈时，应该注意什么条件。" ID="9">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="(3)下面给出一个可能的压栈操作部分语句，依此具体完成该实验。scani)ifi！二1）＆＆（1！＝2））｛printf“工nputierror;exit()" ID="10">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="｝if(topl+l！二top2)switch(i){case1:Vtopl]＝x;" ID="11">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="break;case2:V［一top21=x;" ID="12">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="break;｝" ID="13">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="elseprintfStackisfull" ID="14">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="209" TITLE="实验四  二叉排序树的构造与查找" TYPE="Chapter">
      <fptr LogicalPageNum="219" PhysicalPageNum="219"/>
      <Paragraph CONTEXT="【实验目的与要求】" ID="1">
        <fptr EndPN="00000219" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)掌握二叉排序树的操作特点。&lt;2）熟练掌握二叉排序树的构造方法。" ID="2">
        <fptr EndPN="00000220" StartPN="00000219"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）熟练掌握二叉排序树的查找方法。【实验内容】已知K={5,10,20,17,12,19,2}，设计以下算法" ID="3">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)构造出一棵二叉排序树。" ID="4">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)查找key=17的结点，输出该结点的指针。具体实现的要求是：从键盘输入上述7个整数，动态产生二叉排序树，并输出结点值.从键盘输入17，查找是否存放该结点，若存在，则输出结点的指针值，否则，给出相应的信息。从键盘输入25，查找是否存放该结点，若存在，则输出结点的指针值，否则，给出相应的信息。" ID="5">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="编程提示：" ID="6">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)对于动态产生二叉排序树的方法，可参考课本中的算法。" ID="7">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(2)对于查找操作，可参考课木中的算法。" ID="8">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="210" TITLE="实验五  冒泡排序" TYPE="Chapter">
      <fptr LogicalPageNum="220" PhysicalPageNum="220"/>
      <Paragraph CONTEXT="【实验目的与要求】" ID="1">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(1)掌握排序的特点。" ID="2">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(2）熟练掌握冒泡排序的方法。" ID="3">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
      <Paragraph CONTEXT="(3）关键字序列的有序.与无序，对于不同的排序方法有不同的影响。【实验内容】设有关键字序列K={12,45,21,30,12,68,2,33}，设计冒泡排序算法。具体实现的要求是：从键盘输入上述8个整数，存放在数组bub[81中，并输出值。输出每一趟排序的结果，观察关键字次序的变化。如果上述8个整数按照升序输入，即K{2,12,12,21,30,33,45,68}，输出每一趟排序的结果，观察关键字次序的变化。如果上述8个整数按照降序输入，即Kz={68,45,33,30,21,12,12,2}，输出每一趟排序的结果，观察关键字次序的变化。编程提示：对于冒泡排序的方法，可参考课本中提到的算法。210" ID="4">
        <fptr EndPN="00000220" StartPN="00000220"/>
      </Paragraph>
    </div>
      <div ORDERLABEL="211" TITLE="实验六  快速排序" TYPE="Chapter">
      <fptr LogicalPageNum="221" PhysicalPageNum="221"/>
      </div>
    <Paragraph CONTEXT="课程实验是本课程必不可缺少的重要实践环节。通过课程实验使学生进一步巩固和=t太i里#其太婀今ail其SIC车fii口的郊翻忍知管润只曰q汁角牛巴奋本翻刁二星三仪曰士rTv.加深对本课程基本概念和基本知识的理解和掌握，同时，备的技能基础。本实验指导书共包含6个实验，可供12个学时使用。这些实验都属于基本知识的" ID="1">
      <fptr EndPN="00000217" StartPN="00000217"/>
    </Paragraph>
    <Paragraph CONTEXT="训练，学生应该熟练地掌握。实验环境包括：计算机：PC286型及更高级计算机（最好配置打印机）操作系统：DOS3.3以上编程环境：TurboC2.0" ID="2">
      <fptr EndPN="00000217" StartPN="00000217"/>
    </Paragraph>
  </div>
  
</METS>
